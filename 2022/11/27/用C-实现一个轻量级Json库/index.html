<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xuranus.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="项目地址https:&#x2F;&#x2F;github.com&#x2F;XUranus&#x2F;minijson  JSON是非常常用的结构对象序列化方式。相比于其他基于字节流的序列化方案（thrift，protobuff），JSON易于阅读和编辑；相较于同样基于文本的序列化方案XML，JSON在网络传输占用更小的空间。JSON很好平衡了序列化&#x2F;反序列化的性能、可读性、空间占用的问题。 很多语言都在标准库中添加了JSON相关的A">
<meta property="og:type" content="article">
<meta property="og:title" content="用C++实现一个轻量级Json库">
<meta property="og:url" content="http://xuranus.github.io/2022/11/27/%E7%94%A8C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7Json%E5%BA%93/index.html">
<meta property="og:site_name" content="XUranus">
<meta property="og:description" content="项目地址https:&#x2F;&#x2F;github.com&#x2F;XUranus&#x2F;minijson  JSON是非常常用的结构对象序列化方式。相比于其他基于字节流的序列化方案（thrift，protobuff），JSON易于阅读和编辑；相较于同样基于文本的序列化方案XML，JSON在网络传输占用更小的空间。JSON很好平衡了序列化&#x2F;反序列化的性能、可读性、空间占用的问题。 很多语言都在标准库中添加了JSON相关的A">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-27T09:18:02.000Z">
<meta property="article:modified_time" content="2023-03-11T11:03:32.448Z">
<meta property="article:author" content="XUranus">
<meta property="article:tag" content="CPP">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://xuranus.github.io/2022/11/27/%E7%94%A8C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7Json%E5%BA%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>用C++实现一个轻量级Json库 | XUranus</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">XUranus</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">常应常静，常清净矣</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags" rel="section"><i class="tags fa-fw"></i>标签<span class="badge">59</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories" rel="section"><i class="th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives" rel="section"><i class="archive fa-fw"></i>归档<span class="badge">124</span></a>

  </li>
        <li class="menu-item menu-item-plan">

    <a href="/plan" rel="section"><i class="plane fa-fw"></i>计划</a>

  </li>
        <li class="menu-item menu-item-friends">

    <a href="/friends" rel="section"><i class="star fa-fw"></i>友链</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about" rel="section"><i class="user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-sticky">

    <a href="/sticky" rel="section"><i class="sitemap fa-fw"></i>便签</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://xuranus.github.io/2022/11/27/%E7%94%A8C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7Json%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/assets/march72.jpg">
      <meta itemprop="name" content="XUranus">
      <meta itemprop="description" content="Blog of XUranus">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="XUranus">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          用C++实现一个轻量级Json库
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-27 09:18:02" itemprop="dateCreated datePublished" datetime="2022-11-27T09:18:02Z">2022-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-03-11 11:03:32" itemprop="dateModified" datetime="2023-03-11T11:03:32Z">2023-03-11</time>
              </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/11/27/%E7%94%A8C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7Json%E5%BA%93/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/11/27/用C-实现一个轻量级Json库/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>31k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
              <span>28 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>项目地址<a target="_blank" rel="noopener" href="https://github.com/XUranus/minijson">https://github.com/XUranus/minijson</a></p>
</blockquote>
<p>JSON是非常常用的结构对象序列化方式。相比于其他基于字节流的序列化方案（thrift，protobuff），JSON易于阅读和编辑；相较于同样基于文本的序列化方案XML，JSON在网络传输占用更小的空间。JSON很好平衡了序列化/反序列化的性能、可读性、空间占用的问题。</p>
<p>很多语言都在标准库中添加了JSON相关的API，但C/C++还没有。C++较为完善的开源JSON库有jsoncpp。这篇文件将介绍如何用1K行左右的代码实现一个精简C++的Json库。</p>
<span id="more"></span>
<p>在开始之前强烈建议读一下JSON官方描述<a target="_blank" rel="noopener" href="https://www.json.org/json-en.html">文档</a>，其中包含了JSON格式的详细定义，之后实现JSON解析的时候将会用得到。</p>
<h3 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h3><p>一个JSON成员(JsonElement)可以是一个<code>null</code>、数字(number)、布尔值(bool)、字符串(string)这些基础类型；也可以是一个JSON数组(JsonArray)、JSON对象(JsonObject)这类复合类型。所以这6类类型可以看作<strong>是一个</strong><code>JsonElement</code>：</p>
<p><pre class="mermaid">flowchart TD
    JsonElement --> null
    JsonElement --> number
    JsonElement --> bool
    JsonElement --> string
    JsonElement --> JsonObject
    JsonElement --> JsonArray</pre><br><code>JsonElement</code>应该提供以下能力：</p>
<ol>
<li>记录自己对应的类型信息，并能转化成对应六种的类型之一</li>
<li>提供统一序列化接口，对每一种类型分别实现序列化</li>
</ol>
<p>于是首先定义一个序列化接口，所有的<code>JsonElement</code>都应该实现这个接口。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Serializable</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> std::string <span class="title">Serialize</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>可以定义一个<code>JsonElement</code>类，用枚举类型标记其是哪一种类型，并用联合体成员记存放其对应实际的值：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonElement</span>:</span> <span class="keyword">public</span> Serializable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Type</span> &#123;</span></span><br><span class="line">      JSON_OBJECT,</span><br><span class="line">      JSON_ARRAY,</span><br><span class="line">      JSON_STRING,</span><br><span class="line">      JSON_NUMBER,</span><br><span class="line">      JSON_BOOL,</span><br><span class="line">      JSON_NULL</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Value</span> &#123;</span></span><br><span class="line">      JsonObject* objectValue;</span><br><span class="line">      JsonArray* arrayValue;</span><br><span class="line">      std::string* stringValue;</span><br><span class="line">      <span class="keyword">double</span> numberValue;</span><br><span class="line">      <span class="keyword">bool</span> boolValue;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">Serialize</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type m_type = Type::JSON_NULL;</span><br><span class="line">    Value m_value &#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其中基础类型number类型用<code>double</code>表示，用<code>bool</code>表示布尔值，<code>std::string</code>表示字符串。null类型不需要存放值，只需要在<code>m_type</code>中标记类型即可。对于复合类型JSON数组和JSON对象用对应的指针类型来存放。</p>
<p>由于<code>JsonElement</code>需要提供对于各种类型的转换能力，需要定义从各种基础类型的构造方法，并提供转换成对应类型的<code>AsXXX()</code>和<code>ToXXX()</code>方法。在操作<code>JsonElement</code>对象时需要用<code>TypeName()</code>和<code>IsXXX()</code>判断<code>JsonElement</code>存放的的具体类型。API设计如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonElement</span>:</span> <span class="keyword">public</span> Serializable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">JsonElement</span>();</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonElement</span><span class="params">(JsonElement::Type type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonElement</span><span class="params">(<span class="keyword">bool</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonElement</span><span class="params">(<span class="keyword">double</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonElement</span><span class="params">(<span class="keyword">long</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonElement</span><span class="params">(<span class="keyword">const</span> std::string &amp;str)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonElement</span><span class="params">(<span class="keyword">char</span> <span class="keyword">const</span> *str)</span></span>;</span><br><span class="line">    <span class="built_in">JsonElement</span>(<span class="keyword">const</span> JsonObject&amp; object);</span><br><span class="line">    <span class="built_in">JsonElement</span>(<span class="keyword">const</span> JsonArray&amp; array);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">JsonElement</span>(<span class="keyword">const</span> JsonElement&amp; ele);</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">JsonElement</span><span class="params">(JsonElement&amp;&amp; ele)</span></span>;</span><br><span class="line">    JsonElement&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> JsonElement&amp; ele);</span><br><span class="line">    ~<span class="built_in">JsonElement</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span>&amp; <span class="title">AsBool</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span>&amp; <span class="title">AsNumber</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">AsNull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">std::string&amp; <span class="title">AsString</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">JsonObject&amp; <span class="title">AsJsonObject</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">JsonArray&amp; <span class="title">AsJsonArray</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ToBool</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">ToNumber</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="title">ToNull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">JsonObject <span class="title">ToJsonObject</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">JsonArray <span class="title">ToJsonArray</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsNull</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsBool</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsNumber</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsJsonObject</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsJsonArray</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">TypeName</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">Serialize</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复合类型的JSON对象(JsonObject)和JSON数组(JsonArray)可以包含JsonElement。<br>JsonObject可以看作KV结构的字典，Key是字符串，Value是JsonElement类型；JsonArray可以看成JsonElement构成的数组。于是这里分别选用继承<code>std::vector&lt;JsonElement&gt;</code>和<code>std::map&lt;std::string, JsonElement&gt;</code>来实现JsonArray和JsonObject：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonObject</span>:</span> <span class="keyword">public</span> std::map&lt;std::string, JsonElement&gt;, <span class="keyword">public</span> Serializable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">Serialize</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonArray</span>:</span> <span class="keyword">public</span> std::vector&lt;JsonElement&gt;, <span class="keyword">public</span> Serializable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::string <span class="title">Serialize</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体API的实现代码有400多行，都是比较简单的逻辑判断。这里就不详述了，详细见：<a target="_blank" rel="noopener" href="https://github.com/XUranus/minijson/blob/master/Json.cpp">Json.cpp</a></p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>有了基本的API设计和实现，就已经可以开始实现序列化了。序列化较为简单，只需要实现<code>JsonElement::Serialize()</code>、<code>JsonArray::Serialize()</code>和<code>JsonObject::Serialize()</code>方法。</p>
<p><code>JsonElement::Serialize()</code>中实现五种基础类型的序列化，<code>null</code>和布尔值的<code>true</code>和<code>false</code>直接返回对应的字面量即可，数字类型可以用<code>std::to_string</code>直接获得字面量，然后删除末尾冗余的浮点0（详见<a target="_blank" rel="noopener" href="https://github.com/XUranus/minijson/blob/master/Json.cpp">Json.cpp</a>中<code>DoubleToString()</code>。字符串序列化需要前后带上引号，需要注意特殊字符的转义。<code>JsonObject</code>和<code>JsonArray</code>两种复合类型在对应自身的<code>Serialize()</code>中分别实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">JsonElement::Serialize</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (m_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> JsonElement::Type::JSON_NULL: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JsonElement::Type::JSON_BOOL: &#123;</span><br><span class="line">            <span class="keyword">return</span> m_value.boolValue ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JsonElement::Type::JSON_NUMBER: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">DoubleToString</span>(m_value.numberValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JsonElement::Type::JSON_STRING: &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">string</span>(<span class="string">&quot;\&quot;&quot;</span>) + <span class="built_in">EscapeString</span>(*m_value.stringValue) + <span class="string">&quot;\&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JsonElement::Type::JSON_OBJECT: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">JsonObject</span>(*m_value.objectValue).<span class="built_in">Serialize</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JsonElement::Type::JSON_ARRAY: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">JsonArray</span>(*m_value.arrayValue).<span class="built_in">Serialize</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Panic</span>(<span class="string">&quot;unknown type to serialize: %s&quot;</span>, <span class="built_in">TypeName</span>().<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串转义需要考虑<code>&quot;</code>,<code>\</code>,<code>/</code>,<code>\f</code>,<code>\b</code>,<code>\n</code>,<code>\r</code>,<code>\t</code>这类字符，此处提供的实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">util::EscapeString</span><span class="params">(<span class="keyword">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">char</span> ch: str) &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">                res.<span class="built_in">push_back</span>(ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\f&#x27;</span>: &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;f&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\b&#x27;</span>: &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>: &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>: &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;n&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>: &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(ch);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>JsonObject</code>序列化是一个遍历所有的KV对，递归调用字符串类型KEY和<code>JsonElement</code>类型的<code>JsonElement::Serialize</code>的过程：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">JsonObject::Serialize</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string res = <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">bool</span> moreThanOneItem = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; kv: *<span class="keyword">this</span>) &#123;</span><br><span class="line">        moreThanOneItem = <span class="literal">true</span>;</span><br><span class="line">        res += std::<span class="built_in">string</span>(<span class="string">&quot;\&quot;&quot;</span>) + <span class="built_in">EscapeString</span>(kv.first) + <span class="string">&quot;\&quot;:&quot;</span> + kv.second.<span class="built_in">Serialize</span>() + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (moreThanOneItem) &#123;</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>JsonArray</code>的序列化则是迭代调用所有数组成员类型<code>JsonElement::Serialize</code>的过程：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">JsonArray::Serialize</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string res = <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">bool</span> moreThanOne = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; v: *<span class="keyword">this</span>) &#123;</span><br><span class="line">        moreThanOne = <span class="literal">true</span>;</span><br><span class="line">        res += v.<span class="built_in">Serialize</span>() + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (moreThanOne) &#123;</span><br><span class="line">        res.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    res += <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写个Demo验证序列化成果：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(SerializationTest, JsonBasicSerializationTest) &#123;</span><br><span class="line">    JsonObject object &#123;&#125;;</span><br><span class="line">    object[<span class="string">&quot;name&quot;</span>] = <span class="built_in">JsonElement</span>(<span class="string">&quot;xuranus&quot;</span>);</span><br><span class="line">    object[<span class="string">&quot;age&quot;</span>] = <span class="built_in">JsonElement</span>(<span class="number">300.0</span>);</span><br><span class="line">    object[<span class="string">&quot;isDeveloper&quot;</span>] = <span class="built_in">JsonElement</span>(<span class="literal">true</span>);</span><br><span class="line">    object[<span class="string">&quot;skills&quot;</span>] = <span class="built_in">JsonElement</span>(null);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(object.<span class="built_in">Serialize</span>(), <span class="string">R&quot;(&#123;&quot;age&quot;:300,&quot;name&quot;:&quot;xuranus&quot;, &quot;isDeveloper&quot;:true, &quot;skills&quot;:null&#125;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><h4 id="TOKEN"><a href="#TOKEN" class="headerlink" title="TOKEN"></a>TOKEN</h4><p>反序列化需要实现一个JSON字符串扫描和解析的模块，传入一个JSON字符串转为一个<code>JsonElement</code>。为了降低实现的复杂度，这里将解析的模块分成两块：</p>
<ul>
<li><code>JsonScanner</code>：逐字节扫描输入的字符串，依次识别一个个有意义的JSON语法TOKEN，并逐个返回</li>
<li><code>JsonParser</code>：基于<code>JsonScanner</code>返回的TOKEN流，依据JSON的格式定义解析完整的JSON成员</li>
</ul>
<p>JSON的TOKEN是一个个较为简单的语法单位，这里定义如下的TOKEN:</p>
<ul>
<li><code>WHITESPACE</code>         : 空白符 (<code>&#39; &#39;</code>, <code>&#39;\n&#39;</code>, <code>&#39;\r&#39;</code>, <code>&#39;\t&#39;</code>)</li>
<li><code>NUMBER</code>             : 数字，例如<code>3.14</code>、<code>114514</code>、<code>1919.810</code></li>
<li><code>STRING</code>             : 字符串，例如<code>&quot;xuranus&quot;</code></li>
<li><code>LITERAL_TRUE</code>       : <code>true</code>字面量</li>
<li><code>LITERAL_FALSE</code>      : <code>false</code>字面量</li>
<li><code>LITERAL_NULL</code>       : <code>null</code>字面量</li>
<li><code>COMMA</code>              : 逗号<code>,</code></li>
<li><code>COLON</code>              : 冒号<code>:</code></li>
<li><code>ARRAY_BEGIN</code>        : JSON数组开始符<code>[</code></li>
<li><code>ARRAY_END</code>          : JSON数组结束符<code>]</code></li>
<li><code>OBJECT_BEGIN</code>       : JSON对象开始符<code>&#123;</code></li>
<li><code>OBJECT_END</code>         : JSON对象结束符<code>&#125;</code></li>
<li><code>EOF_TOKEN</code>          : 标记串末尾EOF</li>
</ul>
<p>举个例子：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;xuranus&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;age&quot;</span>  : <span class="number">114514</span>,</span><br><span class="line">    <span class="attr">&quot;skills&quot;</span>: [<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;CPP&quot;</span>, <span class="string">&quot;JS&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果忽略所有的空白符，该JSON字符产长这样：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;xuranus&quot;,&quot;ID&quot;:114514,&quot;skills&quot;:[&quot;Java&quot;,&quot;CPP&quot;,&quot;JS&quot;]&#125;</span><br></pre></td></tr></table></figure><br>按照上述Token定义，我们对该字符串进行Token解析，可以获得Token流：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Token</th>
<th>Token</th>
<th>字符串</th>
<th>数字</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&#123;</code></td>
<td>OBJECT_BEGIN</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&quot;name&quot;</code></td>
<td>STRING</td>
<td>name</td>
<td></td>
</tr>
<tr>
<td><code>:</code></td>
<td>COLON</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&quot;xuranus&quot;</code></td>
<td>STRING</td>
<td>xuranus</td>
<td></td>
</tr>
<tr>
<td><code>,</code></td>
<td>COMMA</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&quot;ID&quot;</code></td>
<td>STRING</td>
<td>ID</td>
<td></td>
</tr>
<tr>
<td><code>:</code></td>
<td>COLON</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>114514</code></td>
<td>NUMBER</td>
<td></td>
<td>114514</td>
</tr>
<tr>
<td><code>,</code></td>
<td>COMMA</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&quot;skills&quot;</code></td>
<td>STRING</td>
<td>skills</td>
<td></td>
</tr>
<tr>
<td><code>:</code></td>
<td>COLON</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>[</code></td>
<td>ARRAY_BEGIN</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&quot;Java&quot;</code></td>
<td>STRING</td>
<td>Java</td>
<td></td>
</tr>
<tr>
<td><code>,</code></td>
<td>COMMA</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&quot;CPP&quot;</code></td>
<td>STRING</td>
<td>CPP</td>
<td></td>
</tr>
<tr>
<td><code>,</code></td>
<td>COMMA</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&quot;JS&quot;</code></td>
<td>STRING</td>
<td>JS</td>
<td></td>
</tr>
<tr>
<td><code>]</code></td>
<td>ARRAY_END</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>&#125;</code></td>
<td>OBJECT_END</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>从Token流可以进一步解析出JSON的AST：</p>
<p><pre class="mermaid">flowchart TD
  obj1(JsonObject) --> objbegin(OBJECT_BEGIN)
  obj1 --> pair1(PAIR_1)
  obj1 --> comma1(COMMA)
  obj1 --> pair2(PAIR_2)
  obj1 --> comma2(COMMA)
  obj1 --> pair3(PAIR_3)
  pair1 --> str1(STRING)
  pair1 --> col1(COLON)
  pair1 --> str2(STRING)
  pair2 --> str3(STRING)
  pair2 --> col2(COLON)
  pair2 --> num1(NUMBER)
  pair3 --> str4(STRING)
  pair3 --> col3(COLON)
  pair3 --> array(JsonArray)
  array --> arraybegin1(ARRAY_BEGIN)
  array --> str5(STRING)
  array --> comma3(COMMA)
  array --> str6(STRING)
  array --> comma4(COMMA)
  array --> str7(STRING)
  array --> arrayend1(ARRAY_END)</pre><br>明确了原理，接下来就来分别看看<code>JsonScanner</code>和<code>JsonParser</code>的实现。</p>
<h4 id="JsonScanner"><a href="#JsonScanner" class="headerlink" title="JsonScanner"></a>JsonScanner</h4><p>给<code>JsonScanner</code>将在内部存放一个带解析的JSON字符串<code>std::string m_str</code>并维护一个指向其当前读取位置的的下标索引<code>std::size_t m_pos</code>。<code>JsonScanner</code>将提供一个返回Token的<code>Next()</code>方法供外部调用者调用，返回下一个解析出的Token。</p>
<p>在上述的13种Token种，数字Token（<code>NUMBER</code>）和字符串Token（<code>STRING</code>）解析起来比较复杂，我们将其解析逻辑放入单独的两个解析方法：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">GetNumberValue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::string <span class="title">GetStringValue</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br>他们解析的类型依然由<code>Next()</code>方法返回，但是他们解析出的值需要单独存档在类成员中，可以用<code>std::string m_tmpStrValue</code>和<code>double m_tmpNumberValue</code>来暂存解析出的值，并由以上两个方法返回。其余的11种Token解析基本拥有固定的字面量（例如<code>LITERAL_TRUE</code>就是<code>true</code>、<code>ARRAY_BEGIN</code>就是<code>[</code>，拿到了Token就是拿到了字面量），他们解析起来也较为容易，解析逻辑将在<code>Next()</code>中实现。</p>
<p>基于以上思路，就可以给出<code>JsonScanner</code>的定义：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonScanner</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Token</span> &#123;</span></span><br><span class="line">        WHITESPACE, <span class="comment">// &#x27; &#x27;, &#x27;\n&#x27;, &#x27;\r&#x27;, &#x27;\t&#x27;</span></span><br><span class="line">        NUMBER,</span><br><span class="line">        STRING,</span><br><span class="line">        LITERAL_TRUE, <span class="comment">// true</span></span><br><span class="line">        LITERAL_FALSE, <span class="comment">// false</span></span><br><span class="line">        LITERAL_NULL, <span class="comment">// null</span></span><br><span class="line">        COMMA, <span class="comment">// ,</span></span><br><span class="line">        COLON, <span class="comment">// :</span></span><br><span class="line">        ARRAY_BEGIN, <span class="comment">// [</span></span><br><span class="line">        ARRAY_END, <span class="comment">// ]</span></span><br><span class="line">        OBJECT_BEGIN, <span class="comment">// &#123;</span></span><br><span class="line">        OBJECT_END, <span class="comment">// &#125;</span></span><br><span class="line">        EOF_TOKEN <span class="comment">// mark the end of the json string</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">JsonScanner</span>(<span class="keyword">const</span> std::string &amp;str);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Token <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetNumberValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">std::string <span class="title">GetStringValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">RollBack</span><span class="params">()</span> </span>&#123; m_pos = m_prevPos; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">Position</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_pos; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ScanNextString</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ScanNextNumber</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_str;</span><br><span class="line">    std::<span class="keyword">size_t</span> m_pos = <span class="number">0</span>;</span><br><span class="line">    std::<span class="keyword">size_t</span> m_prevPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    std::string m_tmpStrValue &#123;&#125;;</span><br><span class="line">    <span class="keyword">double</span> m_tmpNumberValue &#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其中<code>Reset()</code>、<code>RollBack()</code>、<code>Position()</code>用于设置当前索引下标的跳转以辅助解析流程，之后再看他们的实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JsonScanner::Reset</span><span class="params">()</span> </span>&#123; m_pos = <span class="number">0</span>; m_prevPos = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>首先看<code>Next()</code>方法，这是Token解析最核心的部分。<code>Next()</code>的任务是返回下一个Token，在解析下一个Token之前一般需要先跳过空白符，空白符（<code>&#39; &#39;</code>、<code>&#39;\n&#39;</code>、<code>&#39;\r&#39;</code>、<code>&#39;\t&#39;</code>）的存在一般只是用于缩进为了方便阅读JSON，而对JSON的解析毫无意义。空白符可以存在<strong>任何两个Token之间</strong>，所以要先跳过空白符。这里提供跳过空白符的实现：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonScanner</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IsWhiltespaceToken</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ch == <span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span> || ch == <span class="string">&#x27;\r&#x27;</span> || ch == <span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">SkipWhitespaceToken</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (m_pos &lt; m_str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">IsWhiltespaceToken</span>(m_str[m_pos])) &#123;</span><br><span class="line">            m_pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_pos &lt; m_str.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>其中<code>SkipWhitespaceToken</code>将会在解析到字符串末尾时返回<code>false</code>。在每次指向<code>Next()</code>都应该检测解析是否结束，如果结束则返回<code>EOF_TOKEN</code>。当拿到下一个非空白符的字符时，就可以开始解析Token了：如果第一个字符是<code>-</code>或者数字，则下一个Token有<strong>可能</strong>是一个数字，此时则调用<code>ScanNextNumber</code>进入数字解析模式；如果当前字符是<code>&quot;</code>，则下一个Token<strong>可能</strong>是一个字符串；如果当前字符串是<code>t</code>、<code>f</code>、<code>n</code>，则下一个Token<strong>可能</strong>是<code>LITERAL_TRUE</code>、<code>LITERAL_FALSE</code>、<code>LITERAL_NULL</code>，他们的Token对应的字面量固定，用<code>ScanLiteral()</code>检测。<code>ScanLiteral()</code>用于检测之后的字符串是否匹配给定的字面量，失败则用<code>Panic</code>抛异常，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Panic</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> message[<span class="number">100</span>]; </span><br><span class="line">    va_list args;</span><br><span class="line">    <span class="built_in">va_start</span>(args, str);</span><br><span class="line">    <span class="built_in">vsprintf</span>(message, str, args);</span><br><span class="line">    <span class="built_in">va_end</span>(args);</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(message); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonScanner</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ScanLiteral</span><span class="params">(<span class="keyword">const</span> std::string&amp; literal, <span class="keyword">int</span> offset)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_str.<span class="built_in">compare</span>(m_pos, offset, literal) == <span class="number">0</span>) &#123;</span><br><span class="line">        m_pos += offset;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">Panic</span>(<span class="string">&quot;unknown literal token at position = %lu, do you mean: %s ?&quot;</span>, m_pos, literal.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后，<code>ARRAY_BEGIN</code>、<code>OBJECT_BEGIN</code>等剩余的Token长度为1，直接用当前字符就能判断并返回。终于，基于以上逻辑，给出<code>Next()</code>的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// return a non space token</span></span><br><span class="line"><span class="function">JsonScanner::Token <span class="title">JsonScanner::Next</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_prevPos = m_pos;</span><br><span class="line">    <span class="keyword">if</span> (m_str.<span class="built_in">length</span>() &lt;= m_pos || !<span class="built_in">SkipWhitespaceToken</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Token::EOF_TOKEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> curChar = m_str[m_pos];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">IsDigit</span>(curChar) || curChar == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">ScanNextNumber</span>();</span><br><span class="line">        <span class="keyword">return</span> Token::NUMBER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (curChar) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\&quot;&#x27;</span>:</span><br><span class="line">            <span class="built_in">ScanNextString</span>();</span><br><span class="line">            <span class="keyword">return</span> Token::STRING;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>:</span><br><span class="line">            <span class="built_in">ScanLiteral</span>(<span class="string">&quot;true&quot;</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">return</span> Token::LITERAL_TRUE;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>:</span><br><span class="line">            <span class="built_in">ScanLiteral</span>(<span class="string">&quot;false&quot;</span>, <span class="number">5</span>);</span><br><span class="line">            <span class="keyword">return</span> Token::LITERAL_FALSE;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>:</span><br><span class="line">            <span class="built_in">ScanLiteral</span>(<span class="string">&quot;null&quot;</span>, <span class="number">4</span>);</span><br><span class="line">            <span class="keyword">return</span> Token::LITERAL_NULL;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>:</span><br><span class="line">            m_pos ++;</span><br><span class="line">            <span class="keyword">return</span> Token::ARRAY_BEGIN;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>:</span><br><span class="line">            m_pos ++;</span><br><span class="line">            <span class="keyword">return</span> Token::ARRAY_END;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>:</span><br><span class="line">            m_pos ++;</span><br><span class="line">            <span class="keyword">return</span> Token::OBJECT_BEGIN;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">            m_pos ++;</span><br><span class="line">            <span class="keyword">return</span> Token::OBJECT_END;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>:</span><br><span class="line">            m_pos ++;</span><br><span class="line">            <span class="keyword">return</span> Token::COMMA;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>:</span><br><span class="line">            m_pos ++;</span><br><span class="line">            <span class="keyword">return</span> Token::COLON;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Panic</span>(<span class="string">&quot;Invalid token at position %lu&quot;</span>, m_pos);</span><br><span class="line">    <span class="keyword">return</span> Token::LITERAL_NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着来看<code>Next()</code>中用于识别下一个字符串的<code>ScanNextString()</code>方法。<code>ScanNextString()</code>从<strong>当前位置</strong>开始扫描字符串，如果成果就将结果存在<code>m_tmpStrValue</code>中。字符串以<code>&quot;</code>开始、以<code>&quot;</code>结束，由于在调用该方法之前<code>Next()</code>方法总已经扫到了字符串开始的<code>&quot;</code>，接下来扫描字符串也就是要找到下一个<code>&quot;</code>，取其中的值作为字符串值。</p>
<p>在遍历的过程中需要注意特殊字符的转义。由于JSON序列化后的字符串中特殊字符已经被转义成了占用2字节的字面量，例如<code>&#39;\n&#39;</code>、<code>&#39;\r&#39;</code>，或者也可能包含占用5个字符unicode编码字面量，例如<code>\u1289</code>。在反序列化的过程中需要检测<code>\</code>字符，将其视为转义字符。当遇到转义符时，将额外读取1个或4个字符。在解析到下一个<code>&quot;</code>时，字符串读取完毕，此时该字符字串是含有转义字符字面量的串，需要再次进行反转义获得原始字符串。</p>
<p><code>ScanNextString()</code>和字符串反转义实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JsonScanner::ScanNextString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> beginPos = m_pos;</span><br><span class="line">    m_pos ++; <span class="comment">// skip left &quot;</span></span><br><span class="line">    <span class="keyword">while</span> (m_pos &lt; m_str.<span class="built_in">size</span>() &amp;&amp; m_str[m_pos] != <span class="string">&#x27;\&quot;&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> curChar = m_str[m_pos ++];</span><br><span class="line">        <span class="keyword">if</span> (curChar == <span class="string">&#x27;\\&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// &quot; quotation mark</span></span><br><span class="line">            <span class="comment">// \ reverse soildus</span></span><br><span class="line">            <span class="comment">// / sodilus</span></span><br><span class="line">            <span class="comment">// b backspace</span></span><br><span class="line">            <span class="comment">// f formfeed</span></span><br><span class="line">            <span class="comment">// n linefeed</span></span><br><span class="line">            <span class="comment">// r carriage return</span></span><br><span class="line">            <span class="comment">// t horizontal tab</span></span><br><span class="line">            <span class="comment">// u (4 hex digits)</span></span><br><span class="line">            <span class="keyword">if</span> (m_pos &gt;= m_str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">Panic</span>(<span class="string">&quot;missing token, position: %lu&quot;</span>, m_pos);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">char</span> escapeChar = m_str[m_pos];</span><br><span class="line">                <span class="keyword">if</span> (escapeChar == <span class="string">&#x27;\&quot;&#x27;</span> || escapeChar == <span class="string">&#x27;r&#x27;</span> || escapeChar == <span class="string">&#x27;f&#x27;</span> || escapeChar == <span class="string">&#x27;n&#x27;</span> ||</span><br><span class="line">                    escapeChar == <span class="string">&#x27;t&#x27;</span> || escapeChar == <span class="string">&#x27;b&#x27;</span> || escapeChar == <span class="string">&#x27;\\&#x27;</span> || escapeChar == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                    m_pos ++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (escapeChar == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                    m_pos += <span class="number">4</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_pos &gt;= m_str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">Panic</span>(<span class="string">&quot;missing end of string, position: %lu&quot;</span>, beginPos);</span><br><span class="line">    &#125;</span><br><span class="line">    m_pos ++; <span class="comment">// skip right &quot;</span></span><br><span class="line">    std::string rawStr = m_str.<span class="built_in">substr</span>(beginPos + <span class="number">1</span>, m_pos - beginPos - <span class="number">2</span>);</span><br><span class="line">    m_tmpStrValue = util::<span class="built_in">UnescapeString</span>(rawStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">util::UnescapeString</span><span class="params">(<span class="keyword">const</span> std::string&amp; str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::string res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">char</span> curChar = str[i];</span><br><span class="line">        <span class="keyword">if</span> (curChar == <span class="string">&#x27;\\&#x27;</span> &amp;&amp; i + <span class="number">1</span> &lt; str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">char</span> escapeChar = str[++i];</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (escapeChar) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="string">&#x27;\\&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;f&#x27;</span>: &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="string">&#x27;\f&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="string">&#x27;\b&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>: &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="string">&#x27;\r&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="string">&#x27;\t&#x27;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">Panic</span>(<span class="string">&quot;invalid escaped char \\%c&quot;</span>, escapeChar);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(curChar);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">JsonScanner::GetStringValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_tmpStrValue; &#125;</span><br></pre></td></tr></table></figure>
<p>除了字符串解析，另一个复杂Token的解析就是数字了。JSON中的数字可能是整数，也可能是浮点数；可能带符号，也可能不带符号，浮点数还可能是科学计数法表示。数字解析相关实现如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonScanner</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IsDigit</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span> &lt;= ch &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JsonScanner::ScanNextNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> beginPos = m_pos;</span><br><span class="line">    <span class="comment">// example: &quot;-114.51E-4&quot;</span></span><br><span class="line">    m_pos ++; <span class="comment">// skip + or - or first digit</span></span><br><span class="line">    <span class="keyword">while</span> (m_pos &lt; m_str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">IsDigit</span>(m_str[m_pos])) &#123;</span><br><span class="line">        m_pos ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_pos + <span class="number">1</span> &lt; m_str.<span class="built_in">size</span>() &amp;&amp; m_str[m_pos] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; <span class="built_in">IsDigit</span>(m_str[m_pos + <span class="number">1</span>])) &#123;</span><br><span class="line">            m_pos ++; <span class="comment">// skip .</span></span><br><span class="line">            <span class="keyword">while</span>(m_pos &lt; m_str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">IsDigit</span>(m_str[m_pos])) &#123;</span><br><span class="line">            m_pos ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (m_pos + <span class="number">1</span> &lt; m_str.<span class="built_in">size</span>() &amp;&amp; (m_str[m_pos] == <span class="string">&#x27;E&#x27;</span> || m_str[m_pos] == <span class="string">&#x27;e&#x27;</span>)) &#123;</span><br><span class="line">        m_pos ++;</span><br><span class="line">        <span class="keyword">if</span> (m_str[m_pos] == <span class="string">&#x27;-&#x27;</span> || m_str[m_pos] == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">            m_pos ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// parse number</span></span><br><span class="line">        <span class="keyword">while</span> (m_pos &lt; m_str.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">IsDigit</span>(m_str[m_pos])) &#123;</span><br><span class="line">            m_pos ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::string numberStr = m_str.<span class="built_in">substr</span>(beginPos, m_pos - beginPos);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        m_tmpNumberValue = std::<span class="built_in">atof</span>(numberStr.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (std::exception &amp;e) &#123;</span><br><span class="line">        <span class="built_in">Panic</span>(<span class="string">&quot;invalid number %lf, pos: %lu&quot;</span>, m_tmpNumberValue, beginPos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">JsonScanner::GetNumberValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_tmpNumberValue; &#125;</span><br></pre></td></tr></table></figure></p>
<p>此时，<code>JsonScanner</code>的全部代码就实现完了，我们已经获得了一个对JSON字符串实现词法分析的引擎。接下来我们只需要在此基础上基于Token流解析完整的JSON结构。</p>
<h4 id="JsonParser"><a href="#JsonParser" class="headerlink" title="JsonParser"></a>JsonParser</h4><p>由于对JSON的解析依赖于<code>JsonScanner</code>提供的Token解析，<code>JsonParser</code>内部持有一个<code>JsonScanner</code>的instance。</p>
<p>仿照之前<code>JsonScanner</code>的设计方式，将解析流程分成简单结构的解析方法和复杂结构的解析方法，<code>JsonParser</code>可以将数字、布尔值、字符串等基本结构放在一个<code>ParseNext()</code>方法中，而复杂点的复合结构<code>JsonArray</code>和<code>JsonObject</code>则由独立的<code>ParseJsonArray()</code>和<code>ParseJsonObject</code>负责解析。</p>
<p>给出<code>JsonParser</code>定义如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsonParser</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        JsonScanner m_scanner;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">JsonParser</span>(<span class="keyword">const</span> std::string str);</span><br><span class="line">        <span class="function">JsonElement <span class="title">Parse</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function">JsonElement <span class="title">ParseNext</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">JsonObject <span class="title">ParseJsonObject</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function">JsonArray <span class="title">ParseJsonArray</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>正如<code>JsonScanner</code>从前往后解析TOKEN，<code>JsonParser</code>从前往后解析<code>JsonElement</code>。<code>JsonParser::ParseNext</code>是<code>JsonParser</code>的核心逻辑，他返回下一个解析出的<code>JsonElement</code>。类似<code>JsonScanner</code>根据<strong>当前字符</strong>推断下一个可能的Token，<code>JsonParser</code>根据<strong>当前Token</strong>推断下一个可能的结构，所以<code>ParseNext()</code>的实现十分简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">JsonElement <span class="title">JsonParser::ParseNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JsonScanner::Token token = m_scanner.<span class="built_in">Next</span>();</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (token) &#123;</span><br><span class="line">        <span class="keyword">case</span> JsonScanner::Token::OBJECT_BEGIN: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ParseJsonObject</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JsonScanner::Token::ARRAY_BEGIN: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">ParseJsonArray</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JsonScanner::Token::STRING: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">JsonElement</span>(m_scanner.<span class="built_in">GetStringValue</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JsonScanner::Token::NUMBER: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">JsonElement</span>(m_scanner.<span class="built_in">GetNumberValue</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JsonScanner::Token::LITERAL_TRUE: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">JsonElement</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JsonScanner::Token::LITERAL_FALSE: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">JsonElement</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> JsonScanner::Token::LITERAL_NULL: &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">JsonElement</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Panic</span>(<span class="string">&quot;scanner return unexpected token: %d&quot;</span>, token);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JsonElement</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中字符串、布尔、数字、null这四种基础类型可以直接用<code>JsonScanner</code>提供的TOKEN解析能力直接拿到。而<code>JsonArray</code>和<code>JsonObject</code>的解析较为复杂，则放到单独的<code>ParseJsonObject()</code>和<code>ParseJsonArray()</code>方法中实现。</p>
<p><code>ParseJsonObject()</code>本质上就是解析<code>STRING</code>和<code>COLON</code>，然后再递归调用<code>ParseNext()</code>解析value对象，直到遇到<code>OBJECT_END</code>退出：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">JsonObject <span class="title">JsonParser::ParseJsonObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JsonObject object &#123;&#125;;</span><br><span class="line">    JsonScanner::Token token = m_scanner.<span class="built_in">Next</span>();</span><br><span class="line">    <span class="keyword">if</span> (token == JsonScanner::Token::OBJECT_END) &#123;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">    m_scanner.<span class="built_in">RollBack</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> pos = m_scanner.<span class="built_in">Position</span>();</span><br><span class="line">        token = m_scanner.<span class="built_in">Next</span>();</span><br><span class="line">        <span class="keyword">if</span> (token != JsonScanner::Token::STRING) &#123;</span><br><span class="line">            <span class="built_in">Panic</span>(<span class="string">&quot;expect a string as key for json object, position: %lu&quot;</span>, pos);</span><br><span class="line">        &#125;</span><br><span class="line">        std::string key = m_scanner.<span class="built_in">GetStringValue</span>();</span><br><span class="line"></span><br><span class="line">        pos = m_scanner.<span class="built_in">Position</span>();</span><br><span class="line">        token = m_scanner.<span class="built_in">Next</span>();</span><br><span class="line">        <span class="keyword">if</span> (token != JsonScanner::Token::COLON) &#123;</span><br><span class="line">            <span class="built_in">Panic</span>(<span class="string">&quot;expect &#x27;:&#x27; in json object, position: %lu&quot;</span>, pos);</span><br><span class="line">        &#125;</span><br><span class="line">        JsonElement ele = <span class="built_in">ParseNext</span>();</span><br><span class="line">        object[key] = ele;</span><br><span class="line"></span><br><span class="line">        pos = m_scanner.<span class="built_in">Position</span>();</span><br><span class="line">        token = m_scanner.<span class="built_in">Next</span>();</span><br><span class="line">        <span class="keyword">if</span> (token == JsonScanner::Token::OBJECT_END) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (token != JsonScanner::Token::COMMA) &#123;</span><br><span class="line">            <span class="built_in">Panic</span>(<span class="string">&quot;expect &#x27;,&#x27; in json object, position: %lu&quot;</span>, pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>解析数组的原理同理，先解析<code>ARRAY_BEGIN</code>，然后依次递归调用<code>ParseNext()</code>解析下一个<code>JsonElement</code>对象，知道遇到<code>ARRAY_END</code>完成解析。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">JsonArray <span class="title">JsonParser::ParseJsonArray</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JsonArray array &#123;&#125;;</span><br><span class="line">    JsonScanner::Token token = m_scanner.<span class="built_in">Next</span>();</span><br><span class="line">    <span class="keyword">if</span> (token == JsonScanner::Token::ARRAY_END) &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    m_scanner.<span class="built_in">RollBack</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        array.<span class="built_in">push_back</span>(<span class="built_in">ParseNext</span>());</span><br><span class="line">        <span class="keyword">size_t</span> pos = m_scanner.<span class="built_in">Position</span>();</span><br><span class="line">        token = m_scanner.<span class="built_in">Next</span>();</span><br><span class="line">        <span class="keyword">if</span> (token == JsonScanner::Token::ARRAY_END) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (token != JsonScanner::Token::COMMA) &#123;</span><br><span class="line">        <span class="built_in">Panic</span>(<span class="string">&quot;expect &#x27;,&#x27; in array, pos: %lu&quot;</span>, pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>由于进入<code>ParseJsonArray()</code>和<code>ParseJsonObject()</code>之前<code>JsonScanner</code>的字符串索引已经指向了<code>[</code>或<code>&#123;</code>，进入对应方法后需要<code>RollBack()</code>回滚索引。</p>
</blockquote>
<p>到此位置，反序列化也完全实现了。接下来写个用例验证下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">TEST</span>(SerializationTest, JsonParserBasicTest) &#123;</span><br><span class="line">    std::string str = <span class="string">R&quot;(</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">        &quot;name&quot; : &quot;xuranus&quot;,</span></span><br><span class="line"><span class="string">        &quot;age&quot; : 300,</span></span><br><span class="line"><span class="string">        &quot;skills&quot; : [&quot;C++&quot;, &quot;Java&quot;, &quot;Python&quot;]</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    )&quot;</span>;</span><br><span class="line">    JsonElement element = <span class="built_in">JsonParser</span>(str).<span class="built_in">Parse</span>();</span><br><span class="line">    JsonObject object = element.<span class="built_in">AsJsonObject</span>();</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(object[<span class="string">&quot;name&quot;</span>].<span class="built_in">AsString</span>(), <span class="string">&quot;xuranus&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(object[<span class="string">&quot;age&quot;</span>].<span class="built_in">AsNumber</span>(), <span class="number">300</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(object[<span class="string">&quot;skills&quot;</span>].<span class="built_in">AsJsonArray</span>()[<span class="number">0</span>].<span class="built_in">AsString</span>(), <span class="string">&quot;C++&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(object[<span class="string">&quot;skills&quot;</span>].<span class="built_in">AsJsonArray</span>()[<span class="number">1</span>].<span class="built_in">AsString</span>(), <span class="string">&quot;Java&quot;</span>);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(object[<span class="string">&quot;skills&quot;</span>].<span class="built_in">AsJsonArray</span>()[<span class="number">2</span>].<span class="built_in">AsString</span>(), <span class="string">&quot;Python&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="模板工具"><a href="#模板工具" class="headerlink" title="模板工具"></a>模板工具</h3><p>此时，虽然一个完整的JSON序列化和反序列化工具已经实现，但是用起来还是比较麻烦。在Java、GO中都有注解实现的ORM框架，能实现类/结构体的自动序列化/反序列化，我们尝试在C++中也实现这一功能。</p>
<p>在下面的样例中，我们期望实现两个函数：</p>
<ul>
<li><code>std::string util::Serialize(T&amp;)</code>将类型为T的结构体序列化成JSON字符串</li>
<li><code>void util::Deserialize(const std::string&amp;, T&amp;)</code>将JSON字符串反序列化成对应的结构体<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line">    <span class="keyword">float</span> m_price;</span><br><span class="line">    <span class="keyword">bool</span> m_soldOut;</span><br><span class="line">    std::vector&lt;std::string&gt; m_tags;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(SerializationTest, BasicStructSerialization) &#123;</span><br><span class="line">    Book book1 &#123;&#125;;</span><br><span class="line">    book1.m_name = <span class="string">&quot;C++ Primer&quot;</span>;</span><br><span class="line">    book1.m_id = <span class="number">114514</span>;</span><br><span class="line">    book1.m_price = <span class="number">114.5</span>;</span><br><span class="line">    book1.m_soldOut = <span class="literal">true</span>;</span><br><span class="line">    book1.m_tags = &#123;<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Programming&quot;</span>, <span class="string">&quot;Language&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// serialization here</span></span><br><span class="line">    std::string jsonStr = util::<span class="built_in">Serialize</span>(book1);</span><br><span class="line"></span><br><span class="line">    Book book2 &#123;&#125;;</span><br><span class="line">    <span class="comment">// deserialization here</span></span><br><span class="line">    util::<span class="built_in">Deserialize</span>(jsonStr, book2);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(book1.m_name, book2.m_name);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(book1.m_id, book2.m_id);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(book1.m_price, book2.m_price);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(book1.m_soldOut, book2.m_soldOut);</span><br><span class="line">    <span class="built_in">EXPECT_EQ</span>(book1.m_tags, book2.m_tags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
为了实现对每一种类型的结构体都能序列化，我们必须对其中成员序列化映射规则做出定义。为了实现这点，我们不得不在结构体中侵入式的定义一个成员函数<code>_XURANUS_JSON_CPP_SERIALIZE_METHOD_</code>：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line">    <span class="keyword">float</span> m_price;</span><br><span class="line">    <span class="keyword">bool</span> m_soldOut;</span><br><span class="line">    std::vector&lt;std::string&gt; m_tags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> _XURANUS_JSON_CPP_SERIALIZE_METHOD_(xuranus::minijson::JsonObject&amp; object, <span class="keyword">bool</span> toJson) &#123;</span><br><span class="line">        <span class="keyword">if</span> (toJson) &#123;</span><br><span class="line">            util::<span class="built_in">SerializeTo</span>(object, <span class="string">&quot;name&quot;</span>, m_name);</span><br><span class="line">            util::<span class="built_in">SerializeTo</span>(object, <span class="string">&quot;id&quot;</span>, m_id);</span><br><span class="line">            util::<span class="built_in">SerializeTo</span>(object, <span class="string">&quot;price&quot;</span>, m_price);</span><br><span class="line">            util::<span class="built_in">SerializeTo</span>(object, <span class="string">&quot;soldOut&quot;</span>, m_soldOut);</span><br><span class="line">            util::<span class="built_in">SerializeTo</span>(object, <span class="string">&quot;tags&quot;</span>, m_tags);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            util::<span class="built_in">DeserializeFrom</span>(object, <span class="string">&quot;name&quot;</span>, m_name);</span><br><span class="line">            util::<span class="built_in">DeserializeFrom</span>(object, <span class="string">&quot;id&quot;</span>, m_id);</span><br><span class="line">            util::<span class="built_in">DeserializeFrom</span>(object, <span class="string">&quot;price&quot;</span>, m_price);</span><br><span class="line">            util::<span class="built_in">DeserializeFrom</span>(object, <span class="string">&quot;soldOut&quot;</span>, m_soldOut);</span><br><span class="line">            util::<span class="built_in">DeserializeFrom</span>(object, <span class="string">&quot;tags&quot;</span>, m_tags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
我们可以用宏定义简化这部分的表示：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERIALIZE_SECTION_BEGIN                                                                  \</span></span><br><span class="line"><span class="meta">public:                                                                                          \</span></span><br><span class="line"><span class="meta">    using __XURANUS_JSON_SERIALIZATION_MAGIC__ = void;                                           \</span></span><br><span class="line"><span class="meta">public:                                                                                          \</span></span><br><span class="line"><span class="meta">    void _XURANUS_JSON_CPP_SERIALIZE_METHOD_(xuranus::minijson::JsonObject&amp; object, bool toJson) \</span></span><br><span class="line"><span class="meta">    &#123;                                                                                            \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERIALIZE_SECTION_END                                                                    \</span></span><br><span class="line"><span class="meta">    &#125;;                                                                                           \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERIALIZE_FIELD(KEY_NAME, ATTR_NAME)                                                     \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                                         \</span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">if</span> (toJson) &#123;                                                                            \</span></span><br><span class="line"><span class="meta">            util::SerializeTo(object, #KEY_NAME, ATTR_NAME);                                     \</span></span><br><span class="line"><span class="meta">        &#125; <span class="meta-keyword">else</span> &#123;                                                                                 \</span></span><br><span class="line"><span class="meta">            xuranus::minijson::util::DeserializeFrom(object, #KEY_NAME, ATTR_NAME);              \</span></span><br><span class="line"><span class="meta">        &#125;                                                                                        \</span></span><br><span class="line"><span class="meta">    &#125; while (0)                                                                                  \</span></span><br></pre></td></tr></table></figure>
定义宏之后的结构体声明就可以写成如下形式，由一组<code>SERIALIZE_SECTION_BEGIN</code>和<code>SERIALIZE_SECTION_END</code>以及一系列<code>SERIALIZE_FIELD</code>声明成员的序列化/反序列化名称映射关系。：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line">    <span class="keyword">float</span> m_price;</span><br><span class="line">    <span class="keyword">bool</span> m_soldOut;</span><br><span class="line">    std::vector&lt;std::string&gt; m_tags;</span><br><span class="line"></span><br><span class="line">    <span class="function">SERIALIZE_SECTION_BEGIN</span></span><br><span class="line"><span class="function">    <span class="title">SERIALIZE_FIELD</span><span class="params">(name, m_name)</span></span>;</span><br><span class="line">    <span class="built_in">SERIALIZE_FIELD</span>(id, m_id);</span><br><span class="line">    <span class="built_in">SERIALIZE_FIELD</span>(price, m_price);</span><br><span class="line">    <span class="built_in">SERIALIZE_FIELD</span>(soldOut, m_soldOut);</span><br><span class="line">    <span class="built_in">SERIALIZE_FIELD</span>(tags, m_tags);</span><br><span class="line">    SERIALIZE_SECTION_END</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
当类定义了上述的成员方法后，就拥有了序列化和反序列化的能力。此时就可以实现供外部调用的接口了：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Serialize</span><span class="params">(T&amp; value)</span> -&gt; <span class="title">decltype</span><span class="params">(<span class="keyword">typename</span> T::__XURANUS_JSON_SERIALIZATION_MAGIC__(), std::string())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JsonObject object&#123;&#125;;</span><br><span class="line">    value._XURANUS_JSON_CPP_SERIALIZE_METHOD_(object, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> object.<span class="built_in">Serialize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Deserialize</span><span class="params">(<span class="keyword">const</span> std::string&amp; jsonStr, T&amp; value)</span> -&gt; <span class="title">decltype</span><span class="params">(<span class="keyword">typename</span> T::__XURANUS_JSON_SERIALIZATION_MAGIC__())</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">JsonParser <span class="title">parser</span><span class="params">(jsonStr)</span></span>;</span><br><span class="line">    JsonElement ele = parser.<span class="built_in">Parse</span>();</span><br><span class="line">    JsonObject object = ele.<span class="built_in">AsJsonObject</span>();</span><br><span class="line">    value._XURANUS_JSON_CPP_SERIALIZE_METHOD_(object, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里用到了Trailing Return Type，<code>__XURANUS_JSON_SERIALIZATION_MAGIC__</code>在之前的成员宏中已经定义为<code>void</code>，本身并无意义，只是用于标记该类实现了成员序列化方法，用于给序列化/反序列化工具函数在编译期进行检测。如果结构体没定义相关的宏，则模板函数特化时会失败。</p>
</blockquote>
</li>
</ul>
<p>于是接下来的任务就只是实现上述<code>_XURANUS_JSON_CPP_SERIALIZE_METHOD_</code>方法中用到的两个辅助函数：</p>
<ul>
<li><code>std::string util::SerializeTo(JsonObject&amp;, const std::string&amp;, T&amp;)</code></li>
<li><code>void util::DeserializeFrom(JsonObject&amp;, const std::string&amp;, T&amp;)</code></li>
</ul>
<p>首先来看<code>std::string util::SerializeTo(JsonObject&amp;, const std::string&amp;, T&amp;)</code>。它的用途是把参数3的值以参数2作为key转化成<code>JsonElement</code>存入参数1的<code>JsonObject</code>。而<code>void util::DeserializeFrom(JsonObject&amp;, const std::string&amp;, T&amp;)</code>则相反，它的作用是从参数1的<code>JsonObject</code>中取出参数2的key对应的<code>JsonElement</code>，转化为T类型的值存入参数3。这两个模板函数可以实现为：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SerializeTo</span><span class="params">(JsonObject&amp; object, <span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> T&amp; field)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JsonElement ele&#123;&#125;;</span><br><span class="line">    CastToJsonElement&lt;T&gt;(ele, field);</span><br><span class="line">    object[key] = ele;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeserializeFrom</span><span class="params">(<span class="keyword">const</span> JsonObject&amp; object, <span class="keyword">const</span> std::string&amp; key, T&amp; field)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    JsonElement ele = object.<span class="built_in">find</span>(key)-&gt;second;</span><br><span class="line">    CastFromJsonElement&lt;T&gt;(ele, field);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>其中<code>CastToJsonElement(JsonElement &amp; ele, const T &amp; value)</code>和<code>CastFromJsonElement(const JsonElement &amp; ele, T &amp; value)</code>是定义了某一<code>JsonElement</code>和<code>T</code>类型直线转化关系的模板函数。后续我们需要针对不同的类型逐一实现他们。</p>
<p>如果<code>T</code>类型本身是一个已经定义了<code>__XURANUS_JSON_SERIALIZATION_MAGIC__</code>的结构，我们可以递归调用其中的<code>_XURANUS_JSON_CPP_SERIALIZE_METHOD_</code>方法来实现类型映射：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cast between struct and JsonElement</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">CastFromJsonElement</span><span class="params">(<span class="keyword">const</span> JsonElement&amp; ele, T&amp; value)</span> -&gt; <span class="title">decltype</span><span class="params">(<span class="keyword">typename</span> T::__XURANUS_JSON_SERIALIZATION_MAGIC__())</span> </span>&#123;</span><br><span class="line">    JsonObject object = ele.<span class="built_in">ToJsonObject</span>();</span><br><span class="line">    value._XURANUS_JSON_CPP_SERIALIZE_METHOD_(object, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">CastToJsonElement</span><span class="params">(JsonElement&amp; ele, <span class="keyword">const</span> T&amp; value)</span> -&gt; <span class="title">decltype</span><span class="params">(<span class="keyword">typename</span> T::__XURANUS_JSON_SERIALIZATION_MAGIC__())</span> </span>&#123;</span><br><span class="line">    JsonObject object&#123;&#125;;</span><br><span class="line">    T* valueRef = <span class="keyword">reinterpret_cast</span>&lt;T*&gt;((<span class="keyword">void</span>*)&amp;value);</span><br><span class="line">    valueRef-&gt;_XURANUS_JSON_CPP_SERIALIZE_METHOD_(object, <span class="literal">true</span>);</span><br><span class="line">    ele = <span class="built_in">JsonElement</span>(object);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们将这复合一类型的模板作为主模板，利用SFINAE来进一步定义更多基础类型的映射模板：</p>
<p>字符串类型：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cast between std::string and JsonElement</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> std::enable_if&lt;std::is_same&lt;T, std::string&gt;::value&gt;::type* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CastFromJsonElement</span>(<span class="keyword">const</span> JsonElement&amp; ele, T&amp; value) &#123;</span><br><span class="line">    value = ele.<span class="built_in">ToString</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> std::enable_if&lt;std::is_same&lt;T, std::string&gt;::value&gt;::type* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CastToJsonElement</span>(JsonElement&amp; ele, <span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">    ele = <span class="built_in">JsonElement</span>(value);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>数字类型：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cast between numeric and JsonElement</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> std::enable_if&lt;(std::is_integral&lt;T&gt;::value || std::is_floating_point&lt;T&gt;::value)</span><br><span class="line">    &amp;&amp; !std::is_same&lt;T, <span class="keyword">bool</span>&gt;::value&gt;::type* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CastFromJsonElement</span>(<span class="keyword">const</span> JsonElement&amp; ele, T&amp; value) &#123;</span><br><span class="line">    value = <span class="keyword">static_cast</span>&lt;T&gt;(ele.<span class="built_in">ToNumber</span>());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; !std::is_same&lt;T, <span class="keyword">bool</span>&gt;::value&gt;::type* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CastToJsonElement</span>(JsonElement&amp; ele, <span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">    ele = <span class="built_in">JsonElement</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">long</span>&gt;(value));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> std::enable_if&lt;std::is_floating_point&lt;T&gt;::value&gt;::type* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CastToJsonElement</span>(JsonElement&amp; ele, <span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">    ele = <span class="built_in">JsonElement</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(value));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>布尔类型：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cast between bool and JsonElement</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> std::enable_if&lt;std::is_same&lt;T, <span class="keyword">bool</span>&gt;::value&gt;::type* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CastFromJsonElement</span>(<span class="keyword">const</span> JsonElement&amp; ele, T&amp; value) &#123;</span><br><span class="line">    value = ele.<span class="built_in">ToBool</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> std::enable_if&lt;std::is_same&lt;T, <span class="keyword">bool</span>&gt;::value&gt;::type* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CastToJsonElement</span>(JsonElement&amp; ele, <span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">    ele = <span class="built_in">JsonElement</span>(value);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>std::vector</code>和<code>std::list</code>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cast between std::vector or std::list and JsonElement</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">    std::is_same&lt;T, std::vector&lt;<span class="keyword">typename</span> T::value_type&gt;&gt;::value ||</span><br><span class="line">    std::is_same&lt;T, std::list&lt;<span class="keyword">typename</span> T::value_type&gt;&gt;::value</span><br><span class="line">&gt;::type* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CastFromJsonElement</span>(<span class="keyword">const</span> JsonElement &amp; ele, T &amp; value) &#123;</span><br><span class="line">    JsonArray array = ele.<span class="built_in">ToJsonArray</span>();</span><br><span class="line">    value.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> JsonElement&amp; eleItem : array) &#123;</span><br><span class="line">        <span class="keyword">typename</span> T::value_type t;</span><br><span class="line">        CastFromJsonElement&lt;<span class="keyword">typename</span> T::value_type&gt;(eleItem, t);</span><br><span class="line">        value.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">    std::is_same&lt;T, std::vector&lt;<span class="keyword">typename</span> T::value_type&gt;&gt;::value ||</span><br><span class="line">    std::is_same&lt;T, std::list&lt;<span class="keyword">typename</span> T::value_type&gt;&gt;::value</span><br><span class="line">&gt;::type* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CastToJsonElement</span>(JsonElement &amp; ele, <span class="keyword">const</span> T &amp; value) &#123;</span><br><span class="line">    JsonArray array;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">typename</span> T::value_type&amp; item : value) &#123;</span><br><span class="line">        JsonElement itemElement;</span><br><span class="line">        CastToJsonElement&lt;<span class="keyword">typename</span> T::value_type&gt;(itemElement, item);</span><br><span class="line">        array.<span class="built_in">push_back</span>(itemElement);</span><br><span class="line">    &#125;</span><br><span class="line">    ele = <span class="built_in">JsonElement</span>(array);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>std::map</code>和<code>std::unordered_map</code>：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cast between std::map and JsonElement</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">    std::is_same&lt;std::string, <span class="keyword">typename</span> T::key_type&gt;::value &amp;&amp; (</span><br><span class="line">        std::is_same&lt;T, std::map&lt;std::string, <span class="keyword">typename</span> T::mapped_type&gt;&gt;::value ||</span><br><span class="line">        std::is_same&lt;T, std::unordered_map&lt;std::string, <span class="keyword">typename</span> T::mapped_type&gt;&gt;::value</span><br><span class="line">        )&gt;::type* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CastFromJsonElement</span>(<span class="keyword">const</span> JsonElement&amp; ele, T&amp; value) &#123;</span><br><span class="line">    JsonObject object = ele.<span class="built_in">ToJsonObject</span>();</span><br><span class="line">    value.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> std::pair&lt;std::string, JsonElement&gt;&amp; p : object) &#123;</span><br><span class="line">        <span class="keyword">typename</span> T::mapped_type v;</span><br><span class="line">        CastFromJsonElement&lt;<span class="keyword">typename</span> T::mapped_type&gt;(p.second, v);</span><br><span class="line">        value[p.first] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">    std::is_same&lt;std::string, <span class="keyword">typename</span> T::key_type&gt;::value &amp;&amp; (</span><br><span class="line">        std::is_same&lt;T, std::map&lt;std::string, <span class="keyword">typename</span> T::mapped_type&gt;&gt;::value ||</span><br><span class="line">        std::is_same&lt;T, std::unordered_map&lt;std::string, <span class="keyword">typename</span> T::mapped_type&gt;&gt;::value</span><br><span class="line">        )&gt;::type* = <span class="literal">nullptr</span>&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CastToJsonElement</span>(JsonElement&amp; ele, <span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">    JsonObject object;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> std::pair&lt;std::string, <span class="keyword">typename</span> T::mapped_type&gt;&amp; p : value) &#123;</span><br><span class="line">        JsonElement valueElement;</span><br><span class="line">        CastToJsonElement&lt;<span class="keyword">typename</span> T::mapped_type&gt;(valueElement, p.second);</span><br><span class="line">        object[p.first] = valueElement;</span><br><span class="line">    &#125;</span><br><span class="line">    ele = <span class="built_in">JsonElement</span>(object);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此位置，该JSON库的所有功能都已实现了，来跑一个复杂点的用例：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string m_name;</span><br><span class="line">    <span class="keyword">int</span> m_id;</span><br><span class="line">    <span class="keyword">float</span> m_price;</span><br><span class="line">    <span class="keyword">bool</span> m_soldOut;</span><br><span class="line">    std::vector&lt;std::string&gt; m_tags;</span><br><span class="line"></span><br><span class="line">    <span class="function">SERIALIZE_SECTION_BEGIN</span></span><br><span class="line"><span class="function">    <span class="title">SERIALIZE_FIELD</span><span class="params">(name, m_name)</span></span>;</span><br><span class="line">    <span class="built_in">SERIALIZE_FIELD</span>(id, m_id);</span><br><span class="line">    <span class="built_in">SERIALIZE_FIELD</span>(price, m_price);</span><br><span class="line">    <span class="built_in">SERIALIZE_FIELD</span>(soldOut, m_soldOut);</span><br><span class="line">    <span class="built_in">SERIALIZE_FIELD</span>(tags, m_tags);</span><br><span class="line">    SERIALIZE_SECTION_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Author</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    std::string m_name;</span><br><span class="line">    std::list&lt;Book&gt; m_books;</span><br><span class="line"></span><br><span class="line">    <span class="function">SERIALIZE_SECTION_BEGIN</span></span><br><span class="line"><span class="function">    <span class="title">SERIALIZE_FIELD</span><span class="params">(name, m_name)</span></span>;</span><br><span class="line">    <span class="built_in">SERIALIZE_FIELD</span>(books, m_books);</span><br><span class="line">    SERIALIZE_SECTION_END</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Book &amp;book1, <span class="keyword">const</span> Book &amp;book2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">return</span></span> (book1.m_name == book2.m_name &amp;&amp;</span><br><span class="line">            book1.m_id == book2.m_id &amp;&amp;</span><br><span class="line">            book1.m_price == book2.m_price &amp;&amp;</span><br><span class="line">            book1.m_soldOut == book2.m_soldOut &amp;&amp;</span><br><span class="line">            book1.m_tags == book2.m_tags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(SerializationTest, NestedStructSerialization)</span><br><span class="line">&#123;</span><br><span class="line">	Book book1&#123;&#125;;</span><br><span class="line">	book1.m_name = <span class="string">&quot;C++ Primer&quot;</span>;</span><br><span class="line">	book1.m_id = <span class="number">114514</span>;</span><br><span class="line">	book1.m_price = <span class="number">114.5</span>;</span><br><span class="line">	book1.m_soldOut = <span class="literal">true</span>;</span><br><span class="line">	book1.m_tags = &#123;<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Programming&quot;</span>, <span class="string">&quot;Language&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">	Book book2&#123;&#125;;</span><br><span class="line">	book2.m_name = <span class="string">&quot;Essential C++&quot;</span>;</span><br><span class="line">	book2.m_id = <span class="number">1919810</span>;</span><br><span class="line">	book2.m_price = <span class="number">19.19</span>;</span><br><span class="line">	book2.m_soldOut = <span class="literal">false</span>;</span><br><span class="line">	book2.m_tags = &#123;<span class="string">&quot;Programming&quot;</span>, <span class="string">&quot;Computer Science&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">	Author author1&#123;&#125;;</span><br><span class="line">	author1.m_name = <span class="string">&quot;Stanley B. LippmanBarbara E. Moo JoséeLaJoie&quot;</span>;</span><br><span class="line">	author1.m_books = &#123;book1, book2&#125;;</span><br><span class="line"></span><br><span class="line">	Author author2&#123;&#125;;</span><br><span class="line">	std::string jsonStr = util::<span class="built_in">Serialize</span>(author1);</span><br><span class="line">	util::<span class="built_in">Deserialize</span>(jsonStr, author2);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EXPECT_EQ</span>(author2.m_name, author1.m_name);</span><br><span class="line">	<span class="built_in">EXPECT_EQ</span>(author2.m_books, author1.m_books);</span><br><span class="line"></span><br><span class="line">	JsonElement ele = <span class="built_in">JsonParser</span>(jsonStr).<span class="built_in">Parse</span>();</span><br><span class="line">	<span class="built_in">EXPECT_TRUE</span>(ele.<span class="built_in">IsJsonObject</span>());</span><br><span class="line">	JsonObject authorObject = ele.<span class="built_in">AsJsonObject</span>();</span><br><span class="line">	<span class="built_in">EXPECT_TRUE</span>(authorObject[<span class="string">&quot;name&quot;</span>].<span class="built_in">IsString</span>());</span><br><span class="line">	<span class="built_in">EXPECT_TRUE</span>(authorObject[<span class="string">&quot;books&quot;</span>].<span class="built_in">IsJsonArray</span>());</span><br><span class="line">	JsonArray booksArray = authorObject[<span class="string">&quot;books&quot;</span>].<span class="built_in">AsJsonArray</span>();</span><br><span class="line">	<span class="built_in">EXPECT_EQ</span>(booksArray[<span class="number">0</span>].<span class="built_in">AsJsonObject</span>()[<span class="string">&quot;name&quot;</span>].<span class="built_in">AsString</span>(), <span class="string">&quot;C++ Primer&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>完整项目代码见：<a target="_blank" rel="noopener" href="https://github.com/XUranus/minijson">https://github.com/XUranus/minijson</a></p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.json.org/json-en.html">https://www.json.org/json-en.html</a></li>
</ul>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CPP/" rel="tag"># CPP</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/08/15/CPP%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8Dcast/" rel="prev" title="C++中的几种cast">
      <i class="fa fa-chevron-left"></i> C++中的几种cast
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/02/19/%E7%A8%80%E7%96%8F%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B/" rel="next" title="稀疏文件简介">
      稀疏文件简介 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <div>
        <blockquote><b>Disqus评论区没有正常加载，请使用科学上网</b></blockquote>
      </div>
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="nav-number">1.</span> <span class="nav-text">接口设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">反序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TOKEN"><span class="nav-number">3.1.</span> <span class="nav-text">TOKEN</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonScanner"><span class="nav-number">3.2.</span> <span class="nav-text">JsonScanner</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonParser"><span class="nav-number">3.3.</span> <span class="nav-text">JsonParser</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%B7%A5%E5%85%B7"><span class="nav-number">4.</span> <span class="nav-text">模板工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="nav-number">5.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="XUranus"
      src="/assets/march72.jpg">
  <p class="site-author-name" itemprop="name">XUranus</p>
  <div class="site-description" itemprop="description">Blog of XUranus</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
        
          <span class="site-state-item-count">124</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XUranus</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">638k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:40</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

<script>
  function loadCount() {
    var d = document, s = d.createElement('script');
    s.src = 'https://XUranus.disqus.com/count.js';
    s.id = 'dsq-count-scr';
    (d.head || d.body).appendChild(s);
  }
  // defer loading until the whole page loading is completed
  window.addEventListener('load', loadCount, false);
</script>
<script>
  var disqus_config = function() {
    this.page.url = "http://xuranus.github.io/2022/11/27/%E7%94%A8C-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7Json%E5%BA%93/";
    this.page.identifier = "2022/11/27/用C-实现一个轻量级Json库/";
    this.page.title = "用C++实现一个轻量级Json库";
    };
  NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
    if (window.DISQUS) {
      DISQUS.reset({
        reload: true,
        config: disqus_config
      });
    } else {
      var d = document, s = d.createElement('script');
      s.src = 'https://XUranus.disqus.com/embed.js';
      s.setAttribute('data-timestamp', '' + +new Date());
      (d.head || d.body).appendChild(s);
    }
  });
</script>


  <div id="chat_input">
    <input id="question" type="text" placeholder="陪我聊聊天吧" onkeypress="return onKeyPress(event)"/>
</div>

<style> 
#chat_input{
    width: 200px;
    height: 40px;
    position: fixed;
    bottom: 5px;
    left: 50px;
} 

#question{
    border: none;/*取消输入框边框*/
    border-bottom: 1px #aaaaaa solid;/*设置下边框*/
    background-color: transparent;/*背景透明*/
    padding: 5px;
}

/*手机端不显示*/
@media screen and (max-width: 480px) {
    #chat_input{
        display: none;
    }
    #live2d-widget{
        display: none;
    }
}
</style>

<script>
function onKeyPress(e){ //在聊天框按下回车事件处理

  function popDialogAndShow(message) { //显示对话框
    let live2d_dialog = document.getElementsByClassName("live2d-widget-dialog")[0]  //获取对话框
    live2d_dialog.style.opacity=1 //显示对话框
    live2d_dialog.innerHTML = message 
    window.setTimeout(()=>{ live2d_dialog.style.opacity = 0 }, 10000) //10秒后隐藏对话框 
  }

  var keyCode = null;
  if(e.which) {
      keyCode = e.which;
  } else if(e.keyCode) {
      keyCode = e.keyCode;
  }

  if(keyCode == 13) { //如果按下回车
      var question_box = document.getElementById('question') // 获取输入框中的问题
      var question = question_box.value
      question_box.value = "" //清空输入框内容并禁用输入框
      question_box.setAttribute("disabled","disabled")
      var api_key = "f9ead0aad301411392637cc46708c5cd" //图灵机器人KEY,需要申请
      var url = 'https://www.tuling123.com/openapi/api?key='+api_key+'&info='+encodeURIComponent(question)

      var xhr = new XMLHttpRequest()   // 通过XHR发送一个GET请求
      xhr.onreadystatechange = ()=>{
        question_box.removeAttribute('disabled');
        if(xhr.readyState === 4) {
          if (xhr.status === 200) {
            var responseJSON = eval('('+ xhr.responseText +')') //反序列化返回的JSON
            let message = (responseJSON['code'] == 100000 ? responseJSON['text']: '今日对话次数已用完')
            popDialogAndShow(message)
          } else {
            console.error(xhr.statusText);
            popDialogAndShow('网络错误：'+xhr.statusText)
          }
        }
      };

      xhr.onerror = (e)=> {
        console.error(xhr.statusText);
        popDialogAndShow('网络错误：'+xhr.statusText)
      };

      xhr.open('GET',url)
      xhr.send()
  }
}
</script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/umaru.model.json"},"display":{"position":"left","width":200,"height":400,"hOffset":20,"vOffset":30},"mobile":{"show":true,"scale":0.5},"rect":{"opacity":0.7},"dialog":{"enable":true,"hitokoto":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
